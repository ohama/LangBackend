---
phase: 02-core-language-basics
plan: 04
type: execute
wave: 4
depends_on: ["02-03"]
files_modified:
  - tutorial/09-memory-management.md
autonomous: true

must_haves:
  truths:
    - "Reader understands stack vs heap allocation strategy"
    - "Reader can integrate Boehm GC into compilation pipeline"
    - "Reader understands when heap allocation becomes necessary"
    - "Reader has working runtime with GC initialization"
    - "Each section includes expected code output or MLIR IR"
  artifacts:
    - path: "tutorial/09-memory-management.md"
      provides: "Complete memory management and Boehm GC chapter"
      min_lines: 350
      contains:
        - "GC_INIT"
        - "GC_malloc"
        - "memref"
        - "스택"
  key_links:
    - from: "tutorial/09-memory-management.md"
      to: "tutorial/08-control-flow.md"
      via: "prepares for closures in Phase 3"
      pattern: "Chapter 08"
    - from: "GC_malloc"
      to: "llvm.call"
      via: "heap allocation via FFI"
      pattern: "llvm.call @GC_malloc"
---

<objective>
Write Chapter 09: Memory Management - explaining stack vs heap allocation, introducing MLIR's memref dialect, and integrating Boehm GC for future heap-allocated values.

Purpose: Memory management is critical for closures (Phase 3) and data structures (Phase 6). This chapter establishes the conceptual foundation and practical GC integration, even though Phase 2 programs don't strictly need heap allocation yet. Readers understand WHY they'll need GC before they need it.

Output: `tutorial/09-memory-management.md` (~350-450 lines) covering requirements MEM-01, MEM-02, QUAL-01, QUAL-04
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-language-basics/02-RESEARCH.md
@.planning/phases/02-core-language-basics/02-03-SUMMARY.md
@tutorial/08-control-flow.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Chapter 09 - Memory Management (Concepts and memref Dialect)</name>
  <files>tutorial/09-memory-management.md</files>
  <action>
Write the first half of Chapter 09 covering:

1. **Introduction (150-200 words)**
   - So far: all values are SSA registers (no memory operations)
   - This works for integers, booleans, and simple expressions
   - Challenge: closures and data structures need memory allocation
   - Preview: stack vs heap strategy, Boehm GC integration

2. **Memory Management Strategy (MEM-01) (~200 lines)**
   - **What goes on the stack:**
     - Function parameters and local variables
     - Temporary values during computation
     - Automatic deallocation on function return
     - Fast allocation (just move stack pointer)
   - **What goes on the heap:**
     - Values that escape function scope (closures capture environment)
     - Data structures with dynamic size (lists, strings)
     - Values returned from functions (may outlive function)
     - Requires explicit allocation and deallocation
   - **FunLang strategy:**
     - Phase 2: All values are SSA registers (no explicit memory)
     - Phase 3+: Closures need heap allocation for captured environment
     - Boehm GC handles heap deallocation automatically
   - **Diagram: Stack vs Heap**
     ```
     Stack (automatic)         Heap (GC managed)
     ┌───────────────┐        ┌───────────────────┐
     │ func frame    │        │ closure env       │
     │ - return addr │        │ - captured x = 5  │
     │ - local vars  │        │ - captured y = 10 │
     │ - temp values │        └───────────────────┘
     └───────────────┘
     ```

3. **MLIR memref Dialect Overview (~150 lines)**
   - memref: memory reference type representing typed memory region
   - **Stack allocation (memref.alloca):**
     ```mlir
     func.func @stack_example() -> i32 {
       // Allocate single i32 on stack
       %alloca = memref.alloca() : memref<1xi32>
       %c0 = arith.constant 0 : index
       %c42 = arith.constant 42 : i32

       // Store value
       memref.store %c42, %alloca[%c0] : memref<1xi32>

       // Load value
       %loaded = memref.load %alloca[%c0] : memref<1xi32>

       func.return %loaded : i32
       // Stack automatically freed on return
     }
     ```
   - **Heap allocation (memref.alloc):**
     ```mlir
     func.func @heap_example() -> memref<10xi32> {
       // Allocate array on heap
       %heap = memref.alloc() : memref<10xi32>
       // ... use heap memory ...
       // memref.dealloc %heap : memref<10xi32>  // Manual deallocation
       func.return %heap : memref<10xi32>
     }
     ```
   - Note: Phase 2 doesn't use memref operations (SSA registers sufficient)
   - memref becomes essential in Phase 3 for closure environments

4. **Why We Need Garbage Collection (~150 lines)**
   - **The problem: manual deallocation is error-prone**
     - Use-after-free: accessing freed memory
     - Double-free: freeing same memory twice
     - Memory leak: forgetting to free
   - **Why closures make this hard:**
     - Closure captures variables from outer scope
     - Closure may outlive the function that created it
     - Can't free environment until all closures using it are dead
     - Determining "dead" requires runtime tracking
   - **Example: closure lifetime problem**
     ```fsharp
     // FunLang source:
     let makeAdder = fun x -> (fun y -> x + y)
     let add5 = makeAdder 5  // Captures x=5
     let add10 = makeAdder 10  // Captures x=10
     // When can we free x=5? x=10? Only when add5/add10 are dead.
     ```
   - **Solution: Garbage Collection**
     - Runtime automatically tracks live objects
     - Frees memory when no references remain
     - No manual deallocation needed

**Writing style:** Plain Korean (~이다/~한다), technical terms in English
**IMPORTANT:** Explain concepts clearly with diagrams and examples
  </action>
  <verify>File exists at tutorial/09-memory-management.md with sections: Introduction, Memory Management Strategy, memref Dialect, Why We Need GC</verify>
  <done>First half of Chapter 09 written covering memory strategy, memref dialect, and GC motivation</done>
</task>

<task type="auto">
  <name>Task 2: Write Chapter 09 - Memory Management (Boehm GC Integration)</name>
  <files>tutorial/09-memory-management.md</files>
  <action>
Complete Chapter 09 by appending:

5. **Boehm GC Introduction (MEM-02) (~150 lines)**
   - **What is Boehm GC:**
     - Conservative garbage collector for C/C++
     - "Conservative": doesn't require precise type information
     - Scans stack and heap for potential pointers
     - If value could be pointer, assumes it is (safe but may retain more)
   - **Why Boehm GC for FunLang:**
     - Drop-in replacement for malloc/free
     - No compiler changes needed (no write barriers, no stack maps)
     - Battle-tested (30+ years, used by many languages)
     - Thread-safe with proper initialization
   - **Alternatives (why not):**
     - Reference counting: can't handle cycles (closure -> env -> closure)
     - LLVM statepoints: complex (safepoint insertion, stack maps)
     - Custom mark-sweep: lots of work, error-prone
   - **Boehm GC key functions:**
     - `GC_INIT()`: Initialize collector (call once at program start)
     - `GC_malloc(size)`: Allocate heap memory (freed automatically)
     - `GC_malloc_atomic(size)`: For memory with no pointers
     - No `free()` needed - GC handles deallocation

6. **Building and Installing Boehm GC (~100 lines)**
   - **Installation from source:**
     ```bash
     # Clone repositories
     git clone https://github.com/ivmai/libatomic_ops
     git clone https://github.com/ivmai/bdwgc

     # Link atomic_ops into bdwgc
     ln -s $(pwd)/libatomic_ops $(pwd)/bdwgc/libatomic_ops

     # Build
     cd bdwgc
     autoreconf -vif
     automake --add-missing
     ./configure --prefix=$HOME/boehm-gc
     make
     make install

     # Set library path
     export LD_LIBRARY_PATH=$HOME/boehm-gc/lib:$LD_LIBRARY_PATH
     export C_INCLUDE_PATH=$HOME/boehm-gc/include:$C_INCLUDE_PATH
     ```
   - **Package manager alternatives:**
     ```bash
     # Ubuntu/Debian
     sudo apt install libgc-dev

     # macOS
     brew install bdw-gc

     # Fedora
     sudo dnf install gc-devel
     ```

7. **Runtime Integration (~150 lines)**
   - **C runtime wrapper:**
     ```c
     // runtime.c - FunLang runtime with Boehm GC
     #include <stdio.h>
     #include <gc.h>

     // Initialize GC (called before main)
     void funlang_init() {
         GC_INIT();
     }

     // Allocate GC-managed memory
     void* funlang_alloc(size_t size) {
         return GC_malloc(size);
     }

     // Print integer (from Chapter 06)
     void print_int(int value) {
         printf("%d\n", value);
     }

     // MLIR-compiled main function
     extern int funlang_main();

     int main(int argc, char** argv) {
         funlang_init();
         int result = funlang_main();
         return result;
     }
     ```
   - **Compile runtime:**
     ```bash
     gcc -c runtime.c -o runtime.o -I$HOME/boehm-gc/include
     ```

8. **MLIR Code Generation for Heap Allocation (~100 lines)**
   - Declare external GC_malloc function:
     ```mlir
     // Declare external GC_malloc
     llvm.func @GC_malloc(i64) -> !llvm.ptr attributes { sym_visibility = "private" }
     ```
   - Allocate closure environment (preview for Phase 3):
     ```mlir
     func.func @allocate_closure_env() -> !llvm.ptr {
       %size = arith.constant 16 : i64  // 2 captured values * 8 bytes
       %env = llvm.call @GC_malloc(%size) : (i64) -> !llvm.ptr
       // Store captured values into env
       func.return %env : !llvm.ptr
     }
     ```
   - Note: Phase 2 doesn't need this yet - setup for Phase 3

9. **Updated Build Pipeline (~80 lines)**
   - **Link with Boehm GC:**
     ```bash
     # Complete compilation pipeline
     dotnet run "let x = 5 in x + x"  # Outputs LLVM IR

     # Compile to object
     llc -filetype=obj output.ll -o output.o

     # Link with runtime and GC
     gcc output.o runtime.o -o program \
         -L$HOME/boehm-gc/lib -lgc \
         -Wl,-rpath,$HOME/boehm-gc/lib

     # Run
     ./program
     ```
   - **F# helper for linking:**
     ```fsharp
     let linkWithGC objFile outputExe =
         let gcLib = Environment.GetEnvironmentVariable("BOEHM_GC_LIB") |> Option.defaultValue "-lgc"
         let args = sprintf "%s runtime.o -o %s %s" objFile outputExe gcLib
         runCommand "gcc" args
     ```

10. **Phase 2 vs Phase 3+ Memory Usage (~80 lines)**
    - **Phase 2 (current):**
      - All values are SSA registers
      - No heap allocation needed
      - GC is set up but not used
    - **Phase 3 (closures):**
      - Closures capture environment -> heap allocation
      - `GC_malloc` for environment structs
      - GC automatically reclaims dead closures
    - **Phase 6 (data structures):**
      - Lists: cons cells on heap
      - Tuples: heap-allocated when escaping
      - All GC-managed, no manual free

11. **Common Errors Section**
    - Error: Segfault on first GC_malloc call
      - Solution: Call GC_INIT() before any allocation
    - Error: Linker error "undefined reference to GC_malloc"
      - Solution: Link with -lgc and set LD_LIBRARY_PATH
    - Error: GC not collecting (memory grows)
      - Note: Boehm GC is conservative; may retain more than precise GC
      - Usually not a problem for Phase 2-3 programs
    - Error: Thread safety issues (Phase 6+)
      - Solution: Use GC_pthread_create() for threads, or GC_INIT() per thread

12. **Chapter Summary**
    - Recap: stack vs heap, memref dialect, Boehm GC integration
    - Phase 2 uses SSA registers only (no memory operations)
    - GC infrastructure ready for Phase 3 closures
    - Key takeaway: GC enables safe memory management for functional languages
    - Preview Phase 3: functions, recursion, and first closure steps

13. **Phase 2 Complete: What We've Built**
    - Chapter 06: Arithmetic expressions (+, -, *, /, comparisons, negation, print)
    - Chapter 07: Let bindings with SSA environment passing
    - Chapter 08: Control flow with scf.if and block arguments
    - Chapter 09: Memory management strategy and Boehm GC setup
    - Reader can compile: `let x = 5 in if x > 0 then x * 2 else 0`
    - Foundation ready for Phase 3: functions and recursion

**Writing style:** Plain Korean (~이다/~한다), technical terms in English
**IMPORTANT:** Include working code for runtime.c and build commands
  </action>
  <verify>
    - Chapter 09 complete with all 13 sections
    - File contains "GC_INIT", "GC_malloc"
    - File contains stack vs heap explanation
    - File contains complete runtime.c listing
    - File contains build/link commands with -lgc
    - File is at least 350 lines
  </verify>
  <done>Chapter 09 complete covering MEM-01, MEM-02 with memory strategy, Boehm GC integration, and Phase 2 summary</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **File checks:**
   - `tutorial/09-memory-management.md` exists
   - File is 350+ lines
   - Contains all required sections

2. **Content validation:**
   - [ ] Stack vs heap strategy explained (MEM-01)
   - [ ] memref dialect introduced (alloca, alloc, load, store)
   - [ ] Why GC is needed for closures
   - [ ] Boehm GC introduced with key functions (MEM-02)
   - [ ] Build/install instructions for Boehm GC
   - [ ] Complete runtime.c with GC_INIT
   - [ ] Updated build pipeline with -lgc
   - [ ] Phase 2 vs Phase 3+ memory usage comparison
   - [ ] Common Errors section

3. **Style validation:**
   - [ ] Korean text uses ~이다/~한다 style
   - [ ] Code blocks are complete and copy-pasteable
   - [ ] Memory management concepts explained clearly
</verification>

<success_criteria>
- Reader understands when to use stack vs heap allocation
- Reader can build and install Boehm GC
- Reader has working runtime.c with GC initialization
- Reader can link compiled programs with Boehm GC
- Reader understands why closures will need GC
- Reader has debugging guide for GC-related errors
- Phase 2 foundation complete, ready for Phase 3
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-language-basics/02-04-SUMMARY.md` following the summary template.
</output>
