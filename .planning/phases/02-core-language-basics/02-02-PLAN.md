---
phase: 02-core-language-basics
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - tutorial/07-let-bindings.md
autonomous: true

must_haves:
  truths:
    - "Reader can compile let bindings (let x = expr in body)"
    - "Reader can compile nested let bindings with correct scoping"
    - "Reader understands how let bindings map to SSA values"
    - "Reader can see how environment passing works in compiler"
    - "Each code example shows expected MLIR IR output"
  artifacts:
    - path: "tutorial/07-let-bindings.md"
      provides: "Complete let bindings and SSA form chapter"
      min_lines: 350
      contains:
        - "Let("
        - "Map<string, MlirValue>"
        - "SSA"
        - "환경"
  key_links:
    - from: "tutorial/07-let-bindings.md"
      to: "tutorial/06-arithmetic-expressions.md"
      via: "extends compiler with variable support"
      pattern: "Chapter 06"
    - from: "compileExpr"
      to: "env: Map<string, MlirValue>"
      via: "environment parameter added"
      pattern: "compileExpr.*env"
---

<objective>
Write Chapter 07: Let Bindings - teaching how functional language let bindings map directly to SSA values in MLIR, with environment passing for variable resolution.

Purpose: This chapter introduces the reader to SSA form through the lens of functional programming. Let bindings are immutable by nature, which aligns perfectly with SSA semantics. By the end, readers understand why functional languages compile elegantly to SSA-based IRs.

Output: `tutorial/07-let-bindings.md` (~350-500 lines) covering requirements LET-01, LET-02, LET-03, QUAL-01, QUAL-04
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-language-basics/02-RESEARCH.md
@.planning/phases/02-core-language-basics/02-01-SUMMARY.md
@tutorial/06-arithmetic-expressions.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Chapter 07 - Let Bindings (SSA Theory and AST)</name>
  <files>tutorial/07-let-bindings.md</files>
  <action>
Write the first half of Chapter 07 covering:

1. **Introduction (150-200 words)**
   - Explain that variables are fundamental to programming
   - Preview: let bindings in functional languages vs. variable assignment in imperative
   - Key insight: "let x = 5" creates immutable binding, perfect for SSA form
   - State outcome: reader will compile let bindings with proper scoping

2. **SSA Form Explained (LET-03) (~200 lines)**
   - Define SSA: Static Single Assignment - each value defined exactly once
   - **Why SSA matters for compilers:**
     - Enables constant propagation (value known at definition)
     - Enables dead code elimination (unused definitions removable)
     - Enables efficient register allocation (lifetime analysis)
   - **Let bindings are naturally SSA:**
     - `let x = 5` creates one definition
     - No mutation means no "second assignment"
     - Functional programming = SSA without conversion
   - **Contrast with imperative:**
     ```
     // Imperative (NOT SSA):
     x = 5
     x = 10  // mutation - violates SSA

     // Functional/SSA:
     let x = 5 in
     let x = 10 in  // shadowing creates NEW value, not mutation
     ```
   - **Show MLIR IR demonstrating SSA:**
     ```mlir
     // Source: let x = 5 in let x = 10 in x
     func.func @main() -> i32 {
       %x = arith.constant 5 : i32      // First binding
       %x_0 = arith.constant 10 : i32   // Shadowing = new SSA value
       func.return %x_0 : i32            // Uses shadowed value
     }
     ```

3. **AST Extension for Let Bindings (~100 lines)**
   - Add Let case to Expr type:
     ```fsharp
     type Expr =
       | ...existing cases from Chapter 06...
       | Let of name: string * binding: Expr * body: Expr
       | Var of name: string
     ```
   - Explain each field: name (binding identifier), binding (value expression), body (scope)
   - Add Var case for variable references
   - Show complete Ast.fs listing

4. **Environment Concept (~100 lines)**
   - Define environment: mapping from variable names to SSA values
   - F# representation: `type Env = Map<string, MlirValue>`
   - Operations: lookup (Var reference), extend (Let binding)
   - Explain scoping: inner let shadows outer let within body only
   - Diagram showing environment stack:
     ```
     let x = 5 in       env = { x -> %c5 }
       let y = 10 in    env = { x -> %c5, y -> %c10 }
         x + y          lookup x, lookup y -> arith.addi
     ```

**Writing style:** Plain Korean (~이다/~한다), technical terms in English
**IMPORTANT:** Include clear SSA explanation with MLIR IR examples
  </action>
  <verify>File exists at tutorial/07-let-bindings.md with sections: Introduction, SSA Form Explained, AST Extension, Environment Concept</verify>
  <done>First half of Chapter 07 written covering SSA theory, AST definition, and environment concept</done>
</task>

<task type="auto">
  <name>Task 2: Write Chapter 07 - Let Bindings (Code Generation and Examples)</name>
  <files>tutorial/07-let-bindings.md</files>
  <action>
Complete Chapter 07 by appending:

5. **Code Generation with Environment (~200 lines)**
   - Modify compileExpr signature to include environment:
     ```fsharp
     let rec compileExpr (builder: OpBuilder) (expr: Expr) (env: Env) : MlirValue =
     ```
   - Implement Let case:
     ```fsharp
     | Let(name, binding, body) ->
         let bindVal = compileExpr builder binding env
         let env' = env.Add(name, bindVal)
         compileExpr builder body env'
     ```
   - Implement Var case:
     ```fsharp
     | Var(name) ->
         match env.TryFind(name) with
         | Some(value) -> value
         | None -> failwithf "Unbound variable: %s" name
     ```
   - Update all existing cases to pass env through
   - Show complete CodeGen.fs listing

6. **Nested Let Bindings (LET-02) (~150 lines)**
   - Demonstrate nested scopes with example:
     ```fsharp
     // Source: let x = 10 in let y = 20 in let z = x + y in z * 2
     ```
   - **Show expected MLIR IR:**
     ```mlir
     func.func @main() -> i32 {
       %x = arith.constant 10 : i32
       %y = arith.constant 20 : i32
       %z = arith.addi %x, %y : i32
       %c2 = arith.constant 2 : i32
       %result = arith.muli %z, %c2 : i32
       func.return %result : i32
     }
     ```
   - Explain variable reuse: `%x` and `%y` used in `%z`, `%z` used in result
   - Key insight: no explicit "stores" or "loads" - values flow directly

7. **Variable Shadowing (~100 lines)**
   - Explain shadowing semantics:
     ```fsharp
     // Source: let x = 5 in let x = x + 1 in x
     // Inner x shadows outer x, but inner binding uses outer x's value
     ```
   - **Show MLIR IR:**
     ```mlir
     func.func @main() -> i32 {
       %x = arith.constant 5 : i32
       %c1 = arith.constant 1 : i32
       %x_0 = arith.addi %x, %c1 : i32  // Uses outer %x, creates new %x_0
       func.return %x_0 : i32
     }
     ```
   - MLIR automatically generates unique names (%x, %x_0, %x_1...)

8. **Complete Driver and Examples (~100 lines)**
   - Update Main.fs to construct let binding AST
   - Full compilation example:
     ```bash
     $ dotnet run "let x = 5 in let y = 3 in x * y"
     Result: 15
     ```

9. **Common Errors Section**
   - Error: Unbound variable (typo or scoping mistake)
     - Solution: Check variable spelling, verify let binding scope
   - Error: Using variable outside its scope
     - Example: `(let x = 5 in x) + x` - second x is unbound
   - Error: Forgetting to pass environment through recursive calls
     - All compileExpr calls must include env parameter

10. **Chapter Summary**
    - Recap: let bindings, SSA mapping, environment passing
    - Key takeaway: functional immutability = natural SSA form
    - Preview Chapter 08: control flow with if/then/else

**Writing style:** Plain Korean (~이다/~한다), technical terms in English
**IMPORTANT:** Every example MUST show expected MLIR IR output
  </action>
  <verify>
    - Chapter 07 complete with all 10 sections
    - File contains "Map<string, MlirValue>" or "Env ="
    - File contains "SSA" explanation section
    - File contains at least 3 MLIR IR output examples
    - File is at least 350 lines
  </verify>
  <done>Chapter 07 complete covering LET-01, LET-02, LET-03 with SSA explanation, environment passing, and MLIR IR examples</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **File checks:**
   - `tutorial/07-let-bindings.md` exists
   - File is 350+ lines
   - Contains all required sections

2. **Content validation:**
   - [ ] Let case added to AST
   - [ ] Var case added to AST
   - [ ] SSA form explained with examples (LET-03)
   - [ ] Environment type defined (Map<string, MlirValue>)
   - [ ] compileExpr updated with env parameter
   - [ ] Nested let bindings demonstrated (LET-02)
   - [ ] Variable shadowing explained
   - [ ] At least 3 expected MLIR IR output blocks
   - [ ] Common Errors section with debugging tips

3. **Style validation:**
   - [ ] Korean text uses ~이다/~한다 style
   - [ ] Code blocks are complete and copy-pasteable
   - [ ] SSA terminology properly explained
</verification>

<success_criteria>
- Reader can compile `let x = 5 in x + x` to working native binary
- Reader can compile nested `let x = 10 in let y = 20 in x + y`
- Reader understands SSA form and why let bindings map naturally
- Reader can implement environment-passing code generation
- Reader sees expected MLIR IR for all examples
- Reader has debugging guide for scoping errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-language-basics/02-02-SUMMARY.md` following the summary template.
</output>
