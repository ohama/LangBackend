---
phase: 02-core-language-basics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tutorial/06-arithmetic-expressions.md
autonomous: true

must_haves:
  truths:
    - "Reader can compile arithmetic expressions with +, -, *, / operators"
    - "Reader can compile comparison operators (<, >, <=, >=, =, <>) returning i1 boolean"
    - "Reader can compile unary negation (- prefix operator)"
    - "Reader can compile programs that print integer results to stdout"
    - "Each code example shows expected MLIR IR output"
  artifacts:
    - path: "tutorial/06-arithmetic-expressions.md"
      provides: "Complete arithmetic expression compilation chapter"
      min_lines: 400
      contains:
        - "BinaryOp"
        - "arith.addi"
        - "arith.cmpi"
        - "llvm.call @printf"
  key_links:
    - from: "tutorial/06-arithmetic-expressions.md"
      to: "tutorial/05-arithmetic-compiler.md"
      via: "extends compiler from Chapter 05"
      pattern: "Chapter 05"
---

<objective>
Write Chapter 06: Arithmetic Expressions - extending the minimal integer compiler from Chapter 05 to support full arithmetic operations, comparisons, unary negation, and stdout printing.

Purpose: This chapter builds the expression foundation that all subsequent language features depend on. Arithmetic operations use MLIR's arith dialect, which readers learned in the primer. By the end, readers have a working calculator compiler that can print results.

Output: `tutorial/06-arithmetic-expressions.md` (~450-600 lines) covering requirements EXPR-01, EXPR-02, EXPR-03, EXPR-04, QUAL-01, QUAL-04
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-language-basics/02-RESEARCH.md
@.planning/phases/01-foundation-interop/01-03-SUMMARY.md
@tutorial/05-arithmetic-compiler.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Chapter 06 - Arithmetic Expressions (AST and P/Invoke bindings)</name>
  <files>tutorial/06-arithmetic-expressions.md</files>
  <action>
Write the first half of Chapter 06 covering:

1. **Introduction (100-150 words)**
   - Explain that Chapter 05's compiler only handles integer literals
   - Preview what this chapter adds: binary operators, comparisons, negation, printing
   - State the outcome: complete arithmetic expression compiler

2. **Expanded AST Definition (~150 lines)**
   - Extend Expr type with BinaryOp, UnaryOp, Comparison cases
   - Define Operator type: Add, Subtract, Multiply, Divide
   - Define CompareOp type: LessThan, GreaterThan, LessEqual, GreaterEqual, Equal, NotEqual
   - Include UnaryOp for negation
   - Show complete Ast.fs with all cases

3. **P/Invoke Bindings for arith Dialect (~100 lines)**
   - Add mlirArithAddIOp, mlirArithSubIOp, mlirArithMulIOp, mlirArithDivSIOp
   - Add mlirArithCmpIOp with predicate enum (slt, sgt, sle, sge, eq, ne)
   - Add mlirArithConstantOp for boolean constants (i1 type)
   - Show mapping table: FunLang operator -> arith operation
   - Reference existing MlirBindings.fs from Chapter 03

4. **F# Wrapper Extensions (~100 lines)**
   - Extend OpBuilder with CreateArithBinaryOp, CreateArithCompare, CreateArithNegate
   - Handle predicate selection for comparisons
   - Update MlirWrapper.fs module listing

5. **Common Errors Section (first part)**
   - Error: Using wrong integer type (i64 vs i32)
   - Error: Forgetting to handle operator precedence in parser

**Writing style:** Plain Korean (~이다/~한다), technical terms in English
**Code:** Complete, copy-pasteable F# code blocks with annotations
  </action>
  <verify>File exists at tutorial/06-arithmetic-expressions.md with sections: Introduction, AST, P/Invoke Bindings, Wrapper Extensions</verify>
  <done>First half of Chapter 06 written covering AST definition, P/Invoke bindings, and wrapper extensions</done>
</task>

<task type="auto">
  <name>Task 2: Write Chapter 06 - Arithmetic Expressions (Code Generation and Printing)</name>
  <files>tutorial/06-arithmetic-expressions.md</files>
  <action>
Complete Chapter 06 by appending:

6. **Code Generation for Arithmetic (~200 lines)**
   - Extend compileExpr with BinaryOp, UnaryOp, Comparison cases
   - Show recursive compilation maintaining SSA form
   - Include complete CodeGen.fs listing with all operator cases
   - **Show expected MLIR IR output for each example** (QUAL-01):
     ```mlir
     // Source: 10 + 3 * 4
     func.func @main() -> i32 {
       %c10 = arith.constant 10 : i32
       %c3 = arith.constant 3 : i32
       %c4 = arith.constant 4 : i32
       %0 = arith.muli %c3, %c4 : i32
       %1 = arith.addi %c10, %0 : i32
       func.return %1 : i32
     }
     ```

7. **Adding Print Functionality (~150 lines)**
   - Explain llvm.call @printf approach (EXPR-04)
   - Add P/Invoke bindings for llvm.call operation
   - Create printf format string as global constant
   - Show print_int function implementation
   - Include complete example with printing:
     ```fsharp
     // Source: print(10 + 20)
     // Compiles to printf call with format string
     ```

8. **Complete Compiler Driver (~100 lines)**
   - Update Main.fs to handle arithmetic expressions
   - Include parser extension hints (or use simple AST construction)
   - Show full compilation and execution example:
     ```bash
     $ dotnet run "10 + 3 * 4"
     Result: 22
     ```

9. **Common Errors Section (completion)**
   - Error: Comparison returns i1 but used where i32 expected
   - Error: Division by zero (runtime vs compile-time)
   - Error: printf format string missing null terminator

10. **Chapter Summary**
    - Recap what was built (binary ops, comparisons, negation, printing)
    - Preview Chapter 07: let bindings for named values

**Writing style:** Plain Korean (~이다/~한다), technical terms in English
**IMPORTANT:** Every code example MUST show expected MLIR IR output (QUAL-01 requirement)
  </action>
  <verify>
    - Chapter 06 complete with all 10 sections
    - File contains "arith.addi", "arith.cmpi", "llvm.call @printf"
    - File contains at least 3 MLIR IR output examples
    - File is at least 400 lines
  </verify>
  <done>Chapter 06 complete covering EXPR-01, EXPR-02, EXPR-03, EXPR-04 with MLIR IR examples and Common Errors section</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **File checks:**
   - `tutorial/06-arithmetic-expressions.md` exists
   - File is 400+ lines
   - Contains all required sections

2. **Content validation:**
   - [ ] BinaryOp AST case defined
   - [ ] arith.addi, arith.subi, arith.muli, arith.divsi usage shown
   - [ ] arith.cmpi with predicates (slt, sgt, sle, sge, eq, ne) shown
   - [ ] Unary negation implemented
   - [ ] printf integration for printing results
   - [ ] At least 3 expected MLIR IR output blocks
   - [ ] Common Errors section with debugging tips

3. **Style validation:**
   - [ ] Korean text uses ~이다/~한다 style (not ~입니다/~합니다)
   - [ ] Code blocks are complete and copy-pasteable
   - [ ] Technical terms in English (MLIR, arith, SSA, etc.)
</verification>

<success_criteria>
- Reader can compile `10 + 3 * 4` to working native binary
- Reader can compile comparison `5 < 10` returning boolean
- Reader can compile negation `-42`
- Reader can print results to stdout with printf
- Reader sees expected MLIR IR for all examples
- Reader has debugging guide for common errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-language-basics/02-01-SUMMARY.md` following the summary template.
</output>
