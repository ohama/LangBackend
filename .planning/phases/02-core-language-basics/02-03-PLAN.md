---
phase: 02-core-language-basics
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - tutorial/08-control-flow.md
autonomous: true

must_haves:
  truths:
    - "Reader can compile if/then/else expressions that produce values"
    - "Reader understands MLIR block arguments as alternative to PHI nodes"
    - "Reader can compile boolean expressions for conditions"
    - "Reader understands scf.if with scf.yield semantics"
    - "Each code example shows expected MLIR IR output"
  artifacts:
    - path: "tutorial/08-control-flow.md"
      provides: "Complete control flow and block arguments chapter"
      min_lines: 400
      contains:
        - "scf.if"
        - "scf.yield"
        - "block argument"
        - "i1"
  key_links:
    - from: "tutorial/08-control-flow.md"
      to: "tutorial/07-let-bindings.md"
      via: "extends compiler with conditionals"
      pattern: "Chapter 07"
    - from: "scf.if"
      to: "scf.yield"
      via: "both branches yield same type"
      pattern: "scf.yield.*: i32"
---

<objective>
Write Chapter 08: Control Flow - teaching MLIR's structured control flow with block arguments, implementing if/then/else expressions that return values.

Purpose: Control flow is where SSA form gets interesting. Traditional PHI nodes are complex; MLIR's block arguments are the modern solution. This chapter teaches readers the elegant scf.if construct and how branches merge values without explicit PHI insertion.

Output: `tutorial/08-control-flow.md` (~400-550 lines) covering requirements CTRL-01, CTRL-02, CTRL-03, QUAL-01, QUAL-04
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-language-basics/02-RESEARCH.md
@.planning/phases/02-core-language-basics/02-02-SUMMARY.md
@tutorial/07-let-bindings.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Chapter 08 - Control Flow (Block Arguments Theory and P/Invoke)</name>
  <files>tutorial/08-control-flow.md</files>
  <action>
Write the first half of Chapter 08 covering:

1. **Introduction (150-200 words)**
   - Explain that if/then/else in functional languages returns a value
   - Unlike imperative: `result = if cond then a else b` (expression, not statement)
   - Challenge: how do two branches merge into one value in SSA form?
   - Preview: MLIR's elegant solution with block arguments

2. **The PHI Node Problem (CTRL-02) (~200 lines)**
   - Traditional SSA uses PHI nodes at merge points:
     ```
     // Traditional SSA with PHI:
     entry:
       %cond = icmp eq %x, 0
       br i1 %cond, label %then, label %else
     then:
       %a = add %x, 1
       br label %merge
     else:
       %b = sub %x, 1
       br label %merge
     merge:
       %result = phi i32 [ %a, %then ], [ %b, %else ]  // PHI node
     ```
   - **Problems with PHI nodes:**
     - Must be at beginning of block (special position rule)
     - "Lost copy problem" - edge semantics confusion
     - Complex to generate correctly (dominance frontiers)
   - **MLIR's solution: Block Arguments**
     - Values passed explicitly when branching
     - No special PHI instruction - just function-like parameters
     - Same semantics, cleaner representation

3. **Block Arguments in MLIR (~150 lines)**
   - Concept: blocks can have parameters like functions
   - Values passed via branch operands:
     ```mlir
     // MLIR with block arguments:
     ^then:
       %a = arith.addi %x, %c1 : i32
       cf.br ^merge(%a : i32)
     ^else:
       %b = arith.subi %x, %c1 : i32
       cf.br ^merge(%b : i32)
     ^merge(%result: i32):           // Block argument receives value
       func.return %result : i32
     ```
   - Key insight: branch operands -> block parameters (like function call)
   - No separate PHI instruction needed

4. **scf.if: High-Level Control Flow (~150 lines)**
   - MLIR's `scf` dialect provides structured control flow
   - `scf.if` with `scf.yield` terminators:
     ```mlir
     %result = scf.if %cond -> (i32) {
       %c42 = arith.constant 42 : i32
       scf.yield %c42 : i32
     } else {
       %c0 = arith.constant 0 : i32
       scf.yield %c0 : i32
     }
     ```
   - Benefits:
     - Result type declared upfront (`-> (i32)`)
     - Both branches must yield matching types
     - Automatic lowering to cf.cond_br with block arguments
   - **Progressive lowering:** scf.if -> cf.cond_br -> llvm branches

5. **P/Invoke Bindings for SCF Dialect (~100 lines)**
   - Add bindings for scf dialect functions:
     ```fsharp
     [<DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)>]
     extern MlirOperation mlirScfIfOpCreate(MlirLocation loc, MlirType[] resultTypes, int numResults, MlirValue condition, bool withElse)

     [<DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)>]
     extern void mlirScfYieldOpCreate(MlirLocation loc, MlirValue[] operands, int numOperands)
     ```
   - Reference MLIR C API header: `mlir-c/Dialect/SCF.h`
   - Note: If C API has gaps, explain C++ shim approach (see Appendix)

**Writing style:** Plain Korean (~이다/~한다), technical terms in English
**IMPORTANT:** Explain block arguments clearly with diagrams/examples
  </action>
  <verify>File exists at tutorial/08-control-flow.md with sections: Introduction, PHI Node Problem, Block Arguments, scf.if, P/Invoke Bindings</verify>
  <done>First half of Chapter 08 written covering block arguments theory and SCF dialect P/Invoke bindings</done>
</task>

<task type="auto">
  <name>Task 2: Write Chapter 08 - Control Flow (Code Generation and Boolean Expressions)</name>
  <files>tutorial/08-control-flow.md</files>
  <action>
Complete Chapter 08 by appending:

6. **AST Extension for Control Flow (~80 lines)**
   - Add If case to Expr type:
     ```fsharp
     type Expr =
       | ...existing cases...
       | If of condition: Expr * thenBranch: Expr * elseBranch: Expr
       | Bool of bool  // Boolean literals
     ```
   - Explain: condition must produce boolean (i1), branches must have same type
   - Show complete Ast.fs listing

7. **Boolean Expressions (CTRL-03) (~150 lines)**
   - Boolean type in MLIR: `i1` (1-bit integer)
   - Boolean literals:
     ```fsharp
     | Bool(true) -> builder.CreateConstant(1, builder.Context.GetIntegerType(1))
     | Bool(false) -> builder.CreateConstant(0, builder.Context.GetIntegerType(1))
     ```
   - Comparisons already return i1 (from Chapter 06)
   - **Boolean operations (if needed):**
     - AND: arith.andi on i1 values
     - OR: arith.ori on i1 values
     - NOT: arith.xori with constant 1
   - Example: `5 < 10` produces i1 for if condition

8. **Code Generation for If/Then/Else (~200 lines)**
   - Full implementation:
     ```fsharp
     | If(cond, thenExpr, elseExpr) ->
         let condVal = compileExpr builder cond env
         // Ensure condition is i1
         let i32Type = builder.Context.GetIntegerType(32)

         // Create scf.if operation
         let ifOp = builder.CreateScfIf(condVal, [| i32Type |])

         // Build then region
         builder.SetInsertionPointToStart(ifOp.GetThenBlock())
         let thenVal = compileExpr builder thenExpr env
         builder.CreateScfYield([| thenVal |])

         // Build else region
         builder.SetInsertionPointToStart(ifOp.GetElseBlock())
         let elseVal = compileExpr builder elseExpr env
         builder.CreateScfYield([| elseVal |])

         // Reset insertion point and return result
         builder.SetInsertionPointAfter(ifOp)
         ifOp.GetResult(0)
     ```
   - **Show expected MLIR IR:**
     ```mlir
     // Source: if 5 < 10 then 42 else 0
     func.func @main() -> i32 {
       %c5 = arith.constant 5 : i32
       %c10 = arith.constant 10 : i32
       %cond = arith.cmpi slt, %c5, %c10 : i32
       %result = scf.if %cond -> (i32) {
         %c42 = arith.constant 42 : i32
         scf.yield %c42 : i32
       } else {
         %c0 = arith.constant 0 : i32
         scf.yield %c0 : i32
       }
       func.return %result : i32
     }
     ```

9. **Lowering Pass Update (~100 lines)**
   - Add SCF to CF conversion pass:
     ```fsharp
     mlirPassManagerAddOwnedPass(pm, mlirCreateConversionConvertSCFToCFPass())
     ```
   - Pass order: SCF -> CF -> Arith -> Func -> LLVM
   - **Show MLIR IR after lowering:**
     ```mlir
     // After --convert-scf-to-cf:
     func.func @main() -> i32 {
       %c5 = arith.constant 5 : i32
       %c10 = arith.constant 10 : i32
       %cond = arith.cmpi slt, %c5, %c10 : i32
       cf.cond_br %cond, ^then, ^else
     ^then:
       %c42 = arith.constant 42 : i32
       cf.br ^merge(%c42 : i32)
     ^else:
       %c0 = arith.constant 0 : i32
       cf.br ^merge(%c0 : i32)
     ^merge(%result: i32):
       func.return %result : i32
     }
     ```

10. **Nested Conditionals and Let Bindings (~100 lines)**
    - Complex example combining features:
      ```fsharp
      // Source: let x = 5 in if x > 0 then x * 2 else 0
      ```
    - Show environment passed into both branches
    - Show complete MLIR IR output

11. **Common Errors Section**
    - Error: Condition is i32 instead of i1
      - Solution: Use arith.cmpi for comparisons, returns i1
    - Error: scf.yield types don't match between branches
      - Solution: Both branches must yield same type
    - Error: Forgetting scf.yield terminator
      - Solution: Every scf.if branch MUST end with scf.yield
    - Error: Missing --convert-scf-to-cf pass
      - Solution: Add pass before --convert-to-llvm

12. **Chapter Summary**
    - Recap: scf.if, block arguments, boolean expressions
    - Key insight: MLIR block arguments are cleaner than PHI nodes
    - Preview Chapter 09: memory management for future features

**Writing style:** Plain Korean (~이다/~한다), technical terms in English
**IMPORTANT:** Every example MUST show expected MLIR IR output, including after lowering
  </action>
  <verify>
    - Chapter 08 complete with all 12 sections
    - File contains "scf.if", "scf.yield", "block argument"
    - File contains "i1" for boolean type
    - File contains at least 4 MLIR IR output examples (before and after lowering)
    - File is at least 400 lines
  </verify>
  <done>Chapter 08 complete covering CTRL-01, CTRL-02, CTRL-03 with block arguments, scf.if, and MLIR IR examples</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **File checks:**
   - `tutorial/08-control-flow.md` exists
   - File is 400+ lines
   - Contains all required sections

2. **Content validation:**
   - [ ] If case added to AST
   - [ ] Block arguments concept explained (CTRL-02)
   - [ ] PHI nodes vs block arguments comparison
   - [ ] scf.if with scf.yield implementation shown
   - [ ] Boolean expressions compile to i1 (CTRL-03)
   - [ ] Lowering pass (scf-to-cf) explained
   - [ ] At least 4 expected MLIR IR output blocks
   - [ ] Common Errors section with debugging tips

3. **Style validation:**
   - [ ] Korean text uses ~이다/~한다 style
   - [ ] Code blocks are complete and copy-pasteable
   - [ ] Block argument terminology properly explained
</verification>

<success_criteria>
- Reader can compile `if true then 42 else 0` to working native binary
- Reader can compile `if 5 < 10 then 1 else 0` with comparison condition
- Reader understands block arguments vs PHI nodes
- Reader can see scf.if lowering to cf.cond_br
- Reader sees expected MLIR IR for all examples
- Reader has debugging guide for type mismatches and missing yields
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-language-basics/02-03-SUMMARY.md` following the summary template.
</output>
