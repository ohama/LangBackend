---
phase: 04-closures-higher-order
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - tutorial/13-higher-order-functions.md
autonomous: true

must_haves:
  truths:
    - "Reader can compile functions that take other functions as arguments"
    - "Reader can compile functions that return closures"
    - "Reader can implement indirect calls via func.call_indirect"
    - "Reader can compile complete higher-order function examples (map, apply)"
    - "Reader understands GC handles closure lifetime correctly"
  artifacts:
    - path: "tutorial/13-higher-order-functions.md"
      provides: "Complete higher-order function compilation chapter"
      min_lines: 1500
      contains: ["call_indirect", "higher-order", "makeAdder", "map"]
  key_links:
    - from: "Closure parameter"
      to: "func.call_indirect"
      via: "Extract fn_ptr and call with environment"
      pattern: "call_indirect.*llvm.ptr"
    - from: "Closure return"
      to: "Heap-allocated environment"
      via: "Environment survives function return"
      pattern: "func.return.*llvm.ptr"
---

<objective>
Write Chapter 13: Higher-Order Functions - covering functions as arguments, functions as return values, indirect calls, and complete examples with GC integration

Purpose: Complete closure support enabling functional programming patterns (map, filter, composition)
Output: Complete tutorial chapter for higher-order function compilation (CLOS-03, CLOS-04, MEM-03)
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-closures-higher-order/04-RESEARCH.md
@.planning/phases/04-closures-higher-order/04-01-SUMMARY.md
@tutorial/12-closures.md
@tutorial/10-functions.md
@tutorial/09-memory-management.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Chapter 13 Part 1 - Functions as Arguments</name>
  <files>tutorial/13-higher-order-functions.md</files>
  <action>
Create Chapter 13 covering functions as arguments (first-class values).

**Structure (~800 lines):**

1. **Introduction (100 lines)**
   - Higher-order functions definition
   - Why HOF matters: abstraction, reuse, composition
   - Chapter goal: compile `apply f x = f x` and `map f list`
   - Prerequisites: Chapter 12 (closures)

2. **Functions as First-Class Values (150 lines)**
   - Closures ARE the runtime representation of functions
   - All functions (even top-level) can be closure-wrapped
   - Uniform representation: every function is (fn_ptr, env_ptr)
   - Named functions vs anonymous lambdas (both become closures when passed)

3. **Calling Closures: The Indirect Call Pattern (250 lines)**
   - Extract function pointer from closure: llvm.getelementptr + llvm.load
   - Pass closure as first argument (environment)
   - llvm.call with function pointer (not func.call @symbol)
   - F# helper: CallClosure function
   - MLIR IR examples showing indirect call pattern

4. **The Apply Function (150 lines)**
   - `apply : (a -> b) -> a -> b`
   - F# implementation of compileApp for closure calls
   - MLIR IR for apply implementation
   - Testing: apply inc 42 = 43

5. **Functions Taking Multiple Function Arguments (150 lines)**
   - `compose : (b -> c) -> (a -> b) -> a -> c`
   - Multiple closure parameters
   - Chaining indirect calls
   - MLIR IR showing composition pattern

**Writing style:**
- Korean plain style (~이다/~한다)
- Technical terms in English (higher-order, indirect call)
- Code blocks for F# and MLIR examples
- Clear before/after comparisons

**Requirements:**
- Contains "고차 함수" (higher-order function in Korean)
- Contains "간접 호출" (indirect call in Korean)
- Contains "llvm.call" with function pointer (not @symbol)
- At least 6 MLIR IR examples
- At least 3 F# code snippets
  </action>
  <verify>
```bash
wc -l tutorial/13-higher-order-functions.md  # Should be ~800+ lines
grep -c "고차 함수\|higher-order" tutorial/13-higher-order-functions.md  # Should be 5+
grep -c "llvm.call" tutorial/13-higher-order-functions.md  # Should be 5+
grep -c "apply\|compose" tutorial/13-higher-order-functions.md  # Should be 5+
```
  </verify>
  <done>Chapter 13 part 1 complete with functions as arguments and indirect call pattern</done>
</task>

<task type="auto">
  <name>Task 2: Write Chapter 13 Part 2 - Functions as Return Values and Complete Examples</name>
  <files>tutorial/13-higher-order-functions.md</files>
  <action>
Complete Chapter 13 with returning closures and comprehensive examples.

**Structure (append ~700 lines):**

6. **Functions Returning Functions (200 lines)**
   - The upward funarg problem: closure escapes creating function
   - Why heap allocation is essential (not stack)
   - `makeAdder : int -> (int -> int)`
   - Complete compilation of makeAdder
   - MLIR IR showing:
     - Outer function creates environment with GC_malloc
     - Inner closure captures outer parameter
     - Return closure pointer
   - Testing: let add5 = makeAdder 5 in add5 10 = 15

7. **Currying Pattern (150 lines)**
   - Multi-argument functions as nested closures
   - `add : int -> int -> int` = `fun x -> fun y -> x + y`
   - Chain of closure creation
   - Partial application example

8. **Memory Management with Closures (150 lines)**
   - GC handles closure lifetime automatically
   - No dangling pointers when closure escapes
   - No memory leaks with unused closures
   - Cyclic closures (mutual reference) handled by GC
   - Testing memory safety with repeated closure creation

9. **Complete Example: Map Function (100 lines)**
   - `map : (a -> b) -> list a -> list b` (conceptual, full list in Phase 6)
   - For Phase 4: map over simple examples
   - Shows all patterns together: HOF + closures + indirect calls

10. **Common Errors (100 lines)**
    - Error 1: Forgetting to pass closure as first argument
    - Error 2: Direct call to closure body (bypassing environment)
    - Error 3: Stack-allocating returning closure environment
    - Error 4: Type mismatch in indirect call (wrong signature)
    - Error 5: Closure identity confusion (two closures != same)

**Code examples must include:**
- Complete makeAdder F# compilation function
- MLIR IR for makeAdder (outer + inner functions)
- Curried add function example
- Memory safety demonstration
- Full apply and compose working examples

**Requirements:**
- Contains "makeAdder" (canonical returning-closure example)
- Contains "GC_malloc" in context of returning closures
- Contains "upward funarg" or equivalent explanation
- At least 8 MLIR IR examples total in chapter
- Common Errors section with 5 error types
  </action>
  <verify>
```bash
wc -l tutorial/13-higher-order-functions.md  # Should be ~1500+ lines
grep -c "makeAdder" tutorial/13-higher-order-functions.md  # Should be 8+
grep -c "GC_malloc" tutorial/13-higher-order-functions.md  # Should be 3+
grep -c "Error\|오류" tutorial/13-higher-order-functions.md  # Should be 5+ (common errors)
grep -c "upward\|escap" tutorial/13-higher-order-functions.md  # Should be 3+
```
  </verify>
  <done>Chapter 13 complete with functions as return values, currying, memory safety, and common errors</done>
</task>

<task type="auto">
  <name>Task 3: Update SUMMARY.md and Finalize Phase 4</name>
  <files>tutorial/SUMMARY.md</files>
  <action>
Update tutorial SUMMARY.md to include new chapters and add Phase 4 completion summary.

**Updates to tutorial/SUMMARY.md:**
Add after Chapter 11 entry:
```markdown
- [Chapter 12: Closures](12-closures.md)
- [Chapter 13: Higher-Order Functions](13-higher-order-functions.md)
```

**Add Phase 4 summary to Chapter 13 end:**
Append a "Phase 4 Complete" section to Chapter 13:
- Summary of what was accomplished (CLOS-01 through CLOS-05, MEM-03)
- Closure compilation capability summary
- Preview of Phase 5 (Custom MLIR Dialect)

**Requirements:**
- SUMMARY.md includes both new chapters
- Chapter 13 has Phase 4 completion summary
- Preview mentions custom dialect design
  </action>
  <verify>
```bash
grep "12-closures" tutorial/SUMMARY.md  # Should match
grep "13-higher-order" tutorial/SUMMARY.md  # Should match
grep -c "Phase 4\|4단계" tutorial/13-higher-order-functions.md  # Should be 2+ (completion section)
grep "Phase 5\|5단계" tutorial/13-higher-order-functions.md  # Should mention next phase
```
  </verify>
  <done>SUMMARY.md updated with new chapters, Phase 4 completion documented</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Content verification:**
```bash
# Chapter 13 length
wc -l tutorial/13-higher-order-functions.md  # Expect 1500+ lines

# Core concepts present
grep -c "higher-order\|고차" tutorial/13-higher-order-functions.md  # Expect 10+
grep -c "makeAdder" tutorial/13-higher-order-functions.md  # Expect 8+
grep -c "indirect\|간접" tutorial/13-higher-order-functions.md  # Expect 5+
grep -c "llvm.call" tutorial/13-higher-order-functions.md  # Expect 10+

# Code examples
grep -c "```mlir\|```fsharp\|```" tutorial/13-higher-order-functions.md  # Expect 20+
```

2. **Structure verification:**
```bash
# Section headers
grep "^##" tutorial/13-higher-order-functions.md  # Should show all major sections
```

3. **SUMMARY.md verification:**
```bash
cat tutorial/SUMMARY.md  # Should include both Chapter 12 and 13
```

4. **Phase completion:**
```bash
# Both chapters exist and have content
test -f tutorial/12-closures.md && test -f tutorial/13-higher-order-functions.md && echo "Both chapters exist"
wc -l tutorial/12-closures.md tutorial/13-higher-order-functions.md  # Combined 3000+ lines
```
</verification>

<success_criteria>
- [ ] Chapter 13 exists at tutorial/13-higher-order-functions.md
- [ ] Chapter is 1500+ lines
- [ ] Contains functions-as-arguments section with apply/compose examples
- [ ] Contains indirect call pattern explanation with MLIR examples
- [ ] Contains functions-as-return-values with makeAdder
- [ ] Contains currying pattern explanation
- [ ] Contains memory management section confirming GC handles closures
- [ ] Contains at least 8 MLIR IR examples
- [ ] Contains Common Errors section with 5 error types
- [ ] Contains Phase 4 completion summary
- [ ] Contains Phase 5 preview
- [ ] tutorial/SUMMARY.md updated with both new chapters
- [ ] Uses Korean plain style (~이다/~한다)
- [ ] Technical terms in English
</success_criteria>

<output>
After completion, create `.planning/phases/04-closures-higher-order/04-02-SUMMARY.md`
</output>
