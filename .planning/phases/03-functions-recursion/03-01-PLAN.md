---
phase: 03-functions-recursion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tutorial/10-functions.md
autonomous: true

must_haves:
  truths:
    - "Reader can compile simple function definitions with multiple parameters"
    - "Reader can compile function calls and receive return values"
    - "Reader understands MLIR func dialect operations (func.func, func.call, func.return)"
    - "Reader understands function parameters as block arguments, not variables"
    - "Reader understands calling conventions and func-to-llvm lowering"
  artifacts:
    - path: "tutorial/10-functions.md"
      provides: "Chapter 10: Functions with definitions, calls, and calling conventions"
      min_lines: 800
      contains:
        - "func.func"
        - "func.call"
        - "func.return"
        - "block argument"
        - "@function_name"
  key_links:
    - from: "Chapter 10"
      to: "Phase 2 expression compiler"
      via: "compileExpr reused inside function bodies"
    - from: "Function parameters"
      to: "Environment"
      via: "Block arguments added to initial environment"
---

<objective>
Write Chapter 10: Functions covering function definitions, function calls, and MLIR func dialect operations.

Purpose: Enable readers to compile top-level named functions with parameters and return values, understanding how functions translate to MLIR func dialect and eventually to native code via LLVM.

Output: Complete tutorial chapter (800+ lines) with AST extension, P/Invoke bindings for func dialect, code generation patterns, and 8+ MLIR IR examples.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-functions-recursion/03-RESEARCH.md
@tutorial/09-memory-management.md (Chapter 09 - previous chapter)
@tutorial/07-let-bindings.md (Environment passing pattern)
@tutorial/08-control-flow.md (Block arguments concept)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Chapter 10 part 1 - Concepts, AST, and P/Invoke bindings</name>
  <files>tutorial/10-functions.md</files>
  <action>
Write the first half of Chapter 10 covering:

1. **Introduction** (150 lines)
   - Transition from expressions to functions
   - What top-level functions are (not closures - Phase 4)
   - Function compilation overview: definition → call → return
   - Chapter goals: FUNC-01 (definitions), FUNC-02 (calls)

2. **MLIR func Dialect** (250 lines)
   - func.func operation: symbol name (@name), parameters as block arguments, return type
   - func.call operation: symbol reference, arguments, result type
   - func.return operation: terminates function body, yields return value
   - Function visibility: public (default) vs private (external declarations)
   - Complete MLIR IR example for simple function (add two integers)
   - Comparison to Phase 2: functions vs expressions (func.func wraps expression body)

3. **AST Extension** (150 lines)
   - FunDef: top-level function definition (name, params, body)
   - App: function application (callee name, arguments)
   - Program type: list of function definitions plus main expression
   - Example AST for: `let add x y = x + y`
   - Example AST for: `add 10 20`
   - Note: Lambda (anonymous functions) deferred to Phase 4

4. **P/Invoke Bindings for func Dialect** (200 lines)
   - mlirFunctionTypeGet: create function type (param types, result types)
   - mlirFunctionTypeGetInput/GetResult: query function type components
   - Generic operation creation for func.func (attributes: sym_name, function_type)
   - Generic operation creation for func.call (callee attribute, operands)
   - MlirFlatSymbolRefAttrGet for symbol references (@name)
   - MlirBindings.fs additions with CallingConvention.Cdecl

5. **OpBuilder Extensions** (150 lines)
   - CreateFuncOp: create function with name, param types, result type, body region
   - CreateFuncCall: create function call with callee name, arguments
   - CreateFuncReturn: terminate function with return value
   - GetFunctionEntryBlock: get entry block of function for inserting body
   - GetFunctionBlockArg: get block argument by index (function parameter)
   - Helper pattern: CreateFuncOp returns function operation, caller inserts body

Total for Task 1: ~900 lines

**Style requirements:**
- Korean plain style (~이다/~한다) throughout
- English for: func.func, func.call, func.return, @symbol, block argument, SSA
- 4 MLIR IR examples showing expected output
- Code blocks with syntax highlighting (fsharp, mlir)
  </action>
  <verify>
Check file exists and contains required content:
- grep -c "func.func" tutorial/10-functions.md should return 15+
- grep -c "func.call" tutorial/10-functions.md should return 10+
- grep -c "func.return" tutorial/10-functions.md should return 8+
- grep -c "block argument" tutorial/10-functions.md should return 5+
- wc -l tutorial/10-functions.md should be 800+ lines
  </verify>
  <done>
Chapter 10 part 1 complete with func dialect concepts, AST extension, and P/Invoke bindings covering 900 lines.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write Chapter 10 part 2 - Code generation and examples</name>
  <files>tutorial/10-functions.md</files>
  <action>
Continue Chapter 10 with code generation:

6. **Function Parameters as Block Arguments** (150 lines)
   - Why parameters are block arguments (entry block of function body)
   - Block arguments (%arg0, %arg1) are SSA values
   - Parameters added to environment before compiling body
   - Not the same as let bindings (but environment reuse)
   - Pattern: Create function, get block args, add to env, compile body
   - Example: `let add x y = x + y` → %arg0, %arg1 in environment

7. **Code Generation: Function Definition** (200 lines)
   - compileFuncDef: name, params, body → func.func operation
   - Step 1: Create function type (mlirFunctionTypeGet)
   - Step 2: Create func.func operation with sym_name attribute
   - Step 3: Get entry block's block arguments
   - Step 4: Build initial environment from parameters
   - Step 5: Compile body expression with environment
   - Step 6: Insert func.return with body result
   - Complete compileFuncDef implementation
   - MLIR IR example: let double x = x + x

8. **Code Generation: Function Call** (150 lines)
   - Add App case to compileExpr
   - Step 1: Look up callee function (module-level symbol)
   - Step 2: Compile argument expressions (recursive compileExpr)
   - Step 3: Create func.call with symbol reference
   - Step 4: Return call result as SSA value
   - Complete App case implementation
   - MLIR IR example: double 5

9. **Code Generation: Program** (100 lines)
   - compileProgram: compile all function definitions, then main expression
   - Main expression compiled into @funlang_main (called by runtime.c main)
   - Function definition order doesn't matter (module-level symbols)
   - All functions visible to all other functions (flat namespace)
   - Complete compileProgram implementation

10. **Complete Example** (200 lines)
    - Full program: multiple function definitions and main
    - Example: let square x = x * x; let sumSquares a b = square a + square b; sumSquares 3 4
    - Complete AST
    - Complete MLIR IR output (func.func + func.call)
    - Lowering to LLVM dialect (func-to-llvm pass)
    - LLVM IR output (define, call)
    - Compilation and execution

11. **Calling Conventions** (FUNC-05 partial) (150 lines)
    - What calling convention means (argument passing, return value, stack frame)
    - MLIR defaults to C calling convention
    - LLVM handles platform differences (x86-64, ARM, etc.)
    - Function arguments passed in registers then stack (System V ABI)
    - Return value in register (rax for x86-64)
    - Why we don't hand-roll calling conventions (LLVM does it)
    - Tail call optimization preview (mentioned, detailed in Chapter 11)

12. **Common Errors** (100 lines)
    - Error 1: Function not found (symbol reference typo)
    - Error 2: Argument count mismatch (too few/many arguments)
    - Error 3: Type mismatch (argument types don't match parameters)
    - Error 4: Missing func.return (unterminated function body)
    - Error 5: Confusing parameters with let bindings (parameters are block args)
    - Solutions for each error

13. **Chapter Summary** (50 lines)
    - Covered: function definitions, function calls, func dialect, calling conventions
    - Reader can compile multi-function programs
    - Preview: Chapter 11 adds recursion and mutual recursion

Total for Task 2: ~1100 lines
Combined chapter: ~2000 lines

**Style requirements:**
- Korean plain style (~이다/~한다) throughout
- Technical terms in English
- 4+ additional MLIR IR examples (8+ total)
- Common Errors section required
  </action>
  <verify>
Complete verification:
- wc -l tutorial/10-functions.md should be 1800+ lines
- grep -c "compileFuncDef\|compileExpr" tutorial/10-functions.md should return 15+
- grep -c "Common Error\|일반적인 오류\|오류" tutorial/10-functions.md should return 5+
- grep -c "```mlir" tutorial/10-functions.md should return 8+
  </verify>
  <done>
Chapter 10 complete with code generation for function definitions, calls, calling conventions explanation, and 8+ MLIR IR examples.
  </done>
</task>

</tasks>

<verification>
Phase 3 Plan 01 verification:

1. **Chapter content check:**
   - Chapter 10 exists: ls tutorial/10-functions.md
   - Line count: wc -l tutorial/10-functions.md (expect 1800+)

2. **Requirement coverage:**
   - FUNC-01 (function definitions): grep "func.func\|FunDef\|compileFuncDef" tutorial/10-functions.md
   - FUNC-02 (function calls): grep "func.call\|App\|compileExpr.*App" tutorial/10-functions.md
   - FUNC-05 partial (calling conventions): grep -i "calling convention\|호출 규약" tutorial/10-functions.md

3. **Technical content:**
   - Block arguments: grep "block argument\|블록 인자" tutorial/10-functions.md
   - Symbol references: grep "@\|symbol" tutorial/10-functions.md
   - Environment integration: grep "environment\|env\|환경" tutorial/10-functions.md

4. **Examples and errors:**
   - MLIR IR examples: grep -c "```mlir" tutorial/10-functions.md (expect 8+)
   - Common errors section: grep -i "common error\|오류" tutorial/10-functions.md
</verification>

<success_criteria>
1. tutorial/10-functions.md exists with 1800+ lines
2. Contains complete func dialect explanation (func.func, func.call, func.return)
3. Contains AST extension (FunDef, App, Program)
4. Contains P/Invoke bindings for func dialect operations
5. Contains code generation (compileFuncDef, App case, compileProgram)
6. Contains calling conventions explanation (FUNC-05 partial)
7. Contains 8+ MLIR IR examples
8. Contains Common Errors section with 5 errors
9. Korean plain style maintained throughout
10. Git commit successful
</success_criteria>

<output>
After completion, create `.planning/phases/03-functions-recursion/03-01-SUMMARY.md`
</output>
