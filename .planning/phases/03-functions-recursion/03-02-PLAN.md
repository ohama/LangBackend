---
phase: 03-functions-recursion
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - tutorial/11-recursion.md
autonomous: true

must_haves:
  truths:
    - "Reader can compile recursive functions (e.g., factorial, fibonacci)"
    - "Reader can compile mutually recursive functions (e.g., is_even, is_odd)"
    - "Reader understands recursive calls work via module-level symbol table"
    - "Reader understands stack frame management and potential overflow"
    - "Reader understands tail call optimization opportunity"
  artifacts:
    - path: "tutorial/11-recursion.md"
      provides: "Chapter 11: Recursion with recursive and mutually recursive function compilation"
      min_lines: 800
      contains:
        - "factorial"
        - "fibonacci"
        - "is_even"
        - "is_odd"
        - "tail call"
        - "stack frame"
  key_links:
    - from: "Recursive calls"
      to: "func.call @self"
      via: "Symbol reference to own function"
    - from: "Mutual recursion"
      to: "Module symbol table"
      via: "All functions visible at module level"
---

<objective>
Write Chapter 11: Recursion covering recursive function compilation, mutual recursion, stack frames, and tail call optimization concepts.

Purpose: Enable readers to compile recursive functions like factorial and fibonacci, understand mutual recursion via symbol references, and grasp stack frame implications including tail call optimization.

Output: Complete tutorial chapter (800+ lines) with recursion patterns, mutual recursion, stack frame explanation, and 10+ MLIR IR examples.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-functions-recursion/03-RESEARCH.md
@.planning/phases/03-functions-recursion/03-01-SUMMARY.md (Plan 01 output)
@tutorial/10-functions.md (Chapter 10 - previous chapter from Plan 01)
@tutorial/08-control-flow.md (scf.if used in recursive conditions)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Chapter 11 part 1 - Recursion fundamentals and simple examples</name>
  <files>tutorial/11-recursion.md</files>
  <action>
Write the first half of Chapter 11 covering:

1. **Introduction** (100 lines)
   - Recursion in functional programming (self-referential functions)
   - Why recursion is fundamental (no loops in pure FunLang)
   - Chapter goals: FUNC-03 (recursive), FUNC-04 (mutual), FUNC-05 (stack frames)
   - Scope: top-level named functions (closures in Phase 4)

2. **How Recursion Works in MLIR** (150 lines)
   - Module-level symbol table: all func.func operations visible
   - Self-reference via symbol: func.call @factorial inside @factorial
   - No forward declarations needed (unlike C)
   - Symbol resolution at compile time (verifier checks existence)
   - Difference from interpreter: env contains function, compiler uses symbols
   - MLIR IR example: factorial calling itself

3. **Recursive Function: Factorial** (FUNC-03) (200 lines)
   - FunLang source: let rec factorial n = if n <= 1 then 1 else n * factorial (n - 1)
   - AST representation (note: using existing FunDef, not new LetRec AST)
   - Compilation strategy:
     - Compile condition (n <= 1)
     - Compile if/then/else with scf.if
     - Recursive call in else branch: func.call @factorial
   - Complete MLIR IR output (func.func with scf.if and func.call)
   - Step-by-step execution trace: factorial 5 → 5 * factorial 4 → ...
   - Lowered LLVM IR (func-to-llvm, scf-to-cf)

4. **Recursive Function: Fibonacci** (150 lines)
   - FunLang source: let rec fib n = if n <= 1 then n else fib (n - 1) + fib (n - 2)
   - Double recursion pattern (two recursive calls)
   - Compilation: two func.call operations in else branch
   - Complete MLIR IR output
   - Performance note: exponential time complexity (2^n calls)
   - Preview: memoization or dynamic programming (out of scope for Phase 3)

5. **Stack Frame Management** (FUNC-05 continued) (200 lines)
   - What is a stack frame (activation record)
   - Contents: return address, parameters, local variables, saved registers
   - Each function call creates new stack frame
   - Recursive calls: stack grows with each call
   - Stack depth limit (platform dependent, typically 1-8 MB)
   - Visualization: factorial 5 → 5 stack frames
   - LLVM handles stack frame creation (frame pointer, stack pointer)
   - Why stack overflow happens (deep recursion, no optimization)
   - Example: factorial 100000 will crash (stack overflow)
   - Connection to Phase 2: functions use stack, closures will use heap

Total for Task 1: ~800 lines

**Style requirements:**
- Korean plain style (~이다/~한다) throughout
- English for: func.call, stack frame, recursion, factorial, fibonacci
- 4 MLIR IR examples showing expected output
- Execution trace diagrams using text
  </action>
  <verify>
Check file exists and contains required content:
- grep -c "factorial\|Factorial" tutorial/11-recursion.md should return 15+
- grep -c "fibonacci\|fib" tutorial/11-recursion.md should return 8+
- grep -c "stack frame\|스택 프레임" tutorial/11-recursion.md should return 5+
- grep -c "func.call @" tutorial/11-recursion.md should return 10+
- wc -l tutorial/11-recursion.md should be 700+ lines
  </verify>
  <done>
Chapter 11 part 1 complete with factorial, fibonacci, and stack frame explanation covering 800 lines.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write Chapter 11 part 2 - Mutual recursion and tail calls</name>
  <files>tutorial/11-recursion.md</files>
  <action>
Continue Chapter 11 with mutual recursion and advanced topics:

6. **Mutual Recursion** (FUNC-04) (250 lines)
   - What is mutual recursion (functions calling each other)
   - Classic example: is_even and is_odd
   - FunLang source:
     ```
     let rec is_even n = if n = 0 then true else is_odd (n - 1)
     let rec is_odd n = if n = 0 then false else is_even (n - 1)
     ```
   - Why it works: module-level symbol table (no forward declarations)
   - Compilation: both functions compiled to func.func, cross-references work
   - Complete MLIR IR output (two func.func operations calling each other)
   - Execution trace: is_even 4 → is_odd 3 → is_even 2 → is_odd 1 → is_even 0 → true
   - Order of definition doesn't matter in MLIR module
   - Verifier checks all symbol references resolve
   - Note: FunLang interpreter handles this differently (letrec binding)

7. **Tail Recursion and Tail Call Optimization** (200 lines)
   - What is tail position (last operation before return)
   - Tail call: function call in tail position
   - Tail call optimization (TCO): reuse stack frame, no stack growth
   - Why TCO matters for functional languages (recursion instead of loops)
   - Tail-recursive factorial:
     ```
     let rec factorial_tail n acc =
       if n <= 1 then acc else factorial_tail (n - 1) (n * acc)
     ```
   - Compare: regular factorial (n * recursive_call) vs tail (recursive_call is last)
   - MLIR/LLVM TCO:
     - LLVM can recognize and optimize tail calls
     - Requires: tailcc calling convention or tail attribute
     - Not automatic with C calling convention
   - How to enable TCO in LLVM (-tailcallopt flag)
   - MLIR IR example: tail-recursive factorial with tail attribute
   - Note: FunLang Phase 3 doesn't guarantee TCO (educational focus, LLVM may optimize)

8. **Code Generation Updates** (150 lines)
   - No changes to compileFuncDef (from Chapter 10)
   - Recursive calls handled naturally by func.call @name
   - Self-reference works because function already in module when compiling body
   - Mutual recursion: compile all function headers first, then bodies
     - Alternative: compile sequentially, MLIR verifier runs after all functions added
   - Compilation strategy for mutually recursive functions:
     - Approach 1: Add all func.func to module, MLIR allows forward references
     - Approach 2: Create function stubs, then fill in bodies
     - FunLang uses Approach 1 (simpler, MLIR handles it)
   - Complete compileProgram with mutual recursion handling

9. **Complete Example: Multiple Recursive Functions** (150 lines)
   - Full program: factorial, fibonacci, is_even, is_odd, main
   - Complete AST
   - Complete MLIR IR output (4 functions + main)
   - Compilation commands (mlir-opt, mlir-translate, llc, gcc)
   - Execution output

10. **Performance Considerations** (100 lines)
    - Recursive vs iterative performance
    - Stack frame overhead (creation, destruction)
    - Call instruction overhead (jump, return)
    - When recursion is okay (shallow, tail-optimized)
    - When to avoid deep recursion (use iteration or trampolining)
    - FunLang focus: educational, correctness over performance
    - Phase 7 optimization: TCO, inlining (preview)

11. **Common Errors** (100 lines)
    - Error 1: Infinite recursion (no base case)
    - Error 2: Stack overflow (deep recursion without TCO)
    - Error 3: Symbol not found (typo in recursive call)
    - Error 4: Wrong argument order in mutual recursion
    - Error 5: Non-tail position prevents TCO
    - Solutions for each error
    - Debugging tips: add print statements, check base case

12. **Chapter Summary and Phase 3 Completion** (100 lines)
    - Phase 3 complete: functions, calls, recursion, mutual recursion
    - Reader can now compile full functional programs
    - Stack frame management understood
    - TCO opportunity identified (LLVM handles it)
    - Preview Phase 4: closures, lambda expressions, higher-order functions
    - Phase 4 will use heap allocation (Chapter 09 GC ready)

Total for Task 2: ~1050 lines
Combined chapter: ~1850 lines

**Style requirements:**
- Korean plain style (~이다/~한다) throughout
- Technical terms in English: tail call, TCO, stack frame, mutual recursion
- 6+ additional MLIR IR examples (10+ total)
- Common Errors section required
- Phase completion summary required
  </action>
  <verify>
Complete verification:
- wc -l tutorial/11-recursion.md should be 1600+ lines
- grep -c "is_even\|is_odd" tutorial/11-recursion.md should return 15+
- grep -c "tail call\|tail recursion\|꼬리 호출\|꼬리 재귀" tutorial/11-recursion.md should return 8+
- grep -c "```mlir" tutorial/11-recursion.md should return 10+
- grep -c "Common Error\|일반적인 오류\|오류" tutorial/11-recursion.md should return 5+
  </verify>
  <done>
Chapter 11 complete with mutual recursion (is_even/is_odd), tail call optimization, stack frames, and Phase 3 completion summary.
  </done>
</task>

</tasks>

<verification>
Phase 3 Plan 02 verification:

1. **Chapter content check:**
   - Chapter 11 exists: ls tutorial/11-recursion.md
   - Line count: wc -l tutorial/11-recursion.md (expect 1600+)

2. **Requirement coverage:**
   - FUNC-03 (recursive): grep "factorial\|fibonacci\|재귀" tutorial/11-recursion.md
   - FUNC-04 (mutual recursion): grep "is_even\|is_odd\|상호 재귀" tutorial/11-recursion.md
   - FUNC-05 (stack frames): grep "stack frame\|스택 프레임\|calling convention" tutorial/11-recursion.md

3. **Technical content:**
   - Self-reference: grep "func.call @.*@" tutorial/11-recursion.md
   - Tail calls: grep "tail call\|tail recursion" tutorial/11-recursion.md
   - Symbol table: grep "symbol\|심볼" tutorial/11-recursion.md

4. **Examples and errors:**
   - MLIR IR examples: grep -c "```mlir" tutorial/11-recursion.md (expect 10+)
   - Common errors section: grep -i "common error\|오류" tutorial/11-recursion.md
   - Phase completion: grep "Phase 3\|페이즈 3" tutorial/11-recursion.md
</verification>

<success_criteria>
1. tutorial/11-recursion.md exists with 1600+ lines
2. Contains factorial and fibonacci recursive examples (FUNC-03)
3. Contains is_even/is_odd mutual recursion example (FUNC-04)
4. Contains stack frame management explanation (FUNC-05)
5. Contains tail call optimization discussion
6. Contains 10+ MLIR IR examples
7. Contains Common Errors section with 5 errors
8. Contains Phase 3 completion summary
9. Korean plain style maintained throughout
10. Git commit successful
</success_criteria>

<output>
After completion, create `.planning/phases/03-functions-recursion/03-02-SUMMARY.md`
</output>
