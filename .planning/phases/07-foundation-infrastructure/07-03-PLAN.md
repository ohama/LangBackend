---
phase: 07-foundation-infrastructure
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - src/FunLang.Compiler/FunLang.Compiler.fsproj
  - src/FunLang.Compiler/MlirWrapper.fs
autonomous: true

must_haves:
  truths:
    - "Developer can use F# 'use' keyword with Context for automatic cleanup"
    - "Developer can use F# 'use' keyword with Module for automatic cleanup"
    - "Developer can create MLIR constants using OpBuilder fluent API"
    - "All wrapper types prevent premature parent disposal"
  artifacts:
    - path: "src/FunLang.Compiler/MlirWrapper.fs"
      provides: "IDisposable wrappers and fluent OpBuilder"
      exports: ["Context", "Module", "Location", "OpBuilder"]
      min_lines: 250
  key_links:
    - from: "MlirWrapper.Module"
      to: "MlirWrapper.Context"
      via: "parent reference field"
      pattern: "contextRef.*Context"
    - from: "MlirWrapper.OpBuilder"
      to: "MlirNative"
      via: "P/Invoke calls"
      pattern: "MlirNative\\."
---

<objective>
Create IDisposable wrapper classes (Context, Module, Location) and fluent OpBuilder for convenient MLIR IR construction.

Purpose: The wrapper layer makes MLIR programming safe (automatic resource cleanup) and convenient (fluent API). This is the API that later compiler phases will use.
Output: Working `MlirWrapper.fs` with Context, Module, Location wrappers and OpBuilder class.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-foundation-infrastructure/07-02-SUMMARY.md
@.planning/phases/07-foundation-infrastructure/07-RESEARCH.md
@tutorial/04-wrapper-layer.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Context and Location wrappers</name>
  <files>
    src/FunLang.Compiler/FunLang.Compiler.fsproj
    src/FunLang.Compiler/MlirWrapper.fs
  </files>
  <action>
Create MlirWrapper.fs with Context and Location types. Update fsproj to include new file.

**Update FunLang.Compiler.fsproj:**
```xml
<ItemGroup>
  <Compile Include="MlirBindings.fs" />
  <Compile Include="MlirWrapper.fs" />
</ItemGroup>
```

**MlirWrapper.fs structure:**

```fsharp
namespace FunLang.Compiler

open System
open System.Runtime.InteropServices

/// MLIR Context wrapper with automatic resource management.
/// Root object that owns all MLIR resources (dialects, types, attributes).
type Context() =
    let mutable handle = MlirNative.mlirContextCreate()
    let mutable disposed = false

    /// Raw MLIR context handle
    member _.Handle = handle

    /// Load a dialect by name (e.g., "func", "arith", "scf", "llvm")
    member _.LoadDialect(dialectName: string) =
        if disposed then raise (ObjectDisposedException("Context"))
        MlirStringRef.WithString dialectName (fun nameRef ->
            MlirNative.mlirContextGetOrLoadDialect(handle, nameRef) |> ignore)

    /// Load standard dialects needed for FunLang compilation
    member this.LoadStandardDialects() =
        this.LoadDialect("func")
        this.LoadDialect("arith")
        this.LoadDialect("scf")
        this.LoadDialect("llvm")

    interface IDisposable with
        member this.Dispose() =
            if not disposed then
                MlirNative.mlirContextDestroy(handle)
                handle <- Unchecked.defaultof<_>
                disposed <- true
```

**Location type (discriminated union, no IDisposable needed):**

```fsharp
/// Source location for MLIR diagnostics.
/// Locations are value types owned by Context, no manual cleanup needed.
type Location =
    | Unknown of Context
    | FileLineCol of Context * filename: string * line: int * col: int

    /// Get the raw MLIR location handle
    member this.Handle =
        match this with
        | Unknown ctx ->
            MlirNative.mlirLocationUnknownGet(ctx.Handle)
        | FileLineCol(ctx, filename, line, col) ->
            MlirStringRef.WithString filename (fun fnRef ->
                MlirNative.mlirLocationFileLineColGet(ctx.Handle, fnRef, uint32 line, uint32 col))

    /// Get the associated context
    member this.Context =
        match this with
        | Unknown ctx -> ctx
        | FileLineCol(ctx, _, _, _) -> ctx
```

**CRITICAL from research:**
- Context uses mutable handle and disposed flag
- Dispose pattern checks `disposed` to prevent double-free
- Location does NOT implement IDisposable (value type owned by context)
  </action>
  <verify>`dotnet build src/FunLang.Compiler/FunLang.Compiler.fsproj` succeeds</verify>
  <done>Context wrapper with IDisposable, LoadDialect, LoadStandardDialects. Location discriminated union with Unknown and FileLineCol cases.</done>
</task>

<task type="auto">
  <name>Task 2: Implement Module wrapper with parent reference</name>
  <files>
    src/FunLang.Compiler/MlirWrapper.fs
  </files>
  <action>
Add Module wrapper class. CRITICAL: Must hold parent Context reference to prevent premature GC.

```fsharp
/// MLIR Module wrapper with automatic resource management.
/// Modules are the top-level container for functions and operations.
type Module(context: Context, location: Location) =
    let handle = MlirNative.mlirModuleCreateEmpty(location.Handle)
    let contextRef = context  // CRITICAL: Keep parent alive
    let mutable disposed = false

    /// Raw MLIR module handle
    member _.Handle = handle

    /// Associated context (kept alive by this module)
    member _.Context = contextRef

    /// Get the module's body block (where operations are added)
    member _.Body =
        if disposed then raise (ObjectDisposedException("Module"))
        MlirNative.mlirModuleGetBody(handle)

    /// Get the module as an operation
    member _.Operation =
        if disposed then raise (ObjectDisposedException("Module"))
        MlirNative.mlirModuleGetOperation(handle)

    /// Print the module's IR to a string (for debugging)
    member _.Print() =
        if disposed then raise (ObjectDisposedException("Module"))
        let sb = System.Text.StringBuilder()
        let callback = MlirStringCallback(fun strRef _ ->
            let bytes = Array.zeroCreate<byte>(int strRef.Length)
            Marshal.Copy(strRef.Data, bytes, 0, int strRef.Length)
            sb.Append(System.Text.Encoding.UTF8.GetString(bytes)) |> ignore)
        MlirNative.mlirOperationPrint(MlirNative.mlirModuleGetOperation(handle), callback, nativeint 0)
        sb.ToString()

    interface IDisposable with
        member _.Dispose() =
            if not disposed then
                MlirNative.mlirModuleDestroy(handle)
                disposed <- true
```

**CRITICAL ownership pattern:**
- `contextRef = context` keeps the Context object alive as long as Module exists
- F# GC cannot collect Context while Module holds a reference
- This prevents the "premature parent disposal" pitfall from research
  </action>
  <verify>`dotnet build src/FunLang.Compiler/FunLang.Compiler.fsproj` succeeds</verify>
  <done>Module wrapper with IDisposable, parent Context reference, Body, Operation, and Print methods</done>
</task>

<task type="auto">
  <name>Task 3: Implement OpBuilder fluent API</name>
  <files>
    src/FunLang.Compiler/MlirWrapper.fs
  </files>
  <action>
Add OpBuilder class with fluent methods for common MLIR operations.

```fsharp
/// Fluent builder for MLIR operations.
/// Wraps verbose operation state construction with convenient methods.
type OpBuilder(context: Context) =
    let ctx = context

    // ==================== Type Helpers ====================

    /// Get i32 type
    member _.I32Type() = MlirNative.mlirIntegerTypeGet(ctx.Handle, 32u)

    /// Get i64 type
    member _.I64Type() = MlirNative.mlirIntegerTypeGet(ctx.Handle, 64u)

    /// Get i1 (boolean) type
    member _.I1Type() = MlirNative.mlirIntegerTypeGet(ctx.Handle, 1u)

    /// Get index type
    member _.IndexType() = MlirNative.mlirIndexTypeGet(ctx.Handle)

    /// Get LLVM pointer type (opaque pointer)
    member _.PtrType() = MlirNative.mlirLLVMPointerTypeGet(ctx.Handle, 0u)

    /// Create function type
    member _.FunctionType(inputs: MlirType[], results: MlirType[]) =
        use inputsPin = fixed inputs
        use resultsPin = fixed results
        MlirNative.mlirFunctionTypeGet(
            ctx.Handle,
            nativeint inputs.Length, inputsPin,
            nativeint results.Length, resultsPin)

    // ==================== Attribute Helpers ====================

    /// Create integer attribute
    member _.IntegerAttr(value: int64, typ: MlirType) =
        MlirNative.mlirIntegerAttrGet(typ, value)

    /// Create string attribute
    member _.StringAttr(value: string) =
        MlirStringRef.WithString value (fun strRef ->
            MlirNative.mlirStringAttrGet(ctx.Handle, strRef))

    /// Create flat symbol reference attribute
    member _.SymbolRefAttr(name: string) =
        MlirStringRef.WithString name (fun nameRef ->
            MlirNative.mlirFlatSymbolRefAttrGet(ctx.Handle, nameRef))

    /// Create named attribute
    member _.NamedAttr(name: string, attr: MlirAttribute) =
        MlirStringRef.WithString name (fun nameRef ->
            let id = MlirNative.mlirIdentifierGet(ctx.Handle, nameRef)
            MlirNative.mlirNamedAttributeGet(id, attr))

    // ==================== Operation Helpers ====================

    /// Get result value from operation at given index
    member _.GetResult(op: MlirOperation, index: int) =
        MlirNative.mlirOperationGetResult(op, nativeint index)

    /// Create a block with given argument types
    member _.CreateBlock(argTypes: MlirType[], location: Location) =
        let locs = Array.create argTypes.Length location.Handle
        use typesPin = fixed argTypes
        use locsPin = fixed locs
        MlirNative.mlirBlockCreate(nativeint argTypes.Length, typesPin, locsPin)

    /// Create an empty region
    member _.CreateRegion() =
        MlirNative.mlirRegionCreate()

    /// Append block to region
    member _.AppendBlockToRegion(region: MlirRegion, block: MlirBlock) =
        MlirNative.mlirRegionAppendOwnedBlock(region, block)

    /// Append operation to block
    member _.AppendOperationToBlock(block: MlirBlock, op: MlirOperation) =
        MlirNative.mlirBlockAppendOwnedOperation(block, op)

    // ==================== Generic Operation Creation ====================

    /// Create operation with given name, results, operands, attributes, and regions
    member _.CreateOperation(
        name: string,
        location: Location,
        resultTypes: MlirType[],
        operands: MlirValue[],
        attributes: MlirNamedAttribute[],
        regions: MlirRegion[]) =

        let mutable state = MlirStringRef.WithString name (fun nameRef ->
            MlirNative.mlirOperationStateGet(nameRef, location.Handle))

        if resultTypes.Length > 0 then
            use typesPin = fixed resultTypes
            MlirNative.mlirOperationStateAddResults(&state, nativeint resultTypes.Length, typesPin)

        if operands.Length > 0 then
            use operandsPin = fixed operands
            MlirNative.mlirOperationStateAddOperands(&state, nativeint operands.Length, operandsPin)

        if attributes.Length > 0 then
            use attrsPin = fixed attributes
            MlirNative.mlirOperationStateAddAttributes(&state, nativeint attributes.Length, attrsPin)

        if regions.Length > 0 then
            use regionsPin = fixed regions
            MlirNative.mlirOperationStateAddOwnedRegions(&state, nativeint regions.Length, regionsPin)

        MlirNative.mlirOperationCreate(&state)
```

**Key patterns:**
- Type helpers return raw MlirType (value types)
- Attribute helpers handle string marshalling internally
- CreateOperation is the generic entry point, wrapping MlirOperationState complexity
- Uses `use ... = fixed array` for pinning arrays when calling native code
  </action>
  <verify>`dotnet build src/FunLang.Compiler/FunLang.Compiler.fsproj` succeeds</verify>
  <done>OpBuilder class with type helpers, attribute helpers, operation creation. Generic CreateOperation method wraps MlirOperationState complexity.</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build verification:**
   ```bash
   dotnet build src/FunLang.Compiler/FunLang.Compiler.fsproj
   ```

2. **API surface check:**
   - Context: IDisposable, LoadDialect, LoadStandardDialects
   - Location: Unknown, FileLineCol discriminated union
   - Module: IDisposable, Body, Operation, Print, parent Context reference
   - OpBuilder: Type helpers (I32, I64, I1, Index, Ptr, Function), Attribute helpers, CreateOperation

3. **Ownership verification:**
   - Module constructor accepts Context
   - Module stores `contextRef = context`
   - Module.Context property returns stored reference
</verification>

<success_criteria>
- MlirWrapper.fs compiles successfully
- Context implements IDisposable with LoadDialect and LoadStandardDialects
- Location is discriminated union (Unknown, FileLineCol) without IDisposable
- Module implements IDisposable with parent Context reference
- Module.Print() returns IR as string
- OpBuilder has type helpers (I32Type, I64Type, I1Type, IndexType, PtrType, FunctionType)
- OpBuilder has attribute helpers (IntegerAttr, StringAttr, SymbolRefAttr, NamedAttr)
- OpBuilder has CreateOperation generic method
- All wrappers follow tutorial Chapter 04 patterns
</success_criteria>

<output>
After completion, create `.planning/phases/07-foundation-infrastructure/07-03-SUMMARY.md`
</output>
