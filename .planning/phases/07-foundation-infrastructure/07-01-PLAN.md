---
phase: 07-foundation-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/FunLang.Compiler/FunLang.Compiler.fsproj
  - src/FunLang.Compiler/MlirBindings.fs
autonomous: true

must_haves:
  truths:
    - "Developer can compile F# project with MLIR handle types"
    - "Developer can create MlirStringRef from F# string"
    - "Developer can call mlirContextCreate and mlirContextDestroy from F#"
  artifacts:
    - path: "src/FunLang.Compiler/FunLang.Compiler.fsproj"
      provides: "F# class library project targeting .NET 8.0"
      contains: "net8.0"
    - path: "src/FunLang.Compiler/MlirBindings.fs"
      provides: "Handle types and P/Invoke declarations"
      exports: ["MlirContext", "MlirModule", "MlirStringRef", "MlirNative"]
      min_lines: 200
  key_links:
    - from: "src/FunLang.Compiler/MlirBindings.fs"
      to: "MLIR-C"
      via: "DllImport with CallingConvention.Cdecl"
      pattern: 'DllImport.*"MLIR-C"'
---

<objective>
Create F# project structure and implement MLIR P/Invoke bindings for core APIs (context, module, location, dialect).

Purpose: This establishes the foundation for all FunLang compiler infrastructure. The P/Invoke layer enables F# to call MLIR-C API functions directly.
Output: Working `MlirBindings.fs` module with handle types, string marshalling, and core MLIR function bindings.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-foundation-infrastructure/07-RESEARCH.md
@tutorial/03-pinvoke-bindings.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create F# project structure</name>
  <files>
    src/FunLang.Compiler/FunLang.Compiler.fsproj
  </files>
  <action>
Create the F# class library project for the compiler:

1. Create directory structure: `src/FunLang.Compiler/`
2. Create `FunLang.Compiler.fsproj` with:
   - TargetFramework: net8.0
   - GenerateDocumentationFile: true
   - Compile Include for MlirBindings.fs

Project file content:
```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
  </PropertyGroup>
  <ItemGroup>
    <Compile Include="MlirBindings.fs" />
  </ItemGroup>
</Project>
```

This follows the tutorial Chapter 03 project structure pattern.
  </action>
  <verify>`dotnet build src/FunLang.Compiler/FunLang.Compiler.fsproj` succeeds (will fail initially until MlirBindings.fs created)</verify>
  <done>FunLang.Compiler.fsproj exists with correct target framework and file references</done>
</task>

<task type="auto">
  <name>Task 2: Implement handle types and string marshalling</name>
  <files>
    src/FunLang.Compiler/MlirBindings.fs
  </files>
  <action>
Create `MlirBindings.fs` with handle types and string marshalling. Follow tutorial Chapter 03 patterns exactly.

**Namespace:** `FunLang.Compiler`

**Handle Types (all must have `[<Struct>]` attribute):**
- MlirContext (manages dialects, types, global state)
- MlirModule (top-level IR container)
- MlirOperation (fundamental IR unit)
- MlirType (represents value types)
- MlirLocation (source location for diagnostics)
- MlirRegion (contains list of blocks)
- MlirBlock (basic block with operations)
- MlirValue (SSA value)
- MlirAttribute (compile-time constant)
- MlirDialectHandle (registered dialect handle)
- MlirIdentifier (interned string)

Each handle type wraps `nativeint` with constructor:
```fsharp
[<Struct>]
type MlirContext =
    val Handle: nativeint
    new(handle) = { Handle = handle }
```

**MlirStringRef (CRITICAL - must have StructLayout):**
```fsharp
[<Struct; StructLayout(LayoutKind.Sequential)>]
type MlirStringRef =
    val Data: nativeint
    val Length: nativeint
    new(data, length) = { Data = data; Length = length }

    static member FromString(s: string) =
        if String.IsNullOrEmpty(s) then
            MlirStringRef(nativeint 0, nativeint 0)
        else
            let bytes = System.Text.Encoding.UTF8.GetBytes(s)
            let ptr = Marshal.AllocHGlobal(bytes.Length)
            Marshal.Copy(bytes, 0, ptr, bytes.Length)
            MlirStringRef(ptr, nativeint bytes.Length)

    member this.Free() =
        if this.Data <> nativeint 0 then
            Marshal.FreeHGlobal(this.Data)

    static member WithString(s: string, f: MlirStringRef -> 'a) =
        let strRef = MlirStringRef.FromString(s)
        try f strRef
        finally strRef.Free()
```

**MlirNamedAttribute:**
```fsharp
[<Struct; StructLayout(LayoutKind.Sequential)>]
type MlirNamedAttribute =
    val Name: MlirIdentifier
    val Attribute: MlirAttribute
```

**Callback delegate type for IR printing:**
```fsharp
type MlirStringCallback = delegate of MlirStringRef * nativeint -> unit
```

**CRITICAL patterns from research:**
- Always use `CallingConvention = CallingConvention.Cdecl` in DllImport
- Always use `StructLayout(LayoutKind.Sequential)` for structs with multiple fields
- Use UTF-8 encoding for strings (not Ansi)
  </action>
  <verify>`dotnet build src/FunLang.Compiler/FunLang.Compiler.fsproj` succeeds with no errors</verify>
  <done>All handle types compile. MlirStringRef has FromString, Free, and WithString methods.</done>
</task>

<task type="auto">
  <name>Task 3: Implement core P/Invoke declarations</name>
  <files>
    src/FunLang.Compiler/MlirBindings.fs
  </files>
  <action>
Add MlirNative module with P/Invoke declarations for core MLIR-C API functions.

**Module structure:**
```fsharp
module MlirNative =
    // Context management
    [<DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)>]
    extern MlirContext mlirContextCreate()

    [<DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)>]
    extern void mlirContextDestroy(MlirContext ctx)

    // ... more functions
```

**Required functions by category:**

1. **Context Management:**
   - mlirContextCreate() -> MlirContext
   - mlirContextDestroy(MlirContext)
   - mlirContextGetOrLoadDialect(MlirContext, MlirStringRef) -> MlirDialect (or nativeint)
   - mlirContextIsNull(MlirContext) -> bool

2. **Module Management:**
   - mlirModuleCreateEmpty(MlirLocation) -> MlirModule
   - mlirModuleDestroy(MlirModule)
   - mlirModuleGetOperation(MlirModule) -> MlirOperation
   - mlirModuleGetBody(MlirModule) -> MlirBlock

3. **Location:**
   - mlirLocationUnknownGet(MlirContext) -> MlirLocation
   - mlirLocationFileLineColGet(MlirContext, MlirStringRef, uint32, uint32) -> MlirLocation

4. **Dialect Registration (for standard dialects):**
   - mlirGetDialectHandle__func__() -> MlirDialectHandle
   - mlirGetDialectHandle__arith__() -> MlirDialectHandle
   - mlirGetDialectHandle__scf__() -> MlirDialectHandle
   - mlirGetDialectHandle__llvm__() -> MlirDialectHandle
   - mlirDialectHandleRegisterDialect(MlirDialectHandle, MlirContext)

5. **Identifier:**
   - mlirIdentifierGet(MlirContext, MlirStringRef) -> MlirIdentifier

6. **IR Printing (for debugging):**
   - mlirOperationPrint(MlirOperation, MlirStringCallback, nativeint)
   - mlirModulePrint(MlirModule, MlirStringCallback, nativeint)

**CRITICAL:** Every DllImport MUST specify `CallingConvention = CallingConvention.Cdecl` to avoid crashes on Windows.

Follow tutorial Chapter 03 section "Context 관리", "Module 관리", "Location" for exact function signatures.
  </action>
  <verify>`dotnet build src/FunLang.Compiler/FunLang.Compiler.fsproj` succeeds. Check that MlirNative module has at least 15 extern declarations.</verify>
  <done>MlirNative module contains P/Invoke declarations for context, module, location, and dialect functions. All use CallingConvention.Cdecl.</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build verification:**
   ```bash
   dotnet build src/FunLang.Compiler/FunLang.Compiler.fsproj
   ```
   Should complete with 0 errors, 0 warnings.

2. **Code inspection:**
   - MlirBindings.fs has namespace `FunLang.Compiler`
   - At least 10 handle struct types defined
   - MlirStringRef has StructLayout attribute
   - MlirNative module has DllImport declarations
   - All DllImport use CallingConvention.Cdecl
</verification>

<success_criteria>
- F# project structure created at src/FunLang.Compiler/
- MlirBindings.fs compiles successfully
- Handle types defined for Context, Module, Operation, Type, Location, Region, Block, Value, Attribute
- MlirStringRef with FromString, Free, WithString helper methods
- MlirNative module with P/Invoke declarations for core MLIR-C API
- All P/Invoke declarations use CallingConvention.Cdecl
</success_criteria>

<output>
After completion, create `.planning/phases/07-foundation-infrastructure/07-01-SUMMARY.md`
</output>
