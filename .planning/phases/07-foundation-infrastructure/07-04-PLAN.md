---
phase: 07-foundation-infrastructure
plan: 04
type: execute
wave: 4
depends_on: ["07-03"]
files_modified:
  - tests/FunLang.Compiler.Tests/FunLang.Compiler.Tests.fsproj
  - tests/FunLang.Compiler.Tests/MlirBindingsTests.fs
autonomous: false

must_haves:
  truths:
    - "Developer can run tests that verify MLIR library linkage"
    - "Developer can create MLIR context, module, and operations from tests"
    - "Developer can see printed MLIR IR output from test module"
  artifacts:
    - path: "tests/FunLang.Compiler.Tests/FunLang.Compiler.Tests.fsproj"
      provides: "Test project referencing FunLang.Compiler"
      contains: "FunLang.Compiler"
    - path: "tests/FunLang.Compiler.Tests/MlirBindingsTests.fs"
      provides: "Smoke tests for MLIR bindings"
      min_lines: 50
  key_links:
    - from: "tests/FunLang.Compiler.Tests/MlirBindingsTests.fs"
      to: "src/FunLang.Compiler/MlirWrapper.fs"
      via: "imports FunLang.Compiler namespace"
      pattern: "open FunLang.Compiler"
---

<objective>
Create test project with smoke tests verifying MLIR bindings work with actual MLIR library.

Purpose: Validates that P/Invoke declarations correctly link to MLIR-C shared library and that basic operations work. This catches linkage issues before they block later phases.
Output: Test project with passing smoke tests that create MLIR context, module, and print IR.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-foundation-infrastructure/07-03-SUMMARY.md
@.planning/phases/07-foundation-infrastructure/07-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test project structure</name>
  <files>
    tests/FunLang.Compiler.Tests/FunLang.Compiler.Tests.fsproj
  </files>
  <action>
Create the F# test project with Expecto test framework.

1. Create directory: `tests/FunLang.Compiler.Tests/`

2. Create `FunLang.Compiler.Tests.fsproj`:
```xml
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <IsPackable>false</IsPackable>
    <GenerateDocumentationFile>false</GenerateDocumentationFile>
  </PropertyGroup>

  <ItemGroup>
    <Compile Include="MlirBindingsTests.fs" />
    <Compile Include="Program.fs" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Expecto" Version="10.2.1" />
    <PackageReference Include="YoloDev.Expecto.TestSdk" Version="0.14.3" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.9.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="../../src/FunLang.Compiler/FunLang.Compiler.fsproj" />
  </ItemGroup>

</Project>
```

3. Create `Program.fs` (Expecto entry point):
```fsharp
module Program

open Expecto

[<EntryPoint>]
let main args =
    runTestsInAssemblyWithCLIArgs [] args
```

This sets up Expecto with both `dotnet test` and direct execution support.
  </action>
  <verify>`dotnet build tests/FunLang.Compiler.Tests/FunLang.Compiler.Tests.fsproj` succeeds (will fail until MlirBindingsTests.fs created)</verify>
  <done>Test project created with Expecto dependency and reference to FunLang.Compiler</done>
</task>

<task type="auto">
  <name>Task 2: Implement MLIR bindings smoke tests</name>
  <files>
    tests/FunLang.Compiler.Tests/MlirBindingsTests.fs
  </files>
  <action>
Create smoke tests that verify MLIR bindings work correctly.

```fsharp
module MlirBindingsTests

open Expecto
open FunLang.Compiler

[<Tests>]
let contextTests =
    testList "Context" [
        test "can create and dispose context" {
            use ctx = new Context()
            Expect.isTrue (ctx.Handle <> nativeint 0) "Context handle should be non-null"
        }

        test "can load standard dialects" {
            use ctx = new Context()
            ctx.LoadStandardDialects()
            // If we get here without exception, dialects loaded successfully
        }
    ]

[<Tests>]
let moduleTests =
    testList "Module" [
        test "can create empty module" {
            use ctx = new Context()
            ctx.LoadStandardDialects()
            let loc = Location.Unknown ctx
            use mlirMod = new Module(ctx, loc)
            Expect.isTrue (mlirMod.Handle <> nativeint 0) "Module handle should be non-null"
        }

        test "can print empty module" {
            use ctx = new Context()
            ctx.LoadStandardDialects()
            let loc = Location.Unknown ctx
            use mlirMod = new Module(ctx, loc)
            let ir = mlirMod.Print()
            Expect.stringContains ir "module" "IR should contain 'module'"
        }
    ]

[<Tests>]
let opBuilderTests =
    testList "OpBuilder" [
        test "can get i32 type" {
            use ctx = new Context()
            let builder = OpBuilder(ctx)
            let i32Type = builder.I32Type()
            Expect.isTrue (i32Type.Handle <> nativeint 0) "Type handle should be non-null"
        }

        test "can create integer attribute" {
            use ctx = new Context()
            ctx.LoadStandardDialects()
            let builder = OpBuilder(ctx)
            let i32Type = builder.I32Type()
            let attr = builder.IntegerAttr(42L, i32Type)
            Expect.isTrue (attr.Handle <> nativeint 0) "Attribute handle should be non-null"
        }

        test "can create function type" {
            use ctx = new Context()
            let builder = OpBuilder(ctx)
            let i32Type = builder.I32Type()
            let funcType = builder.FunctionType([| i32Type |], [| i32Type |])
            Expect.isTrue (funcType.Handle <> nativeint 0) "Function type handle should be non-null"
        }
    ]

[<Tests>]
let integrationTests =
    testList "Integration" [
        test "can create arith.constant operation" {
            use ctx = new Context()
            ctx.LoadStandardDialects()
            let loc = Location.Unknown ctx
            let builder = OpBuilder(ctx)

            // Create constant: arith.constant 42 : i32
            let i32Type = builder.I32Type()
            let valueAttr = builder.IntegerAttr(42L, i32Type)
            let namedAttr = builder.NamedAttr("value", valueAttr)

            let constOp = builder.CreateOperation(
                "arith.constant",
                loc,
                [| i32Type |],     // result types
                [||],              // operands
                [| namedAttr |],   // attributes
                [||])              // regions

            Expect.isTrue (constOp.Handle <> nativeint 0) "Operation handle should be non-null"

            let result = builder.GetResult(constOp, 0)
            Expect.isTrue (result.Handle <> nativeint 0) "Result value should be non-null"
        }

        test "can build and print simple module with constant" {
            use ctx = new Context()
            ctx.LoadStandardDialects()
            let loc = Location.Unknown ctx
            use mlirMod = new Module(ctx, loc)
            let builder = OpBuilder(ctx)

            // Create arith.constant
            let i32Type = builder.I32Type()
            let valueAttr = builder.IntegerAttr(42L, i32Type)
            let namedAttr = builder.NamedAttr("value", valueAttr)

            let constOp = builder.CreateOperation(
                "arith.constant",
                loc,
                [| i32Type |],
                [||],
                [| namedAttr |],
                [||])

            // Add to module body
            builder.AppendOperationToBlock(mlirMod.Body, constOp)

            let ir = mlirMod.Print()
            printfn "Generated IR:\n%s" ir

            Expect.stringContains ir "arith.constant" "IR should contain arith.constant"
            Expect.stringContains ir "42" "IR should contain value 42"
        }
    ]
```

**Test categories:**
1. **Context tests:** Create, dispose, load dialects
2. **Module tests:** Create, print IR
3. **OpBuilder tests:** Types, attributes
4. **Integration tests:** Create operation, build module with operations
  </action>
  <verify>`dotnet test tests/FunLang.Compiler.Tests/` should attempt to run tests (may fail if MLIR library not in path)</verify>
  <done>MlirBindingsTests.fs with smoke tests for Context, Module, OpBuilder, and integration tests</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete MLIR P/Invoke bindings and wrapper layer with smoke tests.

Files created:
- src/FunLang.Compiler/FunLang.Compiler.fsproj
- src/FunLang.Compiler/MlirBindings.fs (P/Invoke layer)
- src/FunLang.Compiler/MlirWrapper.fs (IDisposable wrappers + OpBuilder)
- tests/FunLang.Compiler.Tests/FunLang.Compiler.Tests.fsproj
- tests/FunLang.Compiler.Tests/MlirBindingsTests.fs
  </what-built>
  <how-to-verify>
1. Ensure MLIR library is accessible. Set environment variable:
   ```bash
   export MLIR_INSTALL_PATH=/path/to/llvm-install  # Your LLVM build directory
   export LD_LIBRARY_PATH=$MLIR_INSTALL_PATH/lib:$LD_LIBRARY_PATH
   ```

2. Build the entire solution:
   ```bash
   dotnet build src/FunLang.Compiler/FunLang.Compiler.fsproj
   dotnet build tests/FunLang.Compiler.Tests/FunLang.Compiler.Tests.fsproj
   ```

3. Run the tests:
   ```bash
   dotnet test tests/FunLang.Compiler.Tests/ --logger "console;verbosity=detailed"
   ```

4. Expected output:
   - All tests should pass
   - Integration test should print MLIR IR containing "arith.constant" and "42"

5. If tests fail with DllNotFoundException:
   - Verify MLIR-C shared library exists: `ls $MLIR_INSTALL_PATH/lib/libMLIR-C*`
   - Verify LD_LIBRARY_PATH includes the library directory
   - On Windows WSL, library should be libMLIR-C.so
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe any failures</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build verification:**
   ```bash
   dotnet build tests/FunLang.Compiler.Tests/FunLang.Compiler.Tests.fsproj
   ```

2. **Test execution:**
   ```bash
   dotnet test tests/FunLang.Compiler.Tests/ -v n
   ```

3. **Expected test output:**
   - Context tests: 2 passed
   - Module tests: 2 passed
   - OpBuilder tests: 3 passed
   - Integration tests: 2 passed
   - Total: 9 tests passed
</verification>

<success_criteria>
- Test project created with Expecto
- Tests compile successfully
- Tests run (may need MLIR library path setup)
- Context creation/disposal works
- Module creation/printing works
- OpBuilder type and attribute helpers work
- Integration test creates arith.constant and prints IR
- Human verification confirms tests pass with real MLIR library
</success_criteria>

<output>
After completion, create `.planning/phases/07-foundation-infrastructure/07-04-SUMMARY.md`
</output>
