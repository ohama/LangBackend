---
phase: 07-foundation-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/FunLang.Compiler/MlirBindings.fs
autonomous: true

must_haves:
  truths:
    - "Developer can create MLIR types (i32, i64, function types) from F#"
    - "Developer can create MLIR operations with results, operands, and attributes"
    - "Developer can create regions and blocks"
  artifacts:
    - path: "src/FunLang.Compiler/MlirBindings.fs"
      provides: "Complete P/Invoke bindings for MLIR-C API"
      exports: ["MlirNative"]
      min_lines: 400
  key_links:
    - from: "MlirNative.mlirOperationCreate"
      to: "MlirOperationState"
      via: "operation state pointer parameter"
      pattern: "mlirOperationCreate.*MlirOperationState"
---

<objective>
Complete P/Invoke declarations for type system, operation building, region/block management, and value/attribute handling.

Purpose: This completes the thin P/Invoke layer, enabling F# to access all MLIR-C API functionality needed for compiler construction.
Output: Complete `MlirBindings.fs` with all required MLIR-C API bindings.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-foundation-infrastructure/07-01-SUMMARY.md
@.planning/phases/07-foundation-infrastructure/07-RESEARCH.md
@tutorial/03-pinvoke-bindings.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement type system P/Invoke declarations</name>
  <files>
    src/FunLang.Compiler/MlirBindings.fs
  </files>
  <action>
Add type system functions to MlirNative module. Follow tutorial Chapter 03 "타입 시스템" section.

**Required type functions:**

1. **Integer Types:**
   - mlirIntegerTypeGet(MlirContext, uint32 bitwidth) -> MlirType
   - mlirIntegerTypeSignedGet(MlirContext, uint32 bitwidth) -> MlirType
   - mlirIntegerTypeUnsignedGet(MlirContext, uint32 bitwidth) -> MlirType

2. **Index Type:**
   - mlirIndexTypeGet(MlirContext) -> MlirType

3. **Float Types:**
   - mlirF32TypeGet(MlirContext) -> MlirType
   - mlirF64TypeGet(MlirContext) -> MlirType

4. **Function Type:**
   - mlirFunctionTypeGet(MlirContext, nativeint numInputs, MlirType* inputs, nativeint numResults, MlirType* results) -> MlirType

5. **LLVM Pointer Type:**
   - mlirLLVMPointerTypeGet(MlirContext, uint32 addressSpace) -> MlirType

6. **Type Queries:**
   - mlirTypeIsNull(MlirType) -> bool
   - mlirTypeEqual(MlirType, MlirType) -> bool

**Example signature:**
```fsharp
[<DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)>]
extern MlirType mlirIntegerTypeGet(MlirContext ctx, uint32 bitwidth)
```

**CRITICAL for mlirFunctionTypeGet:** Use `nativeint` for size parameters and pointer types. F# arrays need to be pinned when passed to native code.
  </action>
  <verify>`dotnet build src/FunLang.Compiler/FunLang.Compiler.fsproj` succeeds</verify>
  <done>Type system functions added: integer types (signed, unsigned, generic), float types, function type, LLVM pointer type</done>
</task>

<task type="auto">
  <name>Task 2: Implement operation building P/Invoke declarations</name>
  <files>
    src/FunLang.Compiler/MlirBindings.fs
  </files>
  <action>
Add operation building functions to MlirNative module. This is the most complex part of the bindings.

**MlirOperationState struct (CRITICAL - must match C layout):**
```fsharp
[<Struct; StructLayout(LayoutKind.Sequential)>]
type MlirOperationState =
    val mutable Name: MlirStringRef
    val mutable Location: MlirLocation
    val mutable NumResults: nativeint
    val mutable Results: nativeint      // MlirType*
    val mutable NumOperands: nativeint
    val mutable Operands: nativeint     // MlirValue*
    val mutable NumRegions: nativeint
    val mutable Regions: nativeint      // MlirRegion*
    val mutable NumSuccessors: nativeint
    val mutable Successors: nativeint   // MlirBlock*
    val mutable NumAttributes: nativeint
    val mutable Attributes: nativeint   // MlirNamedAttribute*
    val mutable EnableResultTypeInference: bool
```

**Required operation functions:**

1. **Operation State:**
   - mlirOperationStateGet(MlirStringRef name, MlirLocation loc) -> MlirOperationState
   - mlirOperationStateAddResults(MlirOperationState* state, nativeint n, MlirType* results)
   - mlirOperationStateAddOperands(MlirOperationState* state, nativeint n, MlirValue* operands)
   - mlirOperationStateAddOwnedRegions(MlirOperationState* state, nativeint n, MlirRegion* regions)
   - mlirOperationStateAddAttributes(MlirOperationState* state, nativeint n, MlirNamedAttribute* attributes)

2. **Operation Creation:**
   - mlirOperationCreate(MlirOperationState* state) -> MlirOperation
   - mlirOperationDestroy(MlirOperation)

3. **Operation Queries:**
   - mlirOperationGetResult(MlirOperation, nativeint pos) -> MlirValue
   - mlirOperationGetNumResults(MlirOperation) -> nativeint
   - mlirOperationGetRegion(MlirOperation, nativeint pos) -> MlirRegion
   - mlirOperationGetBlock(MlirOperation) -> MlirBlock

**CRITICAL patterns:**
- Use `&` when passing MlirOperationState to AddXxx functions (by-ref)
- Use `mutable` for struct fields that will be modified
- Array parameters need careful marshalling (pin arrays or use Marshal.AllocHGlobal)
  </action>
  <verify>`dotnet build src/FunLang.Compiler/FunLang.Compiler.fsproj` succeeds</verify>
  <done>MlirOperationState struct defined with correct layout. Operation state functions and operation creation/query functions added.</done>
</task>

<task type="auto">
  <name>Task 3: Implement region, block, value, and attribute P/Invoke declarations</name>
  <files>
    src/FunLang.Compiler/MlirBindings.fs
  </files>
  <action>
Complete the bindings with region, block, value, and attribute functions.

**Region functions:**
- mlirRegionCreate() -> MlirRegion
- mlirRegionDestroy(MlirRegion)
- mlirRegionAppendOwnedBlock(MlirRegion, MlirBlock)
- mlirRegionGetFirstBlock(MlirRegion) -> MlirBlock

**Block functions:**
- mlirBlockCreate(nativeint numArgs, MlirType* args, MlirLocation* locs) -> MlirBlock
- mlirBlockDestroy(MlirBlock)
- mlirBlockAppendOwnedOperation(MlirBlock, MlirOperation)
- mlirBlockInsertOwnedOperationBefore(MlirBlock, MlirOperation ref, MlirOperation newOp)
- mlirBlockGetArgument(MlirBlock, nativeint pos) -> MlirValue
- mlirBlockGetNumArguments(MlirBlock) -> nativeint
- mlirBlockGetTerminator(MlirBlock) -> MlirOperation

**Value functions:**
- mlirValueIsNull(MlirValue) -> bool
- mlirValueGetType(MlirValue) -> MlirType
- mlirValueEqual(MlirValue, MlirValue) -> bool

**Attribute functions:**
- mlirIntegerAttrGet(MlirType, int64) -> MlirAttribute
- mlirFloatAttrDoubleGet(MlirContext, MlirType, float) -> MlirAttribute
- mlirStringAttrGet(MlirContext, MlirStringRef) -> MlirAttribute
- mlirUnitAttrGet(MlirContext) -> MlirAttribute
- mlirFlatSymbolRefAttrGet(MlirContext, MlirStringRef) -> MlirAttribute
- mlirNamedAttributeGet(MlirIdentifier, MlirAttribute) -> MlirNamedAttribute
- mlirAttributeIsNull(MlirAttribute) -> bool

**Example:**
```fsharp
[<DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)>]
extern MlirRegion mlirRegionCreate()

[<DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)>]
extern MlirBlock mlirBlockCreate(nativeint numArgs, MlirType* args, MlirLocation* locs)
```

**Final file organization:**
1. Handle types (at top)
2. MlirStringRef and MlirNamedAttribute
3. MlirOperationState
4. Callback delegates
5. MlirNative module with functions grouped by category:
   - Context
   - Module
   - Location
   - Dialect
   - Type
   - Operation
   - Region
   - Block
   - Value
   - Attribute
  </action>
  <verify>`dotnet build src/FunLang.Compiler/FunLang.Compiler.fsproj` succeeds. MlirBindings.fs should have 400+ lines.</verify>
  <done>Complete P/Invoke bindings for region, block, value, and attribute management. All MLIR-C API categories covered.</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build verification:**
   ```bash
   dotnet build src/FunLang.Compiler/FunLang.Compiler.fsproj
   ```

2. **Completeness check:** MlirNative module should have bindings for:
   - Context (3+ functions)
   - Module (4+ functions)
   - Location (2+ functions)
   - Dialect (5+ functions)
   - Type (8+ functions)
   - Operation (10+ functions)
   - Region (4+ functions)
   - Block (7+ functions)
   - Value (3+ functions)
   - Attribute (7+ functions)

3. **Pattern verification:**
   - All DllImport use CallingConvention.Cdecl
   - MlirOperationState has StructLayout attribute
   - Pointer parameters use nativeint or typed pointers
</verification>

<success_criteria>
- MlirBindings.fs compiles with complete P/Invoke layer
- MlirOperationState struct defined with correct Sequential layout
- Type system functions (integer, float, function, pointer types)
- Operation building functions (state, create, query)
- Region and block management functions
- Value and attribute handling functions
- All functions use CallingConvention.Cdecl
- Code follows tutorial Chapter 03 patterns exactly
</success_criteria>

<output>
After completion, create `.planning/phases/07-foundation-infrastructure/07-02-SUMMARY.md`
</output>
