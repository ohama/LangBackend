---
phase: 06-pattern-matching-data-structures
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - tutorial/17-pattern-matching-theory.md
  - tutorial/19-match-compilation.md
  - tutorial/20-functional-programs.md
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Reader understands how literal patterns compile (arith.cmpi + scf.if)"
    - "Reader understands wildcard optimization (no test generated)"
    - "Reader can compile match expressions with integer literals"
  artifacts:
    - path: "tutorial/17-pattern-matching-theory.md"
      provides: "Literal pattern theory and examples"
      contains: "리터럴 패턴"
    - path: "tutorial/19-match-compilation.md"
      provides: "Literal lowering implementation"
      contains: "arith.cmpi"
    - path: "tutorial/20-functional-programs.md"
      provides: "Literal pattern example"
      contains: "match.*with.*0"
  key_links:
    - from: "tutorial/19-match-compilation.md"
      to: "arith.cmpi + scf.if pattern"
      via: "literal lowering section"
      pattern: "arith\\.cmpi"
    - from: "tutorial/17-pattern-matching-theory.md"
      to: "wildcard optimization"
      via: "compilation strategy section"
      pattern: "와일드카드.*테스트"
---

<objective>
Close verification gaps for literal pattern matching (PMTC-01) and wildcard pattern compilation (PMTC-02).

Purpose: The phase goal states readers can compile pattern matching, but literal patterns like `match x with 0 -> ... | 1 -> ...` and wildcard optimization strategies are not explained. This plan adds implementation details for both.

Output:
- Extended section in Chapter 17 on literal pattern theory
- New section in Chapter 19 on literal pattern lowering (arith.cmpi vs scf.index_switch)
- Wildcard optimization explanation in Chapter 17
- Example using literal patterns in Chapter 20
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-pattern-matching-data-structures/06-VERIFICATION.md
@.planning/phases/06-pattern-matching-data-structures/06-01-SUMMARY.md
@.planning/phases/06-pattern-matching-data-structures/06-03-SUMMARY.md
@tutorial/17-pattern-matching-theory.md
@tutorial/19-match-compilation.md
@tutorial/20-functional-programs.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Literal and Wildcard Pattern Theory to Chapter 17</name>
  <files>tutorial/17-pattern-matching-theory.md</files>
  <action>
Add a new section "리터럴 패턴과 와일드카드 최적화" (Literal Patterns and Wildcard Optimization) before the Summary section. Include:

1. **리터럴 패턴 컴파일 (Literal Pattern Compilation)**
   - Explain how literal patterns differ from constructor patterns
   - Show pattern matrix with integer literals: `match x with 0 -> ... | 1 -> ... | _ -> ...`
   - Explain that literals don't decompose (no subpatterns unlike Cons)
   - Show specialization for literals: S(0, column, P) keeps rows with 0 or wildcard
   - Contrast with constructor dispatch: literals use equality test, not tag switch

2. **와일드카드 최적화 (Wildcard Optimization)**
   - Explain that wildcard patterns generate NO runtime test
   - Show compilation difference:
     - `match xs with _ :: tl -> ...` - tests tag only, ignores head
     - `match xs with hd :: tl -> ...` - tests tag, extracts head even if unused
   - Performance implication: wildcard saves extraction operations
   - Connect to defaulting operation: wildcards enable default branch

3. **생성 코드 비교 (Generated Code Comparison)**
   - Table comparing literal vs constructor vs wildcard compilation strategy
   - Show which MLIR operations each generates (arith.cmpi, scf.if, scf.index_switch)

Korean plain style (~이다/~한다), code/API names in English.
Target: ~400 lines addition.
  </action>
  <verify>grep -c "리터럴 패턴" tutorial/17-pattern-matching-theory.md returns >= 5</verify>
  <done>Chapter 17 has dedicated section explaining literal pattern compilation and wildcard optimization with concrete examples</done>
</task>

<task type="auto">
  <name>Task 2: Add Literal Pattern Lowering to Chapter 19</name>
  <files>tutorial/19-match-compilation.md</files>
  <action>
Add a new section "리터럴 패턴 로우어링" (Literal Pattern Lowering) after the MatchOpLowering section but before Common Errors. Include:

1. **생성자 vs 리터럴 디스패치 (Constructor vs Literal Dispatch)**
   - Constructor patterns: use tag (scf.index_switch) - O(1) dispatch
   - Literal patterns: use equality comparison (arith.cmpi + scf.if) - sequential tests
   - Explain why: constructors have fixed small set, literals are infinite

2. **리터럴 패턴 로우어링 구현 (Literal Pattern Lowering Implementation)**
   - Show funlang.match with integer literals:
     ```mlir
     %result = funlang.match %x : i32 -> i32 {
       ^case_0:
         funlang.yield %zero_result : i32
       ^case_1:
         funlang.yield %one_result : i32
       ^default:
         funlang.yield %other_result : i32
     }
     ```
   - Show lowering to arith.cmpi + scf.if chain:
     ```mlir
     %is_zero = arith.cmpi eq, %x, %c0 : i32
     %result = scf.if %is_zero -> i32 {
       scf.yield %zero_result : i32
     } else {
       %is_one = arith.cmpi eq, %x, %c1 : i32
       scf.if %is_one -> i32 {
         scf.yield %one_result : i32
       } else {
         scf.yield %other_result : i32
       }
     }
     ```

3. **최적화 기회 (Optimization Opportunities)**
   - Small dense ranges: can use scf.index_switch after range check
   - Jump table: LLVM optimizes sequential tests to switch when beneficial
   - Guard patterns: combine literal test with predicate guards

Korean plain style, code in English.
Target: ~300 lines addition.
  </action>
  <verify>grep -c "arith.cmpi" tutorial/19-match-compilation.md returns >= 3</verify>
  <done>Chapter 19 has section explaining literal pattern lowering with arith.cmpi + scf.if pattern</done>
</task>

<task type="auto">
  <name>Task 3: Add Literal Pattern Example to Chapter 20</name>
  <files>tutorial/20-functional-programs.md</files>
  <action>
Add a new subsection "리터럴 패턴 예제: fizzbuzz" (Literal Pattern Example: FizzBuzz) in the Complete Examples section (before or after sum_of_squares). Include:

1. **FizzBuzz 문제 (The FizzBuzz Problem)**
   - Classic interview problem: print "Fizz" for multiples of 3, "Buzz" for 5, "FizzBuzz" for both
   - Shows literal pattern matching on remainder values

2. **구현 (Implementation)**
   ```fsharp
   let fizzbuzz n =
     match (n % 3, n % 5) with
     | (0, 0) -> "FizzBuzz"
     | (0, _) -> "Fizz"
     | (_, 0) -> "Buzz"
     | (_, _) -> string_of_int n
   ```
   Note: This combines tuple and literal patterns. Since tuples aren't implemented yet, show simplified version:
   ```fsharp
   let classify n =
     let mod3 = n % 3 in
     match mod3 with
     | 0 -> "divisible by 3"
     | 1 -> "remainder 1"
     | 2 -> "remainder 2"
     | _ -> "unexpected"
   ```

3. **컴파일된 MLIR (Compiled MLIR)**
   - Show the arith.cmpi chain generated for literal matching
   - Show how _ (wildcard) default case generates no test

4. **생성 코드 효율 (Generated Code Efficiency)**
   - Compare code size with and without wildcard optimization
   - Note that LLVM may convert to switch for better performance

Korean plain style, code in English.
Target: ~200 lines addition.
  </action>
  <verify>grep -c "fizzbuzz\|classify" tutorial/20-functional-programs.md returns >= 3</verify>
  <done>Chapter 20 has practical example showing literal pattern matching with wildcard default</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. Chapter 17 contains "리터럴 패턴" (literal pattern) section with >= 5 occurrences
2. Chapter 19 contains "arith.cmpi" with >= 3 occurrences showing literal lowering
3. Chapter 20 contains fizzbuzz/classify example with >= 3 occurrences
4. All content follows Korean plain style with English code
5. Gap PMTC-01 (literal patterns) addressed with implementation details
6. Gap PMTC-02 (wildcard) addressed with optimization explanation
</verification>

<success_criteria>
- [ ] Chapter 17 has dedicated section on literal and wildcard pattern theory
- [ ] Chapter 19 has section showing literal pattern lowering to arith.cmpi + scf.if
- [ ] Chapter 20 has working example using literal patterns
- [ ] Reader now understands: literals use equality tests, constructors use tag dispatch
- [ ] Reader now understands: wildcards generate no test (optimization)
- [ ] PMTC-01 gap closed: reader can compile literal pattern matching
- [ ] PMTC-02 gap closed: reader understands wildcard compilation strategy
</success_criteria>

<output>
After completion, create `.planning/phases/06-pattern-matching-data-structures/06-05-SUMMARY.md`
</output>
