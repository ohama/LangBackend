---
phase: 06-pattern-matching-data-structures
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tutorial/17-pattern-matching-theory.md
  - tutorial/SUMMARY.md
autonomous: true

must_haves:
  truths:
    - "Reader understands decision tree compilation strategy"
    - "Reader can explain pattern matrix representation"
    - "Reader understands specialization and defaulting operations"
    - "Reader knows how exhaustiveness checking works"
  artifacts:
    - path: "tutorial/17-pattern-matching-theory.md"
      provides: "Pattern matching theory chapter"
      min_lines: 1200
      contains: "decision tree"
    - path: "tutorial/SUMMARY.md"
      provides: "Table of contents update"
      contains: "17-pattern-matching-theory"
  key_links:
    - from: "tutorial/17-pattern-matching-theory.md"
      to: "tutorial/16-lowering-passes.md"
      via: "builds on lowering infrastructure"
      pattern: "Chapter 16|lowering"
---

<objective>
Write Chapter 17: Pattern Matching Theory - explaining decision tree compilation strategy for pattern matching.

Purpose: Establish theoretical foundation for pattern matching compilation before implementation chapters. Readers need to understand the decision tree algorithm (Maranget 2008) before seeing MLIR operations and lowering code.

Output: tutorial/17-pattern-matching-theory.md (1200+ lines) covering decision tree algorithm, pattern matrix representation, specialization/defaulting, and exhaustiveness checking.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-pattern-matching-data-structures/06-RESEARCH.md

# Phase 5 established custom dialect infrastructure
@.planning/phases/05-custom-mlir-dialect/05-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Chapter 17 Part 1 - Introduction and Pattern Matrix</name>
  <files>tutorial/17-pattern-matching-theory.md</files>
  <action>
Create tutorial/17-pattern-matching-theory.md with:

**Introduction (150+ lines):**
- Phase 6 overview: pattern matching and data structures
- Why pattern matching matters in functional languages
- Chapter 17-20 roadmap preview
- Success criteria for this chapter

**Pattern Matching Problem Statement (200+ lines):**
- ML/OCaml/F# pattern matching syntax examples
- FunLang pattern matching syntax (match expression)
- Pattern types: literals, wildcards, constructors (Nil, Cons)
- The compilation problem: patterns to efficient branches
- Why naive compilation is inefficient (redundant tests)

**Pattern Matrix Representation (300+ lines):**
- Pattern matrix definition: rows = clauses, columns = scrutinees
- Example: matching on list (Nil vs Cons patterns)
- Matrix notation with actions
- Occurrence vectors (how to access subterms)
- Example matrix for nested patterns: Cons(x, Cons(y, _))

**Decision Tree Concept (250+ lines):**
- Decision tree structure: nodes (tests), leaves (actions), edges (outcomes)
- Comparison with naive if-else chains
- Benefits: each subterm tested at most once
- Visual diagram of decision tree for list matching
- Relationship between pattern matrix and decision tree

Write in Korean plain style (~이다/~한다). Keep code examples, API names, and technical terms in English.
  </action>
  <verify>
```bash
wc -l tutorial/17-pattern-matching-theory.md | grep -E "^[0-9]{3,}"
grep -c "pattern matrix\|패턴 매트릭스" tutorial/17-pattern-matching-theory.md
grep -c "decision tree\|결정 트리" tutorial/17-pattern-matching-theory.md
```
  </verify>
  <done>Part 1 complete with 900+ lines covering introduction, problem statement, pattern matrix, and decision tree concept</done>
</task>

<task type="auto">
  <name>Task 2: Write Chapter 17 Part 2 - Algorithm and Exhaustiveness</name>
  <files>tutorial/17-pattern-matching-theory.md</files>
  <action>
Continue tutorial/17-pattern-matching-theory.md with:

**Specialization Operation (250+ lines):**
- Definition: specialize(matrix, column, constructor)
- What specialization does: filters rows, expands constructor patterns
- Example: specialize on Cons constructor
  - Row with Cons(x, xs) -> row with [x, xs, ...]
  - Row with wildcard _ -> row with [_, _, ...]
  - Row with Nil -> removed (incompatible)
- Pseudocode for specialization algorithm
- Visual before/after matrix examples

**Defaulting Operation (200+ lines):**
- Definition: default(matrix, column)
- What defaulting does: keep wildcard rows, remove tested column
- Example: default operation on list patterns
  - Row with _ -> kept, column removed
  - Row with Cons(...) or Nil -> removed
- Pseudocode for default algorithm
- When defaulting produces empty matrix (all patterns are constructors)

**Complete Compilation Algorithm (300+ lines):**
- Recursive compile_decision_tree function
- Base cases:
  - Empty matrix -> MatchFailure (non-exhaustive)
  - First row all wildcards -> Success(action)
- Recursive case:
  - Select column (heuristic: needed by most rows)
  - Get constructors in that column
  - For each constructor: specialize, recurse
  - Default branch: default, recurse
- Column selection heuristics (left-to-right vs needed-first)
- Pseudocode with detailed comments

**Exhaustiveness Checking (200+ lines):**
- Non-exhaustive patterns = empty matrix case
- How algorithm naturally detects missing cases
- Error reporting: which patterns are missing
- FunLang approach: require wildcard or full coverage
- Example: missing Nil case detection

**Summary and Chapter 18 Preview (100+ lines):**
- Key concepts recap
- Connection to MLIR lowering (funlang.match -> SCF)
- Chapter 18 preview: list operations (funlang.nil, funlang.cons)

Update tutorial/SUMMARY.md to add Chapter 17 entry.

Write in Korean plain style (~이다/~한다). Keep code examples, API names, and technical terms in English.
  </action>
  <verify>
```bash
wc -l tutorial/17-pattern-matching-theory.md | grep -E "^1[2-9][0-9]{2}|^[2-9][0-9]{3}"
grep -c "specialize\|specialization\|특수화" tutorial/17-pattern-matching-theory.md
grep -c "default\|defaulting" tutorial/17-pattern-matching-theory.md
grep -c "exhaustive\|exhaustiveness\|완전성" tutorial/17-pattern-matching-theory.md
grep "17-pattern-matching-theory" tutorial/SUMMARY.md
```
  </verify>
  <done>Chapter 17 complete with 1200+ lines, specialization/defaulting algorithms, exhaustiveness checking, and SUMMARY.md updated</done>
</task>

</tasks>

<verification>
All checks must pass:

```bash
# Chapter 17 exists with sufficient content
test -f tutorial/17-pattern-matching-theory.md && echo "Chapter 17 exists"
wc -l tutorial/17-pattern-matching-theory.md  # Should be 1200+

# Core concepts covered
grep -c "decision tree" tutorial/17-pattern-matching-theory.md  # Should be 10+
grep -c "pattern matrix" tutorial/17-pattern-matching-theory.md  # Should be 10+
grep -c "specialize" tutorial/17-pattern-matching-theory.md  # Should be 5+
grep -c "default" tutorial/17-pattern-matching-theory.md  # Should be 5+
grep -c "exhaustive" tutorial/17-pattern-matching-theory.md  # Should be 3+

# SUMMARY.md updated
grep "17-pattern-matching-theory" tutorial/SUMMARY.md
```
</verification>

<success_criteria>
- tutorial/17-pattern-matching-theory.md exists with 1200+ lines
- Pattern matrix representation explained with examples
- Decision tree algorithm explained with pseudocode
- Specialization and defaulting operations documented
- Exhaustiveness checking explained
- SUMMARY.md updated with Chapter 17 entry
- Korean plain style used throughout
</success_criteria>

<output>
After completion, create `.planning/phases/06-pattern-matching-data-structures/06-01-SUMMARY.md`
</output>
