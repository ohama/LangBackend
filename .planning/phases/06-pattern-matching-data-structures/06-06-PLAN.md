---
phase: 06-pattern-matching-data-structures
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - tutorial/18-list-operations.md
  - tutorial/19-match-compilation.md
  - tutorial/20-functional-programs.md
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Reader can define !funlang.tuple<T1, T2, ...> parameterized type"
    - "Reader can create tuples with funlang.make_tuple operation"
    - "Reader can compile tuple destructuring in pattern matching"
  artifacts:
    - path: "tutorial/18-list-operations.md"
      provides: "Tuple type and construction operation"
      contains: "funlang.tuple"
    - path: "tutorial/19-match-compilation.md"
      provides: "Tuple pattern matching support"
      contains: "튜플 패턴"
    - path: "tutorial/20-functional-programs.md"
      provides: "Tuple pattern example (zip or point)"
      contains: "make_tuple"
  key_links:
    - from: "tutorial/18-list-operations.md"
      to: "tuple type definition"
      via: "TableGen type with variadic parameters"
      pattern: "funlang\\.tuple"
    - from: "tutorial/19-match-compilation.md"
      to: "tuple destructuring"
      via: "extractvalue pattern"
      pattern: "llvm\\.extractvalue"
---

<objective>
Close verification gap for tuple pattern matching (PMTC-05).

Purpose: The phase goal explicitly states "lists **and tuples**" but tuple patterns are completely missing. This plan adds tuple type definition, construction operation, and pattern matching support.

Output:
- New section in Chapter 18 for tuple type and make_tuple operation
- New section in Chapter 19 for tuple pattern matching
- Tuple example in Chapter 20 (zip function or point manipulation)
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-pattern-matching-data-structures/06-VERIFICATION.md
@.planning/phases/06-pattern-matching-data-structures/06-02-SUMMARY.md
@.planning/phases/06-pattern-matching-data-structures/06-03-SUMMARY.md
@tutorial/18-list-operations.md
@tutorial/19-match-compilation.md
@tutorial/20-functional-programs.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Tuple Type and Operation to Chapter 18</name>
  <files>tutorial/18-list-operations.md</files>
  <action>
Add a new section "튜플 타입과 연산" (Tuple Type and Operations) after the Cons operation section but before TypeConverter. Include:

1. **튜플 타입 설계 (Tuple Type Design)**
   - Contrast with lists: tuples have fixed arity, heterogeneous elements
   - Type syntax: `!funlang.tuple<i32, f64>` for pair of int and float
   - Variadic type parameter in TableGen (Variadic<Type>)
   - Memory representation: `!llvm.struct<(T1, T2, ...)>` - no tag needed, fixed layout

2. **TableGen 정의 (TableGen Definition)**
   ```tablegen
   def FunLang_TupleType : FunLang_Type<"Tuple", "tuple"> {
     let summary = "FunLang tuple type";
     let description = [{
       Fixed-size product type with heterogeneous elements.
       `!funlang.tuple<i32, f64>` is a pair of integer and float.
     }];
     let parameters = (ins
       ArrayRefParameter<"mlir::Type", "element types">:$elementTypes
     );
     let assemblyFormat = "`<` $elementTypes `>`";
   }
   ```

3. **funlang.make_tuple 연산 (make_tuple Operation)**
   ```tablegen
   def FunLang_MakeTupleOp : FunLang_Op<"make_tuple", [Pure]> {
     let summary = "Create a tuple from values";
     let arguments = (ins Variadic<AnyType>:$elements);
     let results = (outs FunLang_TupleType:$result);
     let assemblyFormat = "`(` $elements `)` attr-dict `:` type($result)";
   }
   ```
   - Example: `%pair = funlang.make_tuple(%x, %y) : !funlang.tuple<i32, i32>`
   - Pure trait: no side effects, enables CSE

4. **로우어링 (Lowering)**
   - TupleType lowering in TypeConverter: map to llvm.struct
   - MakeTupleOpLowering: create struct with insertvalue chain
   ```mlir
   // Before lowering
   %pair = funlang.make_tuple(%a, %b) : !funlang.tuple<i32, f64>

   // After lowering
   %0 = llvm.mlir.undef : !llvm.struct<(i32, f64)>
   %1 = llvm.insertvalue %a, %0[0] : !llvm.struct<(i32, f64)>
   %2 = llvm.insertvalue %b, %1[1] : !llvm.struct<(i32, f64)>
   ```
   - Note: Unlike lists, tuples don't need heap allocation (value semantics)

5. **C API 및 F# 바인딩 (C API and F# Bindings)**
   - funlangTupleTypeGet(context, elementTypes, numElements)
   - funlangMakeTupleOpCreate(builder, elements, numElements)
   - F# CreateTupleType and CreateMakeTupleOp

Korean plain style, code in English.
Target: ~500 lines addition.
  </action>
  <verify>grep -c "funlang.tuple\|make_tuple" tutorial/18-list-operations.md returns >= 10</verify>
  <done>Chapter 18 has complete tuple type and make_tuple operation with TableGen, lowering, and bindings</done>
</task>

<task type="auto">
  <name>Task 2: Add Tuple Pattern Matching to Chapter 19</name>
  <files>tutorial/19-match-compilation.md</files>
  <action>
Add a new section "튜플 패턴 매칭" (Tuple Pattern Matching) after the literal pattern section (from 06-05) or after MatchOpLowering. Include:

1. **튜플 패턴 특성 (Tuple Pattern Characteristics)**
   - Tuples always match (no tag to check, unlike list Nil/Cons)
   - Pattern matching = destructuring = extracting components
   - Pattern: `match pair with (x, y) -> x + y`
   - No branches needed, just extraction

2. **funlang.match 튜플 지원 (Tuple Support in funlang.match)**
   ```mlir
   // Source: let (x, y) = pair in x + y
   %sum = funlang.match %pair : !funlang.tuple<i32, i32> -> i32 {
     ^case(%x: i32, %y: i32):
       %result = arith.addi %x, %y : i32
       funlang.yield %result : i32
   }
   ```
   - Single case (tuples don't have multiple constructors)
   - Block arguments = destructured components

3. **튜플 로우어링 구현 (Tuple Lowering Implementation)**
   - No tag check needed (tuples always match)
   - Direct extractvalue for each component:
   ```mlir
   // Before lowering
   %sum = funlang.match %pair : !funlang.tuple<i32, i32> -> i32 {
     ^case(%x: i32, %y: i32):
       ...
   }

   // After lowering (inline, no scf.index_switch)
   %x = llvm.extractvalue %pair[0] : !llvm.struct<(i32, i32)>
   %y = llvm.extractvalue %pair[1] : !llvm.struct<(i32, i32)>
   %result = arith.addi %x, %y : i32
   ```
   - Key insight: tuple match with single case = let binding

4. **중첩 패턴 (Nested Patterns)**
   - `match (xs, ys) with (Nil, _) -> ... | (Cons(h, t), ys) -> ...`
   - Tuple destructuring + list pattern combination
   - Compile to: extractvalue for tuple, then tag dispatch for list

5. **리스트 vs 튜플 비교 (List vs Tuple Comparison)**

   | Feature | List | Tuple |
   |---------|------|-------|
   | Arity | Variable | Fixed |
   | Elements | Homogeneous | Heterogeneous |
   | Tag | Required (Nil/Cons) | Not needed |
   | Pattern cases | Multiple (2+) | Single |
   | Dispatch | scf.index_switch | Direct extraction |
   | Allocation | Heap (GC) | Stack/inline |

Korean plain style, code in English.
Target: ~400 lines addition.
  </action>
  <verify>grep -c "튜플 패턴\|extractvalue" tutorial/19-match-compilation.md returns >= 5</verify>
  <done>Chapter 19 has complete tuple pattern matching section with lowering and comparison to lists</done>
</task>

<task type="auto">
  <name>Task 3: Add Tuple Example to Chapter 20</name>
  <files>tutorial/20-functional-programs.md</files>
  <action>
Add a new subsection "튜플 예제: zip과 unzip" (Tuple Example: zip and unzip) in a logical location (after map/filter/fold or as separate section). Include:

1. **zip 함수 (The zip Function)**
   - Combines two lists into list of pairs: `zip [1,2] [a,b] = [(1,a), (2,b)]`
   - FunLang implementation:
   ```fsharp
   let rec zip xs ys =
     match (xs, ys) with
     | ([], _) -> []
     | (_, []) -> []
     | (x :: xs', y :: ys') -> (x, y) :: zip xs' ys'
   ```
   Note: Simplified version without full tuple match:
   ```fsharp
   let rec zip xs ys =
     match xs with
     | [] -> []
     | x :: xs' ->
       match ys with
       | [] -> []
       | y :: ys' -> make_tuple(x, y) :: zip xs' ys'
   ```

2. **컴파일된 MLIR (Compiled MLIR)**
   ```mlir
   func.func @zip(%xs: !funlang.list<i32>, %ys: !funlang.list<f64>)
       -> !funlang.list<!funlang.tuple<i32, f64>> {
     %result = funlang.match %xs : !funlang.list<i32> -> !funlang.list<!funlang.tuple<i32, f64>> {
       ^nil:
         %empty = funlang.nil : !funlang.list<!funlang.tuple<i32, f64>>
         funlang.yield %empty
       ^cons(%x: i32, %xs_tail: !funlang.list<i32>):
         // nested match on ys
         %inner = funlang.match %ys ... {
           ^nil: ...
           ^cons(%y: f64, %ys_tail):
             %pair = funlang.make_tuple(%x, %y) : !funlang.tuple<i32, f64>
             %rest = call @zip(%xs_tail, %ys_tail) : ...
             %cell = funlang.cons %pair, %rest : ...
             funlang.yield %cell
         }
         funlang.yield %inner
     }
     return %result
   }
   ```

3. **튜플 추출 예제 (Tuple Extraction Example)**
   - fst and snd functions:
   ```fsharp
   let fst pair = match pair with (x, _) -> x
   let snd pair = match pair with (_, y) -> y
   ```
   - Shows wildcard in tuple pattern (no extraction for ignored component)

4. **point 조작 예제 (Point Manipulation Example)**
   ```fsharp
   type point = (int * int)

   let move_right pt =
     match pt with (x, y) -> (x + 1, y)

   let distance p1 p2 =
     match (p1, p2) with ((x1, y1), (x2, y2)) ->
       sqrt((x2 - x1)^2 + (y2 - y1)^2)
   ```
   - Nested tuple destructuring

Korean plain style, code in English.
Target: ~300 lines addition.
  </action>
  <verify>grep -c "zip\|make_tuple\|fst\|snd" tutorial/20-functional-programs.md returns >= 8</verify>
  <done>Chapter 20 has practical tuple examples with zip, fst/snd, and point manipulation</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. Chapter 18 contains "funlang.tuple" and "make_tuple" with >= 10 occurrences
2. Chapter 19 contains "튜플 패턴" and "extractvalue" with >= 5 occurrences
3. Chapter 20 contains tuple examples (zip, fst, snd) with >= 8 occurrences
4. All content follows Korean plain style with English code
5. Gap PMTC-05 (tuple patterns) fully addressed
6. Phase goal "lists and tuples" now satisfied
</verification>

<success_criteria>
- [ ] Chapter 18 has !funlang.tuple type definition with TableGen
- [ ] Chapter 18 has funlang.make_tuple operation with lowering
- [ ] Chapter 19 has tuple pattern matching section with destructuring
- [ ] Chapter 20 has working examples using tuples (zip, fst/snd, points)
- [ ] Reader can now compile tuple construction (make_tuple)
- [ ] Reader can now compile tuple destructuring (pattern match)
- [ ] PMTC-05 gap closed: reader can compile tuple pattern matching
- [ ] Phase goal "lists and tuples" now achievable
</success_criteria>

<output>
After completion, create `.planning/phases/06-pattern-matching-data-structures/06-06-SUMMARY.md`
</output>
