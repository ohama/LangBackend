---
phase: 06-pattern-matching-data-structures
plan: 04
type: execute
wave: 4
depends_on: ["06-03"]
files_modified:
  - tutorial/20-functional-programs.md
  - tutorial/SUMMARY.md
autonomous: true

must_haves:
  truths:
    - "Reader can compile map, filter, fold using lists and pattern matching"
    - "Reader can compile realistic functional programs end-to-end"
    - "Reader understands complete Phase 6 compilation pipeline"
    - "Reader is ready for Phase 7 optimization work"
  artifacts:
    - path: "tutorial/20-functional-programs.md"
      provides: "Functional programs chapter"
      min_lines: 1500
      contains: "map"
    - path: "tutorial/SUMMARY.md"
      provides: "Table of contents update"
      contains: "20-functional-programs"
  key_links:
    - from: "tutorial/20-functional-programs.md"
      to: "tutorial/19-match-compilation.md"
      via: "uses pattern matching on lists"
      pattern: "Chapter 19|funlang.match"
    - from: "tutorial/20-functional-programs.md"
      to: "tutorial/13-higher-order-functions.md"
      via: "combines closures with lists"
      pattern: "Chapter 13|closure"
---

<objective>
Write Chapter 20: Functional Programs - demonstrating complete functional programming with lists, closures, and pattern matching.

Purpose: Capstone chapter for Phase 6. Shows readers how to compile realistic functional programs (map, filter, fold) that combine all features: closures from Phase 4, custom dialect from Phase 5, and pattern matching from Phase 6. Validates the complete compilation pipeline.

Output: tutorial/20-functional-programs.md (1500+ lines) covering map, filter, fold implementations with end-to-end compilation examples.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-pattern-matching-data-structures/06-RESEARCH.md

# Phase 4 closures (combined with lists here)
@.planning/phases/04-closures-higher-order/04-02-SUMMARY.md

# Prior plans in this phase
@.planning/phases/06-pattern-matching-data-structures/06-01-PLAN.md
@.planning/phases/06-pattern-matching-data-structures/06-02-PLAN.md
@.planning/phases/06-pattern-matching-data-structures/06-03-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Chapter 20 Part 1 - Map and Filter Functions</name>
  <files>tutorial/20-functional-programs.md</files>
  <action>
Create tutorial/20-functional-programs.md with:

**Introduction (150+ lines):**
- Phase 6 journey recap (Chapters 17-19)
- Chapter 20 goals: complete functional programs
- What we'll build: map, filter, fold, length, append
- Success criteria: end-to-end compilation and execution

**Building Lists in FunLang (200+ lines):**
- FunLang AST extensions for lists:
  - Nil expression
  - Cons expression (head :: tail)
  - List literal syntax [1, 2, 3] -> desugaring to cons chain
- Compiler integration:
  - compileExpr for Nil -> builder.CreateNil
  - compileExpr for Cons -> builder.CreateCons
- Example: compiling [1, 2, 3]
  - Desugars to: Cons(1, Cons(2, Cons(3, Nil)))
  - Generates: funlang.cons, funlang.cons, funlang.cons, funlang.nil

**The map Function (350+ lines):**
- FunLang source:
  ```
  let rec map f xs =
    match xs with
    | [] -> []
    | hd :: tl -> (f hd) :: (map f tl)
  ```
- AST representation with Lambda and Match
- Compiled MLIR (FunLang dialect):
  ```mlir
  func.func @map(%f: !funlang.closure, %xs: !funlang.list<i32>) -> !funlang.list<i32> {
    %result = funlang.match %xs : !funlang.list<i32> -> !funlang.list<i32> {
      ^nil:
        %empty = funlang.nil : !funlang.list<i32>
        funlang.yield %empty : !funlang.list<i32>
      ^cons(%hd: i32, %tl: !funlang.list<i32>):
        %mapped_hd = funlang.apply %f, %hd : (i32) -> i32
        %mapped_tl = func.call @map(%f, %tl) : (...) -> !funlang.list<i32>
        %result = funlang.cons %mapped_hd, %mapped_tl : !funlang.list<i32>
        funlang.yield %result : !funlang.list<i32>
    }
    return %result : !funlang.list<i32>
  }
  ```
- Stage-by-stage lowering (FunLang -> SCF -> LLVM)
- Test program: map (fun x -> x * 2) [1, 2, 3] = [2, 4, 6]
- Execution trace

**The filter Function (300+ lines):**
- FunLang source:
  ```
  let rec filter pred xs =
    match xs with
    | [] -> []
    | hd :: tl ->
        if pred hd
        then hd :: (filter pred tl)
        else filter pred tl
  ```
- Nested control flow: match + if
- Compiled MLIR:
  - funlang.match for list pattern
  - scf.if for predicate test (inside cons case)
- Lowering complexity: nested regions
- Test program: filter (fun x -> x > 2) [1, 2, 3, 4] = [3, 4]

**Helper Functions (200+ lines):**
- length function (from Chapter 19):
  ```
  let rec length xs =
    match xs with
    | [] -> 0
    | _ :: tl -> 1 + length tl
  ```
- append function:
  ```
  let rec append xs ys =
    match xs with
    | [] -> ys
    | hd :: tl -> hd :: (append tl ys)
  ```
- Both compiled and tested

Write in Korean plain style (~이다/~한다). Keep code examples, API names, and technical terms in English.
  </action>
  <verify>
```bash
wc -l tutorial/20-functional-programs.md | grep -E "^[0-9]{3,}"
grep -c "map\|Map" tutorial/20-functional-programs.md
grep -c "filter\|Filter" tutorial/20-functional-programs.md
grep -c "funlang.match" tutorial/20-functional-programs.md
```
  </verify>
  <done>Part 1 complete with 1200+ lines covering list building, map, filter, and helper functions</done>
</task>

<task type="auto">
  <name>Task 2: Write Chapter 20 Part 2 - Fold and Complete Pipeline</name>
  <files>tutorial/20-functional-programs.md</files>
  <action>
Continue tutorial/20-functional-programs.md with:

**The fold Function (300+ lines):**
- FunLang source:
  ```
  let rec fold f acc xs =
    match xs with
    | [] -> acc
    | hd :: tl -> fold f (f acc hd) tl
  ```
- fold as the general list combinator
- Common fold patterns:
  - sum = fold (+) 0
  - product = fold (*) 1
  - length = fold (fun acc _ -> acc + 1) 0
- Compiled MLIR with tail recursion opportunity
- Test program: fold (+) 0 [1, 2, 3, 4, 5] = 15

**Complete Example: Sum of Squares (250+ lines):**
- FunLang program:
  ```
  let square x = x * x
  let sum_of_squares xs = fold (+) 0 (map square xs)
  let main = sum_of_squares [1, 2, 3, 4, 5]  // = 55
  ```
- Combines: list construction, map, fold, lambdas
- Full compilation pipeline walkthrough:
  1. FunLang source
  2. AST representation
  3. FunLang dialect MLIR
  4. After FunLangToSCF
  5. After FunLangToLLVM
  6. After convert-scf-to-cf
  7. After convert-*-to-llvm
  8. LLVM IR
  9. Native binary
- Execution and output verification

**Performance Considerations (200+ lines):**
- Stack usage in recursive list functions
- Tail recursion opportunity in fold
- List allocation patterns (GC pressure)
- Comparison with OCaml/Haskell approaches
- Phase 7 preview: optimization opportunities
  - Tail call optimization
  - List fusion (deforestation)
  - Escape analysis for stack allocation

**Complete Compiler Integration (250+ lines):**
- FunLang AST type extensions:
  - Nil, Cons constructors
  - Match expression with pattern cases
- Compiler.fs compileExpr updates:
  - Nil case -> builder.CreateNil
  - Cons case -> builder.CreateCons
  - Match case -> builder.CreateMatch with region callbacks
- Type inference for list types
- End-to-end compilation function
- Running the complete pipeline

**Common Errors (150+ lines):**
- Error 1: Infinite recursion without base case
- Error 2: Type mismatch in map/filter callback
- Error 3: Wrong accumulator type in fold
- Error 4: Stack overflow on large lists
- Debugging recursive list programs

**Phase 6 Complete Summary (200+ lines):**
- Chapter 17: Pattern matching theory (decision trees)
- Chapter 18: List operations (nil, cons, lowering)
- Chapter 19: Match compilation (funlang.match -> SCF)
- Chapter 20: Functional programs (map, filter, fold)
- Total Phase 6 content: ~6000+ lines
- What readers can now compile:
  - Pattern matching on lists
  - Higher-order list functions
  - Recursive functional programs
- Phase 7 preview: optimization passes

Update tutorial/SUMMARY.md to add Chapter 20 entry.

Write in Korean plain style (~이다/~한다). Keep code examples, API names, and technical terms in English.
  </action>
  <verify>
```bash
wc -l tutorial/20-functional-programs.md | grep -E "^1[5-9][0-9]{2}|^[2-9][0-9]{3}"
grep -c "fold\|Fold" tutorial/20-functional-programs.md
grep -c "sum_of_squares\|pipeline" tutorial/20-functional-programs.md
grep -c "Phase 6\|Phase 7" tutorial/20-functional-programs.md
grep "20-functional-programs" tutorial/SUMMARY.md
```
  </verify>
  <done>Chapter 20 complete with 1500+ lines, fold, complete example, Phase 6 summary, and SUMMARY.md updated</done>
</task>

</tasks>

<verification>
All checks must pass:

```bash
# Chapter 20 exists with sufficient content
test -f tutorial/20-functional-programs.md && echo "Chapter 20 exists"
wc -l tutorial/20-functional-programs.md  # Should be 1500+

# Core functions covered
grep -c "map" tutorial/20-functional-programs.md  # Should be 20+
grep -c "filter" tutorial/20-functional-programs.md  # Should be 10+
grep -c "fold" tutorial/20-functional-programs.md  # Should be 15+

# Integration content
grep -c "funlang.match" tutorial/20-functional-programs.md  # Should be 10+
grep -c "funlang.cons\|funlang.nil" tutorial/20-functional-programs.md  # Should be 10+

# SUMMARY.md updated
grep "20-functional-programs" tutorial/SUMMARY.md
```
</verification>

<success_criteria>
- tutorial/20-functional-programs.md exists with 1500+ lines
- map function: source, compiled MLIR, execution
- filter function: source, compiled MLIR, execution
- fold function: source, compiled MLIR, execution
- Complete example (sum_of_squares) with full pipeline
- Compiler integration for list types and match expressions
- Phase 6 summary and Phase 7 preview
- SUMMARY.md updated with Chapter 20 entry
- Korean plain style used throughout
</success_criteria>

<output>
After completion, create `.planning/phases/06-pattern-matching-data-structures/06-04-SUMMARY.md`
</output>
