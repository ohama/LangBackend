---
phase: 06-pattern-matching-data-structures
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - tutorial/18-list-operations.md
  - tutorial/SUMMARY.md
autonomous: true

must_haves:
  truths:
    - "Reader can compile funlang.nil to create empty list"
    - "Reader can compile funlang.cons to create cons cell"
    - "Reader understands list representation as tagged union"
    - "Reader can implement TypeConverter for !funlang.list<T>"
  artifacts:
    - path: "tutorial/18-list-operations.md"
      provides: "List operations chapter"
      min_lines: 1500
      contains: "funlang.nil"
    - path: "tutorial/SUMMARY.md"
      provides: "Table of contents update"
      contains: "18-list-operations"
  key_links:
    - from: "tutorial/18-list-operations.md"
      to: "tutorial/17-pattern-matching-theory.md"
      via: "implements data structures for pattern matching"
      pattern: "Chapter 17|pattern matching"
    - from: "tutorial/18-list-operations.md"
      to: "tutorial/15-custom-operations.md"
      via: "follows custom operation patterns"
      pattern: "Chapter 15|TableGen"
---

<objective>
Write Chapter 18: List Operations - implementing funlang.nil and funlang.cons operations with list representation and lowering.

Purpose: Implement the data structure operations needed for pattern matching. Lists are represented as tagged unions (tag + data pointer) with GC-allocated cons cells. This chapter provides the operations that funlang.match will dispatch on.

Output: tutorial/18-list-operations.md (1500+ lines) covering list representation, funlang.nil/cons operations, TypeConverter, and lowering patterns.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-pattern-matching-data-structures/06-RESEARCH.md

# Phase 5 custom operation patterns to follow
@.planning/phases/05-custom-mlir-dialect/05-02-SUMMARY.md
@.planning/phases/05-custom-mlir-dialect/05-03-SUMMARY.md

# Prior plan in this phase
@.planning/phases/06-pattern-matching-data-structures/06-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Chapter 18 Part 1 - List Representation and Operations</name>
  <files>tutorial/18-list-operations.md</files>
  <action>
Create tutorial/18-list-operations.md with:

**Introduction (150+ lines):**
- Chapter 17 recap (decision tree algorithm)
- Why we need list operations before pattern matching
- Chapter 18 goals: nil, cons, list type, lowering
- Success criteria

**List Representation Design (300+ lines):**
- Tagged union concept: discriminator tag + data
- List representation: !llvm.struct<(i32, ptr)>
  - tag = 0 for Nil (null pointer for data)
  - tag = 1 for Cons (pointer to {head, tail} struct)
- Cons cell memory layout: {element, tail_ptr}
- GC allocation for cons cells (escape analysis not needed)
- Immutability: lists share structure (persistent)
- Visual diagrams:
  - Empty list (Nil): {0, null}
  - Single element [1]: {1, ptr} -> {1, {0, null}}
  - Multiple elements [1, 2, 3]: linked structure

**FunLang List Type (250+ lines):**
- !funlang.list<T> parameterized type (from Chapter 15 preview)
- Why parameterized: type safety for head element
- TableGen type definition:
  ```tablegen
  def FunLang_ListType : FunLang_Type<"List"> {
    let parameters = (ins "Type":$elementType);
    let mnemonic = "list";
    let assemblyFormat = "`<` $elementType `>`";
  }
  ```
- Generated C++ type class
- C API shim for type creation
- F# bindings: CreateListType(elementType)
- Usage examples: !funlang.list<i32>, !funlang.list<!funlang.closure>

**funlang.nil Operation (300+ lines):**
- Purpose: create empty list
- TableGen ODS definition:
  ```tablegen
  def FunLang_NilOp : FunLang_Op<"nil", [Pure]> {
    let results = (outs FunLang_ListType:$result);
    let assemblyFormat = "attr-dict `:` type($result)";
  }
  ```
- Assembly syntax: `%nil = funlang.nil : !funlang.list<i32>`
- C API shim: mlirFunLangNilOpCreate
- F# bindings: CreateNil(elementType)
- No runtime allocation needed (constant representation)

**funlang.cons Operation (350+ lines):**
- Purpose: create cons cell (head :: tail)
- TableGen ODS definition:
  ```tablegen
  def FunLang_ConsOp : FunLang_Op<"cons", [Pure]> {
    let arguments = (ins AnyType:$head, FunLang_ListType:$tail);
    let results = (outs FunLang_ListType:$result);
    let assemblyFormat = "$head `,` $tail attr-dict `:` type($result)";
  }
  ```
- Assembly syntax: `%list = funlang.cons %elem, %tail : !funlang.list<i32>`
- C API shim: mlirFunLangConsOpCreate
- F# bindings: CreateCons(head, tail)
- Type inference: result type from tail type (or explicit)
- Multiple cons example: building [1, 2, 3]

Write in Korean plain style (~이다/~한다). Keep code examples, API names, and technical terms in English.
  </action>
  <verify>
```bash
wc -l tutorial/18-list-operations.md | grep -E "^[0-9]{3,}"
grep -c "funlang.nil\|NilOp" tutorial/18-list-operations.md
grep -c "funlang.cons\|ConsOp" tutorial/18-list-operations.md
grep -c "!funlang.list" tutorial/18-list-operations.md
```
  </verify>
  <done>Part 1 complete with 1350+ lines covering list representation, list type, nil operation, and cons operation</done>
</task>

<task type="auto">
  <name>Task 2: Write Chapter 18 Part 2 - TypeConverter and Lowering</name>
  <files>tutorial/18-list-operations.md</files>
  <action>
Continue tutorial/18-list-operations.md with:

**TypeConverter for List Types (300+ lines):**
- Extending FunLangTypeConverter from Chapter 16
- !funlang.list<T> -> !llvm.struct<(i32, ptr)> conversion
  ```cpp
  addConversion([ctx](funlang::ListType type) -> Type {
    auto i32Type = IntegerType::get(ctx, 32);
    auto ptrType = LLVM::LLVMPointerType::get(ctx);
    return LLVM::LLVMStructType::getLiteral(ctx, {i32Type, ptrType});
  });
  ```
- Element type handling: stored in cons cell, not in list struct
- Recursive types: list of lists
- Type materialization for unconverted types
- Complete FunLangTypeConverter with closure + list support

**NilOp Lowering Pattern (250+ lines):**
- funlang.nil -> LLVM struct with tag=0
- NilOpLowering ConversionPattern:
  ```cpp
  struct NilOpLowering : public OpConversionPattern<funlang::NilOp> {
    LogicalResult matchAndRewrite(...) {
      // Create tag value (0 for Nil)
      Value tag = rewriter.create<arith::ConstantOp>(loc, 0);
      // Create null pointer for data
      Value data = rewriter.create<LLVM::ZeroOp>(loc, ptrType);
      // Build struct {0, null}
      Value result = buildStruct(rewriter, loc, tag, data);
      rewriter.replaceOp(op, result);
    }
  };
  ```
- llvm.insertvalue for struct construction
- No memory allocation (pure constant)
- C API shim for lowering pass

**ConsOp Lowering Pattern (350+ lines):**
- funlang.cons -> GC_malloc + store + struct construction
- ConsOpLowering ConversionPattern:
  ```cpp
  struct ConsOpLowering : public OpConversionPattern<funlang::ConsOp> {
    LogicalResult matchAndRewrite(...) {
      // Allocate cons cell via GC_malloc
      Value cellSize = rewriter.create<arith::ConstantOp>(loc, 16);
      Value cellPtr = rewriter.create<LLVM::CallOp>(loc, "GC_malloc", cellSize);
      // Store head at offset 0
      Value headSlot = rewriter.create<LLVM::GEPOp>(loc, cellPtr, {0});
      rewriter.create<LLVM::StoreOp>(loc, head, headSlot);
      // Store tail at offset 1
      Value tailSlot = rewriter.create<LLVM::GEPOp>(loc, cellPtr, {1});
      rewriter.create<LLVM::StoreOp>(loc, tail, tailSlot);
      // Build result struct {1, cellPtr}
      Value tag = rewriter.create<arith::ConstantOp>(loc, 1);
      Value result = buildStruct(rewriter, loc, tag, cellPtr);
      rewriter.replaceOp(op, result);
    }
  };
  ```
- GEP indexing for struct fields
- Store operations for head and tail
- Memory layout diagram

**Complete Lowering Pass Update (200+ lines):**
- Adding NilOpLowering and ConsOpLowering to FunLangToLLVM
- Pattern registration order
- Testing list construction
- End-to-end example: building [1, 2, 3]
- Before/After IR comparison

**Common Errors (150+ lines):**
- Error 1: Wrong struct size in GC_malloc
- Error 2: Type mismatch in store operations
- Error 3: Missing TypeConverter rule for nested list types
- Error 4: GEP index confusion (element vs byte offset)
- Debugging strategies

**Summary and Chapter 19 Preview (100+ lines):**
- Chapter 18 recap: list representation, nil, cons, lowering
- List operations ready for pattern matching
- Chapter 19 preview: funlang.match and pattern dispatch

Update tutorial/SUMMARY.md to add Chapter 18 entry.

Write in Korean plain style (~이다/~한다). Keep code examples, API names, and technical terms in English.
  </action>
  <verify>
```bash
wc -l tutorial/18-list-operations.md | grep -E "^1[5-9][0-9]{2}|^[2-9][0-9]{3}"
grep -c "TypeConverter\|addConversion" tutorial/18-list-operations.md
grep -c "NilOpLowering\|ConsOpLowering" tutorial/18-list-operations.md
grep -c "GC_malloc\|GEP" tutorial/18-list-operations.md
grep "18-list-operations" tutorial/SUMMARY.md
```
  </verify>
  <done>Chapter 18 complete with 1500+ lines, TypeConverter, lowering patterns, and SUMMARY.md updated</done>
</task>

</tasks>

<verification>
All checks must pass:

```bash
# Chapter 18 exists with sufficient content
test -f tutorial/18-list-operations.md && echo "Chapter 18 exists"
wc -l tutorial/18-list-operations.md  # Should be 1500+

# Core operations covered
grep -c "funlang.nil" tutorial/18-list-operations.md  # Should be 10+
grep -c "funlang.cons" tutorial/18-list-operations.md  # Should be 10+
grep -c "!funlang.list" tutorial/18-list-operations.md  # Should be 15+

# Lowering covered
grep -c "NilOpLowering" tutorial/18-list-operations.md  # Should be 3+
grep -c "ConsOpLowering" tutorial/18-list-operations.md  # Should be 3+
grep -c "TypeConverter" tutorial/18-list-operations.md  # Should be 5+

# SUMMARY.md updated
grep "18-list-operations" tutorial/SUMMARY.md
```
</verification>

<success_criteria>
- tutorial/18-list-operations.md exists with 1500+ lines
- List representation as tagged union explained with diagrams
- funlang.nil operation: TableGen, C API, F#, lowering
- funlang.cons operation: TableGen, C API, F#, lowering
- TypeConverter updated for !funlang.list<T>
- NilOpLowering and ConsOpLowering patterns documented
- SUMMARY.md updated with Chapter 18 entry
- Korean plain style used throughout
</success_criteria>

<output>
After completion, create `.planning/phases/06-pattern-matching-data-structures/06-02-SUMMARY.md`
</output>
