---
phase: 06-pattern-matching-data-structures
plan: 03
type: execute
wave: 3
depends_on: ["06-02"]
files_modified:
  - tutorial/19-match-compilation.md
  - tutorial/SUMMARY.md
autonomous: true

must_haves:
  truths:
    - "Reader can compile funlang.match on list patterns"
    - "Reader understands region-based match operation structure"
    - "Reader can implement MatchOpLowering to SCF dialect"
    - "Reader can handle block arguments for pattern variables"
  artifacts:
    - path: "tutorial/19-match-compilation.md"
      provides: "Match compilation chapter"
      min_lines: 1800
      contains: "funlang.match"
    - path: "tutorial/SUMMARY.md"
      provides: "Table of contents update"
      contains: "19-match-compilation"
  key_links:
    - from: "tutorial/19-match-compilation.md"
      to: "tutorial/17-pattern-matching-theory.md"
      via: "implements decision tree algorithm"
      pattern: "Chapter 17|decision tree"
    - from: "tutorial/19-match-compilation.md"
      to: "tutorial/18-list-operations.md"
      via: "matches on list types"
      pattern: "Chapter 18|funlang.nil|funlang.cons"
---

<objective>
Write Chapter 19: Match Compilation - implementing funlang.match operation with lowering to SCF dialect.

Purpose: This is the core chapter of Phase 6. It implements the funlang.match operation (region-based, multi-case) and lowers it to SCF dialect (scf.index_switch for tag dispatch). This completes the pattern matching compilation pipeline from theory (Chapter 17) through implementation.

Output: tutorial/19-match-compilation.md (1800+ lines) covering funlang.match operation, region handling, SCF lowering, and complete pattern matching pipeline.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-pattern-matching-data-structures/06-RESEARCH.md

# Phase 5 lowering infrastructure
@.planning/phases/05-custom-mlir-dialect/05-03-SUMMARY.md

# Prior plans in this phase
@.planning/phases/06-pattern-matching-data-structures/06-01-PLAN.md
@.planning/phases/06-pattern-matching-data-structures/06-02-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Chapter 19 Part 1 - Match Operation Definition</name>
  <files>tutorial/19-match-compilation.md</files>
  <action>
Create tutorial/19-match-compilation.md with:

**Introduction (150+ lines):**
- Chapter 17-18 recap (theory + list operations)
- Why funlang.match is the most complex operation
- Multi-stage lowering: FunLang -> SCF -> LLVM
- Chapter 19 goals and success criteria

**Match Operation Design (300+ lines):**
- Region-based operation structure (from Chapter 15 preview)
- Why regions not basic blocks:
  - Independent variable scopes per case
  - Type verification at region boundaries
  - Natural lowering to SCF regions
- Match operation semantics:
  - Input: scrutinee value (the value being matched)
  - Cases: multiple regions (nil case, cons case, etc.)
  - Output: result from matching case
  - Exhaustiveness: all cases must be covered
- Block arguments for pattern variables:
  - Nil case: no arguments (no bindings)
  - Cons case: head and tail arguments
- funlang.yield terminator for case results

**TableGen Definition (350+ lines):**
- Complete funlang.match ODS:
  ```tablegen
  def FunLang_MatchOp : FunLang_Op<"match", [
      RecursiveSideEffects,
      SingleBlockImplicitTerminator<"YieldOp">
  ]> {
    let arguments = (ins AnyType:$scrutinee);
    let results = (outs AnyType:$result);
    let regions = (region VariadicRegion<SizedRegion<1>>:$cases);
    let hasVerifier = 1;
  }
  ```
- Trait explanation:
  - RecursiveSideEffects: side effects depend on case bodies
  - SingleBlockImplicitTerminator: each region ends with YieldOp
- VariadicRegion<SizedRegion<1>>: 1+ cases, each with exactly 1 block
- Custom verifier requirements:
  - All yields must have same type as result
  - Scrutinee type matches expected pattern types
- Assembly format (custom printer/parser):
  ```mlir
  %result = funlang.match %list : !funlang.list<i32> -> i32 {
    ^nil:
      %zero = arith.constant 0 : i32
      funlang.yield %zero : i32
    ^cons(%head: i32, %tail: !funlang.list<i32>):
      funlang.yield %head : i32
  }
  ```

**YieldOp for Match Results (200+ lines):**
- TableGen definition:
  ```tablegen
  def FunLang_YieldOp : FunLang_Op<"yield", [
      Terminator,
      HasParent<"MatchOp">
  ]> {
    let arguments = (ins AnyType:$value);
    let assemblyFormat = "$value attr-dict `:` type($value)";
  }
  ```
- Terminator trait
- HasParent constraint (only valid inside MatchOp)
- Connection to scf.yield in lowering

**C API and F# Integration (300+ lines):**
- C API shim complexity for region-based operations:
  - mlirFunLangMatchOpCreate(ctx, loc, scrutinee, numCases)
  - mlirFunLangMatchOpGetCaseRegion(op, index)
  - Region construction helpers
- F# bindings:
  - CreateMatch with builder callback
  - AddMatchCase for each pattern
  - Automatic YieldOp insertion
- Usage example: building match expression in F# compiler

Write in Korean plain style (~이다/~한다). Keep code examples, API names, and technical terms in English.
  </action>
  <verify>
```bash
wc -l tutorial/19-match-compilation.md | grep -E "^[0-9]{3,}"
grep -c "funlang.match\|MatchOp" tutorial/19-match-compilation.md
grep -c "region\|Region" tutorial/19-match-compilation.md
grep -c "YieldOp\|funlang.yield" tutorial/19-match-compilation.md
```
  </verify>
  <done>Part 1 complete with 1300+ lines covering match operation design, TableGen definition, YieldOp, and F# integration</done>
</task>

<task type="auto">
  <name>Task 2: Write Chapter 19 Part 2 - SCF Lowering and Pipeline</name>
  <files>tutorial/19-match-compilation.md</files>
  <action>
Continue tutorial/19-match-compilation.md with:

**SCF Dialect Overview (200+ lines):**
- Why SCF as intermediate target (not direct to LLVM)
- scf.index_switch operation:
  - Multi-way branch on integer index
  - Region-based cases (like funlang.match)
  - Results from case regions
- scf.if for simple two-way branching
- Comparison: SCF preserves structure vs CF loses it
- Optimization opportunities at SCF level

**MatchOp Lowering Strategy (300+ lines):**
- Multi-stage approach:
  1. Extract tag from scrutinee (llvm.extractvalue)
  2. Switch on tag value (scf.index_switch)
  3. In each case: extract data, bind pattern variables
  4. Clone case body with remapped values
  5. Convert funlang.yield to scf.yield
- Tag value mapping:
  - 0 = Nil case
  - 1 = Cons case
- Pattern variable binding:
  - Nil: no variables (empty block args)
  - Cons: head and tail from cons cell

**MatchOpLowering Pattern (400+ lines):**
- Complete ConversionPattern implementation:
  ```cpp
  struct MatchOpLowering : public OpConversionPattern<funlang::MatchOp> {
    LogicalResult matchAndRewrite(
        funlang::MatchOp op, OpAdaptor adaptor,
        ConversionPatternRewriter &rewriter) const override {

      auto loc = op.getLoc();
      Value scrutinee = adaptor.getScrutinee();

      // Extract tag from list struct
      Value tag = rewriter.create<LLVM::ExtractValueOp>(
          loc, scrutinee, ArrayRef<int64_t>{0});

      // Create scf.index_switch
      auto switchOp = rewriter.create<scf::IndexSwitchOp>(
          loc, op.getResultTypes(), tag, op.getCases().size());

      // Process each case region
      for (auto [idx, caseRegion] : llvm::enumerate(op.getCases())) {
        Region &targetRegion = switchOp.getCaseRegions()[idx];

        // For Cons case: extract head and tail
        if (idx == 1) {  // Cons
          Value dataPtr = rewriter.create<LLVM::ExtractValueOp>(
              loc, scrutinee, ArrayRef<int64_t>{1});
          Value head = extractHead(rewriter, loc, dataPtr);
          Value tail = extractTail(rewriter, loc, dataPtr);
          // Remap block arguments to extracted values
        }

        // Clone region body
        rewriter.cloneRegionBefore(caseRegion, targetRegion, targetRegion.end());

        // Convert funlang.yield -> scf.yield
        convertYields(rewriter, targetRegion);
      }

      rewriter.replaceOp(op, switchOp.getResults());
      return success();
    }
  };
  ```
- Block argument remapping (IRMapping)
- Region type conversion
- Helper functions: extractHead, extractTail, convertYields

**Complete Pipeline (250+ lines):**
- Full pass order:
  1. FunLangToSCF pass (new): funlang.match -> scf.index_switch
  2. FunLangToLLVM pass (updated): closure, apply, nil, cons
  3. SCFToControlFlow pass: scf.index_switch -> cf.switch
  4. StandardToLLVM passes: arith, func, cf -> llvm
  5. LLVM translation and compilation
- Pass dependencies and registration
- End-to-end example: length function
  ```mlir
  func.func @length(%list: !funlang.list<i32>) -> i32 {
    %result = funlang.match %list : !funlang.list<i32> -> i32 {
      ^nil:
        %zero = arith.constant 0 : i32
        funlang.yield %zero : i32
      ^cons(%head: i32, %tail: !funlang.list<i32>):
        %rest = func.call @length(%tail) : (!funlang.list<i32>) -> i32
        %one = arith.constant 1 : i32
        %len = arith.addi %one, %rest : i32
        funlang.yield %len : i32
    }
    return %result : i32
  }
  ```
- Stage-by-stage IR transformation

**Common Errors (200+ lines):**
- Error 1: Block argument count mismatch
- Error 2: Type mismatch after region cloning
- Error 3: Missing scf.yield in converted regions
- Error 4: Wrong tag values (0 vs 1 confusion)
- Error 5: Incorrect data extraction from cons cell
- Debugging strategies for region-based lowering

**Summary and Chapter 20 Preview (100+ lines):**
- Chapter 19 recap: funlang.match complete
- Pattern matching pipeline: FunLang -> SCF -> LLVM
- Chapter 20 preview: realistic functional programs

Update tutorial/SUMMARY.md to add Chapter 19 entry.

Write in Korean plain style (~이다/~한다). Keep code examples, API names, and technical terms in English.
  </action>
  <verify>
```bash
wc -l tutorial/19-match-compilation.md | grep -E "^1[8-9][0-9]{2}|^[2-9][0-9]{3}"
grep -c "scf.index_switch\|IndexSwitchOp" tutorial/19-match-compilation.md
grep -c "MatchOpLowering" tutorial/19-match-compilation.md
grep -c "cloneRegion\|convertRegion" tutorial/19-match-compilation.md
grep "19-match-compilation" tutorial/SUMMARY.md
```
  </verify>
  <done>Chapter 19 complete with 1800+ lines, MatchOpLowering, SCF pipeline, and SUMMARY.md updated</done>
</task>

</tasks>

<verification>
All checks must pass:

```bash
# Chapter 19 exists with sufficient content
test -f tutorial/19-match-compilation.md && echo "Chapter 19 exists"
wc -l tutorial/19-match-compilation.md  # Should be 1800+

# Match operation covered
grep -c "funlang.match" tutorial/19-match-compilation.md  # Should be 20+
grep -c "MatchOp" tutorial/19-match-compilation.md  # Should be 15+
grep -c "region" tutorial/19-match-compilation.md  # Should be 20+

# SCF lowering covered
grep -c "scf.index_switch" tutorial/19-match-compilation.md  # Should be 10+
grep -c "MatchOpLowering" tutorial/19-match-compilation.md  # Should be 5+

# SUMMARY.md updated
grep "19-match-compilation" tutorial/SUMMARY.md
```
</verification>

<success_criteria>
- tutorial/19-match-compilation.md exists with 1800+ lines
- funlang.match operation: TableGen, regions, YieldOp
- C API and F# integration for region-based operation
- SCF dialect as lowering target explained
- MatchOpLowering pattern with complete implementation
- Block argument handling for pattern variables
- End-to-end pipeline example (length function)
- SUMMARY.md updated with Chapter 19 entry
- Korean plain style used throughout
</success_criteria>

<output>
After completion, create `.planning/phases/06-pattern-matching-data-structures/06-03-SUMMARY.md`
</output>
