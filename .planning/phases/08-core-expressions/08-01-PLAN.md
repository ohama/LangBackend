---
phase: 08-core-expressions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/FunLang.Compiler/CodeGen.fs
  - tests/FunLang.Compiler.Tests/MlirBindingsTests.fs
autonomous: true

must_haves:
  truths:
    - "Comparison operators compile to arith.cmpi with correct predicates"
    - "Boolean literals compile to arith.constant with i1 type"
    - "Logical AND/OR compile to arith.andi/ori operations"
    - "All tests pass including new comparison and boolean tests"
  artifacts:
    - path: "src/FunLang.Compiler/CodeGen.fs"
      provides: "Comparison and boolean compilation"
      contains: "arith.cmpi"
    - path: "tests/FunLang.Compiler.Tests/MlirBindingsTests.fs"
      provides: "Unit tests for comparisons and booleans"
      contains: "compile and run comparison"
  key_links:
    - from: "src/FunLang.Compiler/CodeGen.fs"
      to: "arith.cmpi"
      via: "emitOp with predicate attribute"
      pattern: "arith\\.cmpi.*predicate"
---

<objective>
Implement comparison operators and boolean expressions in CodeGen.fs

Purpose: Enable FunLang programs to use comparisons (<, >, <=, >=, ==, <>) and boolean logic (true, false, &&, ||). These are prerequisites for if-else control flow in Plan 03.

Output: Extended CodeGen.fs with comparison and boolean compilation, unit tests verifying correct execution.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-core-expressions/08-RESEARCH.md

# Source files to extend
@src/FunLang.Compiler/CodeGen.fs
@src/FunLang.Compiler/MlirWrapper.fs
@LangTutorial/FunLang/Ast.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement comparison operators</name>
  <files>src/FunLang.Compiler/CodeGen.fs</files>
  <action>
Add comparison operator cases to compileExpr function in CodeGen.fs.

For each comparison, use arith.cmpi with the appropriate predicate attribute:
- Equal: predicate = 0 (eq)
- NotEqual: predicate = 1 (ne)
- LessThan: predicate = 2 (slt - signed less than)
- LessEqual: predicate = 3 (sle)
- GreaterThan: predicate = 4 (sgt)
- GreaterEqual: predicate = 5 (sge)

Pattern for each comparison:
```fsharp
| Equal(left, right, _) ->
    let leftVal = compileExpr ctx left
    let rightVal = compileExpr ctx right
    let i64Type = builder.I64Type()
    let predicateAttr = builder.IntegerAttr(0L, i64Type)  // eq = 0
    let i1Type = builder.I1Type()
    let op = emitOp ctx "arith.cmpi" [| i1Type |]
                [| leftVal; rightVal |]
                [| builder.NamedAttr("predicate", predicateAttr) |]
                [||]
    builder.GetResult(op, 0)
```

Note: Predicate attribute MUST be i64 type (not i32). The result type is i1 (boolean).
  </action>
  <verify>Build succeeds: `dotnet build src/FunLang.Compiler`</verify>
  <done>All 6 comparison operators (Equal, NotEqual, LessThan, GreaterThan, LessEqual, GreaterEqual) compile to arith.cmpi with correct predicates</done>
</task>

<task type="auto">
  <name>Task 2: Implement boolean literals and logical operators</name>
  <files>src/FunLang.Compiler/CodeGen.fs</files>
  <action>
Add boolean expression cases to compileExpr function:

1. **Bool literal** - compile true/false to arith.constant with i1 type:
```fsharp
| Bool(b, _) ->
    let i1Type = builder.I1Type()
    let value = if b then 1L else 0L
    let valueAttr = builder.IntegerAttr(value, i1Type)
    let op = emitOp ctx "arith.constant" [| i1Type |] [||]
                [| builder.NamedAttr("value", valueAttr) |] [||]
    builder.GetResult(op, 0)
```

2. **And** - compile to arith.andi on i1 values:
```fsharp
| And(left, right, _) ->
    let leftVal = compileExpr ctx left
    let rightVal = compileExpr ctx right
    let i1Type = builder.I1Type()
    let op = emitOp ctx "arith.andi" [| i1Type |] [| leftVal; rightVal |] [||] [||]
    builder.GetResult(op, 0)
```

3. **Or** - compile to arith.ori on i1 values:
```fsharp
| Or(left, right, _) ->
    let leftVal = compileExpr ctx left
    let rightVal = compileExpr ctx right
    let i1Type = builder.I1Type()
    let op = emitOp ctx "arith.ori" [| i1Type |] [| leftVal; rightVal |] [||] [||]
    builder.GetResult(op, 0)
```

Note: This is NOT short-circuit evaluation. Both operands are always evaluated. For true short-circuit, we would need scf.if (deferred to if-else implementation if needed).
  </action>
  <verify>Build succeeds: `dotnet build src/FunLang.Compiler`</verify>
  <done>Bool, And, Or expressions compile to arith.constant/arith.andi/arith.ori operations</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for comparisons and booleans</name>
  <files>tests/FunLang.Compiler.Tests/MlirBindingsTests.fs</files>
  <action>
Add new test list to MlirBindingsTests.fs for comparison and boolean operations.

Since compileAndRun returns int32 and booleans are i1, we need a way to test boolean results. Options:
1. Add a new function that returns i1 and converts result
2. Test boolean-to-int conversion patterns
3. Use if-else to convert boolean to int (requires Plan 03)

For Phase 8 Plan 01, test comparison results indirectly by examining IR generation:

```fsharp
[<Tests>]
let comparisonTests =
    testList "Comparisons" [
        test "can generate IR for equality comparison" {
            use ctx = new Context()
            ctx.LoadStandardDialects()
            let expr = CodeGen.parse "1 = 1" "<test>"
            use mlirMod = CodeGen.compileToFunction ctx "test_eq" expr
            let ir = mlirMod.Print()
            Expect.stringContains ir "arith.cmpi" "Should contain arith.cmpi"
        }

        test "can generate IR for less-than comparison" {
            use ctx = new Context()
            ctx.LoadStandardDialects()
            let expr = CodeGen.parse "1 < 2" "<test>"
            use mlirMod = CodeGen.compileToFunction ctx "test_lt" expr
            let ir = mlirMod.Print()
            Expect.stringContains ir "arith.cmpi" "Should contain arith.cmpi"
        }
    ]

[<Tests>]
let booleanTests =
    testList "Booleans" [
        test "can generate IR for boolean literal true" {
            use ctx = new Context()
            ctx.LoadStandardDialects()
            let expr = CodeGen.parse "true" "<test>"
            use mlirMod = CodeGen.compileToFunction ctx "test_true" expr
            let ir = mlirMod.Print()
            Expect.stringContains ir "arith.constant" "Should contain arith.constant"
            Expect.stringContains ir "i1" "Should have i1 type"
        }

        test "can generate IR for logical AND" {
            use ctx = new Context()
            ctx.LoadStandardDialects()
            let expr = CodeGen.parse "true && false" "<test>"
            use mlirMod = CodeGen.compileToFunction ctx "test_and" expr
            let ir = mlirMod.Print()
            Expect.stringContains ir "arith.andi" "Should contain arith.andi"
        }

        test "can generate IR for logical OR" {
            use ctx = new Context()
            ctx.LoadStandardDialects()
            let expr = CodeGen.parse "true || false" "<test>"
            use mlirMod = CodeGen.compileToFunction ctx "test_or" expr
            let ir = mlirMod.Print()
            Expect.stringContains ir "arith.ori" "Should contain arith.ori"
        }
    ]
```

Note: Full E2E execution tests for booleans will be added in Plan 04 after if-else is implemented (to convert bool to int for result).
  </action>
  <verify>Tests pass: `dotnet test tests/FunLang.Compiler.Tests`</verify>
  <done>Unit tests verify IR generation for all comparison and boolean operations</done>
</task>

</tasks>

<verification>
1. Build succeeds: `dotnet build src/FunLang.Compiler`
2. All unit tests pass: `dotnet test tests/FunLang.Compiler.Tests`
3. Existing arithmetic tests still pass
4. IR inspection shows correct arith.cmpi predicates and i1 types
</verification>

<success_criteria>
- All 6 comparison operators compile to arith.cmpi with correct predicate attributes
- Bool literals compile to arith.constant with i1 type
- And/Or operators compile to arith.andi/ori
- All existing tests continue to pass
- New unit tests for comparisons and booleans pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-core-expressions/08-01-SUMMARY.md`
</output>
