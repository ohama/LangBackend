---
phase: 08-core-expressions
plan: 02
type: execute
wave: 2
depends_on: [08-01]
files_modified:
  - src/FunLang.Compiler/CodeGen.fs
  - tests/FunLang.Compiler.Tests/MlirBindingsTests.fs
autonomous: true

must_haves:
  truths:
    - "Let bindings compile to SSA values with environment tracking"
    - "Variable references resolve from environment"
    - "Nested let bindings support shadowing"
    - "All tests pass including new let binding tests"
  artifacts:
    - path: "src/FunLang.Compiler/CodeGen.fs"
      provides: "Let binding and variable compilation"
      contains: "Env: Map<string, MlirValue>"
    - path: "tests/FunLang.Compiler.Tests/MlirBindingsTests.fs"
      provides: "Unit tests for let bindings"
      contains: "compile and run let"
  key_links:
    - from: "src/FunLang.Compiler/CodeGen.fs compileExpr"
      to: "CompileContext.Env"
      via: "Map.Add for let, TryFind for Var"
      pattern: "ctx\\.Env\\."
---

<objective>
Implement let bindings and variable references in CodeGen.fs

Purpose: Enable FunLang programs to use local variables with let expressions. This maps FunLang's let bindings to SSA values through an immutable environment (symbol table). Shadowing is handled naturally by F# Map.Add creating new bindings.

Output: Extended CodeGen.fs with Env field in CompileContext, Let and Var expression handling, unit tests verifying correct execution.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-core-expressions/08-RESEARCH.md
@.planning/phases/08-core-expressions/08-01-SUMMARY.md

# Source files to extend
@src/FunLang.Compiler/CodeGen.fs
@LangTutorial/FunLang/Ast.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Env field to CompileContext</name>
  <files>src/FunLang.Compiler/CodeGen.fs</files>
  <action>
Modify CompileContext record type to include an environment for variable bindings:

```fsharp
/// Compilation context
type CompileContext = {
    Context: Context
    Builder: OpBuilder
    Location: Location
    Block: MlirBlock  // Current block to append operations to
    Env: Map<string, MlirValue>  // Variable name -> SSA value mapping
}
```

Update compileToFunction to initialize Env as empty map:

```fsharp
let compileCtx = {
    Context = ctx
    Builder = builder
    Location = loc
    Block = entryBlock
    Env = Map.empty  // NEW: start with empty environment
}
```

This is the symbol table that maps variable names to their SSA values. Using immutable F# Map means:
- Each Let creates a new environment with the binding added
- Shadowing works naturally (Map.Add with existing key creates new binding)
- Lexical scoping is preserved (inner scopes see outer bindings)
  </action>
  <verify>Build succeeds: `dotnet build src/FunLang.Compiler`</verify>
  <done>CompileContext has Env field, compileToFunction initializes with empty map</done>
</task>

<task type="auto">
  <name>Task 2: Implement Let and Var expression compilation</name>
  <files>src/FunLang.Compiler/CodeGen.fs</files>
  <action>
Add Var and Let cases to compileExpr function:

```fsharp
| Var(name, _) ->
    // Look up variable in environment
    match ctx.Env.TryFind(name) with
    | Some value -> value
    | None -> failwithf "Unbound variable: %s" name

| Let(name, expr1, expr2, _) ->
    // Compile the binding expression
    let value = compileExpr ctx expr1

    // Create extended environment with new binding (shadowing handled naturally)
    let extendedEnv = ctx.Env.Add(name, value)
    let ctx' = { ctx with Env = extendedEnv }

    // Compile body expression in extended environment
    compileExpr ctx' expr2
```

Key design points:
1. **Var lookup**: Simple map lookup, fail fast on unbound variable
2. **Let binding**: Compile expr1, extend environment, compile expr2 with extended env
3. **Shadowing**: Map.Add naturally shadows - if name exists, new binding takes precedence
4. **SSA mapping**: Variable values are MLIR SSA values, not mutable storage

Example:
```
let x = 5 in x + 10
```
Compiles to:
```mlir
%c5 = arith.constant 5 : i32      // expr1
// Env = {x -> %c5}
%c10 = arith.constant 10 : i32    // in expr2
%result = arith.addi %c5, %c10 : i32  // x resolves to %c5
```
  </action>
  <verify>Build succeeds: `dotnet build src/FunLang.Compiler`</verify>
  <done>Let and Var expressions compile correctly with environment tracking</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for let bindings</name>
  <files>tests/FunLang.Compiler.Tests/MlirBindingsTests.fs</files>
  <action>
Add tests for let bindings to MlirBindingsTests.fs:

```fsharp
[<Tests>]
let letBindingTests =
    testList "LetBindings" [
        test "compile and run simple let binding" {
            let result = CodeGen.compileAndRun "let x = 5 in x"
            Expect.equal result 5 "let x = 5 in x should return 5"
        }

        test "compile and run let with arithmetic in body" {
            let result = CodeGen.compileAndRun "let x = 5 in x + 10"
            Expect.equal result 15 "let x = 5 in x + 10 should return 15"
        }

        test "compile and run let with arithmetic binding" {
            let result = CodeGen.compileAndRun "let x = 2 + 3 in x * 2"
            Expect.equal result 10 "let x = 2 + 3 in x * 2 should return 10"
        }

        test "compile and run nested let bindings" {
            let result = CodeGen.compileAndRun "let x = 5 in let y = 10 in x + y"
            Expect.equal result 15 "nested let should return 15"
        }

        test "compile and run let with shadowing" {
            let result = CodeGen.compileAndRun "let x = 5 in let x = 10 in x"
            Expect.equal result 10 "shadowed let should return 10"
        }

        test "compile and run let shadowing with outer reference" {
            let result = CodeGen.compileAndRun "let x = 5 in let y = x in let x = 10 in y"
            Expect.equal result 5 "y captures outer x before shadow"
        }

        test "compile and run complex nested let" {
            let result = CodeGen.compileAndRun "let a = 1 in let b = 2 in let c = 3 in a + b + c"
            Expect.equal result 6 "a + b + c should return 6"
        }
    ]
```

These tests verify:
1. Simple variable binding and reference
2. Arithmetic in binding expression
3. Arithmetic in body expression
4. Nested let bindings
5. Variable shadowing
6. Capture semantics (outer binding captured before shadow)
  </action>
  <verify>Tests pass: `dotnet test tests/FunLang.Compiler.Tests`</verify>
  <done>Unit tests verify let bindings work correctly with shadowing and nesting</done>
</task>

</tasks>

<verification>
1. Build succeeds: `dotnet build src/FunLang.Compiler`
2. All unit tests pass: `dotnet test tests/FunLang.Compiler.Tests`
3. Existing arithmetic and comparison tests still pass
4. Let binding tests demonstrate correct scoping and shadowing
</verification>

<success_criteria>
- CompileContext has Env: Map<string, MlirValue> field
- Var expressions look up values from Env
- Let expressions extend Env and compile body in extended context
- Shadowing works correctly (inner binding overrides outer)
- All existing tests continue to pass
- New let binding tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-core-expressions/08-02-SUMMARY.md`
</output>
