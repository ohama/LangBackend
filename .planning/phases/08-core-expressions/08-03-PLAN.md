---
phase: 08-core-expressions
plan: 03
type: execute
wave: 3
depends_on: [08-01, 08-02]
files_modified:
  - src/FunLang.Compiler/CodeGen.fs
  - tests/FunLang.Compiler.Tests/MlirBindingsTests.fs
autonomous: true

must_haves:
  truths:
    - "If-then-else expressions compile to scf.if with regions"
    - "Both branches end with scf.yield terminators"
    - "Result type is inferred from branch expressions"
    - "All tests pass including new if-else tests"
  artifacts:
    - path: "src/FunLang.Compiler/CodeGen.fs"
      provides: "If-else expression compilation"
      contains: "scf.if"
    - path: "tests/FunLang.Compiler.Tests/MlirBindingsTests.fs"
      provides: "Unit tests for if-else"
      contains: "compile and run if"
  key_links:
    - from: "src/FunLang.Compiler/CodeGen.fs If case"
      to: "scf.if regions"
      via: "CreateRegion + scf.yield terminators"
      pattern: "scf\\.if.*scf\\.yield"
---

<objective>
Implement if-then-else expressions using MLIR scf.if dialect

Purpose: Enable FunLang programs to use conditional expressions. scf.if is MLIR's structured control flow operation that maintains well-formedness through explicit scf.yield terminators in both branches.

Output: Extended CodeGen.fs with If expression handling using scf.if regions, unit tests verifying correct conditional execution.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-core-expressions/08-RESEARCH.md
@.planning/phases/08-core-expressions/08-01-SUMMARY.md
@.planning/phases/08-core-expressions/08-02-SUMMARY.md

# Source files to extend
@src/FunLang.Compiler/CodeGen.fs
@src/FunLang.Compiler/MlirWrapper.fs
@LangTutorial/FunLang/Ast.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement If expression compilation</name>
  <files>src/FunLang.Compiler/CodeGen.fs</files>
  <action>
Add If case to compileExpr function using scf.if with regions.

The scf.if operation has:
- A condition operand (i1 type)
- A "then" region with one block ending in scf.yield
- An "else" region with one block ending in scf.yield
- Result types matching what both branches yield

Implementation:

```fsharp
| If(cond, thenExpr, elseExpr, _) ->
    // 1. Compile condition (must be i1 type)
    let condVal = compileExpr ctx cond

    // 2. Determine result type (assume i32 for now - FunLang is well-typed)
    //    For boolean results, use i1; for integer results, use i32
    let resultType = builder.I32Type()  // TODO: type inference if needed

    // 3. Create THEN region
    let thenRegion = builder.CreateRegion()
    let thenBlock = builder.CreateBlock([||], ctx.Location)
    builder.AppendBlockToRegion(thenRegion, thenBlock)

    // Compile then expression in new block context
    let thenCtx = { ctx with Block = thenBlock }
    let thenVal = compileExpr thenCtx thenExpr

    // Add scf.yield terminator to then block
    let thenYieldOp = builder.CreateOperation(
        "scf.yield", ctx.Location,
        [||], [| thenVal |], [||], [||])
    builder.AppendOperationToBlock(thenBlock, thenYieldOp)

    // 4. Create ELSE region
    let elseRegion = builder.CreateRegion()
    let elseBlock = builder.CreateBlock([||], ctx.Location)
    builder.AppendBlockToRegion(elseRegion, elseBlock)

    // Compile else expression in new block context
    let elseCtx = { ctx with Block = elseBlock }
    let elseVal = compileExpr elseCtx elseExpr

    // Add scf.yield terminator to else block
    let elseYieldOp = builder.CreateOperation(
        "scf.yield", ctx.Location,
        [||], [| elseVal |], [||], [||])
    builder.AppendOperationToBlock(elseBlock, elseYieldOp)

    // 5. Create scf.if operation
    let ifOp = builder.CreateOperation(
        "scf.if", ctx.Location,
        [| resultType |],              // result types
        [| condVal |],                 // operands (condition only)
        [||],                          // no attributes
        [| thenRegion; elseRegion |])  // regions: then, else

    builder.AppendOperationToBlock(ctx.Block, ifOp)
    builder.GetResult(ifOp, 0)
```

CRITICAL details:
1. **Block context**: Each region compiles in its OWN block context (`thenCtx`, `elseCtx`)
2. **scf.yield terminators**: BOTH branches MUST end with scf.yield - MLIR verifier will fail otherwise
3. **Type consistency**: Both branches must yield the same type as declared in scf.if result types
4. **Region order**: First region is "then", second region is "else"
5. **Environment threading**: Each branch gets same Env from parent context
  </action>
  <verify>Build succeeds: `dotnet build src/FunLang.Compiler`</verify>
  <done>If expressions compile to scf.if with proper region structure and scf.yield terminators</done>
</task>

<task type="auto">
  <name>Task 2: Add lowering pass for scf dialect</name>
  <files>src/FunLang.Compiler/CodeGen.fs</files>
  <action>
Update the pass pipeline in compileAndRun to include scf-to-cf conversion.

The current pipeline is:
```fsharp
pm.AddPipeline("builtin.module(convert-arith-to-llvm,convert-func-to-llvm,reconcile-unrealized-casts)")
```

Update to include scf conversion:
```fsharp
pm.AddPipeline("builtin.module(convert-scf-to-cf,convert-arith-to-llvm,convert-cf-to-llvm,convert-func-to-llvm,reconcile-unrealized-casts)")
```

The conversion order matters:
1. `convert-scf-to-cf` - Convert structured control flow (scf.if) to unstructured (cf.br, cf.cond_br)
2. `convert-arith-to-llvm` - Convert arith operations to LLVM dialect
3. `convert-cf-to-llvm` - Convert cf dialect branches to LLVM dialect
4. `convert-func-to-llvm` - Convert func dialect to LLVM dialect
5. `reconcile-unrealized-casts` - Clean up any unrealized casts

Note: The `cf` dialect must be loaded in LoadStandardDialects. Check if it's already loaded or add it.
  </action>
  <verify>Build succeeds and simple if-else compiles: `dotnet build src/FunLang.Compiler`</verify>
  <done>Pass pipeline handles scf.if lowering to LLVM dialect</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for if-else expressions</name>
  <files>tests/FunLang.Compiler.Tests/MlirBindingsTests.fs</files>
  <action>
Add tests for if-else expressions to MlirBindingsTests.fs:

```fsharp
[<Tests>]
let ifElseTests =
    testList "IfElse" [
        test "compile and run if-else with true condition" {
            let result = CodeGen.compileAndRun "if true then 1 else 2"
            Expect.equal result 1 "if true then 1 else 2 should return 1"
        }

        test "compile and run if-else with false condition" {
            let result = CodeGen.compileAndRun "if false then 1 else 2"
            Expect.equal result 2 "if false then 1 else 2 should return 2"
        }

        test "compile and run if-else with comparison condition" {
            let result = CodeGen.compileAndRun "if 1 < 2 then 10 else 20"
            Expect.equal result 10 "if 1 < 2 then 10 else 20 should return 10"
        }

        test "compile and run if-else with equality condition" {
            let result = CodeGen.compileAndRun "if 5 = 5 then 100 else 200"
            Expect.equal result 100 "if 5 = 5 then ... should return 100"
        }

        test "compile and run if-else with inequality condition false" {
            let result = CodeGen.compileAndRun "if 3 > 5 then 1 else 0"
            Expect.equal result 0 "if 3 > 5 then 1 else 0 should return 0"
        }

        test "compile and run nested if-else" {
            let result = CodeGen.compileAndRun "if true then (if false then 1 else 2) else 3"
            Expect.equal result 2 "nested if-else should return 2"
        }

        test "compile and run if-else with let binding" {
            let result = CodeGen.compileAndRun "let x = 5 in if x < 10 then x + 1 else x - 1"
            Expect.equal result 6 "let x = 5 in if x < 10 then x + 1 else x - 1 should return 6"
        }

        test "compile and run if-else with let in branches" {
            let result = CodeGen.compileAndRun "if true then let x = 1 in x + 2 else let y = 3 in y + 4"
            Expect.equal result 3 "if true then let x = 1 in x + 2 should return 3"
        }

        test "compile and run if-else with complex arithmetic" {
            let result = CodeGen.compileAndRun "if (2 + 3) = 5 then 100 * 2 else 0"
            Expect.equal result 200 "complex if-else should return 200"
        }

        test "compile and run if-else with logical AND condition" {
            let result = CodeGen.compileAndRun "if true && true then 1 else 0"
            Expect.equal result 1 "true && true should be true"
        }

        test "compile and run if-else with logical OR condition" {
            let result = CodeGen.compileAndRun "if false || true then 1 else 0"
            Expect.equal result 1 "false || true should be true"
        }
    ]
```

These tests verify:
1. Boolean literal conditions (true/false)
2. Comparison operators as conditions
3. Nested if-else expressions
4. Let bindings with if-else
5. Let bindings inside branches
6. Logical operators as conditions
  </action>
  <verify>Tests pass: `dotnet test tests/FunLang.Compiler.Tests`</verify>
  <done>Unit tests verify if-else expressions work correctly with all condition types</done>
</task>

</tasks>

<verification>
1. Build succeeds: `dotnet build src/FunLang.Compiler`
2. All unit tests pass: `dotnet test tests/FunLang.Compiler.Tests`
3. Existing arithmetic, comparison, and let binding tests still pass
4. If-else tests demonstrate correct conditional evaluation
5. Generated MLIR IR contains scf.if with proper structure
</verification>

<success_criteria>
- If expressions compile to scf.if with then/else regions
- Both regions end with scf.yield terminators
- Pass pipeline handles scf-to-cf-to-llvm conversion
- Nested if-else expressions work correctly
- If-else with let bindings preserves scoping
- All existing tests continue to pass
- New if-else tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-core-expressions/08-03-SUMMARY.md`
</output>
