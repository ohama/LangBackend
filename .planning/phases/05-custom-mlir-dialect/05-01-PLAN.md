---
phase: 05-custom-mlir-dialect
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tutorial/14-custom-dialect-design.md
  - tutorial/SUMMARY.md
autonomous: true

must_haves:
  truths:
    - "Reader understands why custom dialects improve compiler design"
    - "Reader can explain TableGen ODS syntax for operations and types"
    - "Reader understands the C API shim pattern for F# interop"
    - "Reader can trace progressive lowering path: FunLang -> SCF/MemRef -> LLVM"
  artifacts:
    - path: "tutorial/14-custom-dialect-design.md"
      provides: "Chapter 14: Custom dialect design theory and C API shim architecture"
      min_lines: 1500
    - path: "tutorial/SUMMARY.md"
      provides: "Updated chapter list with Chapter 14"
      contains: "14-custom-dialect-design"
  key_links:
    - from: "Chapter 14"
      to: "Chapter 12-13 closure patterns"
      via: "Motivation section referencing verbose lowlevel MLIR from Phase 4"
      pattern: "funlang\\.closure|GEP|getelementptr"
    - from: "Chapter 14"
      to: "Appendix custom dialect"
      via: "Reference to C++ dialect registration established in Phase 1"
      pattern: "extern.*C|DialectRegistry"
---

<objective>
Write Chapter 14: Custom Dialect Design - explaining why and how to design FunLang's custom MLIR dialect

Purpose: Establish theoretical foundation for custom dialect operations before implementation. Reader learns dialect design principles, TableGen ODS syntax, and the C API shim pattern needed for F# interop.

Output:
- `tutorial/14-custom-dialect-design.md` (1500+ lines)
- Updated `tutorial/SUMMARY.md` with Chapter 14
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-custom-mlir-dialect/05-RESEARCH.md

# Prior work
@tutorial/12-closures.md
@tutorial/13-higher-order-functions.md
@tutorial/appendix-custom-dialect.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Chapter 14 Part 1 - Dialect Design Motivation and Progressive Lowering</name>
  <files>tutorial/14-custom-dialect-design.md</files>
  <action>
Create Chapter 14 first half covering:

**Section 1: Introduction (200+ lines)**
- Chapter 14 목표와 범위
- Phase 4의 문제점 분석:
  - 저수준 LLVM dialect 직접 생성의 복잡성
  - GEP + load + store 패턴의 반복
  - 최적화 pass 추가의 어려움
- Custom dialect의 이점:
  - 도메인 의미론 보존 (funlang.closure vs raw pointers)
  - 컴파일러 코드 단순화
  - dialect-specific 최적화 기회
- Before/After 비교 (Phase 4 vs Phase 5 코드)

**Section 2: MLIR Dialect Architecture (300+ lines)**
- Dialect hierarchy 개념 (FunLang -> Standard dialects -> LLVM)
- Operation, Type, Attribute의 역할
- Region과 Block 복습 (Phase 1 연결)
- Symbol table과 함수 참조
- DialectRegistry와 의존성 선언
- 다이어그램: FunLang dialect 계층 구조

**Section 3: Progressive Lowering Philosophy (400+ lines)**
- Why not direct FunLang -> LLVM lowering?
  - 최적화 기회 상실
  - 코드 복잡성 폭발
  - 디버깅 어려움
- Progressive lowering 단계:
  1. FunLang dialect (고수준 의미론)
  2. Func + SCF + MemRef (중간 추상화)
  3. LLVM dialect (저수준)
- 각 단계의 역할과 변환 예시
- ConversionTarget과 legal/illegal dialects
- RewritePatternSet 개념
- 실제 lowering pass 구조 미리보기

Use Korean plain style (~이다/~한다). Keep technical terms (TableGen, Operation, Type, ConversionPattern) in English.
  </action>
  <verify>
```bash
# Check chapter exists and has substantial content
wc -l tutorial/14-custom-dialect-design.md | grep -E "^[89][0-9]{2}|^[0-9]{4}"

# Verify key sections
grep -c "Progressive Lowering\|점진적 하강" tutorial/14-custom-dialect-design.md | grep -E "^[3-9]|^[0-9]{2}"

# Verify Phase 4 comparison exists
grep -c "Phase 4\|getelementptr\|GC_malloc" tutorial/14-custom-dialect-design.md | grep -E "^[5-9]|^[0-9]{2}"
```
  </verify>
  <done>
Chapter 14 Part 1 exists with 900+ lines covering dialect motivation and progressive lowering philosophy. Key sections present: introduction with Phase 4 comparison, dialect architecture, progressive lowering stages.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write Chapter 14 Part 2 - TableGen ODS and C API Shim Pattern</name>
  <files>tutorial/14-custom-dialect-design.md</files>
  <action>
Complete Chapter 14 second half:

**Section 4: TableGen ODS Fundamentals (400+ lines)**
- TableGen이란? (LLVM의 DSL for code generation)
- FunLang dialect 정의:
```tablegen
def FunLang_Dialect : Dialect {
  let name = "funlang";
  let cppNamespace = "::mlir::funlang";
  let dependentDialects = ["func::FuncDialect", "LLVM::LLVMDialect"];
}
```
- Operation 정의 구조:
  - def, class inheritance
  - arguments (ins), results (outs)
  - assemblyFormat
  - hasVerifier, Pure traits
- Type 정의:
  - TypeDef syntax
  - parameters와 mnemonic
- FunLang 타입 설계:
  - FunLang_ClosureType (클로저 표현)
  - FunLang_ListType (Phase 6 preview)
- 예시: funlang.closure operation TableGen 정의
- 생성되는 C++ 코드 설명

**Section 5: C API Shim Pattern for F# Interop (400+ lines)**
- 문제: TableGen은 C++ 코드 생성, F#은 C API 필요
- 해결책: extern C wrapper functions
- FunLangCAPI.h 구조:
```c
extern "C" {
  void mlirContextRegisterFunLangDialect(MlirContext ctx);
  MlirOperation mlirFunLangClosureOpCreate(...);
  MlirType mlirFunLangClosureTypeGet(MlirContext ctx);
}
```
- FunLangCAPI.cpp 구현 패턴:
  - wrap/unwrap 헬퍼 사용
  - OpBuilder 활용
  - 타입 생성 및 검증
- CMakeLists.txt 빌드 설정
- F# P/Invoke 바인딩 (Mlir.FunLang 모듈)
- 전체 아키텍처 다이어그램:
  ```
  F# Code -> P/Invoke -> FunLangCAPI.cpp -> C++ Dialect -> MLIR
  ```

**Section 6: FunLang Dialect Operations Preview (200+ lines)**
- 설계할 operations 목록:
  - funlang.closure: 클로저 생성
  - funlang.apply: 클로저 호출
  - funlang.match: 패턴 매칭 (Phase 6)
- 각 operation의 의미와 시그니처
- Chapter 15에서 구현할 내용 미리보기

**Section 7: Common Pitfalls (100+ lines)**
- Pitfall 1: 불완전한 타입 시스템 (AnyType 남용)
- Pitfall 2: Missing operation traits (Pure, MemoryEffects)
- Pitfall 3: Symbol table 미사용 (string 함수 참조)
- Pitfall 4: C API 메모리 관리 혼동

**Summary Section:**
- Chapter 14에서 배운 것
- Chapter 15 preview (operations 구현)

Update tutorial/SUMMARY.md to include Chapter 14.

Use Korean plain style. Technical terms in English.
  </action>
  <verify>
```bash
# Check total line count
wc -l tutorial/14-custom-dialect-design.md | grep -E "^1[5-9][0-9]{2}|^[2-9][0-9]{3}"

# Verify TableGen content
grep -c "TableGen\|tablegen\|def.*Dialect\|def.*Op" tutorial/14-custom-dialect-design.md | grep -E "^[1-9][0-9]|^[0-9]{3}"

# Verify C API shim pattern
grep -c "extern.*C\|mlirFunLang\|wrap\|unwrap" tutorial/14-custom-dialect-design.md | grep -E "^[1-9][0-9]|^[0-9]{3}"

# Check SUMMARY.md updated
grep "14-custom-dialect-design" tutorial/SUMMARY.md
```
  </verify>
  <done>
Chapter 14 complete with 1500+ lines. Contains: TableGen ODS fundamentals with FunLang dialect definition, C API shim pattern with code examples, operation preview, common pitfalls. SUMMARY.md updated with Chapter 14 entry.
  </done>
</task>

</tasks>

<verification>
After all tasks:
```bash
# Verify chapter completeness
wc -l tutorial/14-custom-dialect-design.md

# Check key content exists
grep -c "funlang\." tutorial/14-custom-dialect-design.md   # Custom dialect references
grep -c "TableGen" tutorial/14-custom-dialect-design.md    # TableGen content
grep -c "C API\|CAPI\|extern" tutorial/14-custom-dialect-design.md  # C API shim
grep -c "Lowering\|하강" tutorial/14-custom-dialect-design.md  # Lowering content

# Verify Korean writing style
grep -c "~이다\|~한다\|~된다" tutorial/14-custom-dialect-design.md | grep -E "^[5-9][0-9]|^[0-9]{3}"

# Verify SUMMARY.md has chapter 14
grep "14-custom-dialect-design" tutorial/SUMMARY.md
```
</verification>

<success_criteria>
- Chapter 14 exists with 1500+ lines
- TableGen ODS syntax explained with FunLang dialect definition
- C API shim pattern documented with code examples
- Progressive lowering philosophy covered (FunLang -> SCF/MemRef -> LLVM)
- Common pitfalls section present
- SUMMARY.md updated with Chapter 14 entry
- Korean plain style (~이다/~한다) throughout
- Technical terms (TableGen, Operation, Type) in English
</success_criteria>

<output>
After completion, create `.planning/phases/05-custom-mlir-dialect/05-01-SUMMARY.md`
</output>
