---
phase: 05-custom-mlir-dialect
plan: 03
type: execute
wave: 3
depends_on: ["05-02"]
files_modified:
  - tutorial/16-lowering-passes.md
  - tutorial/SUMMARY.md
autonomous: true

must_haves:
  truths:
    - "Reader understands ConversionTarget and legal/illegal dialects"
    - "Reader can implement ConversionPattern for funlang.closure lowering"
    - "Reader can implement ConversionPattern for funlang.apply lowering"
    - "Reader understands TypeConverter for FunLang types to LLVM types"
    - "Reader can implement DRR (Declarative Rewrite Rules) for optimization"
    - "Reader can run complete lowering pipeline: FunLang -> SCF/MemRef -> LLVM"
  artifacts:
    - path: "tutorial/16-lowering-passes.md"
      provides: "Chapter 16: Lowering passes and pattern-based rewrites"
      min_lines: 1500
    - path: "tutorial/SUMMARY.md"
      provides: "Updated chapter list with Chapter 16"
      contains: "16-lowering-passes"
  key_links:
    - from: "Chapter 16 lowering"
      to: "Chapter 15 operations"
      via: "ConversionPattern for each custom operation"
      pattern: "ClosureOpLowering|ApplyOpLowering"
    - from: "Chapter 16 TypeConverter"
      to: "Chapter 15 custom types"
      via: "FunLang_ClosureType -> !llvm.ptr conversion"
      pattern: "addConversion.*closure|typeConverter"
---

<objective>
Write Chapter 16: Lowering Passes - implementing progressive lowering from FunLang dialect to LLVM dialect with pattern-based rewrites

Purpose: Complete the custom dialect journey by showing how high-level FunLang operations lower to the LLVM dialect patterns established in Phase 4. Reader learns ConversionPattern, TypeConverter, and DRR optimization patterns.

Output:
- `tutorial/16-lowering-passes.md` (1500+ lines)
- Updated `tutorial/SUMMARY.md` with Chapter 16
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-custom-mlir-dialect/05-RESEARCH.md

# Prior work - operations to lower
# Assumes Chapter 14-15 complete from 05-01 and 05-02

# Phase 4 lowering targets
@tutorial/12-closures.md
@tutorial/13-higher-order-functions.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Chapter 16 Part 1 - Lowering Infrastructure and ClosureOp Lowering</name>
  <files>tutorial/16-lowering-passes.md</files>
  <action>
Create Chapter 16 first half covering:

**Section 1: Introduction (200+ lines)**
- Chapter 16 목표와 범위
- Chapter 14-15 복습: custom operations 정의 완료
- 이제 해결할 문제: FunLang dialect -> 실행 가능 코드
- Lowering pass란?
- Progressive lowering 복습:
  1. FunLang dialect (Chapter 15에서 정의)
  2. Func + SCF + MemRef (중간 추상화)
  3. LLVM dialect (최종 목표)
- Chapter 16 성공 기준

**Section 2: DialectConversion Framework (350+ lines)**
- ConversionTarget 설명:
```cpp
ConversionTarget target(getContext());
target.addLegalDialect<LLVM::LLVMDialect, func::FuncDialect>();
target.addIllegalDialect<funlang::FunLangDialect>();
```
- addLegalDialect, addIllegalDialect, addDynamicallyLegalOp 차이
- Partial vs Full conversion
- RewritePatternSet 구성:
```cpp
RewritePatternSet patterns(&getContext());
patterns.add<ClosureOpLowering, ApplyOpLowering>(&getContext());
```
- applyPartialConversion vs applyFullConversion
- TypeConverter 역할:
```cpp
TypeConverter typeConverter;
typeConverter.addConversion([](funlang::ClosureType type) {
    return LLVM::LLVMPointerType::get(type.getContext());
});
```
- 변환 실패 처리 (signalPassFailure)

**Section 3: ClosureOp Lowering Pattern (450+ lines)**
- funlang.closure가 생성해야 할 LLVM IR (Chapter 12 복습):
```mlir
// funlang.closure @lambda, %n -> becomes:
%env_size = arith.constant 16 : i64
%env = llvm.call @GC_malloc(%env_size) : (i64) -> !llvm.ptr
%fn_ptr = llvm.mlir.addressof @lambda : !llvm.ptr
%slot0 = llvm.getelementptr %env[0] : (!llvm.ptr) -> !llvm.ptr
llvm.store %fn_ptr, %slot0 : !llvm.ptr, !llvm.ptr
%slot1 = llvm.getelementptr %env[1] : (!llvm.ptr) -> !llvm.ptr
llvm.store %n, %slot1 : i32, !llvm.ptr
// Result: %env (closure pointer)
```
- ConversionPattern 구현:
```cpp
struct ClosureOpLowering : public OpConversionPattern<funlang::ClosureOp> {
  using OpConversionPattern<funlang::ClosureOp>::OpConversionPattern;

  LogicalResult matchAndRewrite(
      funlang::ClosureOp op, OpAdaptor adaptor,
      ConversionPatternRewriter &rewriter) const override {

    auto loc = op.getLoc();
    auto ctx = rewriter.getContext();

    // 1. Calculate environment size
    size_t numCaptured = adaptor.getCaptured().size();
    size_t envSize = 8 + numCaptured * 8;  // fn_ptr + captured vars

    // 2. Allocate environment via GC_malloc
    auto i64Type = rewriter.getI64Type();
    auto ptrType = LLVM::LLVMPointerType::get(ctx);
    auto envSizeConst = rewriter.create<arith::ConstantOp>(
        loc, i64Type, rewriter.getI64IntegerAttr(envSize));
    auto gcMalloc = rewriter.create<LLVM::CallOp>(
        loc, ptrType, "GC_malloc", ValueRange{envSizeConst});

    // 3. Store function pointer at env[0]
    auto fnPtrAddr = rewriter.create<LLVM::AddressOfOp>(
        loc, op.getCalleeAttr());
    auto slot0 = rewriter.create<LLVM::GEPOp>(
        loc, ptrType, ptrType, gcMalloc.getResult(),
        ArrayRef<LLVM::GEPArg>{0});
    rewriter.create<LLVM::StoreOp>(loc, fnPtrAddr, slot0);

    // 4. Store captured values at env[1..]
    for (auto [idx, val] : llvm::enumerate(adaptor.getCaptured())) {
      auto slot = rewriter.create<LLVM::GEPOp>(
          loc, ptrType, ptrType, gcMalloc.getResult(),
          ArrayRef<LLVM::GEPArg>{static_cast<int32_t>(idx + 1)});
      rewriter.create<LLVM::StoreOp>(loc, val, slot);
    }

    // 5. Replace closure op with environment pointer
    rewriter.replaceOp(op, gcMalloc.getResult());
    return success();
  }
};
```
- 코드 상세 설명:
  - OpAdaptor와 adaptor.getCaptured()
  - ConversionPatternRewriter 사용법
  - rewriter.replaceOp으로 원본 operation 교체
- C API shim으로 pass 노출:
```cpp
extern "C" void mlirFunLangRegisterLoweringPass(MlirContext ctx);
```
- F#에서 pass 실행

Use Korean plain style. Technical terms in English.
  </action>
  <verify>
```bash
# Check chapter has substantial content
wc -l tutorial/16-lowering-passes.md | grep -E "^[89][0-9]{2}|^1[0-9]{3}"

# Verify ConversionTarget content
grep -c "ConversionTarget\|addLegalDialect\|addIllegalDialect" tutorial/16-lowering-passes.md | grep -E "^[1-9][0-9]|^[0-9]{3}"

# Verify ClosureOp lowering
grep -c "ClosureOpLowering\|OpConversionPattern\|matchAndRewrite" tutorial/16-lowering-passes.md | grep -E "^[1-9][0-9]|^[0-9]{3}"

# Verify GC_malloc and GEP patterns
grep -c "GC_malloc\|GEPOp\|getelementptr" tutorial/16-lowering-passes.md | grep -E "^[1-9][0-9]|^[0-9]{3}"
```
  </verify>
  <done>
Chapter 16 Part 1 exists with 1000+ lines covering: DialectConversion framework (ConversionTarget, RewritePatternSet, TypeConverter), ClosureOp lowering pattern with complete C++ implementation, C API shim for pass execution.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write Chapter 16 Part 2 - ApplyOp Lowering and DRR Patterns</name>
  <files>tutorial/16-lowering-passes.md</files>
  <action>
Complete Chapter 16 second half:

**Section 4: ApplyOp Lowering Pattern (350+ lines)**
- funlang.apply가 생성해야 할 LLVM IR (Chapter 13 복습):
```mlir
// funlang.apply %closure(%arg) -> becomes:
%fn_ptr_addr = llvm.getelementptr %closure[0] : (!llvm.ptr) -> !llvm.ptr
%fn_ptr = llvm.load %fn_ptr_addr : !llvm.ptr -> !llvm.ptr
%result = llvm.call %fn_ptr(%closure, %arg) : (!llvm.ptr, i32) -> i32
```
- ConversionPattern 구현:
```cpp
struct ApplyOpLowering : public OpConversionPattern<funlang::ApplyOp> {
  using OpConversionPattern<funlang::ApplyOp>::OpConversionPattern;

  LogicalResult matchAndRewrite(
      funlang::ApplyOp op, OpAdaptor adaptor,
      ConversionPatternRewriter &rewriter) const override {

    auto loc = op.getLoc();
    auto ctx = rewriter.getContext();
    auto ptrType = LLVM::LLVMPointerType::get(ctx);

    // 1. Extract function pointer from closure[0]
    Value closure = adaptor.getClosure();
    auto slot0 = rewriter.create<LLVM::GEPOp>(
        loc, ptrType, ptrType, closure,
        ArrayRef<LLVM::GEPArg>{0});
    auto fnPtr = rewriter.create<LLVM::LoadOp>(loc, ptrType, slot0);

    // 2. Prepare arguments (closure + original args)
    SmallVector<Value> callArgs;
    callArgs.push_back(closure);
    callArgs.append(adaptor.getArgs().begin(), adaptor.getArgs().end());

    // 3. Indirect call
    auto resultType = getTypeConverter()->convertType(op.getResult().getType());
    auto call = rewriter.create<LLVM::CallOp>(
        loc, resultType, fnPtr, callArgs);

    rewriter.replaceOp(op, call.getResult());
    return success();
  }
};
```
- getTypeConverter() 사용법
- Indirect call (llvm.call with function pointer)

**Section 5: TypeConverter for FunLang Types (250+ lines)**
- FunLang_ClosureType -> !llvm.ptr 변환:
```cpp
typeConverter.addConversion([&](funlang::ClosureType type) {
    return LLVM::LLVMPointerType::get(type.getContext());
});

typeConverter.addConversion([&](funlang::ListType type) {
    return LLVM::LLVMPointerType::get(type.getContext());
});
```
- Materialization 함수:
  - addSourceMaterialization: 원본 타입으로 변환
  - addTargetMaterialization: 대상 타입으로 변환
  - unrealized_conversion_cast 처리
- 타입 변환 체인 설명

**Section 6: Declarative Rewrite Rules (DRR) (300+ lines)**
- DRR이란? TableGen 기반 패턴 매칭
- 사용 사례: 최적화, 정규화, 간단한 lowering
- 예시 1 - Empty closure 최적화:
```tablegen
def SimplifyEmptyClosure : Pat<
  (FunLang_ClosureOp $callee, (variadic)),
  (FunLang_FuncRefOp $callee),
  [(Constraint<CPred<"$0.empty()">>, $1)]
>;
```
- 예시 2 - Known closure inlining:
```tablegen
def InlineKnownApply : Pat<
  (FunLang_ApplyOp (FunLang_ClosureOp $callee, $captures), $args),
  (FunLang_DirectCallOp $callee, (ConcatValues $captures, $args))
>;
```
- DRR vs C++ ConversionPattern 비교:
  - DRR: 간단한 패턴, 선언적
  - C++: 복잡한 로직, 제어 흐름
- mlir-tblgen으로 DRR 컴파일

**Section 7: Complete Lowering Pass (250+ lines)**
- Pass 정의:
```cpp
struct FunLangToLLVMPass
    : public PassWrapper<FunLangToLLVMPass, OperationPass<ModuleOp>> {

  void getDependentDialects(DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect, func::FuncDialect>();
  }

  void runOnOperation() override {
    ConversionTarget target(getContext());
    target.addLegalDialect<LLVM::LLVMDialect, func::FuncDialect>();
    target.addIllegalDialect<funlang::FunLangDialect>();

    TypeConverter typeConverter;
    // ... type conversions ...

    RewritePatternSet patterns(&getContext());
    patterns.add<ClosureOpLowering, ApplyOpLowering>(&getContext());

    if (failed(applyPartialConversion(getOperation(), target, std::move(patterns)))) {
      signalPassFailure();
    }
  }
};
```
- Pass 등록:
```cpp
void registerFunLangPasses() {
  PassRegistration<FunLangToLLVMPass>("funlang-to-llvm",
      "Lower FunLang dialect to LLVM dialect");
}
```
- C API로 pass 노출
- F#에서 pass 실행:
```fsharp
let lowerToLLVM (module_: MlirModule) =
    mlirFunLangLowerToLLVM(module_)
```

**Section 8: End-to-End Example (200+ lines)**
- makeAdder 함수 전체 lowering 추적:
```fsharp
// Source
let makeAdder n = fun x -> x + n

// Phase 5 FunLang dialect
%closure = funlang.closure @lambda_adder, %n : !funlang.closure<(i32) -> i32>

// After funlang-to-llvm pass
%env = llvm.call @GC_malloc(%c16) : (i64) -> !llvm.ptr
%fn_ptr = llvm.mlir.addressof @lambda_adder : !llvm.ptr
llvm.store %fn_ptr, %env[0] : !llvm.ptr
llvm.store %n, %env[1] : i32
```
- IR 덤프로 각 단계 확인
- 전체 컴파일 파이프라인 다이어그램

**Section 9: Common Errors (100+ lines)**
- Error 1: Illegal operation remaining after conversion
- Error 2: Type conversion failure (missing addConversion)
- Error 3: Wrong operand types in rewriter.create
- Error 4: Pass not registered in pipeline

**Summary Section:**
- Chapter 16에서 배운 것
- Phase 5 완료 요약
- Phase 6 preview (Pattern Matching with funlang.match)

Update tutorial/SUMMARY.md to include Chapter 16.

Use Korean plain style. Technical terms in English.
  </action>
  <verify>
```bash
# Check total line count
wc -l tutorial/16-lowering-passes.md | grep -E "^1[5-9][0-9]{2}|^[2-9][0-9]{3}"

# Verify ApplyOp lowering
grep -c "ApplyOpLowering\|funlang.apply" tutorial/16-lowering-passes.md | grep -E "^[1-9][0-9]|^[0-9]{3}"

# Verify DRR content
grep -c "DRR\|Declarative.*Rewrite\|Pat<\|SimplifyEmpty" tutorial/16-lowering-passes.md | grep -E "^[1-9]|^[0-9]{2}"

# Verify complete pass
grep -c "FunLangToLLVM\|registerFunLangPasses\|runOnOperation" tutorial/16-lowering-passes.md | grep -E "^[5-9]|^[0-9]{2}"

# Verify TypeConverter content
grep -c "TypeConverter\|addConversion\|Materialization" tutorial/16-lowering-passes.md | grep -E "^[1-9]|^[0-9]{2}"

# Check SUMMARY.md updated
grep "16-lowering-passes" tutorial/SUMMARY.md
```
  </verify>
  <done>
Chapter 16 complete with 1500+ lines. Contains: ApplyOp lowering pattern, TypeConverter for FunLang types, DRR optimization patterns, complete FunLangToLLVMPass implementation, end-to-end makeAdder example, common errors. SUMMARY.md updated with Chapter 16 entry.
  </done>
</task>

</tasks>

<verification>
After all tasks:
```bash
# Verify chapter completeness
wc -l tutorial/16-lowering-passes.md

# Check lowering patterns
grep -c "ConversionPattern\|OpConversionPattern" tutorial/16-lowering-passes.md
grep -c "ClosureOpLowering\|ApplyOpLowering" tutorial/16-lowering-passes.md

# Check framework content
grep -c "ConversionTarget\|TypeConverter\|RewritePatternSet" tutorial/16-lowering-passes.md

# Check DRR content
grep -c "DRR\|Pat<\|tablegen" tutorial/16-lowering-passes.md

# Check end-to-end example
grep -c "makeAdder\|lambda_adder" tutorial/16-lowering-passes.md

# Verify Korean writing style
grep -c "~이다\|~한다\|~된다" tutorial/16-lowering-passes.md | grep -E "^[5-9][0-9]|^[0-9]{3}"

# Verify SUMMARY.md has chapter 16
grep "16-lowering-passes" tutorial/SUMMARY.md
```
</verification>

<success_criteria>
- Chapter 16 exists with 1500+ lines
- ClosureOp lowering pattern with complete C++ code
- ApplyOp lowering pattern with complete C++ code
- TypeConverter for FunLang -> LLVM type conversion
- DRR optimization patterns (SimplifyEmptyClosure, InlineKnownApply)
- Complete FunLangToLLVMPass implementation
- End-to-end example (makeAdder through pipeline)
- Common errors section present
- SUMMARY.md updated with Chapter 16 entry
- Korean plain style (~이다/~한다) throughout
</success_criteria>

<output>
After completion, create `.planning/phases/05-custom-mlir-dialect/05-03-SUMMARY.md`
</output>
