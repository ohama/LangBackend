---
phase: 05-custom-mlir-dialect
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - tutorial/15-custom-operations.md
  - tutorial/SUMMARY.md
autonomous: true

must_haves:
  truths:
    - "Reader can define funlang.closure operation using TableGen ODS"
    - "Reader can define funlang.apply operation for closure invocation"
    - "Reader can define funlang.match operation for pattern matching"
    - "Reader can implement C API shim functions for each operation"
    - "Reader can call custom operations from F# via P/Invoke"
  artifacts:
    - path: "tutorial/15-custom-operations.md"
      provides: "Chapter 15: Custom operations implementation with F# integration"
      min_lines: 1500
    - path: "tutorial/SUMMARY.md"
      provides: "Updated chapter list with Chapter 15"
      contains: "15-custom-operations"
  key_links:
    - from: "Chapter 15 funlang.closure"
      to: "Chapter 12-13 closure patterns"
      via: "Operation replaces manual GEP+store sequence"
      pattern: "funlang\\.closure.*@lambda"
    - from: "Chapter 15 C API"
      to: "Chapter 14 shim pattern"
      via: "mlirFunLang* function implementations"
      pattern: "mlirFunLang.*Create|mlirFunLang.*Get"
---

<objective>
Write Chapter 15: Custom Operations - implementing funlang.closure, funlang.apply, and funlang.match operations with complete F# integration

Purpose: Give reader hands-on experience defining MLIR operations with TableGen ODS and connecting them to F# via C API shim. Each operation replaces verbose Phase 4 patterns.

Output:
- `tutorial/15-custom-operations.md` (1500+ lines)
- Updated `tutorial/SUMMARY.md` with Chapter 15
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-custom-mlir-dialect/05-RESEARCH.md

# Prior work - custom dialect design
# Assumes Chapter 14 complete from 05-01-PLAN

# Phase 4 patterns to abstract
@tutorial/12-closures.md
@tutorial/13-higher-order-functions.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Chapter 15 Part 1 - funlang.closure and funlang.apply Operations</name>
  <files>tutorial/15-custom-operations.md</files>
  <action>
Create Chapter 15 first half covering:

**Section 1: Introduction (150+ lines)**
- Chapter 15 목표와 범위
- Chapter 14 복습: TableGen ODS, C API shim
- 구현할 operations 목록:
  - funlang.closure: 클로저 생성
  - funlang.apply: 클로저 호출
  - funlang.match: 패턴 매칭 (Phase 6 preview)
- Chapter 15 성공 기준

**Section 2: funlang.closure Operation (450+ lines)**
- Phase 4 패턴 분석 (어떤 코드를 추상화하는가):
```mlir
// Phase 4: 12+ lines of LLVM dialect
%env = llvm.call @GC_malloc(%c16) : (i64) -> !llvm.ptr
%fn_ptr = llvm.mlir.addressof @lambda_N : !llvm.ptr
%slot0 = llvm.getelementptr %env[0] : (!llvm.ptr) -> !llvm.ptr
llvm.store %fn_ptr, %slot0 : !llvm.ptr, !llvm.ptr
// ... more stores ...
```

- TableGen 정의:
```tablegen
def FunLang_ClosureOp : FunLang_Op<"closure", [Pure]> {
  let summary = "Create a closure with captured environment";
  let arguments = (ins
    FlatSymbolRefAttr:$callee,
    Variadic<AnyType>:$captured
  );
  let results = (outs FunLang_ClosureType:$result);
  let assemblyFormat = "$callee `,` $captured attr-dict `:` type($result)";
}
```

- TableGen 상세 설명:
  - Pure trait 의미 (side-effect free)
  - FlatSymbolRefAttr로 함수 참조
  - Variadic<AnyType>으로 캡처 변수들
  - assemblyFormat 파싱
- 생성되는 C++ 클래스 (ClosureOp)
- C API shim 구현:
```cpp
extern "C" MlirOperation mlirFunLangClosureOpCreate(
    MlirContext ctx, MlirLocation loc,
    MlirAttribute callee, intptr_t numCaptured, MlirValue *captured) {
  // Implementation with OpBuilder
}
```
- F# P/Invoke 바인딩:
```fsharp
[<DllImport("FunLangCAPI")>]
extern MlirOperation mlirFunLangClosureOpCreate(
    MlirContext ctx, MlirLocation loc,
    MlirAttribute callee, nativeint numCaptured, MlirValue[] captured)
```
- 사용 예시: F#에서 funlang.closure 생성
- Phase 4 vs Phase 5 코드 비교

**Section 3: funlang.apply Operation (400+ lines)**
- Phase 4 간접 호출 패턴 분석:
```mlir
// Phase 4: 8+ lines
%fn_ptr_addr = llvm.getelementptr %closure[0] : (!llvm.ptr) -> !llvm.ptr
%fn_ptr = llvm.load %fn_ptr_addr : !llvm.ptr -> !llvm.ptr
%result = llvm.call %fn_ptr(%closure, %arg) : (!llvm.ptr, i32) -> i32
```

- TableGen 정의:
```tablegen
def FunLang_ApplyOp : FunLang_Op<"apply", []> {
  let summary = "Apply a closure to arguments";
  let arguments = (ins
    FunLang_ClosureType:$closure,
    Variadic<AnyType>:$args
  );
  let results = (outs AnyType:$result);
  let assemblyFormat = "$closure `(` $args `)` attr-dict `:` functional-type($args, $result)";
}
```

- 메모리 효과 traits 설명 (MemoryEffects)
- C API shim 구현
- F# 바인딩
- Closure + Apply 조합 예시:
```mlir
%closure = funlang.closure @add_n, %n : !funlang.closure<(i32) -> i32>
%result = funlang.apply %closure(%x) : (i32) -> i32
```

Use Korean plain style. Technical terms in English.
  </action>
  <verify>
```bash
# Check chapter has substantial content
wc -l tutorial/15-custom-operations.md | grep -E "^[89][0-9]{2}|^1[0-9]{3}"

# Verify closure operation content
grep -c "funlang.closure\|ClosureOp\|FunLang_ClosureOp" tutorial/15-custom-operations.md | grep -E "^[2-9][0-9]|^[0-9]{3}"

# Verify apply operation content
grep -c "funlang.apply\|ApplyOp\|FunLang_ApplyOp" tutorial/15-custom-operations.md | grep -E "^[1-9][0-9]|^[0-9]{3}"

# Verify TableGen examples
grep -c "def.*Op\|let summary\|let arguments" tutorial/15-custom-operations.md | grep -E "^[1-9][0-9]|^[0-9]{3}"
```
  </verify>
  <done>
Chapter 15 Part 1 exists with 1000+ lines covering funlang.closure and funlang.apply operations. Each operation has: TableGen definition, C API shim implementation, F# P/Invoke binding, usage example.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write Chapter 15 Part 2 - funlang.match Operation and Complete F# Integration</name>
  <files>tutorial/15-custom-operations.md</files>
  <action>
Complete Chapter 15 second half:

**Section 4: funlang.match Operation (Phase 6 Preview) (300+ lines)**
- 패턴 매칭 개념 (Phase 6에서 완전 구현)
- TableGen 정의:
```tablegen
def FunLang_MatchOp : FunLang_Op<"match", [
    RecursiveSideEffects,
    SingleBlockImplicitTerminator<"funlang.yield">
]> {
  let summary = "Pattern matching expression";
  let arguments = (ins AnyType:$scrutinee);
  let results = (outs AnyType:$result);
  let regions = (region VariadicRegion<SizedRegion<1>>:$cases);
  let hasVerifier = 1;
}
```
- Region-based operation 설명
- 각 case가 별도 region인 이유
- Verifier 필요성 (모든 케이스가 같은 타입 반환)
- C API shim 구현 패턴 (region 생성 포함)
- Phase 6에서의 사용 예시:
```mlir
%result = funlang.match %list {
  ^nil: funlang.yield %zero : i32
  ^cons(%head: i32, %tail: !funlang.list):
    funlang.yield %head : i32
}
```

**Section 5: FunLang Custom Types (250+ lines)**
- FunLang_ClosureType 상세:
```tablegen
def FunLang_ClosureType : TypeDef<FunLang_Dialect, "Closure"> {
  let mnemonic = "closure";
  let parameters = (ins "FunctionType":$funcType);
  let assemblyFormat = "`<` $funcType `>`";
}
```
- FunLang_ListType (Phase 6 preview):
```tablegen
def FunLang_ListType : TypeDef<FunLang_Dialect, "List"> {
  let mnemonic = "list";
  let parameters = (ins "Type":$elementType);
  let assemblyFormat = "`<` $elementType `>`";
}
```
- 타입의 LLVM lowering 미리보기:
  - !funlang.closure -> !llvm.ptr
  - !funlang.list -> !llvm.ptr (cons cell)

**Section 6: Complete F# Integration Module (350+ lines)**
- Mlir.FunLang.fs 모듈 전체 구조:
```fsharp
module Mlir.FunLang

// Type bindings
[<DllImport("FunLangCAPI")>]
extern MlirType mlirFunLangClosureTypeGet(MlirContext ctx, MlirType funcType)

// Operation bindings
[<DllImport("FunLangCAPI")>]
extern MlirOperation mlirFunLangClosureOpCreate(...)

// High-level F# wrapper
type FunLangDialect(context: MlirContext) =
    member this.CreateClosure(callee: string, captured: MlirValue list) =
        // ...
    member this.CreateApply(closure: MlirValue, args: MlirValue list) =
        // ...
```
- F# wrapper 클래스 설계
- Builder 패턴으로 operation 생성
- 타입 안전성 보장
- 사용 예시: makeAdder를 FunLang dialect로 컴파일

**Section 7: Refactoring Chapter 12-13 with Custom Dialect (200+ lines)**
- Before (Phase 4 lowlevel MLIR):
  - 클로저 생성: 12+ lines
  - 클로저 호출: 8+ lines
- After (Phase 5 custom dialect):
  - 클로저 생성: 1 line (funlang.closure)
  - 클로저 호출: 1 line (funlang.apply)
- compileExpr 함수 변경점:
```fsharp
| Lambda(param, body) ->
    // Phase 5: use custom operation
    let callee = createLiftedFunction ...
    let capturedVals = freeVars |> List.map (fun v -> env.[v])
    funlangDialect.CreateClosure(callee, capturedVals)
```
- 코드 줄 수 비교 (60% 이상 감소)

**Section 8: Common Errors (100+ lines)**
- Error 1: Missing dialect registration
- Error 2: Wrong attribute type for callee (string vs SymbolRefAttr)
- Error 3: Type mismatch in variadic arguments
- Error 4: Forgetting to declare dependent dialects

**Summary Section:**
- Chapter 15에서 배운 것
- Chapter 16 preview (lowering passes)

Update tutorial/SUMMARY.md to include Chapter 15.

Use Korean plain style. Technical terms in English.
  </action>
  <verify>
```bash
# Check total line count
wc -l tutorial/15-custom-operations.md | grep -E "^1[5-9][0-9]{2}|^[2-9][0-9]{3}"

# Verify all three operations
grep -c "funlang.closure\|funlang.apply\|funlang.match" tutorial/15-custom-operations.md | grep -E "^[4-9][0-9]|^[0-9]{3}"

# Verify F# integration content
grep -c "DllImport\|extern\|P/Invoke\|FunLangDialect" tutorial/15-custom-operations.md | grep -E "^[2-9][0-9]|^[0-9]{3}"

# Verify refactoring section
grep -c "Phase 4\|Phase 5\|Before.*After\|Refactor" tutorial/15-custom-operations.md | grep -E "^[5-9]|^[0-9]{2}"

# Check SUMMARY.md updated
grep "15-custom-operations" tutorial/SUMMARY.md
```
  </verify>
  <done>
Chapter 15 complete with 1500+ lines. Contains: funlang.closure, funlang.apply, funlang.match operations with TableGen definitions, C API shims, F# P/Invoke bindings, complete F# wrapper module, refactoring examples, common errors. SUMMARY.md updated with Chapter 15 entry.
  </done>
</task>

</tasks>

<verification>
After all tasks:
```bash
# Verify chapter completeness
wc -l tutorial/15-custom-operations.md

# Check operation definitions
grep -c "def FunLang_.*Op" tutorial/15-custom-operations.md
grep -c "funlang\\.closure\|funlang\\.apply\|funlang\\.match" tutorial/15-custom-operations.md

# Check C API content
grep -c "extern.*C\|mlirFunLang" tutorial/15-custom-operations.md

# Check F# integration
grep -c "DllImport\|FunLangDialect\|P/Invoke" tutorial/15-custom-operations.md

# Verify Korean writing style
grep -c "~이다\|~한다\|~된다" tutorial/15-custom-operations.md | grep -E "^[5-9][0-9]|^[0-9]{3}"

# Verify SUMMARY.md has chapter 15
grep "15-custom-operations" tutorial/SUMMARY.md
```
</verification>

<success_criteria>
- Chapter 15 exists with 1500+ lines
- funlang.closure operation: TableGen + C API + F# binding
- funlang.apply operation: TableGen + C API + F# binding
- funlang.match operation: TableGen + C API (Phase 6 preview)
- Complete F# wrapper module (Mlir.FunLang)
- Refactoring examples showing Phase 4 vs Phase 5
- Common errors section present
- SUMMARY.md updated with Chapter 15 entry
- Korean plain style (~이다/~한다) throughout
</success_criteria>

<output>
After completion, create `.planning/phases/05-custom-mlir-dialect/05-02-SUMMARY.md`
</output>
