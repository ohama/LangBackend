---
phase: 01-foundation-interop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tutorial/00-prerequisites.md
  - tutorial/01-mlir-primer.md
autonomous: true

must_haves:
  truths:
    - "Reader knows exact LLVM 19.x build commands for their platform (Linux/macOS/Windows) to produce libMLIR-C shared library"
    - "Reader knows what .NET SDK version to install and how to verify F# toolchain works"
    - "Reader understands what a dialect is and can name examples (arith, func, llvm)"
    - "Reader understands operations, regions, blocks, and SSA form with concrete MLIR IR examples"
    - "Reader can mentally trace through a simple MLIR IR snippet identifying ops, blocks, and regions"
  artifacts:
    - path: "tutorial/00-prerequisites.md"
      provides: "LLVM/MLIR build guide and .NET setup instructions"
      contains: "DMLIR_BUILD_MLIR_C_DYLIB"
      min_lines: 150
    - path: "tutorial/01-mlir-primer.md"
      provides: "MLIR concept primer covering dialect, operation, region, block, SSA"
      contains: "SSA"
      min_lines: 200
  key_links:
    - from: "tutorial/00-prerequisites.md"
      to: "tutorial/01-mlir-primer.md"
      via: "Chapter navigation (next chapter link)"
      pattern: "01-mlir-primer"
---

<objective>
Write the first two tutorial chapters: Prerequisites (LLVM/MLIR build setup, .NET installation) and MLIR Primer (core concepts).

Purpose: These chapters establish the foundation for all subsequent chapters. Without a working MLIR build, nothing else can proceed. Without understanding MLIR concepts, the reader cannot follow any code chapter. These two chapters are independent of each other (one is practical setup, one is conceptual), so they belong together in a single plan.

Output: Two markdown chapter files in `tutorial/` — `00-prerequisites.md` and `01-mlir-primer.md`
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-interop/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Chapter 00 - Prerequisites</name>
  <files>tutorial/00-prerequisites.md</files>
  <action>
Write `tutorial/00-prerequisites.md` covering FOUND-01 (MLIR build setup).

**Chapter structure:**

1. **Introduction** (2-3 paragraphs)
   - What this tutorial series is about (MLIR-based compiler backend for FunLang)
   - What the reader needs before starting (FunLang from LangTutorial)
   - What this chapter covers (build LLVM/MLIR, install .NET, verify setup)

2. **System Requirements**
   - Disk space: ~30 GB for LLVM source + build
   - RAM: 16 GB recommended (8 GB minimum with ninja -j2)
   - Time: 30-60 minutes for MLIR build
   - Supported platforms: Linux (Ubuntu 22.04+), macOS (13+), Windows (with WSL2 recommended)

3. **Building LLVM/MLIR with C API**
   - Clone LLVM 19.x: `git clone --depth 1 --branch release/19.x https://github.com/llvm/llvm-project.git`
   - CMake configuration command with ALL required flags:
     ```
     cmake -S llvm -B build -G Ninja \
       -DCMAKE_BUILD_TYPE=Release \
       -DLLVM_ENABLE_PROJECTS=mlir \
       -DMLIR_BUILD_MLIR_C_DYLIB=ON \
       -DLLVM_TARGETS_TO_BUILD="X86;AArch64" \
       -DCMAKE_INSTALL_PREFIX=$HOME/mlir-install
     ```
   - Build and install: `cmake --build build --target install`
   - Explain each CMake flag (especially `-DMLIR_BUILD_MLIR_C_DYLIB=ON` which produces the shared C API library)
   - Platform-specific notes:
     - Linux: install prerequisites (`sudo apt install cmake ninja-build clang lld`)
     - macOS: Xcode Command Line Tools, Homebrew cmake/ninja
     - Windows: recommend WSL2 with Ubuntu; native MSVC build alternative
   - Verify build: `ls $HOME/mlir-install/lib/libMLIR-C*` should show shared library

4. **Installing .NET SDK**
   - Install .NET 8.0 SDK (LTS) or .NET 9.0
   - Verify: `dotnet --version`, `dotnet fsi --version`
   - Create test project: `dotnet new console -lang F# -o test-fsharp && cd test-fsharp && dotnet run`

5. **Setting Up Library Search Paths**
   - Linux: `export LD_LIBRARY_PATH=$HOME/mlir-install/lib:$LD_LIBRARY_PATH`
   - macOS: `export DYLD_LIBRARY_PATH=$HOME/mlir-install/lib:$DYLD_LIBRARY_PATH`
   - Windows/WSL2: same as Linux
   - Recommend adding to shell profile (~/.bashrc or ~/.zshrc)
   - Show how to verify: `ldconfig -p | grep MLIR` (Linux) or `ls $HOME/mlir-install/lib/libMLIR-C*`

6. **Troubleshooting Common Issues**
   - Out of memory during build: reduce parallelism (`ninja -j2`)
   - "MLIR-C library not found": library path not set correctly
   - CMake version too old: need 3.20+
   - Missing Ninja: install or use `-G "Unix Makefiles"` (slower)

7. **What We Built** (brief summary)
   - LLVM/MLIR installed at `$HOME/mlir-install`
   - `libMLIR-C.so` (or .dylib/.dll) available for P/Invoke from F#
   - .NET SDK ready for F# development
   - Next chapter: understanding MLIR concepts

**Writing style:**
- Direct, instructional tone ("Run this command", "You should see...")
- Every command should be copy-pasteable
- Include expected output after commands where appropriate
- Use callout blocks (> **Note:**) for platform-specific differences
- Do NOT include F# code yet — this chapter is purely about toolchain setup
  </action>
  <verify>
File exists at tutorial/00-prerequisites.md. Contains: cmake command with DMLIR_BUILD_MLIR_C_DYLIB, LD_LIBRARY_PATH instructions, dotnet commands, platform-specific sections for Linux/macOS/Windows. Minimum 150 lines.
  </verify>
  <done>
Reader has step-by-step instructions to build LLVM 19.x with MLIR C API shared library on Linux, macOS, or Windows, install .NET SDK, configure library search paths, and verify the setup works. Covers requirement FOUND-01.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write Chapter 01 - MLIR Primer</name>
  <files>tutorial/01-mlir-primer.md</files>
  <action>
Write `tutorial/01-mlir-primer.md` covering QUAL-03 (MLIR primer concepts).

**Chapter structure:**

1. **Introduction** (2-3 paragraphs)
   - Why MLIR matters for compiler developers (multi-level, reusable, pluggable)
   - How MLIR differs from LLVM IR (higher-level, custom dialects, progressive lowering)
   - What this chapter covers (the mental model needed before writing code)

2. **The MLIR IR Structure**
   - Show a complete, annotated MLIR IR example (a simple function that adds two integers):
     ```mlir
     module {
       func.func @add(%arg0: i32, %arg1: i32) -> i32 {
         %result = arith.addi %arg0, %arg1 : i32
         return %result : i32
       }
     }
     ```
   - Walk through every element: module, func.func, arguments, types, arith.addi operation, return

3. **Dialects**
   - What a dialect is (a namespace of operations, types, and attributes)
   - Built-in dialects we will use:
     - `arith`: arithmetic operations (addi, muli, cmpi, etc.)
     - `func`: function definitions and calls
     - `scf`: structured control flow (for, while, if)
     - `llvm`: LLVM dialect (lowering target)
   - Custom dialects: we will define a FunLang dialect in later chapters
   - Dialect naming: `dialect.operation` format (e.g., `arith.addi`, `func.func`)

4. **Operations**
   - An operation is the fundamental unit of MLIR IR
   - Anatomy of an operation: name, operands, results, attributes, regions, successors
   - Show textual format: `%result = arith.addi %a, %b : i32`
   - Explain: `%result` is the SSA value, `arith.addi` is the op, `%a, %b` are operands, `i32` is the type

5. **Regions and Blocks**
   - A region is a list of blocks; a block is a list of operations
   - Function bodies are regions with blocks
   - Block arguments replace phi nodes (explain this contrast with LLVM IR):
     ```mlir
     ^bb1(%val: i32):
       // block arguments instead of phi nodes
     ```
   - Show a control flow example with two blocks:
     ```mlir
     func.func @example(%cond: i1, %a: i32, %b: i32) -> i32 {
       cf.cond_br %cond, ^bb1(%a : i32), ^bb1(%b : i32)
     ^bb1(%result: i32):
       return %result : i32
     }
     ```
   - Explain how block arguments work (values passed at branch point)

6. **SSA Form (Static Single Assignment)**
   - Every value defined exactly once
   - Values are immutable after definition
   - How this maps to FunLang (let bindings are already single-assignment)
   - Contrast with mutable variables: SSA requires new names for each "version"
   - Show example: `let x = 1; let y = x + 2` maps to `%0 = arith.constant 1`, `%1 = arith.addi %0, ...`

7. **Types in MLIR**
   - Built-in types: i32, i64, f32, f64, index, memref
   - Function types: `(i32, i32) -> i32`
   - How FunLang types will map: Int -> i64, Bool -> i1, String -> memref
   - Type safety: MLIR verifier checks type consistency

8. **Progressive Lowering**
   - The key MLIR philosophy: lower in stages, not all at once
   - Our pipeline: FunLang AST -> (arith + func dialect) -> (LLVM dialect) -> LLVM IR -> native binary
   - Each lowering step is a pass that rewrites operations
   - Diagram (ASCII art or description): AST -> High-Level MLIR -> Low-Level MLIR -> LLVM IR -> Machine Code

9. **What is Next** (brief)
   - Now that we understand MLIR concepts, Chapter 02 will write our first F# program that creates MLIR IR
   - Link to next chapter

**Writing style:**
- Conceptual and explanatory, not code-heavy (this is a primer, not a coding chapter)
- Use concrete MLIR IR examples (not abstract descriptions)
- Every concept should have an IR snippet showing it
- Draw parallels to things FunLang readers know (ASTs, type systems, tree-walking evaluation)
- Explain how MLIR concepts map to FunLang compilation (preview, not full detail)
- Use > **Key Insight:** callouts for important realizations
- Do NOT include F# code — this chapter is purely about understanding MLIR IR
  </action>
  <verify>
File exists at tutorial/01-mlir-primer.md. Contains: "dialect", "operation", "region", "block", "SSA" as section headers or key terms. Has at least 3 MLIR IR code blocks. Contains explanation of progressive lowering. Minimum 200 lines.
  </verify>
  <done>
Reader understands the five core MLIR concepts (dialect, operation, region, block, SSA form), can read MLIR IR textual format, understands progressive lowering philosophy, and knows how FunLang concepts will map to MLIR. Covers requirement QUAL-03.
  </done>
</task>

</tasks>

<verification>
- [ ] `tutorial/00-prerequisites.md` exists with LLVM build instructions, .NET setup, library path config
- [ ] `tutorial/01-mlir-primer.md` exists with dialect/operation/region/block/SSA coverage
- [ ] Both chapters have navigation links (next chapter references)
- [ ] No F# code in either chapter (Chapter 00 is shell commands, Chapter 01 is MLIR IR examples)
- [ ] All MLIR IR examples are syntactically plausible (not fabricated syntax)
- [ ] Requirement FOUND-01 covered by Chapter 00
- [ ] Requirement QUAL-03 covered by Chapter 01
</verification>

<success_criteria>
1. Chapter 00 gives a reader everything needed to build LLVM/MLIR with C API on Linux, macOS, or Windows
2. Chapter 01 gives a reader the conceptual foundation to understand all subsequent coding chapters
3. Both chapters are self-contained, readable, and follow tutorial conventions (callouts, copy-pasteable commands, annotated examples)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-interop/01-01-SUMMARY.md`
</output>
