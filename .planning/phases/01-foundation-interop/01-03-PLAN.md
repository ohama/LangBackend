---
phase: 01-foundation-interop
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - tutorial/04-wrapper-layer.md
  - tutorial/05-arithmetic-compiler.md
  - tutorial/appendix-custom-dialect.md
autonomous: true

must_haves:
  truths:
    - "Reader has idiomatic F# wrapper types (Context, Module, Location, OpBuilder) that implement IDisposable and manage MLIR object lifetimes automatically"
    - "Reader can compile a trivial FunLang program (integer literal expression) to a native binary and execute it"
    - "Reader understands the full compilation pipeline: parse source -> build MLIR IR -> verify -> lower to LLVM dialect -> translate to LLVM IR -> emit object file -> link to native binary"
    - "Reader understands why custom MLIR dialect registration requires C++ and how the C API wrapper shim pattern works"
    - "Reader knows the ownership hierarchy (Context owns Module, Module owns Operations) and how F# wrappers enforce it"
  artifacts:
    - path: "tutorial/04-wrapper-layer.md"
      provides: "Idiomatic F# wrapper layer over raw P/Invoke bindings"
      contains: "IDisposable"
      min_lines: 200
    - path: "tutorial/05-arithmetic-compiler.md"
      provides: "Complete compiler driver compiling integer literals to native binary"
      contains: "native"
      min_lines: 250
    - path: "tutorial/appendix-custom-dialect.md"
      provides: "Custom MLIR dialect registration from C++ with F# consumption"
      contains: "funlangRegisterDialect"
      min_lines: 150
  key_links:
    - from: "tutorial/04-wrapper-layer.md"
      to: "tutorial/03-pinvoke-bindings.md"
      via: "Wraps raw MlirBindings with safe F# types"
      pattern: "MlirBindings|03-pinvoke"
    - from: "tutorial/05-arithmetic-compiler.md"
      to: "tutorial/04-wrapper-layer.md"
      via: "Uses wrapper types to build compiler"
      pattern: "Context|Module|04-wrapper"
    - from: "tutorial/05-arithmetic-compiler.md"
      to: "tutorial/01-mlir-primer.md"
      via: "References progressive lowering concept"
      pattern: "lowering|01-mlir-primer"
    - from: "tutorial/appendix-custom-dialect.md"
      to: "tutorial/04-wrapper-layer.md"
      via: "Shows P/Invoke consumption of custom dialect C API"
      pattern: "DllImport|P/Invoke"
---

<objective>
Write the final three chapters of Phase 1: the F# wrapper layer (Chapter 04), the arithmetic compiler that produces a native binary (Chapter 05), and the appendix on custom MLIR dialect registration from C++ (Appendix).

Purpose: Chapter 04 fulfills FOUND-03 (idiomatic F# wrappers). Chapter 05 fulfills FOUND-04 (compiler driver producing native binary) and is the culmination of Phase 1 — the reader compiles and runs actual code. The appendix fulfills FOUND-05 (custom dialect registration). Together these complete all Phase 1 requirements.

Output: Three markdown chapter files in `tutorial/` — `04-wrapper-layer.md`, `05-arithmetic-compiler.md`, and `appendix-custom-dialect.md`
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-interop/01-RESEARCH.md
@.planning/phases/01-foundation-interop/01-01-SUMMARY.md
@.planning/phases/01-foundation-interop/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Chapter 04 - F# Wrapper Layer</name>
  <files>tutorial/04-wrapper-layer.md</files>
  <action>
Write `tutorial/04-wrapper-layer.md` covering FOUND-03 (idiomatic F# wrapper layer over raw P/Invoke).

**Chapter structure:**

1. **Introduction** (2-3 paragraphs)
   - Problem: raw P/Invoke from Chapter 03 is verbose, unsafe, and leak-prone
   - Solution: wrap MLIR handles in F# types implementing IDisposable
   - Goal: create a safe, idiomatic API that tutorial code will use from now on

2. **The Ownership Problem**
   - MLIR has a strict ownership hierarchy:
     - Context is the root owner
     - Module belongs to a Context
     - Operations belong to Blocks, Blocks belong to Regions, Regions belong to Operations
   - In C++, ownership is automatic (unique_ptr-like). In P/Invoke, we must manage it manually
   - Show the bug: create Context, create Module, destroy Context first — Module handle is dangling
   - Solution: F# wrappers store parent references to prevent premature garbage collection

3. **Context Wrapper**
   - Full implementation with IDisposable:
     ```fsharp
     type Context() =
         let handle = MlirBindings.mlirContextCreate()
         let mutable disposed = false

         member _.Handle = handle

         member _.LoadDialect(name: string) =
             use strRef = MlirStringRef.FromString(name)
             MlirBindings.mlirContextGetOrLoadDialect(handle, strRef) |> ignore

         interface IDisposable with
             member this.Dispose() =
                 if not disposed then
                     MlirBindings.mlirContextDestroy(handle)
                     disposed <- true
     ```
   - Explain the `disposed` guard (prevent double-free)
   - Show usage with `use` keyword: `use ctx = new Context()`

4. **Location Wrapper**
   - Unknown location (simplest): `Location.Unknown(ctx)`
   - File/line/col location: `Location.FileLineCol(ctx, "file.fun", 1, 1)`
   - Locations do NOT own resources — they are lightweight value types
   - Explain: not every MLIR type needs IDisposable — only those that own native memory

5. **Module Wrapper**
   - Stores reference to Context (prevents Context GC before Module):
     ```fsharp
     type Module(context: Context, location: Location) =
         let handle = MlirBindings.mlirModuleCreateEmpty(location.Handle)
         let _contextRef = context  // prevent premature GC

         member _.Handle = handle
         member _.Body = MlirBindings.mlirModuleGetBody(handle)
         member _.Verify() = MlirBindings.mlirOperationVerify(MlirBindings.mlirModuleGetOperation(handle))
         member _.Print() = // ... use callback pattern from Ch 03
     ```

6. **OpBuilder: A Fluent API for Building IR**
   - This is the key ergonomic type — hides operation creation complexity:
     ```fsharp
     type OpBuilder(context: Context) =
         member _.CreateFunction(name, argTypes, retTypes, body) = ...
         member _.CreateArithConstant(value, type_) = ...
         member _.CreateReturn(values) = ...
         member _.CreateArithBinaryOp(opName, lhs, rhs) = ...
     ```
   - Each method wraps the verbose MlirOperationState pattern from Chapter 03
   - Show the contrast: 15 lines of raw P/Invoke vs. 1 line with OpBuilder
   - OpBuilder does NOT own operations — it is a utility, not a resource holder

7. **Type Helpers**
   - MLIRType module with convenience functions:
     ```fsharp
     module MLIRType =
         let i32 (ctx: Context) = MlirBindings.mlirIntegerTypeGet(ctx.Handle, 32u)
         let i64 (ctx: Context) = MlirBindings.mlirIntegerTypeGet(ctx.Handle, 64u)
         let i1 (ctx: Context) = MlirBindings.mlirIntegerTypeGet(ctx.Handle, 1u)
         let f64 (ctx: Context) = MlirBindings.mlirF64TypeGet(ctx.Handle)
         let functionType (ctx: Context) (inputs: MlirType[]) (outputs: MlirType[]) = ...
     ```

8. **Putting It All Together**
   - Rebuild the hello-mlir example using wrappers:
     ```fsharp
     use ctx = new Context()
     ctx.LoadDialect("arith")
     ctx.LoadDialect("func")

     use loc = Location.Unknown(ctx)
     use mlirMod = new Module(ctx, loc)

     let builder = OpBuilder(ctx)
     let i32Type = MLIRType.i32 ctx

     let funcOp = builder.CreateFunction("hello", [||], [| i32Type |], fun entry ->
         let constant = builder.CreateArithConstant(42, i32Type)
         builder.CreateReturn([| constant |])
     )

     mlirMod.AddOperation(funcOp)
     assert (mlirMod.Verify())
     mlirMod.Print()
     ```
   - Compare with raw P/Invoke version from Chapter 02 — dramatically shorter and safer

9. **Complete Wrapper Module Listing**
   - Full MlirWrapper.fs file organized by type: Context, Location, Module, OpBuilder, MLIRType
   - This file is used by all subsequent tutorial chapters

10. **What We Learned / What is Next**
    - We have a safe, idiomatic F# API over MLIR
    - Next chapter: use this API to build a real compiler that takes FunLang source and produces a native binary

**Writing style:**
- Motivate each wrapper by showing the raw P/Invoke pain point first, then the wrapper solution
- Emphasize ownership and lifetime management throughout
- Use > **Design Decision:** callouts explaining why we chose IDisposable over SafeHandle, why OpBuilder is not IDisposable, etc.
- Show before/after comparisons (raw vs. wrapped)
- End with complete MlirWrapper.fs listing
  </action>
  <verify>
File exists at tutorial/04-wrapper-layer.md. Contains: Context class implementing IDisposable, Module class with parent Context reference, OpBuilder with CreateFunction/CreateArithConstant methods, MLIRType convenience module, complete MlirWrapper.fs listing. Minimum 200 lines.
  </verify>
  <done>
Reader has idiomatic F# wrapper types (Context, Module, Location, OpBuilder, MLIRType) implementing IDisposable with proper lifetime management, and understands the ownership hierarchy that prevents use-after-free bugs. Covers requirement FOUND-03.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write Chapter 05 - Arithmetic Compiler</name>
  <files>tutorial/05-arithmetic-compiler.md</files>
  <action>
Write `tutorial/05-arithmetic-compiler.md` covering FOUND-04 (basic compiler driver) — the culmination of Phase 1.

**Chapter structure:**

1. **Introduction** (2-3 paragraphs)
   - The payoff chapter: we compile a FunLang program and run it as a native binary
   - Scope: compile a single integer literal expression (e.g., `42`) to a native executable
   - This validates the entire pipeline: source -> MLIR IR -> LLVM dialect -> LLVM IR -> object file -> native binary

2. **The FunLang Subset**
   - For Phase 1, we only support one thing: integer literal expressions
   - Input: `42` (a FunLang program that evaluates to 42)
   - Output: a native binary that exits with code 42 (or prints 42)
   - Show the (trivial) AST: `Expr.IntLit 42`
   - Explain: we hard-code the parser for now; a real parser comes from LangTutorial

3. **Compiler Pipeline Overview**
   - Diagram/description of the full pipeline:
     1. Parse source to AST (trivial for integer literals)
     2. Build MLIR IR using arith + func dialects
     3. Verify the MLIR IR
     4. Lower arith + func dialects to LLVM dialect
     5. Translate LLVM dialect to LLVM IR
     6. Emit object file from LLVM IR
     7. Link object file to native binary using system linker (cc/clang)
   - Each step maps to specific MLIR-C API calls

4. **Step 1: AST Definition and Parsing**
   - Trivial AST type:
     ```fsharp
     type Expr =
         | IntLit of int
     ```
   - Trivial parser: `let parse (source: string) = Expr.IntLit (int source)`
   - Explain: this grows significantly in Phase 2+; for now, it validates the pipeline

5. **Step 2: AST to MLIR Translation**
   - Create a `main` function in MLIR that returns the integer:
     ```fsharp
     let translateToMlir (ctx: Context) (expr: Expr) =
         use loc = Location.Unknown(ctx)
         use mlirMod = new Module(ctx, loc)
         let builder = OpBuilder(ctx)

         match expr with
         | IntLit n ->
             let i64Type = MLIRType.i64 ctx
             let mainFunc = builder.CreateFunction("main", [||], [| i64Type |], fun entry ->
                 let constant = builder.CreateArithConstant(n, i64Type)
                 builder.CreateReturn([| constant |])
             )
             mlirMod.AddOperation(mainFunc)

         mlirMod
     ```
   - Show the generated MLIR IR:
     ```mlir
     module {
       func.func @main() -> i64 {
         %0 = arith.constant 42 : i64
         return %0 : i64
       }
     }
     ```

6. **Step 3: MLIR Verification**
   - Call verify, handle failure with meaningful error message
   - Show what a verification error looks like

7. **Step 4: Lowering to LLVM Dialect**
   - Register LLVM dialect pass pipeline
   - Key P/Invoke functions for pass management:
     - mlirPassManagerCreate, mlirPassManagerAddOwnedPass
     - mlirCreateConversionConvertArithToLLVMPass
     - mlirCreateConversionConvertFuncToLLVMPass
     - mlirPassManagerRunOnOp
   - Show the lowered IR (now using llvm.func, llvm.return, llvm.mlir.constant)
   - Explain what lowering means: replacing high-level ops with LLVM dialect equivalents

8. **Step 5: LLVM IR Translation**
   - Key P/Invoke function: mlirTranslateModuleToLLVMIR
   - This converts MLIR LLVM dialect to actual LLVM IR string
   - Show expected LLVM IR output:
     ```llvm
     define i64 @main() {
       ret i64 42
     }
     ```

9. **Step 6: Emit Object File**
   - Use LLVM target machine API (via MLIR-C or LLVM-C):
     - LLVMInitializeX86Target, LLVMCreateTargetMachine, etc.
   - Or simpler approach: write LLVM IR to file and use `llc` command-line tool
   - Show both approaches and recommend the simpler one for tutorial:
     ```bash
     # Write LLVM IR to file
     dotnet run > output.ll
     # Compile to object file
     llc -filetype=obj output.ll -o output.o
     # Link to executable
     cc output.o -o hello-funlang
     # Run!
     ./hello-funlang; echo $?  # prints 42
     ```

10. **Step 7: The Complete Compiler Driver**
    - Full `Compiler.fs` that ties everything together:
      ```fsharp
      module FunLang.Compiler

      let compile (source: string) (outputPath: string) =
          // 1. Parse
          let ast = parse source
          // 2. Translate to MLIR
          use ctx = new Context()
          ctx.LoadDialect("arith")
          ctx.LoadDialect("func")
          ctx.LoadDialect("llvm")
          let mlirMod = translateToMlir ctx ast
          // 3. Verify
          if not (mlirMod.Verify()) then failwith "Verification failed"
          // 4. Lower
          lower mlirMod
          // 5. Translate to LLVM IR
          let llvmIR = translateToLLVMIR mlirMod
          // 6. Write and compile
          File.WriteAllText(outputPath + ".ll", llvmIR)
          // 7. Invoke llc and linker
          runCommand $"llc -filetype=obj {outputPath}.ll -o {outputPath}.o"
          runCommand $"cc {outputPath}.o -o {outputPath}"
      ```

11. **Running It**
    - Step-by-step: `dotnet run -- "42" output`
    - Run the output: `./output` then `echo $?` shows 42
    - Try different values: `dotnet run -- "99" output` then `./output; echo $?` shows 99
    - Celebrate: we have a working compiler!

12. **What We Built**
    - Recap the full pipeline
    - What works: integer literals compiled to native binary
    - What is next (Phase 2): arithmetic expressions, let bindings, if/else
    - Reference the roadmap for the full journey ahead

**Writing style:**
- Build excitement — this is the payoff chapter
- Show each pipeline step separately with intermediate output (MLIR IR, LLVM IR, etc.)
- Use > **Milestone:** callouts when something works for the first time
- Be practical about the object file / linking step (use llc + cc, not complex LLVM API)
- Include complete Program.fs / Compiler.fs at the end
- Show terminal output of compiling and running
  </action>
  <verify>
File exists at tutorial/05-arithmetic-compiler.md. Contains: AST type definition, translateToMlir function, MLIR lowering pass invocation, LLVM IR translation, object file emission (via llc or API), linking step, complete compiler driver code, terminal output showing compilation and execution. Minimum 250 lines.
  </verify>
  <done>
Reader can compile a trivial FunLang program (integer literal) through the full pipeline (AST -> MLIR -> LLVM dialect -> LLVM IR -> object file -> native binary) and execute the resulting binary. Covers requirement FOUND-04.
  </done>
</task>

<task type="auto">
  <name>Task 3: Write Appendix - Custom MLIR Dialect Registration</name>
  <files>tutorial/appendix-custom-dialect.md</files>
  <action>
Write `tutorial/appendix-custom-dialect.md` covering FOUND-05 (custom MLIR dialect registration from F# via C API).

**Chapter structure:**

1. **Introduction** (2-3 paragraphs)
   - Why custom dialects matter: model FunLang semantics at the MLIR level (funlang.closure, funlang.apply, funlang.match)
   - The challenge: MLIR C API does NOT support custom dialect registration directly
   - Solution: write a small C++ library with C API shim, call from F# via P/Invoke
   - This appendix previews what we build fully in Phase 5

2. **Why the C API Cannot Register Custom Dialects**
   - MLIR's `mlirContextGetOrLoadDialect` only loads already-registered (built-in) dialects
   - Custom dialect definition requires: subclassing `mlir::Dialect`, defining operations (ODS/TableGen or manual C++)
   - The C API has no mechanism to pass C++ class definitions through a C interface
   - Reference: MLIR Discourse thread confirming this limitation
   - Explain: this is a fundamental FFI boundary — not a bug, but a design boundary

3. **The C++ Wrapper Approach**
   - Architecture diagram:
     ```
     F# Code  --(P/Invoke)-->  C API Shim (.so/.dll)  --(C++)-->  MLIR C++ API
     ```
   - Create a small C++ file that:
     1. Defines a minimal FunLang dialect class
     2. Registers it with a context
     3. Exports a C function for F# to call

4. **Minimal Custom Dialect in C++**
   - Show the C++ code (`funlang_dialect.cpp`):
     ```cpp
     #include "mlir/IR/Dialect.h"
     #include "mlir/IR/MLIRContext.h"
     #include "mlir-c/IR.h"
     #include "mlir/CAPI/IR.h"  // for unwrap()

     namespace funlang {
     class FunLangDialect : public mlir::Dialect {
     public:
         explicit FunLangDialect(mlir::MLIRContext *context)
             : mlir::Dialect("funlang", context, mlir::TypeID::get<FunLangDialect>()) {}

         static llvm::StringRef getDialectNamespace() { return "funlang"; }
     };
     }

     // C API shim
     extern "C" {
         void funlangRegisterDialect(MlirContext ctx) {
             mlir::DialectRegistry registry;
             registry.insert<funlang::FunLangDialect>();
             unwrap(ctx)->appendDialectRegistry(registry);
         }

         MlirDialect funlangLoadDialect(MlirContext ctx) {
             auto *dialect = unwrap(ctx)->getOrLoadDialect("funlang");
             return wrap(dialect);
         }
     }
     ```
   - Explain every line — readers may not know C++ well
   - Explain `unwrap()`/`wrap()` — MLIR's C API helper macros that convert between C handles and C++ pointers

5. **Building the C++ Library**
   - CMakeLists.txt for the dialect library:
     ```cmake
     cmake_minimum_required(VERSION 3.20)
     project(FunLangDialect)

     find_package(MLIR REQUIRED CONFIG)
     include(AddLLVM)

     add_library(FunLangDialect SHARED funlang_dialect.cpp)
     target_link_libraries(FunLangDialect PRIVATE MLIRIR MLIRSupport)
     ```
   - Build: `cmake -B build -DMLIR_DIR=$HOME/mlir-install/lib/cmake/mlir && cmake --build build`
   - Output: `libFunLangDialect.so` (Linux), `libFunLangDialect.dylib` (macOS), `FunLangDialect.dll` (Windows)

6. **Consuming from F#**
   - Add P/Invoke declaration:
     ```fsharp
     [<DllImport("FunLangDialect", CallingConvention = CallingConvention.Cdecl)>]
     extern void funlangRegisterDialect(MlirContext ctx)

     [<DllImport("FunLangDialect", CallingConvention = CallingConvention.Cdecl)>]
     extern MlirDialect funlangLoadDialect(MlirContext ctx)
     ```
   - Usage:
     ```fsharp
     use ctx = new Context()
     funlangRegisterDialect(ctx.Handle)
     let dialect = funlangLoadDialect(ctx.Handle)
     printfn "FunLang dialect loaded: %A" dialect
     ```
   - Verify the dialect is registered by checking the dialect name

7. **Adding Custom Operations (Preview)**
   - Brief preview of how to add operations (e.g., `funlang.constant`) — covered fully in Phase 5
   - Show the pattern: ODS TableGen definition OR manual C++ operation class
   - Emphasize: this is a preview — Phase 5 develops the full FunLang dialect

8. **When to Use Custom Dialects vs. Built-In**
   - Built-in dialects (arith, func, scf) cover most needs for Phases 1-4
   - Custom dialect adds value when:
     - Modeling domain-specific semantics (closure creation, pattern match, type tags)
     - Enabling domain-specific optimizations (closure inlining, pattern match simplification)
     - Improving IR readability (`funlang.apply` vs. series of memref/call operations)
   - Our tutorial uses built-in dialects first, introduces custom dialect in Phase 5

9. **Summary**
   - Custom dialects require a C++ bridge — this is a fundamental MLIR architecture boundary
   - The pattern (C++ library with C API shim consumed via P/Invoke) is clean and maintainable
   - Phase 5 will build this out fully with proper operations, types, and lowering passes
   - For Phases 1-4, built-in dialects are sufficient

**Writing style:**
- This is an appendix — can be more reference-heavy and less narrative than main chapters
- Clearly mark what is "preview" vs. "complete" (this is a preview; Phase 5 is complete)
- Explain C++ code line-by-line for readers unfamiliar with C++
- Use > **Architecture Note:** callouts for design decisions
- Be honest about the complexity — this is the hardest part of the F#/MLIR interop story
  </action>
  <verify>
File exists at tutorial/appendix-custom-dialect.md. Contains: C++ FunLangDialect class definition, funlangRegisterDialect C API shim with extern "C", CMakeLists.txt for building, F# P/Invoke declaration for funlangRegisterDialect, explanation of why C API cannot register custom dialects. Minimum 150 lines.
  </verify>
  <done>
Reader understands why custom MLIR dialect registration requires C++, can build a minimal C++ dialect library with C API shim, and can call it from F# via P/Invoke. Covers requirement FOUND-05.
  </done>
</task>

</tasks>

<verification>
- [ ] `tutorial/04-wrapper-layer.md` exists with Context, Module, OpBuilder IDisposable wrappers
- [ ] `tutorial/05-arithmetic-compiler.md` exists with full pipeline from AST to native binary
- [ ] `tutorial/appendix-custom-dialect.md` exists with C++ dialect and C API shim
- [ ] Chapter 05 shows reader compiling and running a native binary
- [ ] Appendix explains the C API limitation and the C++ wrapper solution
- [ ] All three chapters reference prior chapters appropriately
- [ ] Requirements FOUND-03, FOUND-04, FOUND-05 fully covered
- [ ] All six Phase 1 requirements covered across Plans 01-03
</verification>

<success_criteria>
1. Reader has safe F# wrappers (Context, Module, OpBuilder) with automatic resource management
2. Reader can compile `42` to a native binary and run it, seeing exit code 42
3. Reader understands the custom dialect C++ bridge pattern for future use in Phase 5
4. Phase 1 is complete: all 6 requirements (FOUND-01 through FOUND-05, QUAL-03) delivered
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-interop/01-03-SUMMARY.md`
</output>
