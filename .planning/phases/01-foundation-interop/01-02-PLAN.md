---
phase: 01-foundation-interop
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - tutorial/02-hello-mlir.md
  - tutorial/03-pinvoke-bindings.md
autonomous: true

must_haves:
  truths:
    - "Reader can write an F# program that creates an MLIR context, builds a simple module with arith operations, and prints the IR"
    - "Reader understands DllImport syntax for MLIR-C API functions with correct CallingConvention and struct handle types"
    - "Reader has a complete set of P/Invoke bindings for context, module, location, type, operation, region, and block creation"
    - "Reader understands cross-platform library naming (no extension in DllImport, platform-specific library paths)"
  artifacts:
    - path: "tutorial/02-hello-mlir.md"
      provides: "First F# program creating MLIR IR via P/Invoke"
      contains: "DllImport"
      min_lines: 200
    - path: "tutorial/03-pinvoke-bindings.md"
      provides: "Complete P/Invoke binding layer for MLIR-C API"
      contains: "CallingConvention.Cdecl"
      min_lines: 250
  key_links:
    - from: "tutorial/02-hello-mlir.md"
      to: "tutorial/01-mlir-primer.md"
      via: "References MLIR concepts from primer"
      pattern: "Chapter 1|01-mlir-primer"
    - from: "tutorial/03-pinvoke-bindings.md"
      to: "tutorial/02-hello-mlir.md"
      via: "Extends hello-mlir bindings into organized module"
      pattern: "Chapter 2|02-hello-mlir"
    - from: "tutorial/02-hello-mlir.md"
      to: "tutorial/00-prerequisites.md"
      via: "References build output from prerequisites"
      pattern: "Chapter 0|00-prerequisites"
---

<objective>
Write tutorial chapters 02 (Hello MLIR) and 03 (P/Invoke Bindings) — the reader's first hands-on F# code interacting with MLIR-C API.

Purpose: Chapter 02 is the reader's first "it works!" moment — calling MLIR from F#. Chapter 03 systematizes those ad-hoc bindings into a proper binding module. These two chapters build on each other directly and together cover requirement FOUND-02 (F# P/Invoke bindings to MLIR-C API with working examples).

Output: Two markdown chapter files in `tutorial/` — `02-hello-mlir.md` and `03-pinvoke-bindings.md`
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-interop/01-RESEARCH.md
@.planning/phases/01-foundation-interop/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Chapter 02 - Hello MLIR from F#</name>
  <files>tutorial/02-hello-mlir.md</files>
  <action>
Write `tutorial/02-hello-mlir.md` — the reader's first F# program that creates MLIR IR.

**Chapter structure:**

1. **Introduction** (2-3 paragraphs)
   - Goal: write an F# script that creates a simple MLIR module with one function
   - This is the "hello world" of MLIR from F# — proving the toolchain works end-to-end
   - We will use P/Invoke (DllImport) to call MLIR-C API functions directly

2. **Creating an F# Script Project**
   - Create a new directory and F# script file: `HelloMlir.fsx`
   - Explain .fsx (F# script) vs .fs (compiled) — scripts are better for exploration
   - Show project structure:
     ```
     hello-mlir/
     └── HelloMlir.fsx
     ```

3. **First P/Invoke: Creating an MLIR Context**
   - Introduce the DllImport attribute and how it maps to native C functions
   - Define the MlirContext struct handle type:
     ```fsharp
     [<Struct>]
     type MlirContext =
         val mutable ptr: nativeint
     ```
   - Declare `mlirContextCreate` and `mlirContextDestroy` externs
   - Explain: `CallingConvention.Cdecl` (C calling convention), library name `"MLIR-C"` without extension
   - Write a minimal script that creates and destroys a context:
     ```fsharp
     let ctx = mlirContextCreate()
     printfn "MLIR Context created: %A" ctx.ptr
     mlirContextDestroy(ctx)
     printfn "Context destroyed"
     ```
   - Show how to run: `dotnet fsi HelloMlir.fsx`
   - Show expected output

4. **Building a Simple MLIR Module**
   - Add more P/Invoke declarations: MlirLocation, MlirModule, mlirLocationUnknownGet, mlirModuleCreateEmpty
   - Create an empty module:
     ```fsharp
     let loc = mlirLocationUnknownGet(ctx)
     let mlirMod = mlirModuleCreateEmpty(loc)
     ```
   - Add MlirStringRef struct and mlirOperationDump to print the module
   - Show empty module output: `module { }`

5. **Adding an Operation: Integer Constant**
   - Load the arith dialect: `mlirContextGetOrLoadDialect(ctx, ...)`
   - Explain MlirStringRef (MLIR's string passing convention — pointer + length, NOT null-terminated)
   - Create arith.constant operation producing an i32 value
   - Show the P/Invoke declarations needed: mlirIntegerTypeGet, mlirAttributeParseGet, mlirOperationCreate (or mlirOperationStateGet + mlirOperationStateAddResults pattern)
   - Walk through operation creation step by step with explanations
   - Print resulting IR

6. **Building a Complete Function**
   - Load the func dialect
   - Create a func.func operation with a body region and entry block
   - Add the arith.constant inside the function body
   - Add a return operation
   - Print the complete module — should look like:
     ```mlir
     module {
       func.func @hello() -> i32 {
         %0 = arith.constant 42 : i32
         return %0 : i32
       }
     }
     ```

7. **Verifying the IR**
   - Call `mlirOperationVerify()` on the module operation
   - Show what happens with valid IR (returns true)
   - Intentionally create invalid IR (e.g., missing return) and show verification failure
   - Explain: always verify after building IR — catches errors early

8. **Cleanup and Resource Management**
   - Show proper cleanup order (module before context)
   - Foreshadow: Chapter 04 will wrap this in IDisposable for safety
   - Current code is fragile — if exception occurs, resources leak

9. **Complete Listing**
   - Full, copy-pasteable HelloMlir.fsx script
   - Expected output when run

10. **What We Learned / What is Next**
    - We proved F# can talk to MLIR-C via P/Invoke
    - The raw API is verbose — Chapter 03 will organize bindings properly
    - Link to next chapter

**Writing style:**
- Hands-on, incremental — build the script piece by piece, running after each addition
- Show expected output after each `dotnet fsi` run
- Explain every P/Invoke declaration the first time it appears
- Use > **Warning:** callouts for common mistakes (wrong CallingConvention, missing dialect load)
- Include > **How it works:** callouts explaining what the MLIR-C API does internally
- End with complete listing so reader has a single reference
  </action>
  <verify>
File exists at tutorial/02-hello-mlir.md. Contains: DllImport declarations, MlirContext struct, mlirContextCreate, mlirContextDestroy, a complete F# script that creates a module with func.func and arith.constant, expected MLIR IR output, verification example. Minimum 200 lines.
  </verify>
  <done>
Reader can write and run an F# script that creates an MLIR context, loads arith and func dialects, builds a simple function returning an integer constant, verifies the IR, and prints it. Covers requirement FOUND-02 (partial — working examples).
  </done>
</task>

<task type="auto">
  <name>Task 2: Write Chapter 03 - P/Invoke Bindings</name>
  <files>tutorial/03-pinvoke-bindings.md</files>
  <action>
Write `tutorial/03-pinvoke-bindings.md` — systematizing MLIR-C bindings into a proper F# module.

**Chapter structure:**

1. **Introduction** (2-3 paragraphs)
   - Chapter 02 proved P/Invoke works, but the declarations were ad-hoc in a script
   - This chapter organizes bindings into a reusable F# module (`MlirBindings.fs`)
   - We will cover all MLIR-C API areas needed for our compiler: context, module, types, operations, regions, blocks, locations, attributes, string handling

2. **Project Structure**
   - Move from .fsx script to F# project:
     ```
     funlang-compiler/
     ├── FunLangCompiler.fsproj
     └── MlirBindings.fs
     ```
   - Show the .fsproj file contents (reference to System.Runtime.InteropServices)
   - Explain: compiled project gives us proper modules, type checking, and IntelliSense

3. **Handle Types**
   - Define ALL handle types as value structs with a single `nativeint` field:
     - MlirContext, MlirModule, MlirOperation, MlirBlock, MlirRegion
     - MlirType, MlirAttribute, MlirLocation, MlirValue
     - MlirIdentifier, MlirStringRef, MlirLogicalResult
   - Explain why structs (not classes): C API passes these by value, not by pointer
   - Explain MlirStringRef specially: it has TWO fields (data: nativeint, length: nativeint) — this is MLIR's string convention
   - Show helper to create MlirStringRef from F# string:
     ```fsharp
     let toStringRef (s: string) : MlirStringRef =
         let bytes = System.Text.Encoding.UTF8.GetBytes(s)
         // Pin and pass pointer + length
     ```
   - Discuss the pinning/marshalling approach for string references

4. **Context and Module Bindings**
   - Group related functions:
     ```fsharp
     module MlirBindings =
         // Context
         [<DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)>]
         extern MlirContext mlirContextCreate()

         [<DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)>]
         extern void mlirContextDestroy(MlirContext ctx)

         [<DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)>]
         extern MlirDialect mlirContextGetOrLoadDialect(MlirContext ctx, MlirStringRef name)
     ```
   - Cover: create, destroy, getOrLoadDialect for context
   - Cover: createEmpty, destroy, getOperation, getBody for module

5. **Type Bindings**
   - Integer types: mlirIntegerTypeGet, mlirIntegerTypeGetWidth
   - Float types: mlirF32TypeGet, mlirF64TypeGet
   - Function types: mlirFunctionTypeGet (takes input types array, output types array)
   - Index type: mlirIndexTypeGet
   - NoneType: mlirNoneTypeGet
   - Show how F# arrays of MlirType are marshalled to C arrays (using fixed/pinned pointers)

6. **Operation Bindings**
   - The operation creation pattern (this is the most complex part):
     - MlirOperationState: initialize with operation name
     - Add operands, results, attributes, regions, successors
     - Create operation from state
   - Show the full pattern:
     ```fsharp
     extern MlirOperationState mlirOperationStateGet(MlirStringRef name, MlirLocation loc)
     extern void mlirOperationStateAddResults(MlirOperationState& state, nativeint n, MlirType[] results)
     extern void mlirOperationStateAddOperands(MlirOperationState& state, nativeint n, MlirValue[] operands)
     extern void mlirOperationStateAddAttributes(MlirOperationState& state, nativeint n, MlirNamedAttribute[] attrs)
     extern void mlirOperationStateAddOwnedRegions(MlirOperationState& state, nativeint n, MlirRegion[] regions)
     extern MlirOperation mlirOperationCreate(MlirOperationState& state)
     ```
   - Operation inspection: mlirOperationGetResult, mlirOperationVerify, mlirOperationDump

7. **Region and Block Bindings**
   - Region: mlirRegionCreate, mlirRegionDestroy, mlirRegionAppendOwnedBlock
   - Block: mlirBlockCreate, mlirBlockDestroy, mlirBlockAppendOwnedOperation, mlirBlockGetArgument, mlirBlockAddArgument
   - Explain ownership model: regions own blocks, blocks own operations

8. **Location and Attribute Bindings**
   - Location: mlirLocationUnknownGet, mlirLocationFileLineColGet
   - Named attributes: mlirNamedAttributeGet, with mlirIdentifierGet for names
   - Common attributes: mlirIntegerAttrGet, mlirStringAttrGet, mlirTypeAttrGet, mlirFlatSymbolRefAttrGet
   - Attribute parsing: mlirAttributeParseGet (parse attribute from string — useful for complex attributes)

9. **Printing and Verification**
   - mlirOperationPrint with callback pattern (MLIR uses function pointer callbacks for printing)
   - Show how to implement the callback in F#:
     ```fsharp
     type MlirStringCallback = delegate of MlirStringRef * nativeint -> unit

     [<DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)>]
     extern void mlirOperationPrint(MlirOperation op, MlirStringCallback callback, nativeint userData)
     ```
   - Helper function to print to F# string
   - mlirOperationVerify for IR validation

10. **Cross-Platform Considerations**
    - Library naming: use `"MLIR-C"` without extension — runtime adds .so/.dylib/.dll
    - NativeLibrary.SetDllImportResolver for custom library paths (advanced)
    - Struct layout: `[<StructLayout(LayoutKind.Sequential)>]` ensures C-compatible layout

11. **Testing the Bindings**
    - Recreate the HelloMlir example using the organized bindings module
    - Show it produces identical output
    - Prove the module compiles: `dotnet build`

12. **Complete Bindings Reference**
    - Full MlirBindings.fs file listing organized by category
    - This becomes the reference file for all subsequent chapters

13. **What We Learned / What is Next**
    - We have a complete, organized P/Invoke binding layer
    - Raw API is still verbose and unsafe (manual cleanup, raw pointers)
    - Chapter 04 will wrap these in idiomatic F# types with automatic resource management

**Writing style:**
- Reference-oriented with teaching — explain the pattern once, then show all declarations
- Group functions by MLIR concept (context, types, operations, etc.)
- Use > **MLIR C API Pattern:** callouts to explain recurring patterns (e.g., state-based operation creation)
- Warn about: struct by-value passing, string marshalling, array pinning
- Include complete MlirBindings.fs at end as full reference
  </action>
  <verify>
File exists at tutorial/03-pinvoke-bindings.md. Contains: organized MlirBindings module with DllImport declarations for context, module, type, operation, region, block, location, and attribute functions. Contains MlirStringRef with two fields. Contains MlirStringCallback delegate. Contains cross-platform discussion. Complete MlirBindings.fs listing at end. Minimum 250 lines.
  </verify>
  <done>
Reader has a complete, organized F# P/Invoke binding module covering all MLIR-C API areas needed for the compiler. Reader understands handle types, string marshalling, operation creation pattern, and cross-platform library loading. Covers requirement FOUND-02 (complete — F# P/Invoke bindings with working examples).
  </done>
</task>

</tasks>

<verification>
- [ ] `tutorial/02-hello-mlir.md` exists with runnable F# script producing MLIR IR
- [ ] `tutorial/03-pinvoke-bindings.md` exists with complete organized binding module
- [ ] Chapter 02 builds incrementally (each step produces runnable code)
- [ ] Chapter 03 contains full MlirBindings.fs listing
- [ ] Both chapters reference prior chapters appropriately
- [ ] Code snippets use correct F# syntax and plausible MLIR-C API function names
- [ ] Requirement FOUND-02 fully covered across both chapters
</verification>

<success_criteria>
1. A reader following Chapter 02 can create and run their first F# script that produces MLIR IR output
2. A reader following Chapter 03 has a reusable MlirBindings.fs module they can compile and use in subsequent chapters
3. Both chapters teach the P/Invoke mechanics (DllImport, struct handles, string marshalling, callbacks) thoroughly
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-interop/01-02-SUMMARY.md`
</output>
