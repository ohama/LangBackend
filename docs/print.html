<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>LangBackend Tutorial</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="MLIR 기반 FunLang 컴파일러 백엔드 튜토리얼">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-2a27a2f4.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-d20149da.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">LangBackend Tutorial</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/ohama/LangBackend" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="langbackend-tutorial"><a class="header" href="#langbackend-tutorial">LangBackend Tutorial</a></h1>
<p>MLIR 기반 FunLang 컴파일러 백엔드 튜토리얼입니다.</p>
<p>FunLang의 Typed AST를 MLIR을 거쳐 네이티브 바이너리로 컴파일하는 과정을 단계별로 다룹니다. 각 챕터마다 그때까지 다룬 기능이 모두 동작하는 컴파일러를 만들 수 있습니다.</p>
<h2 id="시작하기"><a class="header" href="#시작하기">시작하기</a></h2>
<p><a href="#chapter-00-사전-준비">Chapter 00: 사전 준비</a>부터 시작하세요.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-00-사전-준비"><a class="header" href="#chapter-00-사전-준비">Chapter 00: 사전 준비</a></h1>
<h2 id="소개"><a class="header" href="#소개">소개</a></h2>
<p>LangBackend 튜토리얼 시리즈에 오신 것을 환영한다. 여러분은 LangTutorial을 완료하고 완전히 동작하는 FunLang 인터프리터를 구축했기 때문에 이 튜토리얼을 시작하게 되었을 것이다. 이미 파서, Hindley-Milner 타입 추론을 갖춘 타입 체커, 그리고 트리 워킹 평가기를 갖추고 있다. 이제 FunLang을 다음 단계로 끌어올릴 차례다: 네이티브 머신 코드로 컴파일하는 것이다.</p>
<p>이 튜토리얼 시리즈에서는 타입이 지정된 FunLang AST를 실행 가능한 바이너리로 변환하는 MLIR 기반 컴파일러 백엔드를 구축하는 방법을 배운다. MLIR(Multi-Level Intermediate Representation)은 LLVM 프로젝트에서 제공하는 현대적인 컴파일러 프레임워크로, 구조화된 IR 연산, 타입 안전성, 플러그인 가능한 dialect, 그리고 고수준 의미론에서 머신 코드까지의 점진적 lowering 등 필요한 인프라를 제공한다.</p>
<p>이 장에서는 필수 사전 준비 설정을 다룬다: C API를 활성화하여 LLVM/MLIR을 소스에서 빌드하고, F# 개발을 위한 .NET SDK를 설치하며, 두 시스템이 통신할 수 있도록 환경을 구성하는 것이다. 이러한 기초가 없으면 나머지 튜토리얼을 진행할 수 없다.</p>
<h2 id="시스템-요구-사항"><a class="header" href="#시스템-요구-사항">시스템 요구 사항</a></h2>
<p>시작하기 전에 시스템이 다음 요구 사항을 충족하는지 확인한다:</p>
<ul>
<li><strong>디스크 공간:</strong> ~30 GB (LLVM 소스 + 빌드 산출물 + 설치)</li>
<li><strong>RAM:</strong> 16 GB 권장 (빌드 병렬 처리를 줄이면 최소 8 GB)</li>
<li><strong>빌드 시간:</strong> 최신 하드웨어 기준 30-60분 (4코어 이상, SSD)</li>
<li><strong>지원 플랫폼:</strong>
<ul>
<li>Linux (Ubuntu 22.04+, Fedora 38+ 또는 이에 상응하는 배포판)</li>
<li>macOS (13 Ventura 이상, Intel 및 Apple Silicon 모두 지원)</li>
<li>Windows (Ubuntu 22.04+가 설치된 WSL2 권장; 네이티브 MSVC 빌드도 가능하지만 이 튜토리얼에서는 다루지 않는다)</li>
</ul>
</li>
</ul>
<h2 id="c-api를-포함한-llvmmlir-빌드"><a class="header" href="#c-api를-포함한-llvmmlir-빌드">C API를 포함한 LLVM/MLIR 빌드</a></h2>
<p>MLIR은 LLVM 프로젝트의 일부이다. MLIR 팀은 F#과 같은 비-C++ 언어가 MLIR 인프라와 상호작용할 수 있도록 안정적인 C API를 제공한다. 이 C API는 기본적으로 빌드되지 않으므로 CMake 구성 단계에서 명시적으로 활성화해야 한다.</p>
<h3 id="빌드-의존성-설치"><a class="header" href="#빌드-의존성-설치">빌드 의존성 설치</a></h3>
<h4 id="linux-ubuntudebian"><a class="header" href="#linux-ubuntudebian">Linux (Ubuntu/Debian)</a></h4>
<pre><code class="language-bash">sudo apt update
sudo apt install -y \
  build-essential \
  cmake \
  ninja-build \
  clang \
  lld \
  python3 \
  git
</code></pre>
<h4 id="macos"><a class="header" href="#macos">macOS</a></h4>
<p>먼저 Xcode Command Line Tools가 설치되어 있지 않다면 설치한다:</p>
<pre><code class="language-bash">xcode-select --install
</code></pre>
<p>그런 다음 Homebrew를 통해 CMake와 Ninja를 설치한다:</p>
<pre><code class="language-bash">brew install cmake ninja
</code></pre>
<p>macOS에는 이미 Clang이 포함되어 있으므로 빌드할 준비가 된 것이다.</p>
<h4 id="windows-wsl2"><a class="header" href="#windows-wsl2">Windows (WSL2)</a></h4>
<p>Ubuntu 22.04가 설치된 Windows Subsystem for Linux 2 (WSL2)를 사용하는 것을 권장한다. <a href="https://learn.microsoft.com/en-us/windows/wsl/install">WSL2 설치 가이드</a>를 따른 후, 위의 Linux (Ubuntu) 의존성 설치 단계를 사용한다.</p>
<blockquote>
<p><strong>참고:</strong> MSVC를 사용한 네이티브 Windows 빌드도 가능하지만 다른 CMake 구성이 필요하며 이 튜토리얼의 범위를 벗어난다. WSL2는 Windows에서 일관된 Linux 환경을 제공한다.</p>
</blockquote>
<h3 id="llvm-클론"><a class="header" href="#llvm-클론">LLVM 클론</a></h3>
<p>LLVM monorepo를 LLVM 19.x 안정 릴리스 브랜치에서 클론한다. <code>--depth 1</code>을 사용하면 최신 커밋만 가져와 디스크 공간과 다운로드 시간을 절약할 수 있다:</p>
<pre><code class="language-bash">cd $HOME
git clone --depth 1 --branch release/19.x https://github.com/llvm/llvm-project.git
cd llvm-project
</code></pre>
<p>shallow clone 후 저장소 크기는 약 2 GB이다.</p>
<h3 id="빌드-구성"><a class="header" href="#빌드-구성">빌드 구성</a></h3>
<p>CMake 구성 단계는 매우 중요하다. 각 플래그는 특정 목적을 가지고 있다:</p>
<pre><code class="language-bash">cmake -S llvm -B build -G Ninja \
  -DCMAKE_BUILD_TYPE=Release \
  -DLLVM_ENABLE_PROJECTS=mlir \
  -DMLIR_BUILD_MLIR_C_DYLIB=ON \
  -DLLVM_TARGETS_TO_BUILD="X86;AArch64" \
  -DCMAKE_INSTALL_PREFIX=$HOME/mlir-install
</code></pre>
<p><strong>플래그 설명:</strong></p>
<ul>
<li><code>-S llvm</code>: 소스 디렉터리 (저장소 내의 <code>llvm</code> 하위 디렉터리)</li>
<li><code>-B build</code>: 빌드 디렉터리 (out-of-tree 빌드 권장)</li>
<li><code>-G Ninja</code>: Ninja 빌드 시스템 사용 (Make보다 빠름)</li>
<li><code>-DCMAKE_BUILD_TYPE=Release</code>: 디버그 심볼 없이 최적화된 빌드 (크기가 훨씬 작고 빠름)</li>
<li><code>-DLLVM_ENABLE_PROJECTS=mlir</code>: LLVM과 함께 MLIR 빌드 (MLIR은 LLVM에 의존)</li>
<li><strong><code>-DMLIR_BUILD_MLIR_C_DYLIB=ON</code></strong>: <strong>핵심 플래그</strong> — MLIR C API를 노출하는 <code>libMLIR-C</code> 공유 라이브러리를 빌드한다</li>
<li><code>-DLLVM_TARGETS_TO_BUILD="X86;AArch64"</code>: x86-64 및 ARM64 백엔드만 빌드 (빌드 시간 단축; 필요시 다른 타겟 추가)</li>
<li><code>-DCMAKE_INSTALL_PREFIX=$HOME/mlir-install</code>: 설치 위치 (쓰기 가능한 디렉터리 사용)</li>
</ul>
<p>CMake 구성은 1-2분 내에 완료된다. 다음과 같은 출력이 표시된다:</p>
<pre><code>-- The C compiler identification is GNU 11.4.0
-- The CXX compiler identification is GNU 11.4.0
...
-- Build files have been written to: /home/user/llvm-project/build
</code></pre>
<h3 id="빌드-및-설치"><a class="header" href="#빌드-및-설치">빌드 및 설치</a></h3>
<p>사용 가능한 모든 CPU 코어를 활용하여 MLIR을 빌드한다 (Ninja는 자동으로 병렬 처리를 사용한다):</p>
<pre><code class="language-bash">cmake --build build --target install
</code></pre>
<p>이 단계는 하드웨어에 따라 30-60분이 소요된다. 수천 줄의 컴파일 로그가 스크롤된다. 빌드 중 메모리가 부족해지면 (시스템이 응답하지 않는 경우), 빌드를 중지하고 (Ctrl+C) 병렬 처리를 줄여 다시 시작한다:</p>
<pre><code class="language-bash">cmake --build build --target install -- -j2
</code></pre>
<p><code>-j2</code> 플래그는 Ninja의 병렬 컴파일 작업을 2개로 제한하여, 빌드 시간이 느려지는 대신 최대 메모리 사용량을 줄인다.</p>
<p>빌드가 완료되면 다음과 같이 표시된다:</p>
<pre><code>[100%] Built target install
</code></pre>
<h3 id="설치-확인"><a class="header" href="#설치-확인">설치 확인</a></h3>
<p>MLIR C API 공유 라이브러리가 설치되었는지 확인한다:</p>
<pre><code class="language-bash">ls -lh $HOME/mlir-install/lib/libMLIR-C*
</code></pre>
<p><strong>예상 출력:</strong></p>
<ul>
<li><strong>Linux:</strong> <code>libMLIR-C.so</code> 및 <code>libMLIR-C.so.19</code> (버전이 지정된 라이브러리에 대한 심볼릭 링크)</li>
<li><strong>macOS:</strong> <code>libMLIR-C.19.dylib</code> 및 <code>libMLIR-C.dylib</code> (심볼릭 링크)</li>
<li><strong>Windows (WSL):</strong> Linux와 동일</li>
</ul>
<p><code>No such file or directory</code>가 표시되면 CMake 구성에 <code>-DMLIR_BUILD_MLIR_C_DYLIB=ON</code>이 포함되어 있는지 확인하고 빌드 단계를 다시 실행한다.</p>
<p><code>mlir-opt</code> 도구도 설치되어 있어야 한다:</p>
<pre><code class="language-bash">$HOME/mlir-install/bin/mlir-opt --version
</code></pre>
<p>예상 출력: <code>MLIR (http://mlir.llvm.org) version 19.1.x</code></p>
<h2 id="net-sdk-설치"><a class="header" href="#net-sdk-설치">.NET SDK 설치</a></h2>
<p>FunLang의 컴파일러 백엔드는 F#으로 구현된다. F# 프로그램을 컴파일하고 실행하려면 .NET SDK가 필요하다.</p>
<h3 id="linux-ubuntudebian-1"><a class="header" href="#linux-ubuntudebian-1">Linux (Ubuntu/Debian)</a></h3>
<p>.NET 8.0 SDK (2026년 11월까지 지원되는 LTS 릴리스)를 설치한다:</p>
<pre><code class="language-bash">wget https://dot.net/v1/dotnet-install.sh -O dotnet-install.sh
chmod +x dotnet-install.sh
./dotnet-install.sh --channel 8.0
</code></pre>
<p>스크립트는 .NET을 <code>$HOME/.dotnet</code>에 설치한다. PATH에 추가한다:</p>
<pre><code class="language-bash">echo 'export PATH="$HOME/.dotnet:$PATH"' &gt;&gt; ~/.bashrc
source ~/.bashrc
</code></pre>
<h3 id="macos-1"><a class="header" href="#macos-1">macOS</a></h3>
<p><a href="https://dotnet.microsoft.com/download/dotnet/8.0">https://dotnet.microsoft.com/download/dotnet/8.0</a>에서 .NET 8.0 SDK 설치 프로그램을 다운로드하여 설치하거나, Homebrew를 사용한다:</p>
<pre><code class="language-bash">brew install --cask dotnet-sdk
</code></pre>
<h3 id="windows-wsl2-1"><a class="header" href="#windows-wsl2-1">Windows (WSL2)</a></h3>
<p>WSL2 Ubuntu 환경에서 위의 Linux 설치 단계를 따른다.</p>
<h3 id="net-설치-확인"><a class="header" href="#net-설치-확인">.NET 설치 확인</a></h3>
<p>.NET 버전을 확인한다:</p>
<pre><code class="language-bash">dotnet --version
</code></pre>
<p>예상 출력: <code>8.0.x</code></p>
<p>F# 컴파일러가 사용 가능한지 확인한다:</p>
<pre><code class="language-bash">dotnet fsi --version
</code></pre>
<p>예상 출력: <code>Microsoft (R) F# Interactive version 12.8.x.0</code></p>
<p>모든 것이 정상적으로 작동하는지 확인하기 위해 테스트 F# 프로젝트를 생성한다:</p>
<pre><code class="language-bash">dotnet new console -lang F# -o test-fsharp
cd test-fsharp
dotnet run
</code></pre>
<p>다음과 같이 출력되어야 한다:</p>
<pre><code>Hello from F#
</code></pre>
<h2 id="라이브러리-검색-경로-설정"><a class="header" href="#라이브러리-검색-경로-설정">라이브러리 검색 경로 설정</a></h2>
<p>F# 프로그램이 P/Invoke를 통해 MLIR C API 함수를 호출할 때, .NET 런타임은 런타임에 <code>libMLIR-C</code> 공유 라이브러리를 찾을 수 있어야 한다. 표준적인 방법은 MLIR 설치 라이브러리 디렉터리를 시스템의 라이브러리 검색 경로에 추가하는 것이다.</p>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<p>MLIR 라이브러리 디렉터리를 <code>LD_LIBRARY_PATH</code>에 추가한다:</p>
<pre><code class="language-bash">echo 'export LD_LIBRARY_PATH="$HOME/mlir-install/lib:$LD_LIBRARY_PATH"' &gt;&gt; ~/.bashrc
source ~/.bashrc
</code></pre>
<p>라이브러리가 검색 가능한지 확인한다:</p>
<pre><code class="language-bash">ldconfig -p | grep MLIR
</code></pre>
<p><code>libMLIR-C.so</code>에 대한 항목이 표시되어야 한다.</p>
<h3 id="macos-2"><a class="header" href="#macos-2">macOS</a></h3>
<p>MLIR 라이브러리 디렉터리를 <code>DYLD_LIBRARY_PATH</code>에 추가한다:</p>
<pre><code class="language-bash">echo 'export DYLD_LIBRARY_PATH="$HOME/mlir-install/lib:$DYLD_LIBRARY_PATH"' &gt;&gt; ~/.zshrc
source ~/.zshrc
</code></pre>
<blockquote>
<p><strong>참고:</strong> macOS Catalina 이후 macOS는 기본적으로 zsh를 사용한다. bash를 사용하고 있다면 <code>~/.bashrc</code>를 수정한다.</p>
</blockquote>
<p>라이브러리가 존재하는지 확인한다:</p>
<pre><code class="language-bash">ls -l $HOME/mlir-install/lib/libMLIR-C.dylib
</code></pre>
<h3 id="windows-wsl2-2"><a class="header" href="#windows-wsl2-2">Windows (WSL2)</a></h3>
<p>WSL2에서 위의 Linux 지침을 따른다.</p>
<h3 id="대안-프로젝트별-구성"><a class="header" href="#대안-프로젝트별-구성">대안: 프로젝트별 구성</a></h3>
<p>전역 환경 변수를 설정하는 대신, F# 애플리케이션을 실행할 때 라이브러리 경로를 지정할 수 있다:</p>
<pre><code class="language-bash">LD_LIBRARY_PATH=$HOME/mlir-install/lib dotnet run
</code></pre>
<p>이 방법은 셸 프로파일을 수정하지 않고 테스트할 때 유용하다.</p>
<h2 id="자주-발생하는-문제-해결"><a class="header" href="#자주-발생하는-문제-해결">자주 발생하는 문제 해결</a></h2>
<h3 id="빌드-중-메모리-부족"><a class="header" href="#빌드-중-메모리-부족">빌드 중 메모리 부족</a></h3>
<p><strong>증상:</strong> MLIR 빌드 중 시스템이 응답하지 않음; 스왑 사용량이 100%.</p>
<p><strong>해결 방법:</strong> 빌드 병렬 처리를 줄인다:</p>
<pre><code class="language-bash">cmake --build build --target install -- -j2
</code></pre>
<p>RAM이 8 GB인 시스템에서는 <code>-j1</code>이 필요할 수 있다.</p>
<h3 id="mlir-c-library-not-found-런타임-오류"><a class="header" href="#mlir-c-library-not-found-런타임-오류">“MLIR-C library not found” 런타임 오류</a></h3>
<p><strong>증상:</strong> F# 프로그램이 <code>DllNotFoundException: Unable to load shared library 'MLIR-C'</code>로 실패한다.</p>
<p><strong>해결 방법:</strong> 라이브러리 검색 경로가 구성되어 있는지 확인한다:</p>
<pre><code class="language-bash"># Linux
echo $LD_LIBRARY_PATH
# $HOME/mlir-install/lib이 포함되어 있어야 합니다

# macOS
echo $DYLD_LIBRARY_PATH
</code></pre>
<p>라이브러리 파일이 존재하는지 확인한다:</p>
<pre><code class="language-bash">ls $HOME/mlir-install/lib/libMLIR-C*
</code></pre>
<p>파일이 없다면 <code>-DMLIR_BUILD_MLIR_C_DYLIB=ON</code>으로 다시 빌드한다.</p>
<h3 id="cmake-버전이-너무-오래됨"><a class="header" href="#cmake-버전이-너무-오래됨">CMake 버전이 너무 오래됨</a></h3>
<p><strong>증상:</strong> CMake 구성이 <code>CMake 3.20 or higher is required</code>로 실패한다.</p>
<p><strong>해결 방법:</strong> 최신 CMake를 설치한다:</p>
<pre><code class="language-bash"># Linux: 최신 CMake 바이너리 다운로드
wget https://github.com/Kitware/CMake/releases/download/v3.28.0/cmake-3.28.0-linux-x86_64.sh
sudo sh cmake-3.28.0-linux-x86_64.sh --prefix=/usr/local --skip-license

# macOS
brew upgrade cmake
</code></pre>
<h3 id="ninja-빌드-시스템-누락"><a class="header" href="#ninja-빌드-시스템-누락">Ninja 빌드 시스템 누락</a></h3>
<p><strong>증상:</strong> CMake 구성이 <code>Could not find Ninja</code>로 실패한다.</p>
<p><strong>해결 방법:</strong> Ninja를 설치하거나 (위의 “빌드 의존성 설치” 참조), 대신 Unix Makefiles를 사용한다 (더 느림):</p>
<pre><code class="language-bash">cmake -S llvm -B build -G "Unix Makefiles" \
  -DCMAKE_BUILD_TYPE=Release \
  -DLLVM_ENABLE_PROJECTS=mlir \
  -DMLIR_BUILD_MLIR_C_DYLIB=ON \
  -DLLVM_TARGETS_TO_BUILD="X86;AArch64" \
  -DCMAKE_INSTALL_PREFIX=$HOME/mlir-install

make -C build install -j$(nproc)
</code></pre>
<h3 id="디스크-공간-부족"><a class="header" href="#디스크-공간-부족">디스크 공간 부족</a></h3>
<p><strong>증상:</strong> 빌드가 <code>No space left on device</code>로 실패한다.</p>
<p><strong>해결 방법:</strong> LLVM 빌드에는 ~30 GB가 필요하다. 공간을 확보하거나 다른 파티션에서 빌드한다. 설치 후 <code>build</code> 디렉터리를 삭제하면 ~20 GB를 회수할 수 있다:</p>
<pre><code class="language-bash">rm -rf $HOME/llvm-project/build
</code></pre>
<h2 id="이-장에서-완료한-것"><a class="header" href="#이-장에서-완료한-것">이 장에서 완료한 것</a></h2>
<p>이 시점에서 다음 항목이 준비되어 있다:</p>
<ol>
<li><strong>LLVM/MLIR 설치 완료</strong> — <code>$HOME/mlir-install</code>에 C API 공유 라이브러리(<code>libMLIR-C.so</code>, <code>libMLIR-C.dylib</code>, 또는 <code>MLIR-C.dll</code>) 포함</li>
<li><strong>.NET 8.0 SDK</strong> — F# 컴파일러 및 런타임과 함께 설치 완료</li>
<li><strong>라이브러리 검색 경로 구성 완료</strong> — .NET이 런타임에 MLIR을 찾을 수 있도록 설정</li>
<li><strong>빌드 도구 검증 완료</strong> — 개발 준비 완료 (<code>mlir-opt</code>, <code>dotnet</code>)</li>
</ol>
<p>이제 MLIR과 상호작용하는 F# 코드를 작성할 준비가 되었다. 다음 장에서는 코드를 작성하기 전에 이해해야 할 핵심 MLIR 개념들을 살펴본다: dialect, operation, region, block, 그리고 SSA 형식이다.</p>
<h2 id="다음-장"><a class="header" href="#다음-장">다음 장</a></h2>
<p><a href="#chapter-01-mlir-입문">Chapter 01: MLIR 입문</a>으로 이동하여 MLIR IR의 기본 개념을 학습한다.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-01-mlir-입문"><a class="header" href="#chapter-01-mlir-입문">Chapter 01: MLIR 입문</a></h1>
<h2 id="소개-1"><a class="header" href="#소개-1">소개</a></h2>
<p>이전 챕터에서 LLVM/MLIR을 소스에서 빌드하고 .NET SDK를 설정했다. 필요한 도구는 모두 설치되었다. 하지만 MLIR을 생성하는 F# 코드를 작성하기 전에, MLIR이 무엇이고 프로그램을 어떻게 표현하는지 이해해야 한다.</p>
<p>MLIR은 전통적인 중간 표현(intermediate representation)과 다르다. 단순히 “하나의 IR“이 아니라, 서로 상호 운용할 수 있는 여러 IR(dialect이라고 부른다)을 구축하기 위한 프레임워크이다. 이 다단계(multi-level) 철학이 MLIR을 컴파일러 개발에 강력하게 만드는 핵심이다. 고수준 함수형 언어를 매우 저수준인 LLVM IR로 직접 변환하도록 강제하는 대신, MLIR은 언어의 의미론(semantics)을 필요한 만큼 보존하는 중간 표현을 정의한 다음, 단계적으로 점진적 하강(progressive lowering)할 수 있게 해준다.</p>
<p>FunLang의 컴파일 파이프라인은 다음과 같다:</p>
<pre><code>FunLang Typed AST
    ↓
High-Level MLIR (arith, func, scf dialects)
    ↓
Low-Level MLIR (LLVM dialect)
    ↓
LLVM IR
    ↓
Native Machine Code
</code></pre>
<p>이 챕터에서는 MLIR IR을 이해하기 위한 멘탈 모델을 제공한다. 다섯 가지 핵심 개념 — <strong>dialect</strong>, <strong>operation</strong>, <strong>region</strong>, <strong>block</strong>, 그리고 <strong>SSA form</strong> — 을 구체적인 예제를 통해 배운다. 챕터를 마치면 MLIR 텍스트 IR을 읽고, FunLang 프로그램이 MLIR 구조에 어떻게 매핑되는지 이해할 수 있을 것이다.</p>
<h2 id="mlir-ir-구조"><a class="header" href="#mlir-ir-구조">MLIR IR 구조</a></h2>
<p>완전한 MLIR 프로그램을 보면서 각 부분을 분석해 본다. 다음은 두 개의 32비트 정수를 더하는 간단한 함수이다:</p>
<pre><code class="language-mlir">module {
  func.func @add(%arg0: i32, %arg1: i32) -&gt; i32 {
    %result = arith.addi %arg0, %arg1 : i32
    return %result : i32
  }
}
</code></pre>
<p>한 줄씩 분석해 본다:</p>
<ul>
<li>
<p><strong><code>module { ... }</code></strong>: 모든 MLIR 프로그램은 module에 포함된다. module은 모든 코드를 담는 최상위 컨테이너로, C의 컴파일 단위(compilation unit)나 .NET의 어셈블리와 유사하다.</p>
</li>
<li>
<p><strong><code>func.func @add(...) -&gt; i32 { ... }</code></strong>: <code>func</code> dialect의 operation으로, <code>@add</code>라는 이름의 함수를 정의한다. <code>@</code> 접두사는 심볼(함수 이름)을 나타낸다. 이 함수는 두 개의 인자를 받아 <code>i32</code>(32비트 정수)를 반환한다.</p>
</li>
<li>
<p><strong><code>%arg0: i32, %arg1: i32</code></strong>: 함수 매개변수이다. 각 매개변수는 타입 어노테이션(<code>: i32</code>)을 가진 SSA 값(<code>%</code>로 시작)이다. 이것이 함수의 입력이다.</p>
</li>
<li>
<p><strong><code>%result = arith.addi %arg0, %arg1 : i32</code></strong>: <code>arith</code> dialect의 산술 덧셈 operation이다. 두 피연산자(<code>%arg0</code>과 <code>%arg1</code>)를 받아 더한 후, 새로운 SSA 값 <code>%result</code>를 생성한다. <code>: i32</code> 접미사는 결과 타입을 지정한다.</p>
</li>
<li>
<p><strong><code>return %result : i32</code></strong>: 함수의 return operation이다. <code>%result</code> 값을 호출자에게 반환한다. <code>: i32</code> 타입 어노테이션은 타입 안전성을 보장한다.</p>
</li>
</ul>
<p>MLIR의 모든 요소에는 목적과 타입이 있다. 암시적 변환이나 정의되지 않은 동작(undefined behavior)은 없다. 이러한 엄격함이 MLIR이 공격적인 최적화와 검증을 수행할 수 있게 해주는 것이다.</p>
<h2 id="dialect"><a class="header" href="#dialect">Dialect</a></h2>
<p><strong>Dialect</strong>은 관련된 operation, 타입, attribute를 그룹화하는 네임스페이스이다. Dialect은 MLIR의 확장성 메커니즘이다 — 모든 가능한 operation을 하나의 거대한 IR에 넣는 대신, MLIR은 도메인에 맞는 커스텀 dialect을 정의할 수 있게 해준다.</p>
<h3 id="사용할-내장-dialect"><a class="header" href="#사용할-내장-dialect">사용할 내장 Dialect</a></h3>
<p>FunLang 컴파일러에서는 주로 다음 표준 dialect들을 사용한다:</p>
<ol>
<li>
<p><strong><code>arith</code></strong> — 산술 연산</p>
<ul>
<li><code>arith.addi</code>, <code>arith.subi</code>, <code>arith.muli</code>, <code>arith.divsi</code> (부호 있는 정수 산술)</li>
<li><code>arith.cmpi</code> (정수 비교: <code>&lt;</code>, <code>&gt;</code>, <code>==</code> 등)</li>
<li><code>arith.constant</code> (정수 및 부동소수점 상수)</li>
</ul>
</li>
<li>
<p><strong><code>func</code></strong> — 함수 정의 및 호출</p>
<ul>
<li><code>func.func</code> (함수 정의)</li>
<li><code>func.call</code> (함수 호출)</li>
<li><code>func.return</code> (함수에서 반환)</li>
</ul>
</li>
<li>
<p><strong><code>scf</code></strong> — 구조적 제어 흐름(Structured Control Flow)</p>
<ul>
<li><code>scf.if</code> (조건부 실행)</li>
<li><code>scf.for</code> (카운트 루프)</li>
<li><code>scf.while</code> (조건 루프)</li>
</ul>
</li>
<li>
<p><strong><code>llvm</code></strong> — LLVM dialect (lowering 대상)</p>
<ul>
<li><code>llvm.func</code>, <code>llvm.call</code>, <code>llvm.add</code> 등</li>
<li>이 dialect은 LLVM IR 구성 요소와 1:1로 매핑된다</li>
</ul>
</li>
</ol>
<h3 id="커스텀-dialect"><a class="header" href="#커스텀-dialect">커스텀 Dialect</a></h3>
<p>이 튜토리얼 시리즈의 후반부(Chapter 10-11)에서는 다음과 같은 operation을 가진 <strong>FunLang dialect</strong>을 정의하게 된다:</p>
<ul>
<li><code>funlang.closure</code> (클로저 생성)</li>
<li><code>funlang.apply</code> (클로저에 인자를 적용)</li>
<li><code>funlang.match</code> (패턴 매칭)</li>
</ul>
<p>커스텀 dialect을 사용하면 컴파일 과정에서 고수준 의미론을 보존할 수 있다. FunLang 클로저를 즉시 저수준 구조체 할당과 함수 포인터로 변환하는 대신, 고수준 <code>funlang.closure</code> operation으로 표현한다. 이렇게 하면 최적화를 작성하고 이해하기가 더 쉬워진다.</p>
<h3 id="dialect-명명-규칙"><a class="header" href="#dialect-명명-규칙">Dialect 명명 규칙</a></h3>
<p>Operation은 항상 자신이 속한 dialect 이름을 접두사로 가지며, 점(.)으로 구분된다:</p>
<pre><code class="language-mlir">arith.addi   // "arith" dialect의 "addi" operation
func.call    // "func" dialect의 "call" operation
llvm.load    // "llvm" dialect의 "load" operation
</code></pre>
<p>이를 통해 이름 충돌을 방지한다. <code>arith</code> dialect의 <code>addi</code>는 가상의 <code>mydialect.addi</code>와 구별된다.</p>
<h2 id="operation"><a class="header" href="#operation">Operation</a></h2>
<p><strong>Operation</strong>은 MLIR IR의 기본 단위이다. MLIR에서는 함수 정의, 산술 명령어, 제어 흐름 등 모든 것이 operation으로 표현된다. 심지어 타입과 attribute도 operation에 첨부된다.</p>
<h3 id="operation의-구조"><a class="header" href="#operation의-구조">Operation의 구조</a></h3>
<p>텍스트 형식에서 operation은 다음과 같은 구조를 가진다:</p>
<pre><code class="language-mlir">%results = dialect.opname(%operands) {attributes} : (types) -&gt; result_type
</code></pre>
<p>덧셈 예제에서 각 구성 요소를 살펴본다:</p>
<pre><code class="language-mlir">%result = arith.addi %arg0, %arg1 : i32
</code></pre>
<ul>
<li>
<p><strong><code>%result</code></strong>: 이 operation이 생성하는 SSA 값이다. 이 값은 이후 operation에서 사용할 수 있다. <code>%</code> 접두사는 SSA 값을 심볼(<code>@function_name</code>)과 구별한다.</p>
</li>
<li>
<p><strong><code>arith.addi</code></strong>: operation 이름(dialect + opname)이다.</p>
</li>
<li>
<p><strong><code>%arg0, %arg1</code></strong>: 피연산자(operation의 입력)이다. 이전에 정의된 SSA 값(이 경우 함수 인자)이다.</p>
</li>
<li>
<p><strong><code>: i32</code></strong>: 타입 제약 조건이다. 이 operation은 32비트 정수에 대해 동작한다.</p>
</li>
</ul>
<p>모든 operation이 결과를 생성하는 것은 아니다. 예를 들어, <code>return</code>은 함수를 종료하는 operation이지만 이후에 사용할 값을 생성하지는 않는다:</p>
<pre><code class="language-mlir">return %result : i32
</code></pre>
<h3 id="복수-결과를-가진-operation"><a class="header" href="#복수-결과를-가진-operation">복수 결과를 가진 Operation</a></h3>
<p>일부 operation은 여러 값을 생성한다. 예를 들어, 몫과 나머지를 모두 반환하는 나눗셈 operation이 있다:</p>
<pre><code class="language-mlir">%quot, %rem = arith.divrem %dividend, %divisor : i32
</code></pre>
<p>이제 <code>%quot</code>과 <code>%rem</code> 모두 사용 가능한 SSA 값이다.</p>
<h3 id="attribute를-가진-operation"><a class="header" href="#attribute를-가진-operation">Attribute를 가진 Operation</a></h3>
<p>Attribute는 컴파일 타임 상수 메타데이터를 제공한다. 예를 들어, 정수 상수는 다음과 같다:</p>
<pre><code class="language-mlir">%zero = arith.constant 0 : i32
</code></pre>
<p><code>0</code>은 attribute(상수 값)이고, <code>i32</code>는 타입이다. Attribute는 런타임 값이 아니라 컴파일 타임에 IR에 내장되는 것이다.</p>
<h2 id="region과-block"><a class="header" href="#region과-block">Region과 Block</a></h2>
<p>MLIR operation은 <strong>region</strong>을 포함할 수 있고, region은 <strong>block</strong>을 포함한다. 이것이 MLIR이 중첩된 스코프와 제어 흐름을 표현하는 방식이다.</p>
<h3 id="region"><a class="header" href="#region">Region</a></h3>
<p><strong>Region</strong>은 block의 목록이다. 함수 본문은 region이다. <code>scf.if</code>와 같은 제어 흐름 operation에는 “then“과 “else” 분기를 위한 region이 있다.</p>
<p>다음은 하나의 region에 하나의 block을 포함하는 함수이다:</p>
<pre><code class="language-mlir">func.func @example() -&gt; i32 {
  %one = arith.constant 1 : i32
  return %one : i32
}
</code></pre>
<p>중괄호 <code>{ ... }</code>가 함수의 region을 구분한다. region 내부에는 두 개의 operation(상수와 return)을 가진 하나의 block이 있다.</p>
<h3 id="block"><a class="header" href="#block">Block</a></h3>
<p><strong>Block</strong>은 선형적으로 실행되는 operation의 시퀀스이다. 모든 block은 <strong>terminator</strong> operation — 제어를 다른 곳으로 이전하는 operation(return, branch 등) — 으로 끝나야 한다. Block을 “통과(fall through)“할 수 없다.</p>
<p>제어 흐름이 있을 때 block이 필수적이 된다. 다음은 두 개의 block을 가진 함수이다:</p>
<pre><code class="language-mlir">func.func @conditional(%cond: i1, %a: i32, %b: i32) -&gt; i32 {
  cf.cond_br %cond, ^then_block, ^else_block

^then_block:
  return %a : i32

^else_block:
  return %b : i32
}
</code></pre>
<p>분석해 본다:</p>
<ul>
<li>
<p><strong><code>cf.cond_br %cond, ^then_block, ^else_block</code></strong>: 조건 분기 operation(<code>cf</code> control-flow dialect)이다. <code>%cond</code>가 참이면 <code>^then_block</code>으로, 그렇지 않으면 <code>^else_block</code>으로 점프한다. 이것이 entry block의 terminator이다.</p>
</li>
<li>
<p><strong><code>^then_block:</code></strong>: block 레이블이다. <code>^</code> 접두사는 block을 나타낸다. block 이름은 함수 내에서 로컬이다.</p>
</li>
<li>
<p><strong><code>return %a : i32</code></strong>: <code>^then_block</code>의 terminator이다. <code>%a</code>를 호출자에게 반환한다.</p>
</li>
<li>
<p><strong><code>^else_block:</code></strong>: 또 다른 block 레이블이다.</p>
</li>
<li>
<p><strong><code>return %b : i32</code></strong>: <code>^else_block</code>의 terminator이다. <code>%b</code>를 반환한다.</p>
</li>
</ul>
<h3 id="block-인자-mlir의-phi-node-처리-방식"><a class="header" href="#block-인자-mlir의-phi-node-처리-방식">Block 인자 (MLIR의 Phi Node 처리 방식)</a></h3>
<p>MLIR은 LLVM의 phi node 대신 <strong>block 인자</strong>를 사용한다. LLVM IR에서는 여러 선행 block의 값을 병합하기 위해 phi node를 사용한다. MLIR에서는 block으로 분기할 때 값을 인자로 전달한다.</p>
<p>다음은 두 값을 병합하는 예제이다:</p>
<pre><code class="language-mlir">func.func @merge_example(%cond: i1, %a: i32, %b: i32) -&gt; i32 {
  cf.cond_br %cond, ^merge(%a : i32), ^merge(%b : i32)

^merge(%result: i32):
  return %result : i32
}
</code></pre>
<p>무슨 일이 일어나는지 살펴본다:</p>
<ul>
<li>
<p><strong><code>cf.cond_br %cond, ^merge(%a : i32), ^merge(%b : i32)</code></strong>: <code>^merge</code> block으로 분기하되, 조건이 참이면 <code>%a</code>를, 거짓이면 <code>%b</code>를 전달한다.</p>
</li>
<li>
<p><strong><code>^merge(%result: i32):</code></strong>: <code>^merge</code> block은 <code>i32</code> 타입의 인자 하나를 기대한다고 선언한다. 어느 분기가 선택되든, 전달된 값이 이 block 내에서 <code>%result</code>가 된다.</p>
</li>
</ul>
<p>이 방식은 LLVM의 phi node보다 깔끔하다. 데이터 흐름이 분기 지점에서 명시적으로 표현되며, 사후에 재구성할 필요가 없기 때문이다.</p>
<h2 id="ssa-form-static-single-assignment"><a class="header" href="#ssa-form-static-single-assignment">SSA Form (Static Single Assignment)</a></h2>
<p>MLIR은 <strong>SSA form</strong>을 사용한다. 즉, 모든 값은 정확히 한 번만 정의되고 절대 변경되지 않는다. <code>%x</code>를 정의하면 다시 할당할 수 없다. 이 속성 덕분에 “지금 어떤 버전의 변수를 보고 있는 것인가?“를 추적할 필요가 없어 최적화가 단순해진다.</p>
<h3 id="ssa-동작-예시"><a class="header" href="#ssa-동작-예시">SSA 동작 예시</a></h3>
<p>다음 FunLang 코드를 살펴본다:</p>
<pre><code class="language-fsharp">let x = 5
let y = x + 3
let z = y * 2
z
</code></pre>
<p>MLIR SSA form에서 각 let 바인딩은 새로운 SSA 값이 된다:</p>
<pre><code class="language-mlir">func.func @example() -&gt; i32 {
  %x = arith.constant 5 : i32
  %three = arith.constant 3 : i32
  %y = arith.addi %x, %three : i32
  %two = arith.constant 2 : i32
  %z = arith.muli %y, %two : i32
  return %z : i32
}
</code></pre>
<p>주목할 점:</p>
<ul>
<li>각 <code>let</code> 바인딩은 새로운 SSA 값(<code>%x</code>, <code>%y</code>, <code>%z</code>)이 된다.</li>
<li>상수는 값을 생성하는 operation(<code>arith.constant</code>)이다.</li>
<li>어떤 값도 재할당되지 않는다.</li>
</ul>
<h3 id="ssa와-가변성mutability"><a class="header" href="#ssa와-가변성mutability">SSA와 가변성(Mutability)</a></h3>
<p>FunLang은 불변(immutable)이므로 SSA와 자연스럽게 매핑된다. 하지만 변이(mutation)가 있는 명령형 코드는 어떨까? 다음을 살펴본다:</p>
<pre><code class="language-c">int x = 1;
x = x + 1;
return x;
</code></pre>
<p>SSA에서는 <code>x</code>를 변경할 수 없다. 대신, 새로운 버전을 생성한다:</p>
<pre><code class="language-mlir">%x0 = arith.constant 1 : i32
%one = arith.constant 1 : i32
%x1 = arith.addi %x0, %one : i32
return %x1 : i32
</code></pre>
<p>각 “변이“는 새로운 SSA 값(<code>%x0</code>, <code>%x1</code> 등)을 생성한다. 이 변환을 <strong>SSA conversion</strong>이라고 하며, 명령형 언어의 컴파일러에서 자동으로 처리된다.</p>
<p>FunLang은 함수형이므로 이 작업은 필요하지 않다 — 모든 <code>let</code> 바인딩이 이미 새로운 이름을 도입하기 때문이다.</p>
<h3 id="핵심-통찰-ssa는-최적화를-가능하게-한다"><a class="header" href="#핵심-통찰-ssa는-최적화를-가능하게-한다">핵심 통찰: SSA는 최적화를 가능하게 한다</a></h3>
<p>SSA form은 많은 컴파일러 최적화를 간단하게 만들어 준다. 예를 들어:</p>
<ul>
<li><strong>Dead code elimination(죽은 코드 제거):</strong> SSA 값이 정의되었지만 사용되지 않으면, 해당 값을 정의하는 operation을 삭제한다.</li>
<li><strong>Constant propagation(상수 전파):</strong> <code>%x</code>가 <code>arith.constant 5</code>로 정의되었다면, <code>%x</code>의 모든 사용을 <code>5</code>로 대체한다.</li>
<li><strong>Common subexpression elimination(공통 하위 표현식 제거):</strong> 두 operation이 같은 값을 계산하면, 하나를 재사용하고 다른 하나를 삭제한다.</li>
</ul>
<p>이 모든 최적화는 값이 정의 후 절대 변경되지 않는다는 보장에 의존한다.</p>
<h2 id="mlir의-타입"><a class="header" href="#mlir의-타입">MLIR의 타입</a></h2>
<p>MLIR은 강타입(strongly typed)이다. 모든 SSA 값, operation, 함수에는 타입이 있다. 타입 시스템은 확장 가능하며(dialect이 커스텀 타입을 정의할 수 있음), 다음은 사용하게 될 내장 타입이다:</p>
<h3 id="정수-타입"><a class="header" href="#정수-타입">정수 타입</a></h3>
<ul>
<li><code>i1</code> — 1비트 정수 (boolean)</li>
<li><code>i32</code> — 32비트 부호 있는 정수</li>
<li><code>i64</code> — 64비트 부호 있는 정수</li>
<li><code>i8</code>, <code>i16</code>, <code>i128</code> 등 — 임의 비트 너비 정수</li>
</ul>
<h3 id="부동소수점-타입"><a class="header" href="#부동소수점-타입">부동소수점 타입</a></h3>
<ul>
<li><code>f32</code> — 32비트 IEEE 754 float</li>
<li><code>f64</code> — 64비트 IEEE 754 double</li>
</ul>
<h3 id="index-타입"><a class="header" href="#index-타입">Index 타입</a></h3>
<ul>
<li><code>index</code> — 배열 인덱싱을 위한 플랫폼 의존 정수 (대상 아키텍처에 따라 일반적으로 32비트 또는 64비트)</li>
</ul>
<h3 id="메모리-타입"><a class="header" href="#메모리-타입">메모리 타입</a></h3>
<ul>
<li><code>memref&lt;4xi32&gt;</code> — 메모리상의 4개 <code>i32</code> 값 배열에 대한 참조</li>
<li><code>memref&lt;*xf64&gt;</code> — <code>f64</code> 값에 대한 unranked(동적) 메모리 참조</li>
</ul>
<h3 id="함수-타입"><a class="header" href="#함수-타입">함수 타입</a></h3>
<ul>
<li><code>(i32, i32) -&gt; i32</code> — 두 개의 <code>i32</code> 인자를 받아 <code>i32</code>를 반환하는 함수</li>
</ul>
<h3 id="funlang-타입-매핑"><a class="header" href="#funlang-타입-매핑">FunLang 타입 매핑</a></h3>
<p>FunLang 타입이 MLIR 타입에 어떻게 매핑되는지 정리하면 다음과 같다:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>FunLang 타입</th><th>MLIR 타입</th><th>비고</th></tr>
</thead>
<tbody>
<tr><td><code>Int</code></td><td><code>i64</code></td><td>FunLang 정수는 인터프리터에서 임의 정밀도이지만, 64비트로 컴파일한다</td></tr>
<tr><td><code>Bool</code></td><td><code>i1</code></td><td>True = 1, False = 0</td></tr>
<tr><td><code>String</code></td><td><code>!llvm.ptr</code> (LLVM dialect 포인터)</td><td>문자열은 힙에 할당된 null 종료 C 문자열이다</td></tr>
<tr><td><code>Float</code></td><td><code>f64</code></td><td>배정밀도 부동소수점</td></tr>
<tr><td><code>List&lt;'a&gt;</code></td><td><code>!llvm.ptr</code></td><td>리스트는 힙에 할당된 연결 구조이다</td></tr>
<tr><td><code>Tuple&lt;'a, 'b, ...&gt;</code></td><td><code>!llvm.struct&lt;...&gt;</code></td><td>튜플은 LLVM struct로 컴파일된다</td></tr>
</tbody>
</table>
</div>
<p><code>!</code> 접두사는 dialect에서 정의된 타입을 나타낸다 (예: <code>!llvm.ptr</code>는 LLVM dialect의 포인터 타입).</p>
<h2 id="progressive-lowering"><a class="header" href="#progressive-lowering">Progressive Lowering</a></h2>
<p>MLIR의 강력함은 <strong>progressive lowering</strong>에 있다: 한 번에 크게 변환하는 대신, 고수준 operation을 여러 단계에 걸쳐 저수준 operation으로 변환하는 방식이다.</p>
<h3 id="funlang-컴파일-파이프라인"><a class="header" href="#funlang-컴파일-파이프라인">FunLang 컴파일 파이프라인</a></h3>
<p>이 튜토리얼에서 구축할 파이프라인은 다음과 같다:</p>
<pre><code>Stage 1: AST → High-Level MLIR
    FunLang AST (타입 검사기에서 전달)
    ↓
    arith, func, scf dialect을 사용하여 MLIR로 변환
    예: `let x = 1 + 2`는 `%x = arith.addi ...`가 됩니다

Stage 2: High-Level MLIR → LLVM Dialect
    `arith.addi` 같은 operation이 `llvm.add`로 lowering됩니다
    구조적 제어 흐름(`scf.if`)은 basic block과 branch로 lowering됩니다

Stage 3: LLVM Dialect → LLVM IR
    MLIR의 LLVM dialect이 텍스트 LLVM IR로 변환됩니다

Stage 4: LLVM IR → Native Code
    LLVM 백엔드(llc)가 대상 플랫폼의 머신 코드로 컴파일합니다
</code></pre>
<p>각 lowering 단계는 <strong>pass</strong> — IR을 재작성하는 변환 — 이다. MLIR은 pass 정의, 패턴 기반 재작성, 각 단계 후 검증을 위한 인프라를 제공한다.</p>
<h3 id="progressive-lowering이-중요한-이유"><a class="header" href="#progressive-lowering이-중요한-이유">Progressive Lowering이 중요한 이유</a></h3>
<p>FunLang의 패턴 매칭을 컴파일하는 경우를 생각해 보자. LLVM IR로 직접 lowering해야 한다면, 즉시 basic block, phi node, 메모리 로드로 이루어진 복잡한 결정 트리로 확장해야 한다. 하지만 progressive lowering을 사용하면:</p>
<ol>
<li><strong>고수준:</strong> 패턴 매칭을 구조를 보존하는 <code>funlang.match</code> operation으로 표현한다.</li>
<li><strong>중간 수준:</strong> <code>funlang.match</code>를 <code>scf.if</code>와 <code>scf.while</code>(구조적 제어 흐름)로 lowering한다.</li>
<li><strong>저수준:</strong> <code>scf.if</code>를 LLVM basic block과 branch로 lowering한다.</li>
</ol>
<p>각 단계에서 해당 추상화 수준에 맞는 최적화를 수행할 수 있다. 패턴 매칭 최적화(중복 검사 제거)는 고수준에서 이루어지고, LLVM 수준 최적화(레지스터 할당, 명령어 스케줄링)는 저수준에서 이루어진다.</p>
<h2 id="종합-예제"><a class="header" href="#종합-예제">종합 예제</a></h2>
<p>여러 개념을 함께 사용하는 좀 더 현실적인 MLIR 예제를 살펴본다:</p>
<pre><code class="language-mlir">module {
  func.func @factorial(%n: i64) -&gt; i64 {
    %c0 = arith.constant 0 : i64
    %c1 = arith.constant 1 : i64
    %is_zero = arith.cmpi eq, %n, %c0 : i64
    cf.cond_br %is_zero, ^base_case, ^recursive_case

  ^base_case:
    return %c1 : i64

  ^recursive_case:
    %n_minus_1 = arith.subi %n, %c1 : i64
    %rec_result = func.call @factorial(%n_minus_1) : (i64) -&gt; i64
    %result = arith.muli %n, %rec_result : i64
    return %result : i64
  }
}
</code></pre>
<p>이 코드를 추적해 본다:</p>
<ol>
<li>
<p><strong><code>func.func @factorial(%n: i64) -&gt; i64</code></strong>: 하나의 64비트 정수를 받아 64비트 정수를 반환하는 <code>@factorial</code> 함수를 정의한다.</p>
</li>
<li>
<p><strong><code>%c0 = arith.constant 0 : i64</code></strong>: 상수 <code>0</code>을 생성한다.</p>
</li>
<li>
<p><strong><code>%c1 = arith.constant 1 : i64</code></strong>: 상수 <code>1</code>을 생성한다.</p>
</li>
<li>
<p><strong><code>%is_zero = arith.cmpi eq, %n, %c0 : i64</code></strong>: <code>%n</code>과 <code>0</code>을 동등성 비교한다. 결과는 <code>i1</code>(boolean)이다.</p>
</li>
<li>
<p><strong><code>cf.cond_br %is_zero, ^base_case, ^recursive_case</code></strong>: 참이면 <code>^base_case</code>로, 아니면 <code>^recursive_case</code>로 분기한다.</p>
</li>
<li>
<p><strong><code>^base_case:</code></strong>: n == 0이면 1을 반환한다.</p>
</li>
<li>
<p><strong><code>^recursive_case:</code></strong>: n &gt; 0이면 <code>n * factorial(n - 1)</code>을 계산한다:</p>
<ul>
<li><code>%n_minus_1 = arith.subi %n, %c1</code>: <code>n - 1</code>을 계산한다.</li>
<li><code>%rec_result = func.call @factorial(%n_minus_1)</code>: 재귀 호출이다.</li>
<li><code>%result = arith.muli %n, %rec_result</code>: <code>n</code>과 재귀 결과를 곱한다.</li>
<li><code>return %result</code>: 결과를 반환한다.</li>
</ul>
</li>
</ol>
<p>이 예제는 다음을 보여준다:</p>
<ul>
<li><strong>SSA form:</strong> 모든 값(<code>%c0</code>, <code>%n_minus_1</code> 등)이 한 번만 정의된다.</li>
<li><strong>Operation:</strong> 상수, 비교, 산술, 함수 호출.</li>
<li><strong>Region과 block:</strong> 함수 본문은 세 개의 block(entry, <code>^base_case</code>, <code>^recursive_case</code>)을 가진 region이다.</li>
<li><strong>Terminator:</strong> 모든 block이 terminator(<code>cf.cond_br</code> 또는 <code>return</code>)로 끝난다.</li>
<li><strong>Dialect:</strong> <code>arith</code>, <code>func</code>, <code>cf</code> dialect을 사용한다.</li>
</ul>
<h2 id="학습-내용-정리"><a class="header" href="#학습-내용-정리">학습 내용 정리</a></h2>
<p>이제 MLIR의 다섯 가지 핵심 개념을 이해하게 되었다:</p>
<ol>
<li><strong>Dialect:</strong> operation, 타입, attribute의 네임스페이스 (예: <code>arith</code>, <code>func</code>, <code>llvm</code>).</li>
<li><strong>Operation:</strong> MLIR IR의 기본 단위 (예: <code>arith.addi</code>, <code>func.call</code>).</li>
<li><strong>Region:</strong> block의 목록 (예: 함수 본문).</li>
<li><strong>Block:</strong> terminator로 끝나는 operation 시퀀스 (예: 제어 흐름의 basic block).</li>
<li><strong>SSA form:</strong> 모든 값이 정확히 한 번만 정의되며 불변.</li>
</ol>
<p>구체적인 예제(산술, 제어 흐름, 재귀)를 통해 이 개념들이 어떻게 함께 작동하는지 살펴보았다. 또한 progressive lowering — IR을 한 번에 큰 점프가 아닌 단계적으로 변환하는 철학 — 을 이해하게 되었다.</p>
<h2 id="다음-단계"><a class="header" href="#다음-단계">다음 단계</a></h2>
<p>다음 챕터에서는 MLIR IR을 생성하는 첫 번째 F# 프로그램을 작성한다. P/Invoke를 사용하여 MLIR의 C API를 호출하고, 컴파일러의 “Hello, World“인 상수 정수를 반환하는 프로그램을 생성할 것이다.</p>
<p>**Chapter 02: Hello MLIR from F#**로 계속된다 (작성 예정).</p>
<h2 id="참고-자료"><a class="header" href="#참고-자료">참고 자료</a></h2>
<ul>
<li><a href="https://mlir.llvm.org/docs/LangRef/">MLIR Language Reference</a> — MLIR의 텍스트 형식, dialect, 의미론에 대한 공식 사양.</li>
<li><a href="https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/">Understanding MLIR IR Structure</a> — operation, region, block에 대한 심층 분석.</li>
<li><a href="https://mlir.llvm.org/docs/Tutorials/Toy/">MLIR Toy Tutorial</a> — MLIR을 사용하여 “Toy” 언어의 컴파일러를 구축하는 완전한 튜토리얼.</li>
<li><a href="https://mlir.llvm.org/docs/Dialects/">Dialects Documentation</a> — 내장 dialect(arith, func, scf, llvm 등)에 대한 참조 문서.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="챕터-02-f에서-hello-mlir"><a class="header" href="#챕터-02-f에서-hello-mlir">챕터 02: F#에서 Hello MLIR</a></h1>
<h2 id="소개-2"><a class="header" href="#소개-2">소개</a></h2>
<p>챕터 00에서는 MLIR을 소스에서 빌드하고 .NET SDK를 설치했다. 챕터 01에서는 MLIR의 핵심 개념인 dialect, operation, region, block, SSA 형태에 대해 배웠다. 이제 코드를 작성할 차례다.</p>
<p>이 챕터는 처음으로 “동작한다!“를 경험하는 순간이다. F# 스크립트를 작성하여 P/Invoke를 통해 MLIR C API를 호출하고, MLIR context와 module을 생성하며, 산술 연산이 포함된 간단한 함수를 구성한 뒤, 결과 IR을 콘솔에 출력할 것이다. 이 챕터를 마치면 F#이 MLIR과 상호운용될 수 있다는 것을 증명하는 동작하는 프로토타입을 갖게 된다.</p>
<p>이 챕터의 코드는 의도적으로 즉흥적이고 탐색적이다. P/Invoke 바인딩을 인라인으로 정의하고 우선 동작하는 것에 집중한다. 챕터 03에서 이 바인딩들을 적절한 재사용 가능한 모듈로 구성할 것이다.</p>
<h2 id="만들어-볼-것"><a class="header" href="#만들어-볼-것">만들어 볼 것</a></h2>
<p>첫 번째 MLIR 프로그램은 상수 정수를 반환하는 함수다. MLIR 텍스트 형식으로는 다음과 같다:</p>
<pre><code class="language-mlir">module {
  func.func @return_forty_two() -&gt; i32 {
    %c42 = arith.constant 42 : i32
    return %c42 : i32
  }
}
</code></pre>
<p>이것은 가장 간단한 MLIR 프로그램이다:</p>
<ul>
<li><code>@return_forty_two</code>라는 이름의 함수 하나</li>
<li>매개변수 없음</li>
<li><code>i32</code> (32비트 정수) 반환</li>
<li>본문에서 상수 <code>42</code>를 생성하고 반환</li>
</ul>
<p>이것을 MLIR의 C API를 사용하여 F#에서 프로그래밍 방식으로 구성할 것이다.</p>
<h2 id="pinvoke-이해하기"><a class="header" href="#pinvoke-이해하기">P/Invoke 이해하기</a></h2>
<p>P/Invoke (Platform Invoke)는 .NET의 외부 함수 인터페이스(FFI) 메커니즘이다. 관리 코드(F#, C# 등)에서 공유 라이브러리(Linux의 <code>.so</code>, macOS의 <code>.dylib</code>, Windows의 <code>.dll</code>)에 있는 비관리 네이티브 함수를 호출할 수 있게 해준다.</p>
<h3 id="dllimport-속성"><a class="header" href="#dllimport-속성">DllImport 속성</a></h3>
<p>네이티브 함수를 호출하려면 <code>[&lt;DllImport&gt;]</code> 속성을 사용하여 함수 시그니처를 선언한다. 패턴은 다음과 같다:</p>
<pre><code class="language-fsharp">[&lt;DllImport("library-name", CallingConvention = CallingConvention.Cdecl)&gt;]
extern ReturnType functionName(ParamType1 param1, ParamType2 param2)
</code></pre>
<p>하나씩 살펴본다:</p>
<ul>
<li>
<p><strong><code>[&lt;DllImport("library-name")&gt;]</code></strong>: 함수가 포함된 공유 라이브러리를 지정한다. MLIR의 경우 <code>"MLIR-C"</code>이다(파일 확장자 없이 – .NET이 플랫폼에 따라 자동으로 <code>.so</code>, <code>.dylib</code>, <code>.dll</code>을 추가한다).</p>
</li>
<li>
<p><strong><code>CallingConvention = CallingConvention.Cdecl</code></strong>: 인수 전달 및 스택 관리 방식을 지정한다. MLIR C API는 C 라이브러리의 표준인 C 호출 규약(<code>Cdecl</code>)을 사용한다.</p>
</li>
<li>
<p><strong><code>extern</code></strong>: 네이티브 코드에 정의된 외부 함수임을 표시한다.</p>
</li>
<li>
<p><strong>반환 타입과 매개변수</strong>: C 함수 시그니처와 정확히 일치해야 한다. MLIR은 불투명 구조체 핸들(내부 데이터 구조에 대한 포인터)을 사용하며, F#에서는 이를 <code>nativeint</code>로 표현한다.</p>
</li>
</ul>
<h3 id="mlir-핸들-타입"><a class="header" href="#mlir-핸들-타입">MLIR 핸들 타입</a></h3>
<p>MLIR C API는 모든 IR 엔티티에 불투명 구조체 타입을 사용한다:</p>
<pre><code class="language-c">// MLIR-C API (C header)
typedef struct MlirContext { void *ptr; } MlirContext;
typedef struct MlirModule { void *ptr; } MlirModule;
typedef struct MlirOperation { void *ptr; } MlirOperation;
// ... and many more
</code></pre>
<p>각 구조체는 포인터를 감싸는 래퍼다. F#의 관점에서는 내부 구조에 관심이 없고, MLIR 함수 간에 이 핸들들을 전달하기만 하면 된다. 단일 <code>nativeint</code> 필드를 가진 F# 구조체로 표현한다:</p>
<pre><code class="language-fsharp">[&lt;Struct&gt;]
type MlirContext =
    val Handle: nativeint
    new(handle) = { Handle = handle }
</code></pre>
<p>이는 C 메모리 레이아웃(단일 포인터)과 일치하며, P/Invoke 경계를 넘어 안전하게 전달할 수 있다.</p>
<h2 id="f-스크립트-생성"><a class="header" href="#f-스크립트-생성">F# 스크립트 생성</a></h2>
<p>코드를 작성해 본다. 작업 디렉터리에 <code>HelloMlir.fsx</code>라는 새 파일을 생성한다:</p>
<pre><code class="language-bash">cd $HOME
mkdir -p mlir-fsharp-tutorial
cd mlir-fsharp-tutorial
touch HelloMlir.fsx
</code></pre>
<p>텍스트 편집기에서 <code>HelloMlir.fsx</code>를 열고 필요한 import부터 시작한다:</p>
<pre><code class="language-fsharp">open System
open System.Runtime.InteropServices
</code></pre>
<ul>
<li><code>System</code>: .NET 핵심 타입</li>
<li><code>System.Runtime.InteropServices</code>: <code>DllImport</code>, <code>CallingConvention</code>, 마샬링 속성 포함</li>
</ul>
<h2 id="핸들-타입-정의"><a class="header" href="#핸들-타입-정의">핸들 타입 정의</a></h2>
<p>먼저 필요한 MLIR 핸들 타입을 정의한다. 이 간단한 예제에서는 다음이 필요하다:</p>
<ul>
<li><code>MlirContext</code>: MLIR 루트 context (메모리, dialect 등을 관리)</li>
<li><code>MlirModule</code>: module (함수의 최상위 컨테이너)</li>
<li><code>MlirLocation</code>: 소스 위치 정보 (operation 생성에 필요)</li>
<li><code>MlirType</code>: 타입 시스템 (<code>i32</code> 사용 예정)</li>
<li><code>MlirBlock</code>: 기본 블록</li>
<li><code>MlirRegion</code>: 블록을 포함하는 region</li>
<li><code>MlirOperation</code>: operation (함수나 산술 연산 생성 결과)</li>
<li><code>MlirValue</code>: SSA 값 (operation의 결과)</li>
</ul>
<p>스크립트에 다음 타입 정의를 추가한다:</p>
<pre><code class="language-fsharp">[&lt;Struct&gt;]
type MlirContext =
    val Handle: nativeint
    new(handle) = { Handle = handle }

[&lt;Struct&gt;]
type MlirModule =
    val Handle: nativeint
    new(handle) = { Handle = handle }

[&lt;Struct&gt;]
type MlirLocation =
    val Handle: nativeint
    new(handle) = { Handle = handle }

[&lt;Struct&gt;]
type MlirType =
    val Handle: nativeint
    new(handle) = { Handle = handle }

[&lt;Struct&gt;]
type MlirBlock =
    val Handle: nativeint
    new(handle) = { Handle = handle }

[&lt;Struct&gt;]
type MlirRegion =
    val Handle: nativeint
    new(handle) = { Handle = handle }

[&lt;Struct&gt;]
type MlirOperation =
    val Handle: nativeint
    new(handle) = { Handle = handle }

[&lt;Struct&gt;]
type MlirValue =
    val Handle: nativeint
    new(handle) = { Handle = handle }
</code></pre>
<p>각 핸들은 네이티브 포인터를 감싸는 얇은 래퍼다. <code>[&lt;Struct&gt;]</code> 속성은 이들이 힙에 할당되는 클래스가 아닌 스택에 할당되는 값 타입임을 보장하며, 작은 래퍼에 대해 더 효율적이다.</p>
<h2 id="문자열-마샬링-mlirstringref"><a class="header" href="#문자열-마샬링-mlirstringref">문자열 마샬링: MlirStringRef</a></h2>
<p>MLIR의 C API는 소유권 문제 없이 문자열을 전달하기 위해 <code>MlirStringRef</code>라는 사용자 정의 문자열 구조체를 사용한다. C에서는 다음과 같이 정의되어 있다:</p>
<pre><code class="language-c">typedef struct MlirStringRef {
    const char *data;
    size_t length;
} MlirStringRef;
</code></pre>
<p>이 레이아웃을 F#에서 맞춰야 한다:</p>
<pre><code class="language-fsharp">[&lt;Struct; StructLayout(LayoutKind.Sequential)&gt;]
type MlirStringRef =
    val Data: nativeint  // const char*
    val Length: nativeint  // size_t

    new(data, length) = { Data = data; Length = length }

    static member FromString(s: string) =
        let bytes = System.Text.Encoding.UTF8.GetBytes(s)
        let ptr = Marshal.AllocHGlobal(bytes.Length)
        Marshal.Copy(bytes, 0, ptr, bytes.Length)
        MlirStringRef(ptr, nativeint bytes.Length)

    member this.Free() =
        if this.Data &lt;&gt; nativeint 0 then
            Marshal.FreeHGlobal(this.Data)
</code></pre>
<p>세부 사항을 살펴본다:</p>
<ul>
<li>
<p><strong><code>[&lt;StructLayout(LayoutKind.Sequential)&gt;]</code></strong>: 필드가 선언된 순서대로 메모리에 배치되도록 보장한다 (C 구조체와 일치).</p>
</li>
<li>
<p><strong><code>FromString(s: string)</code></strong>: F# 문자열을 <code>MlirStringRef</code>로 변환하는 헬퍼다. 비관리 메모리를 할당하고, UTF-8 바이트를 복사한 후, 해당 메모리를 가리키는 <code>MlirStringRef</code>를 반환한다.</p>
</li>
<li>
<p><strong><code>Free()</code></strong>: 비관리 메모리를 해제한다. 문자열을 MLIR에 전달한 후 반드시 호출해야 하며, 그렇지 않으면 메모리 누수가 발생한다.</p>
</li>
</ul>
<h2 id="pinvoke-함수-선언"><a class="header" href="#pinvoke-함수-선언">P/Invoke 함수 선언</a></h2>
<p>이제 P/Invoke 선언을 작성한다. 이 예제에 필요한 함수만 선언한다. 스크립트에 다음을 추가한다:</p>
<pre><code class="language-fsharp">module MlirNative =
    // Context management
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirContext mlirContextCreate()

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirContextDestroy(MlirContext ctx)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirDialectHandle mlirGetDialectHandle__func__()

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirDialectHandle mlirGetDialectHandle__arith__()

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirDialectHandleRegisterDialect(MlirDialectHandle handle, MlirContext ctx)

    // Module management
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirModule mlirModuleCreateEmpty(MlirLocation loc)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirModuleGetOperation(MlirModule m)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirModuleDestroy(MlirModule m)

    // Location
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirLocation mlirLocationUnknownGet(MlirContext ctx)

    // Types
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirIntegerTypeGet(MlirContext ctx, uint32 bitwidth)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirFunctionTypeGet(MlirContext ctx, nativeint numInputs, MlirType&amp; inputs, nativeint numResults, MlirType&amp; results)

    // Operation building
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirOperationCreate(MlirOperationState&amp; state)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirRegion mlirOperationGetRegion(MlirOperation op, nativeint pos)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirRegionAppendOwnedBlock(MlirRegion region, MlirBlock block)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirBlock mlirBlockCreate(nativeint numArgs, MlirType&amp; argTypes, MlirLocation&amp; argLocs)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirBlockInsertOwnedOperation(MlirBlock block, nativeint pos, MlirOperation op)

    // Printing
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirOperationPrint(MlirOperation op, MlirStringCallback callback, nativeint userData)
</code></pre>
<p>함수 시그니처에 등장한 추가 핸들 타입도 필요하다:</p>
<pre><code class="language-fsharp">[&lt;Struct&gt;]
type MlirDialectHandle =
    val Handle: nativeint
    new(handle) = { Handle = handle }

[&lt;Struct&gt;]
type MlirOperationState =
    val Name: MlirStringRef
    val Location: MlirLocation
    val NumResults: nativeint
    val Results: nativeint  // Pointer to MlirType array
    val NumOperands: nativeint
    val Operands: nativeint  // Pointer to MlirValue array
    val NumRegions: nativeint
    val Regions: nativeint  // Pointer to MlirRegion array
    val NumSuccessors: nativeint
    val Successors: nativeint  // Pointer to MlirBlock array
    val NumAttributes: nativeint
    val Attributes: nativeint  // Pointer to MlirNamedAttribute array
    val EnableResultTypeInference: bool
</code></pre>
<p>그리고 출력을 위한 콜백 delegate도 필요하다:</p>
<pre><code class="language-fsharp">[&lt;UnmanagedFunctionPointer(CallingConvention.Cdecl)&gt;]
type MlirStringCallback = delegate of MlirStringRef * nativeint -&gt; unit
</code></pre>
<p>이 delegate는 IR 출력 시 MLIR이 F# 코드를 콜백할 수 있게 해준다. MLIR은 출력의 각 청크마다 콜백을 호출한다.</p>
<h2 id="mlir-module-구성하기"><a class="header" href="#mlir-module-구성하기">MLIR Module 구성하기</a></h2>
<p>이제 MLIR module을 생성하는 로직을 작성한다. 스크립트에 다음 함수를 추가한다:</p>
<pre><code class="language-fsharp">let buildHelloMlir() =
    // Step 1: Create MLIR context
    let ctx = MlirNative.mlirContextCreate()
    printfn "Created MLIR context"

    // Step 2: Load required dialects (func and arith)
    let funcDialect = MlirNative.mlirGetDialectHandle__func__()
    MlirNative.mlirDialectHandleRegisterDialect(funcDialect, ctx)
    let arithDialect = MlirNative.mlirGetDialectHandle__arith__()
    MlirNative.mlirDialectHandleRegisterDialect(arithDialect, ctx)
    printfn "Registered func and arith dialects"

    // Step 3: Create an empty module
    let loc = MlirNative.mlirLocationUnknownGet(ctx)
    let mlirModule = MlirNative.mlirModuleCreateEmpty(loc)
    printfn "Created empty module"

    // Step 4: Create the function type () -&gt; i32
    let i32Type = MlirNative.mlirIntegerTypeGet(ctx, 32u)
    let mutable resultType = i32Type
    let funcType = MlirNative.mlirFunctionTypeGet(ctx, nativeint 0, &amp;i32Type, nativeint 1, &amp;resultType)
    printfn "Created function type () -&gt; i32"

    // Step 5: Create func.func operation
    let funcName = MlirStringRef.FromString("func.func")
    let mutable funcState =
        { MlirOperationState.Name = funcName
          Location = loc
          NumResults = nativeint 0
          Results = nativeint 0
          NumOperands = nativeint 0
          Operands = nativeint 0
          NumRegions = nativeint 1  // Function body is a region
          Regions = nativeint 0
          NumSuccessors = nativeint 0
          Successors = nativeint 0
          NumAttributes = nativeint 0
          Attributes = nativeint 0
          EnableResultTypeInference = false }

    let funcOp = MlirNative.mlirOperationCreate(&amp;funcState)
    funcName.Free()
    printfn "Created func.func operation"

    // Step 6: Create a block for the function body
    let funcRegion = MlirNative.mlirOperationGetRegion(funcOp, nativeint 0)
    let block = MlirNative.mlirBlockCreate(nativeint 0, &amp;i32Type, &amp;loc)
    MlirNative.mlirRegionAppendOwnedBlock(funcRegion, block)
    printfn "Created function body block"

    // Step 7: Create arith.constant 42 : i32
    let constantName = MlirStringRef.FromString("arith.constant")
    let mutable constantState =
        { MlirOperationState.Name = constantName
          Location = loc
          NumResults = nativeint 1
          Results = Marshal.AllocHGlobal(sizeof&lt;nativeint&gt;)
          NumOperands = nativeint 0
          Operands = nativeint 0
          NumRegions = nativeint 0
          Regions = nativeint 0
          NumSuccessors = nativeint 0
          Successors = nativeint 0
          NumAttributes = nativeint 0
          Attributes = nativeint 0
          EnableResultTypeInference = false }
    Marshal.StructureToPtr(i32Type, constantState.Results, false)

    let constantOp = MlirNative.mlirOperationCreate(&amp;constantState)
    constantName.Free()
    Marshal.FreeHGlobal(constantState.Results)
    printfn "Created arith.constant operation"

    // Step 8: Create return operation
    let returnName = MlirStringRef.FromString("func.return")
    let mutable returnState =
        { MlirOperationState.Name = returnName
          Location = loc
          NumResults = nativeint 0
          Results = nativeint 0
          NumOperands = nativeint 1
          Operands = nativeint 0  // Should point to constant's result
          NumRegions = nativeint 0
          Regions = nativeint 0
          NumSuccessors = nativeint 0
          Successors = nativeint 0
          NumAttributes = nativeint 0
          Attributes = nativeint 0
          EnableResultTypeInference = false }

    let returnOp = MlirNative.mlirOperationCreate(&amp;returnState)
    returnName.Free()
    printfn "Created func.return operation"

    // Step 9: Insert operations into the block
    MlirNative.mlirBlockInsertOwnedOperation(block, nativeint 0, constantOp)
    MlirNative.mlirBlockInsertOwnedOperation(block, nativeint 1, returnOp)
    printfn "Inserted operations into block"

    // Step 10: Get module operation and print
    let moduleOp = MlirNative.mlirModuleGetOperation(mlirModule)
    printfn "\n--- Generated MLIR IR ---"

    let mutable output = ""
    let callback = MlirStringCallback(fun strRef _ -&gt;
        let length = int strRef.Length
        let bytes = Array.zeroCreate&lt;byte&gt; length
        Marshal.Copy(strRef.Data, bytes, 0, length)
        let text = System.Text.Encoding.UTF8.GetString(bytes)
        output &lt;- output + text
    )

    MlirNative.mlirOperationPrint(moduleOp, callback, nativeint 0)
    printfn "%s" output
    printfn "--- End of IR ---\n"

    // Cleanup
    MlirNative.mlirModuleDestroy(mlirModule)
    MlirNative.mlirContextDestroy(ctx)
    printfn "Cleaned up MLIR context and module"
</code></pre>
<p>이 함수에는 많은 내용이 있으므로 단계별로 살펴본다.</p>
<h2 id="단계별-분석"><a class="header" href="#단계별-분석">단계별 분석</a></h2>
<h3 id="1단계-mlir-context-생성"><a class="header" href="#1단계-mlir-context-생성">1단계: MLIR Context 생성</a></h3>
<pre><code class="language-fsharp">let ctx = MlirNative.mlirContextCreate()
</code></pre>
<p>MLIR context는 등록된 dialect, 타입 고유화, 메모리 관리 등 모든 MLIR 상태를 관리하는 루트 객체다. 다른 작업을 하기 전에 반드시 context를 생성해야 한다.</p>
<h3 id="2단계-dialect-로드"><a class="header" href="#2단계-dialect-로드">2단계: Dialect 로드</a></h3>
<pre><code class="language-fsharp">let funcDialect = MlirNative.mlirGetDialectHandle__func__()
MlirNative.mlirDialectHandleRegisterDialect(funcDialect, ctx)
let arithDialect = MlirNative.mlirGetDialectHandle__arith__()
MlirNative.mlirDialectHandleRegisterDialect(arithDialect, ctx)
</code></pre>
<p>MLIR dialect은 요청 시 로드된다. 함수 정의를 위한 <code>func</code> dialect과 상수 및 산술 연산을 위한 <code>arith</code> dialect이 필요하다. 각 dialect에는 getter 함수(<code>mlirGetDialectHandle__&lt;dialect&gt;__</code>)가 있으며, 이를 context에 등록한다.</p>
<h3 id="3단계-빈-module-생성"><a class="header" href="#3단계-빈-module-생성">3단계: 빈 Module 생성</a></h3>
<pre><code class="language-fsharp">let loc = MlirNative.mlirLocationUnknownGet(ctx)
let mlirModule = MlirNative.mlirModuleCreateEmpty(loc)
</code></pre>
<p>모든 MLIR operation에는 소스 위치가 필요하다. 생성된 코드의 경우 “unknown” 위치를 사용한다. 그런 다음 빈 module을 생성한다.</p>
<h3 id="4단계-함수-타입-생성"><a class="header" href="#4단계-함수-타입-생성">4단계: 함수 타입 생성</a></h3>
<pre><code class="language-fsharp">let i32Type = MlirNative.mlirIntegerTypeGet(ctx, 32u)
let mutable resultType = i32Type
let funcType = MlirNative.mlirFunctionTypeGet(ctx, nativeint 0, &amp;i32Type, nativeint 1, &amp;resultType)
</code></pre>
<p>함수 시그니처를 정의한다: 입력 없음(<code>nativeint 0</code>), 출력 하나(<code>i32</code>). <code>mlirFunctionTypeGet</code> 함수는 타입 배열에 대한 포인터를 받으므로 <code>&amp;</code>를 사용하여 참조로 전달한다.</p>
<h3 id="5-6단계-함수-operation-및-본문-block-생성"><a class="header" href="#5-6단계-함수-operation-및-본문-block-생성">5-6단계: 함수 Operation 및 본문 Block 생성</a></h3>
<p>MLIR에서 operation을 생성하려면 <code>MlirOperationState</code>를 구성하고 <code>mlirOperationCreate</code>를 호출해야 한다. 이것이 모든 operation 생성의 일반적인 패턴이다:</p>
<ol>
<li>operation 이름, 위치, 피연산자, 결과, region 등을 포함하는 <code>MlirOperationState</code> 생성</li>
<li><code>mlirOperationCreate(&amp;state)</code> 호출</li>
<li>할당된 메모리(operation 이름 문자열 등) 해제</li>
</ol>
<p>함수의 경우 region(함수 본문)과 그 안의 block도 생성한다.</p>
<h3 id="7-8단계-함수-내부-operation-생성"><a class="header" href="#7-8단계-함수-내부-operation-생성">7-8단계: 함수 내부 Operation 생성</a></h3>
<p>두 개의 operation을 생성한다:</p>
<ol>
<li><strong><code>arith.constant 42 : i32</code></strong>: 상수 operation이다. 하나의 결과(값 42)를 가진다.</li>
<li><strong><code>func.return %result</code></strong>: 반환 operation이다. 하나의 피연산자(상수의 결과)를 가진다.</li>
</ol>
<p>각 operation은 동일한 패턴을 따른다: <code>MlirOperationState</code> 생성, <code>mlirOperationCreate</code> 호출, 정리.</p>
<h3 id="9단계-operation을-block에-삽입"><a class="header" href="#9단계-operation을-block에-삽입">9단계: Operation을 Block에 삽입</a></h3>
<pre><code class="language-fsharp">MlirNative.mlirBlockInsertOwnedOperation(block, nativeint 0, constantOp)
MlirNative.mlirBlockInsertOwnedOperation(block, nativeint 1, returnOp)
</code></pre>
<p>Operation은 실행 순서대로 block에 삽입해야 한다. 상수가 먼저(위치 0), 그다음 반환(위치 1)이다.</p>
<h3 id="10단계-ir-출력"><a class="header" href="#10단계-ir-출력">10단계: IR 출력</a></h3>
<pre><code class="language-fsharp">let callback = MlirStringCallback(fun strRef _ -&gt;
    // MlirStringRef를 F# 문자열로 변환
    // output 변수에 누적
)
MlirNative.mlirOperationPrint(moduleOp, callback, nativeint 0)
</code></pre>
<p>MLIR의 출력 함수는 콜백을 사용한다. 콜백은 출력의 청크마다 여러 번 호출된다. 이 청크들을 하나의 문자열로 누적하여 출력한다.</p>
<h3 id="정리"><a class="header" href="#정리">정리</a></h3>
<pre><code class="language-fsharp">MlirNative.mlirModuleDestroy(mlirModule)
MlirNative.mlirContextDestroy(ctx)
</code></pre>
<p>메모리 누수를 방지하기 위해 항상 module과 context를 파괴해야 한다.</p>
<h2 id="스크립트-실행"><a class="header" href="#스크립트-실행">스크립트 실행</a></h2>
<p><code>HelloMlir.fsx</code> 파일 끝에 다음을 추가한다:</p>
<pre><code class="language-fsharp">[&lt;EntryPoint&gt;]
let main argv =
    buildHelloMlir()
    0
</code></pre>
<p>이제 F# Interactive로 스크립트를 실행한다:</p>
<pre><code class="language-bash">LD_LIBRARY_PATH=$HOME/mlir-install/lib dotnet fsi HelloMlir.fsx
</code></pre>
<p><strong>예상 출력:</strong></p>
<pre><code>Created MLIR context
Registered func and arith dialects
Created empty module
Created function type () -&gt; i32
Created func.func operation
Created function body block
Created arith.constant operation
Created func.return operation
Inserted operations into block

--- Generated MLIR IR ---
module {
  func.func @return_forty_two() -&gt; i32 {
    %c42 = arith.constant 42 : i32
    return %c42 : i32
  }
}
--- End of IR ---

Cleaned up MLIR context and module
</code></pre>
<p>이 출력이 보인다면 성공이다! F#에서 MLIR을 호출하고 프로그래밍 방식으로 IR을 생성하는 데 성공한 것이다.</p>
<h2 id="문제-해결"><a class="header" href="#문제-해결">문제 해결</a></h2>
<h3 id="dllnotfoundexception-unable-to-load-shared-library-mlir-c"><a class="header" href="#dllnotfoundexception-unable-to-load-shared-library-mlir-c">DllNotFoundException: Unable to load shared library ‘MLIR-C’</a></h3>
<p><strong>원인:</strong> .NET 런타임이 MLIR-C 공유 라이브러리를 찾을 수 없다.</p>
<p><strong>해결 방법:</strong> <code>LD_LIBRARY_PATH</code> (Linux) 또는 <code>DYLD_LIBRARY_PATH</code> (macOS)에 <code>$HOME/mlir-install/lib</code>이 포함되어 있는지 확인한다:</p>
<pre><code class="language-bash">export LD_LIBRARY_PATH=$HOME/mlir-install/lib:$LD_LIBRARY_PATH
dotnet fsi HelloMlir.fsx
</code></pre>
<p>또는 환경 변수를 인라인으로 지정하여 실행한다:</p>
<pre><code class="language-bash">LD_LIBRARY_PATH=$HOME/mlir-install/lib dotnet fsi HelloMlir.fsx
</code></pre>
<h3 id="accessviolationexception-또는-segmentation-fault"><a class="header" href="#accessviolationexception-또는-segmentation-fault">AccessViolationException 또는 Segmentation Fault</a></h3>
<p><strong>원인:</strong> 잘못된 P/Invoke 시그니처 (잘못된 매개변수 타입, byref 매개변수에 <code>&amp;</code> 누락 등).</p>
<p><strong>해결 방법:</strong> <code>DllImport</code> 선언이 MLIR-C API 헤더 파일과 정확히 일치하는지 확인한다. <a href="https://mlir.llvm.org/docs/CAPI/">MLIR-C API 문서</a>와 <code>$HOME/mlir-install/include/mlir-c/</code>의 헤더 파일을 참고한다.</p>
<h3 id="비어있거나-잘못된-형식의-ir-출력"><a class="header" href="#비어있거나-잘못된-형식의-ir-출력">비어있거나 잘못된 형식의 IR 출력</a></h3>
<p><strong>원인:</strong> Operation이 block에 제대로 삽입되지 않았거나, region이 operation에 제대로 연결되지 않았다.</p>
<p><strong>해결 방법:</strong> 연산 순서를 확인한다: operation 생성 -&gt; region 가져오기 -&gt; block 생성 -&gt; block에 operation 삽입.</p>
<h2 id="배운-내용"><a class="header" href="#배운-내용">배운 내용</a></h2>
<p>이 챕터에서 다음을 배웠다:</p>
<ol>
<li><strong>MLIR 핸들 타입 정의</strong> - 네이티브 포인터를 감싸는 F# 구조체로 정의했다.</li>
<li><strong><code>[&lt;DllImport&gt;]</code> 사용</strong> - 외부 MLIR-C API 함수를 선언했다.</li>
<li><strong>문자열 마샬링</strong> - <code>MlirStringRef</code>와 수동 메모리 관리를 사용했다.</li>
<li><strong>MLIR context와 module 생성</strong> - 처음부터 생성했다.</li>
<li><strong>프로그래밍 방식으로 operation 구성</strong> - <code>MlirOperationState</code>를 사용했다.</li>
<li><strong>MLIR IR 출력</strong> - 콜백을 사용했다.</li>
<li><strong>메모리 관리</strong> - 완료 후 context와 module을 파괴했다.</li>
</ol>
<p>이제 F#이 MLIR과 상호운용될 수 있다는 것이 증명되었다. 하지만 이 코드는 정돈되지 않았다 – 타입과 P/Invoke 함수를 스크립트에 인라인으로 정의하고 있다. 실제 컴파일러에서는 이 바인딩들이 재사용 가능한 모듈로 구성되어야 한다.</p>
<h2 id="다음-챕터"><a class="header" href="#다음-챕터">다음 챕터</a></h2>
<p><a href="#chapter-03-pinvoke-바인딩">챕터 03: P/Invoke 바인딩</a>으로 이어서 이 바인딩들을 깔끔한 API와 MLIR-C API의 포괄적인 커버리지를 갖춘 적절한 F# 모듈로 구성하는 방법을 배운다.</p>
<h2 id="추가-참고-자료"><a class="header" href="#추가-참고-자료">추가 참고 자료</a></h2>
<ul>
<li><a href="https://mlir.llvm.org/docs/CAPI/">MLIR C API Documentation</a> – MLIR C API 설계 및 사용 패턴에 대한 공식 가이드.</li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke">.NET P/Invoke Documentation</a> – .NET에서의 Platform Invoke 종합 가이드.</li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/standard/native-interop/type-marshalling">Marshalling in .NET</a> – .NET이 관리 타입과 비관리 타입 간에 변환하는 방법.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-03-pinvoke-바인딩"><a class="header" href="#chapter-03-pinvoke-바인딩">Chapter 03: P/Invoke 바인딩</a></h1>
<h2 id="소개-3"><a class="header" href="#소개-3">소개</a></h2>
<p>Chapter 02에서는 MLIR IR을 생성하는 첫 번째 F# 프로그램을 작성했다. 핸들 타입을 정의하고, <code>DllImport</code> 선언을 작성하며, MLIR C API를 성공적으로 호출하여 간단한 함수를 만들었다. 하지만 그 코드는 탐색적이고 임시방편적이었다 – 모든 바인딩이 스크립트 내에 인라인으로 정의되어 있었다.</p>
<p>실제 컴파일러에는 체계적이고 재사용 가능한 바인딩이 필요하다. 이 장에서는 Chapter 02에서 배운 모든 것을 가져와 적절한 F# 모듈인 <code>MlirBindings.fs</code>로 체계화한다. 이 모듈은 이후 모든 장의 기반이 된다. 이 장에서 배울 내용은 다음과 같다:</p>
<ul>
<li>기능 영역별(context, module, type, operation 등)로 MLIR C API 바인딩을 구성하는 방법</li>
<li>문자열 마샬링을 올바르고 안전하게 처리하는 방법</li>
<li>IR 출력을 위한 콜백 처리 방법</li>
<li>크로스 플랫폼 고려 사항 (Linux, macOS, Windows)</li>
</ul>
<p>이 장을 마치면 MLIR C API에 대한 완전하고 프로덕션에 사용할 수 있는 바인딩 레이어를 갖추게 된다.</p>
<h2 id="설계-철학"><a class="header" href="#설계-철학">설계 철학</a></h2>
<p>바인딩 레이어는 다음 원칙을 따른다:</p>
<ol>
<li><strong>얇은 래퍼:</strong> C API 위에 최소한의 추상화만 적용한다. 각 F# 함수는 C 함수에 직접 대응된다.</li>
<li><strong>타입 안전성:</strong> MLIR 핸들에 F# struct 타입을 사용하여 컴파일 시점에 타입 오류를 잡는다.</li>
<li><strong>메모리 안전성:</strong> 안전한 문자열 마샬링과 정리를 위한 유틸리티를 제공하되, destroy 함수를 호출해야 하는 필요성을 숨기지 않는다.</li>
<li><strong>완전성:</strong> 컴파일러에 필요한 모든 MLIR C API 함수를 다룬다 (context, module, type, operation, region, block, location, attribute, value).</li>
<li><strong>문서화:</strong> 모든 함수에 목적과 MLIR C API 대응 관계를 설명하는 주석이 있다.</li>
</ol>
<h2 id="프로젝트-구조"><a class="header" href="#프로젝트-구조">프로젝트 구조</a></h2>
<p>코드를 작성하기 전에 적절한 F# 프로젝트를 설정한다. Chapter 02에서는 스크립트(<code>.fsx</code>)를 사용했지만, 이제 라이브러리 프로젝트를 만든다:</p>
<pre><code class="language-bash">cd $HOME/mlir-fsharp-tutorial
dotnet new classlib -lang F# -o MlirBindings
cd MlirBindings
</code></pre>
<p>이렇게 하면 다음과 같은 구조의 새 F# 라이브러리 프로젝트가 생성된다:</p>
<pre><code>MlirBindings/
├── MlirBindings.fsproj
└── Library.fs
</code></pre>
<p>기본 <code>Library.fs</code>를 삭제한다:</p>
<pre><code class="language-bash">rm Library.fs
</code></pre>
<p><code>MlirBindings.fs</code>를 처음부터 새로 만든다.</p>
<h2 id="모듈-구성"><a class="header" href="#모듈-구성">모듈 구성</a></h2>
<p>바인딩 모듈은 다음과 같은 논리적 섹션으로 구성된다:</p>
<ol>
<li><strong>핸들 타입:</strong> MLIR 불투명 타입을 나타내는 F# struct</li>
<li><strong>문자열 마샬링:</strong> <code>MlirStringRef</code>와 헬퍼 함수</li>
<li><strong>콜백 델리게이트:</strong> MLIR 콜백을 위한 함수 포인터 타입</li>
<li><strong>Context 관리:</strong> Context 생성, 소멸, dialect 로딩</li>
<li><strong>Module 관리:</strong> Module 생성, 연산, 출력</li>
<li><strong>Location:</strong> 소스 위치 유틸리티</li>
<li><strong>타입 시스템:</strong> 정수 타입, 함수 타입, LLVM 타입</li>
<li><strong>Operation 빌딩:</strong> Operation state 생성 및 조립</li>
<li><strong>Region과 Block:</strong> Region 및 Block 생성과 관리</li>
<li><strong>Value와 Attribute:</strong> SSA value 및 attribute 처리</li>
</ol>
<p>단계별로 구축해 본다.</p>
<h2 id="핸들-타입"><a class="header" href="#핸들-타입">핸들 타입</a></h2>
<p><code>MlirBindings</code> 디렉토리에 새 파일 <code>MlirBindings.fs</code>를 생성한다:</p>
<pre><code class="language-bash">touch MlirBindings.fs
</code></pre>
<p>프로젝트 파일 <code>MlirBindings.fsproj</code>를 편집하여 파일을 추가한다. 내용을 다음으로 교체한다:</p>
<pre><code class="language-xml">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;

  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;
    &lt;GenerateDocumentationFile&gt;true&lt;/GenerateDocumentationFile&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemGroup&gt;
    &lt;Compile Include="MlirBindings.fs" /&gt;
  &lt;/ItemGroup&gt;

&lt;/Project&gt;
</code></pre>
<p>이제 <code>MlirBindings.fs</code>를 열고 namespace와 import부터 시작한다:</p>
<pre><code class="language-fsharp">namespace MlirBindings

open System
open System.Runtime.InteropServices
</code></pre>
<p>필요한 모든 핸들 타입을 정의한다. 이것들은 MLIR 내부 구조체에 대한 불투명 포인터이다:</p>
<pre><code class="language-fsharp">/// MLIR context - manages dialects, types, and global state
[&lt;Struct&gt;]
type MlirContext =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR module - top-level container for functions and global data
[&lt;Struct&gt;]
type MlirModule =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR operation - fundamental IR unit (instructions, functions, etc.)
[&lt;Struct&gt;]
type MlirOperation =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR type - represents value types (i32, f64, pointers, etc.)
[&lt;Struct&gt;]
type MlirType =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR location - source code location for diagnostics
[&lt;Struct&gt;]
type MlirLocation =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR region - contains a list of blocks
[&lt;Struct&gt;]
type MlirRegion =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR block - basic block containing a sequence of operations
[&lt;Struct&gt;]
type MlirBlock =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR value - SSA value produced by an operation
[&lt;Struct&gt;]
type MlirValue =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR attribute - compile-time constant metadata
[&lt;Struct&gt;]
type MlirAttribute =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR named attribute - key-value pair (name: attribute)
[&lt;Struct; StructLayout(LayoutKind.Sequential)&gt;]
type MlirNamedAttribute =
    val Name: MlirStringRef
    val Attribute: MlirAttribute

/// MLIR dialect handle - opaque handle to a registered dialect
[&lt;Struct&gt;]
type MlirDialectHandle =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR identifier - interned string for operation names, attribute keys, etc.
[&lt;Struct&gt;]
type MlirIdentifier =
    val Handle: nativeint
    new(handle) = { Handle = handle }
</code></pre>
<p>각 핸들 타입에는 목적을 설명하는 문서 주석이 포함되어 있다. <code>[&lt;Struct&gt;]</code> 어트리뷰트는 이들이 스택에 할당되는 값 타입임을 보장한다.</p>
<h2 id="문자열-마샬링"><a class="header" href="#문자열-마샬링">문자열 마샬링</a></h2>
<p>MLIR은 소유권 의미 없이 문자열을 전달하기 위해 <code>MlirStringRef</code>를 사용한다. 헬퍼 유틸리티와 함께 정의한다:</p>
<pre><code class="language-fsharp">/// MLIR string reference - non-owning pointer to string data
[&lt;Struct; StructLayout(LayoutKind.Sequential)&gt;]
type MlirStringRef =
    val Data: nativeint  // const char*
    val Length: nativeint  // size_t

    new(data, length) = { Data = data; Length = length }

    /// Convert F# string to MlirStringRef (allocates unmanaged memory)
    static member FromString(s: string) =
        if String.IsNullOrEmpty(s) then
            MlirStringRef(nativeint 0, nativeint 0)
        else
            let bytes = System.Text.Encoding.UTF8.GetBytes(s)
            let ptr = Marshal.AllocHGlobal(bytes.Length)
            Marshal.Copy(bytes, 0, ptr, bytes.Length)
            MlirStringRef(ptr, nativeint bytes.Length)

    /// Convert MlirStringRef to F# string
    member this.ToString() =
        if this.Data = nativeint 0 || this.Length = nativeint 0 then
            String.Empty
        else
            let length = int this.Length
            let bytes = Array.zeroCreate&lt;byte&gt; length
            Marshal.Copy(this.Data, bytes, 0, length)
            System.Text.Encoding.UTF8.GetString(bytes)

    /// Free unmanaged memory (call after passing to MLIR)
    member this.Free() =
        if this.Data &lt;&gt; nativeint 0 then
            Marshal.FreeHGlobal(this.Data)

    /// Create from string, use it, and automatically free
    static member WithString(s: string, f: MlirStringRef -&gt; 'a) =
        let strRef = MlirStringRef.FromString(s)
        try
            f strRef
        finally
            strRef.Free()
</code></pre>
<p><code>WithString</code> 헬퍼는 특히 유용하다 – 할당과 정리를 자동으로 처리한다:</p>
<pre><code class="language-fsharp">// 이렇게 하는 대신:
let strRef = MlirStringRef.FromString("func.func")
let op = createOp strRef
strRef.Free()

// 다음과 같이 작성할 수 있습니다:
MlirStringRef.WithString "func.func" (fun strRef -&gt;
    createOp strRef
)
</code></pre>
<h2 id="콜백-델리게이트"><a class="header" href="#콜백-델리게이트">콜백 델리게이트</a></h2>
<p>MLIR은 출력과 문자열 처리를 위해 콜백을 사용한다. 델리게이트 타입을 정의한다:</p>
<pre><code class="language-fsharp">/// Callback for MLIR IR printing (invoked with chunks of output)
[&lt;UnmanagedFunctionPointer(CallingConvention.Cdecl)&gt;]
type MlirStringCallback = delegate of MlirStringRef * nativeint -&gt; unit

/// Callback for diagnostic handlers
[&lt;UnmanagedFunctionPointer(CallingConvention.Cdecl)&gt;]
type MlirDiagnosticCallback = delegate of MlirDiagnostic * nativeint -&gt; MlirLogicalResult

/// MLIR diagnostic handle
[&lt;Struct&gt;]
type MlirDiagnostic =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR logical result (success/failure)
[&lt;Struct&gt;]
type MlirLogicalResult =
    val Value: int8
    new(value) = { Value = value }
    member this.IsSuccess = this.Value &lt;&gt; 0y
    member this.IsFailure = this.Value = 0y
</code></pre>
<h2 id="operation-state"><a class="header" href="#operation-state">Operation State</a></h2>
<p><code>MlirOperationState</code> struct는 operation을 빌드하는 데 사용된다. 배열에 대한 포인터를 포함하기 때문에 복잡하다:</p>
<pre><code class="language-fsharp">/// MLIR operation state - used to construct operations
[&lt;Struct; StructLayout(LayoutKind.Sequential)&gt;]
type MlirOperationState =
    val mutable Name: MlirStringRef
    val mutable Location: MlirLocation
    val mutable NumResults: nativeint
    val mutable Results: nativeint  // Pointer to MlirType array
    val mutable NumOperands: nativeint
    val mutable Operands: nativeint  // Pointer to MlirValue array
    val mutable NumRegions: nativeint
    val mutable Regions: nativeint  // Pointer to MlirRegion array
    val mutable NumSuccessors: nativeint
    val mutable Successors: nativeint  // Pointer to MlirBlock array
    val mutable NumAttributes: nativeint
    val mutable Attributes: nativeint  // Pointer to MlirNamedAttribute array
    val mutable EnableResultTypeInference: bool
</code></pre>
<p>참고: <code>mlirOperationCreate</code>에 전달하기 전에 수정해야 하므로 모든 필드가 mutable이다.</p>
<h2 id="pinvoke-선언"><a class="header" href="#pinvoke-선언">P/Invoke 선언</a></h2>
<p>이제 핵심 부분이다: MLIR C API에 대한 P/Invoke 선언이다. 모듈로 구성한다:</p>
<pre><code class="language-fsharp">module MlirNative =

    //==========================================================================
    // Context 관리
    //==========================================================================

    /// Create an MLIR context
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirContext mlirContextCreate()

    /// Destroy an MLIR context (frees all owned IR)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirContextDestroy(MlirContext ctx)

    /// Check if two contexts are equal
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern bool mlirContextEqual(MlirContext ctx1, MlirContext ctx2)

    /// Get dialect handle for the 'func' dialect
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirDialectHandle mlirGetDialectHandle__func__()

    /// Get dialect handle for the 'arith' dialect
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirDialectHandle mlirGetDialectHandle__arith__()

    /// Get dialect handle for the 'scf' (structured control flow) dialect
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirDialectHandle mlirGetDialectHandle__scf__()

    /// Get dialect handle for the 'cf' (control flow) dialect
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirDialectHandle mlirGetDialectHandle__cf__()

    /// Get dialect handle for the 'llvm' dialect
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirDialectHandle mlirGetDialectHandle__llvm__()

    /// Register a dialect with a context
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirDialectHandleRegisterDialect(MlirDialectHandle handle, MlirContext ctx)

    //==========================================================================
    // Module 관리
    //==========================================================================

    /// Create an empty MLIR module
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirModule mlirModuleCreateEmpty(MlirLocation loc)

    /// Create an MLIR module from parsing a string
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirModule mlirModuleCreateParse(MlirContext ctx, MlirStringRef mlir)

    /// Get the top-level operation of a module
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirModuleGetOperation(MlirModule m)

    /// Get the body (region) of a module
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirRegion mlirModuleGetBody(MlirModule m)

    /// Destroy a module (frees all owned IR)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirModuleDestroy(MlirModule m)

    //==========================================================================
    // Location
    //==========================================================================

    /// Create an unknown location (for generated code)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirLocation mlirLocationUnknownGet(MlirContext ctx)

    /// Create a file-line-column location
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirLocation mlirLocationFileLineColGet(MlirContext ctx, MlirStringRef filename, uint32 line, uint32 col)

    /// Create a fused location (combination of multiple locations)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirLocation mlirLocationFusedGet(MlirContext ctx, nativeint numLocs, MlirLocation&amp; locs, MlirAttribute metadata)

    //==========================================================================
    // 타입 시스템
    //==========================================================================

    /// Create an integer type with specified bit width
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirIntegerTypeGet(MlirContext ctx, uint32 bitwidth)

    /// Create a signed integer type
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirIntegerTypeSignedGet(MlirContext ctx, uint32 bitwidth)

    /// Create an unsigned integer type
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirIntegerTypeUnsignedGet(MlirContext ctx, uint32 bitwidth)

    /// Create a floating-point type (f32, f64, etc.)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirF32TypeGet(MlirContext ctx)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirF64TypeGet(MlirContext ctx)

    /// Create the index type (platform-dependent integer for indexing)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirIndexTypeGet(MlirContext ctx)

    /// Create a function type
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirFunctionTypeGet(MlirContext ctx, nativeint numInputs, MlirType&amp; inputs, nativeint numResults, MlirType&amp; results)

    /// Get the number of inputs for a function type
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern nativeint mlirFunctionTypeGetNumInputs(MlirType funcType)

    /// Get the number of results for a function type
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern nativeint mlirFunctionTypeGetNumResults(MlirType funcType)

    /// Create an LLVM pointer type
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirLLVMPointerTypeGet(MlirContext ctx, uint32 addressSpace)

    /// Create an LLVM void type
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirLLVMVoidTypeGet(MlirContext ctx)

    /// Create an LLVM struct type
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirLLVMStructTypeLiteralGet(MlirContext ctx, nativeint numFieldTypes, MlirType&amp; fieldTypes, bool isPacked)

    //==========================================================================
    // Attribute 시스템
    //==========================================================================

    /// Create an integer attribute
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirAttribute mlirIntegerAttrGet(MlirType typ, int64 value)

    /// Create a float attribute
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirAttribute mlirFloatAttrDoubleGet(MlirContext ctx, MlirType typ, float64 value)

    /// Create a string attribute
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirAttribute mlirStringAttrGet(MlirContext ctx, MlirStringRef str)

    /// Create a type attribute
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirAttribute mlirTypeAttrGet(MlirType typ)

    /// Create a symbol reference attribute
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirAttribute mlirFlatSymbolRefAttrGet(MlirContext ctx, MlirStringRef symbol)

    /// Create an array attribute
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirAttribute mlirArrayAttrGet(MlirContext ctx, nativeint numElements, MlirAttribute&amp; elements)

    /// Get an identifier from a string
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirIdentifier mlirIdentifierGet(MlirContext ctx, MlirStringRef str)

    /// Create a named attribute
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirNamedAttribute mlirNamedAttributeGet(MlirIdentifier name, MlirAttribute attr)

    //==========================================================================
    // Operation 빌딩
    //==========================================================================

    /// Create an operation state
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperationState mlirOperationStateGet(MlirStringRef name, MlirLocation loc)

    /// Create an operation from an operation state
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirOperationCreate(MlirOperationState&amp; state)

    /// Destroy an operation (if not owned by a block)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirOperationDestroy(MlirOperation op)

    /// Get the name of an operation
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirIdentifier mlirOperationGetName(MlirOperation op)

    /// Get the number of regions in an operation
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern nativeint mlirOperationGetNumRegions(MlirOperation op)

    /// Get a region from an operation by index
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirRegion mlirOperationGetRegion(MlirOperation op, nativeint pos)

    /// Get the number of results an operation produces
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern nativeint mlirOperationGetNumResults(MlirOperation op)

    /// Get a result value from an operation by index
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirValue mlirOperationGetResult(MlirOperation op, nativeint pos)

    /// Get the number of operands an operation takes
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern nativeint mlirOperationGetNumOperands(MlirOperation op)

    /// Get an operand value from an operation by index
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirValue mlirOperationGetOperand(MlirOperation op, nativeint pos)

    /// Set an operand of an operation
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirOperationSetOperand(MlirOperation op, nativeint pos, MlirValue value)

    /// Print an operation to a callback
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirOperationPrint(MlirOperation op, MlirStringCallback callback, nativeint userData)

    /// Verify an operation (check IR well-formedness)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern bool mlirOperationVerify(MlirOperation op)

    //==========================================================================
    // Region 관리
    //==========================================================================

    /// Create a new region
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirRegion mlirRegionCreate()

    /// Destroy a region (if not owned by an operation)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirRegionDestroy(MlirRegion region)

    /// Append a block to a region (region takes ownership)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirRegionAppendOwnedBlock(MlirRegion region, MlirBlock block)

    /// Insert a block into a region at position (region takes ownership)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirRegionInsertOwnedBlock(MlirRegion region, nativeint pos, MlirBlock block)

    /// Get the first block in a region
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirBlock mlirRegionGetFirstBlock(MlirRegion region)

    //==========================================================================
    // Block 관리
    //==========================================================================

    /// Create a new block with arguments
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirBlock mlirBlockCreate(nativeint numArgs, MlirType&amp; argTypes, MlirLocation&amp; argLocs)

    /// Destroy a block (if not owned by a region)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirBlockDestroy(MlirBlock block)

    /// Get the number of arguments a block has
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern nativeint mlirBlockGetNumArguments(MlirBlock block)

    /// Get a block argument by index
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirValue mlirBlockGetArgument(MlirBlock block, nativeint pos)

    /// Append an operation to a block (block takes ownership)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirBlockAppendOwnedOperation(MlirBlock block, MlirOperation op)

    /// Insert an operation into a block at position (block takes ownership)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirBlockInsertOwnedOperation(MlirBlock block, nativeint pos, MlirOperation op)

    /// Get the first operation in a block
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirBlockGetFirstOperation(MlirBlock block)

    //==========================================================================
    // Value
    //==========================================================================

    /// Get the type of a value
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirValueGetType(MlirValue value)

    /// Print a value
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirValuePrint(MlirValue value, MlirStringCallback callback, nativeint userData)
</code></pre>
<p>이것은 컴파일러 구축에 필요한 모든 MLIR C API 함수를 다루는 포괄적인 바인딩 레이어이다. 각 함수에는 목적을 설명하는 문서가 포함되어 있다.</p>
<h2 id="크로스-플랫폼-라이브러리-로딩"><a class="header" href="#크로스-플랫폼-라이브러리-로딩">크로스 플랫폼 라이브러리 로딩</a></h2>
<p>중요한 세부 사항이 하나 있다: 라이브러리 이름 <code>"MLIR-C"</code>는 .NET이 자동으로 올바른 확장자를 추가하기 때문에 플랫폼 간에 동작한다:</p>
<ul>
<li><strong>Linux:</strong> <code>libMLIR-C.so</code></li>
<li><strong>macOS:</strong> <code>libMLIR-C.dylib</code></li>
<li><strong>Windows:</strong> <code>MLIR-C.dll</code></li>
</ul>
<p>그러나 .NET은 런타임에 라이브러리를 어디서 찾을 수 있는지 알아야 한다. 이 내용은 Chapter 00에서 다루었다 (<code>LD_LIBRARY_PATH</code> 또는 <code>DYLD_LIBRARY_PATH</code> 설정). 프로덕션 애플리케이션의 경우 여러 가지 옵션이 있다:</p>
<h3 id="옵션-1-환경-변수-개발-시"><a class="header" href="#옵션-1-환경-변수-개발-시">옵션 1: 환경 변수 (개발 시)</a></h3>
<p>실행 전에 라이브러리 경로를 설정한다:</p>
<pre><code class="language-bash">LD_LIBRARY_PATH=$HOME/mlir-install/lib dotnet run
</code></pre>
<h3 id="옵션-2-nativelibrarysetdllimportresolver-런타임"><a class="header" href="#옵션-2-nativelibrarysetdllimportresolver-런타임">옵션 2: NativeLibrary.SetDllImportResolver (런타임)</a></h3>
<p>.NET의 <code>NativeLibrary</code> API를 사용하여 커스텀 검색 경로를 지정한다:</p>
<pre><code class="language-fsharp">open System.Runtime.InteropServices

module LibraryLoader =
    let initialize() =
        NativeLibrary.SetDllImportResolver(
            typeof&lt;MlirContext&gt;.Assembly,
            fun libraryName assemblyPath searchPath -&gt;
                if libraryName = "MLIR-C" then
                    let customPath = Environment.GetEnvironmentVariable("MLIR_INSTALL_PATH")
                    if not (String.IsNullOrEmpty(customPath)) then
                        let libPath =
                            if RuntimeInformation.IsOSPlatform(OSPlatform.Linux) then
                                System.IO.Path.Combine(customPath, "lib", "libMLIR-C.so")
                            elif RuntimeInformation.IsOSPlatform(OSPlatform.OSX) then
                                System.IO.Path.Combine(customPath, "lib", "libMLIR-C.dylib")
                            else
                                System.IO.Path.Combine(customPath, "bin", "MLIR-C.dll")
                        NativeLibrary.Load(libPath)
                    else
                        nativeint 0
                else
                    nativeint 0
        )
</code></pre>
<p>MLIR 함수를 호출하기 전에 <code>LibraryLoader.initialize()</code>를 호출한다.</p>
<h3 id="옵션-3-rpath-linuxmacos-바이너리"><a class="header" href="#옵션-3-rpath-linuxmacos-바이너리">옵션 3: rpath (Linux/macOS 바이너리)</a></h3>
<p>컴파일된 바이너리의 경우, rpath를 사용하여 실행 파일에 라이브러리 검색 경로를 내장한다. 이 방법은 이 튜토리얼의 범위를 벗어나지만, 배포 애플리케이션의 표준 솔루션이다.</p>
<h2 id="헬퍼-유틸리티"><a class="header" href="#헬퍼-유틸리티">헬퍼 유틸리티</a></h2>
<p>자주 사용되는 패턴을 위한 고수준 헬퍼 함수를 추가한다:</p>
<pre><code class="language-fsharp">module MlirHelpers =
    /// Print an operation to a string
    let operationToString (op: MlirOperation) : string =
        let mutable output = ""
        let callback = MlirStringCallback(fun strRef _ -&gt;
            output &lt;- output + strRef.ToString()
        )
        MlirNative.mlirOperationPrint(op, callback, nativeint 0)
        output

    /// Print a module to a string
    let moduleToString (m: MlirModule) : string =
        let op = MlirNative.mlirModuleGetOperation(m)
        operationToString op

    /// Print a value to a string
    let valueToString (v: MlirValue) : string =
        let mutable output = ""
        let callback = MlirStringCallback(fun strRef _ -&gt;
            output &lt;- output + strRef.ToString()
        )
        MlirNative.mlirValuePrint(v, callback, nativeint 0)
        output

    /// Create a context with common dialects registered
    let createContextWithDialects() : MlirContext =
        let ctx = MlirNative.mlirContextCreate()
        MlirNative.mlirDialectHandleRegisterDialect(MlirNative.mlirGetDialectHandle__func__(), ctx)
        MlirNative.mlirDialectHandleRegisterDialect(MlirNative.mlirGetDialectHandle__arith__(), ctx)
        MlirNative.mlirDialectHandleRegisterDialect(MlirNative.mlirGetDialectHandle__scf__(), ctx)
        MlirNative.mlirDialectHandleRegisterDialect(MlirNative.mlirGetDialectHandle__cf__(), ctx)
        MlirNative.mlirDialectHandleRegisterDialect(MlirNative.mlirGetDialectHandle__llvm__(), ctx)
        ctx

    /// Create a block with no arguments
    let createEmptyBlock(ctx: MlirContext) : MlirBlock =
        let loc = MlirNative.mlirLocationUnknownGet(ctx)
        let mutable dummyType = MlirType()
        let mutable dummyLoc = loc
        MlirNative.mlirBlockCreate(nativeint 0, &amp;dummyType, &amp;dummyLoc)
</code></pre>
<p>이 유틸리티들은 일반적인 작업을 래핑하여 사용자 코드에서 보일러플레이트를 줄여 준다.</p>
<h2 id="전체-mlirbindingsfs-목록"><a class="header" href="#전체-mlirbindingsfs-목록">전체 MlirBindings.fs 목록</a></h2>
<p>다음은 모든 섹션이 통합된 완전한 <code>MlirBindings.fs</code> 파일이다:</p>
<pre><code class="language-fsharp">namespace MlirBindings

open System
open System.Runtime.InteropServices

//=============================================================================
// Handle Types
//=============================================================================

/// MLIR context - manages dialects, types, and global state
[&lt;Struct&gt;]
type MlirContext =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR module - top-level container for functions and global data
[&lt;Struct&gt;]
type MlirModule =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR operation - fundamental IR unit (instructions, functions, etc.)
[&lt;Struct&gt;]
type MlirOperation =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR type - represents value types (i32, f64, pointers, etc.)
[&lt;Struct&gt;]
type MlirType =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR location - source code location for diagnostics
[&lt;Struct&gt;]
type MlirLocation =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR region - contains a list of blocks
[&lt;Struct&gt;]
type MlirRegion =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR block - basic block containing a sequence of operations
[&lt;Struct&gt;]
type MlirBlock =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR value - SSA value produced by an operation
[&lt;Struct&gt;]
type MlirValue =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR attribute - compile-time constant metadata
[&lt;Struct&gt;]
type MlirAttribute =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR dialect handle - opaque handle to a registered dialect
[&lt;Struct&gt;]
type MlirDialectHandle =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR identifier - interned string for operation names, attribute keys, etc.
[&lt;Struct&gt;]
type MlirIdentifier =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR diagnostic handle
[&lt;Struct&gt;]
type MlirDiagnostic =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR logical result (success/failure)
[&lt;Struct&gt;]
type MlirLogicalResult =
    val Value: int8
    new(value) = { Value = value }
    member this.IsSuccess = this.Value &lt;&gt; 0y
    member this.IsFailure = this.Value = 0y

//=============================================================================
// String Marshalling
//=============================================================================

/// MLIR string reference - non-owning pointer to string data
[&lt;Struct; StructLayout(LayoutKind.Sequential)&gt;]
type MlirStringRef =
    val Data: nativeint
    val Length: nativeint

    new(data, length) = { Data = data; Length = length }

    static member FromString(s: string) =
        if String.IsNullOrEmpty(s) then
            MlirStringRef(nativeint 0, nativeint 0)
        else
            let bytes = System.Text.Encoding.UTF8.GetBytes(s)
            let ptr = Marshal.AllocHGlobal(bytes.Length)
            Marshal.Copy(bytes, 0, ptr, bytes.Length)
            MlirStringRef(ptr, nativeint bytes.Length)

    member this.ToString() =
        if this.Data = nativeint 0 || this.Length = nativeint 0 then
            String.Empty
        else
            let length = int this.Length
            let bytes = Array.zeroCreate&lt;byte&gt; length
            Marshal.Copy(this.Data, bytes, 0, length)
            System.Text.Encoding.UTF8.GetString(bytes)

    member this.Free() =
        if this.Data &lt;&gt; nativeint 0 then
            Marshal.FreeHGlobal(this.Data)

    static member WithString(s: string, f: MlirStringRef -&gt; 'a) =
        let strRef = MlirStringRef.FromString(s)
        try
            f strRef
        finally
            strRef.Free()

/// MLIR named attribute - key-value pair
[&lt;Struct; StructLayout(LayoutKind.Sequential)&gt;]
type MlirNamedAttribute =
    val Name: MlirStringRef
    val Attribute: MlirAttribute

//=============================================================================
// Callback Delegates
//=============================================================================

/// Callback for MLIR IR printing
[&lt;UnmanagedFunctionPointer(CallingConvention.Cdecl)&gt;]
type MlirStringCallback = delegate of MlirStringRef * nativeint -&gt; unit

/// Callback for diagnostic handlers
[&lt;UnmanagedFunctionPointer(CallingConvention.Cdecl)&gt;]
type MlirDiagnosticCallback = delegate of MlirDiagnostic * nativeint -&gt; MlirLogicalResult

//=============================================================================
// Operation State
//=============================================================================

/// MLIR operation state - used to construct operations
[&lt;Struct; StructLayout(LayoutKind.Sequential)&gt;]
type MlirOperationState =
    val mutable Name: MlirStringRef
    val mutable Location: MlirLocation
    val mutable NumResults: nativeint
    val mutable Results: nativeint
    val mutable NumOperands: nativeint
    val mutable Operands: nativeint
    val mutable NumRegions: nativeint
    val mutable Regions: nativeint
    val mutable NumSuccessors: nativeint
    val mutable Successors: nativeint
    val mutable NumAttributes: nativeint
    val mutable Attributes: nativeint
    val mutable EnableResultTypeInference: bool

//=============================================================================
// P/Invoke Declarations
//=============================================================================

module MlirNative =

    // Context Management
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirContext mlirContextCreate()

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirContextDestroy(MlirContext ctx)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirDialectHandle mlirGetDialectHandle__func__()

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirDialectHandle mlirGetDialectHandle__arith__()

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirDialectHandle mlirGetDialectHandle__scf__()

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirDialectHandle mlirGetDialectHandle__cf__()

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirDialectHandle mlirGetDialectHandle__llvm__()

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirDialectHandleRegisterDialect(MlirDialectHandle handle, MlirContext ctx)

    // Module Management
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirModule mlirModuleCreateEmpty(MlirLocation loc)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirModule mlirModuleCreateParse(MlirContext ctx, MlirStringRef mlir)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirModuleGetOperation(MlirModule m)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirRegion mlirModuleGetBody(MlirModule m)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirModuleDestroy(MlirModule m)

    // Location
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirLocation mlirLocationUnknownGet(MlirContext ctx)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirLocation mlirLocationFileLineColGet(MlirContext ctx, MlirStringRef filename, uint32 line, uint32 col)

    // Type System
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirIntegerTypeGet(MlirContext ctx, uint32 bitwidth)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirF32TypeGet(MlirContext ctx)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirF64TypeGet(MlirContext ctx)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirIndexTypeGet(MlirContext ctx)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirFunctionTypeGet(MlirContext ctx, nativeint numInputs, MlirType&amp; inputs, nativeint numResults, MlirType&amp; results)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirLLVMPointerTypeGet(MlirContext ctx, uint32 addressSpace)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirLLVMVoidTypeGet(MlirContext ctx)

    // Attributes
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirAttribute mlirIntegerAttrGet(MlirType typ, int64 value)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirAttribute mlirStringAttrGet(MlirContext ctx, MlirStringRef str)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirAttribute mlirTypeAttrGet(MlirType typ)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirIdentifier mlirIdentifierGet(MlirContext ctx, MlirStringRef str)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirNamedAttribute mlirNamedAttributeGet(MlirIdentifier name, MlirAttribute attr)

    // Operation Building
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperationState mlirOperationStateGet(MlirStringRef name, MlirLocation loc)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirOperationCreate(MlirOperationState&amp; state)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirOperationDestroy(MlirOperation op)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirRegion mlirOperationGetRegion(MlirOperation op, nativeint pos)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern nativeint mlirOperationGetNumResults(MlirOperation op)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirValue mlirOperationGetResult(MlirOperation op, nativeint pos)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirOperationSetOperand(MlirOperation op, nativeint pos, MlirValue value)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirOperationPrint(MlirOperation op, MlirStringCallback callback, nativeint userData)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern bool mlirOperationVerify(MlirOperation op)

    // Region Management
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirRegion mlirRegionCreate()

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirRegionAppendOwnedBlock(MlirRegion region, MlirBlock block)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirBlock mlirRegionGetFirstBlock(MlirRegion region)

    // Block Management
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirBlock mlirBlockCreate(nativeint numArgs, MlirType&amp; argTypes, MlirLocation&amp; argLocs)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern nativeint mlirBlockGetNumArguments(MlirBlock block)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirValue mlirBlockGetArgument(MlirBlock block, nativeint pos)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirBlockAppendOwnedOperation(MlirBlock block, MlirOperation op)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirBlockInsertOwnedOperation(MlirBlock block, nativeint pos, MlirOperation op)

    // Value
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirValueGetType(MlirValue value)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirValuePrint(MlirValue value, MlirStringCallback callback, nativeint userData)

//=============================================================================
// Helper Utilities
//=============================================================================

module MlirHelpers =
    let operationToString (op: MlirOperation) : string =
        let mutable output = ""
        let callback = MlirStringCallback(fun strRef _ -&gt;
            output &lt;- output + strRef.ToString()
        )
        MlirNative.mlirOperationPrint(op, callback, nativeint 0)
        output

    let moduleToString (m: MlirModule) : string =
        let op = MlirNative.mlirModuleGetOperation(m)
        operationToString op

    let valueToString (v: MlirValue) : string =
        let mutable output = ""
        let callback = MlirStringCallback(fun strRef _ -&gt;
            output &lt;- output + strRef.ToString()
        )
        MlirNative.mlirValuePrint(v, callback, nativeint 0)
        output

    let createContextWithDialects() : MlirContext =
        let ctx = MlirNative.mlirContextCreate()
        MlirNative.mlirDialectHandleRegisterDialect(MlirNative.mlirGetDialectHandle__func__(), ctx)
        MlirNative.mlirDialectHandleRegisterDialect(MlirNative.mlirGetDialectHandle__arith__(), ctx)
        MlirNative.mlirDialectHandleRegisterDialect(MlirNative.mlirGetDialectHandle__scf__(), ctx)
        MlirNative.mlirDialectHandleRegisterDialect(MlirNative.mlirGetDialectHandle__cf__(), ctx)
        MlirNative.mlirDialectHandleRegisterDialect(MlirNative.mlirGetDialectHandle__llvm__(), ctx)
        ctx
</code></pre>
<p>이것이 완전하고 프로덕션에 사용할 수 있는 MLIR 바인딩 레이어이다.</p>
<h2 id="라이브러리-빌드"><a class="header" href="#라이브러리-빌드">라이브러리 빌드</a></h2>
<p>라이브러리 프로젝트를 빌드한다:</p>
<pre><code class="language-bash">cd $HOME/mlir-fsharp-tutorial/MlirBindings
dotnet build
</code></pre>
<p>예상 출력:</p>
<pre><code>Build succeeded.
    0 Warning(s)
    0 Error(s)
</code></pre>
<p>컴파일된 라이브러리는 <code>bin/Debug/net8.0/MlirBindings.dll</code>에 위치한다.</p>
<h2 id="바인딩-사용하기"><a class="header" href="#바인딩-사용하기">바인딩 사용하기</a></h2>
<p>새 바인딩을 사용하여 Chapter 02의 hello-world 예제를 다시 작성해 본다. 새 콘솔 프로젝트를 생성한다:</p>
<pre><code class="language-bash">cd $HOME/mlir-fsharp-tutorial
dotnet new console -lang F# -o HelloMlirWithBindings
cd HelloMlirWithBindings
dotnet add reference ../MlirBindings/MlirBindings.fsproj
</code></pre>
<p><code>Program.fs</code>의 내용을 다음으로 교체한다:</p>
<pre><code class="language-fsharp">open System
open MlirBindings

[&lt;EntryPoint&gt;]
let main argv =
    // Create context with dialects
    let ctx = MlirHelpers.createContextWithDialects()
    printfn "Created MLIR context with dialects loaded"

    // Create empty module
    let loc = MlirNative.mlirLocationUnknownGet(ctx)
    let mlirModule = MlirNative.mlirModuleCreateEmpty(loc)
    printfn "Created empty module"

    // Print the module
    printfn "\nGenerated MLIR IR:"
    printfn "%s" (MlirHelpers.moduleToString mlirModule)

    // Cleanup
    MlirNative.mlirModuleDestroy(mlirModule)
    MlirNative.mlirContextDestroy(ctx)
    printfn "\nCleaned up"

    0
</code></pre>
<p>실행한다:</p>
<pre><code class="language-bash">LD_LIBRARY_PATH=$HOME/mlir-install/lib dotnet run
</code></pre>
<p>예상 출력:</p>
<pre><code>Created MLIR context with dialects loaded
Created empty module

Generated MLIR IR:
module {
}

Cleaned up
</code></pre>
<p>Chapter 02보다 훨씬 깔끔하다! 바인딩 모듈이 모든 마샬링과 보일러플레이트를 처리한다.</p>
<h2 id="이-장에서-배운-내용"><a class="header" href="#이-장에서-배운-내용">이 장에서 배운 내용</a></h2>
<p>이 장에서는 다음을 수행했다:</p>
<ol>
<li><strong>MLIR 바인딩을 구성하여</strong> 논리적 섹션으로 나뉜 재사용 가능한 F# 라이브러리 모듈을 만들었다.</li>
<li><strong>포괄적인 핸들 타입을 정의하여</strong> 모든 MLIR 엔티티(context, module, operation, type, region, block, value, attribute)를 다루었다.</li>
<li><strong>안전한 문자열 마샬링을 구현하여</strong> <code>MlirStringRef</code>와 헬퍼 유틸리티를 만들었다.</li>
<li><strong>P/Invoke 바인딩을 선언하여</strong> 컴파일에 필요한 MLIR C API의 전체 표면적을 다루었다.</li>
<li><strong>헬퍼 유틸리티를 생성하여</strong> 보일러플레이트를 줄였다 (출력, context 생성).</li>
<li><strong>크로스 플랫폼 고려 사항을</strong> 이해하여 라이브러리 로딩을 다루었다.</li>
<li><strong>바인딩 라이브러리를 빌드하고 사용하여</strong> 별도의 프로젝트에서 활용했다.</li>
</ol>
<p>이제 MLIR에 대한 완전하고 프로덕션에 사용할 수 있는 바인딩 레이어를 갖추었다. 이 <code>MlirBindings</code> 모듈은 FunLang 컴파일러를 구축하는 이후 모든 장의 기반이 된다.</p>
<h2 id="다음-장-1"><a class="header" href="#다음-장-1">다음 장</a></h2>
<p>다음 장에서는 FunLang 컴파일러 백엔드 구축을 시작한다. 타입이 지정된 FunLang AST를 F#에서 표현하기 위한 데이터 구조를 정의하고, 여기서 만든 바인딩을 사용하여 FunLang 표현식을 MLIR operation으로 변환하는 코드 생성 로직을 작성하기 시작한다.</p>
<p><strong>Chapter 04: FunLang AST에서 MLIR로</strong> (작성 예정)로 이어진다.</p>
<h2 id="참고-자료-1"><a class="header" href="#참고-자료-1">참고 자료</a></h2>
<ul>
<li><a href="https://mlir.llvm.org/docs/CAPI/">MLIR C API Documentation</a> – 공식 C API 가이드</li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/standard/native-interop/best-practices">P/Invoke Best Practices</a> – 안전하고 고성능의 interop을 위한 Microsoft의 가이드라인</li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/standard/native-interop/tutorial-custom-marshaller">Memory Management in P/Invoke</a> – 관리/비관리 메모리 경계 이해</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-04-f-래퍼-레이어"><a class="header" href="#chapter-04-f-래퍼-레이어">Chapter 04: F# 래퍼 레이어</a></h1>
<h2 id="소개-4"><a class="header" href="#소개-4">소개</a></h2>
<p>Chapter 03에서는 MLIR C API에 대한 완전한 P/Invoke 바인딩 모듈인 <code>MlirBindings.fs</code>를 구축했다. 이제 Context를 생성하고, Module을 만들며, Operation을 구성하는 등 MLIR C API의 모든 기능을 F#에서 호출할 수 있다.</p>
<p>하지만 Chapter 02와 03의 코드를 살펴보면 몇 가지 문제점이 드러난다:</p>
<p><strong>문제 1: 리소스 누수 위험</strong></p>
<pre><code class="language-fsharp">let ctx = MlirNative.mlirContextCreate()
let loc = MlirNative.mlirLocationUnknownGet(ctx)
let mlirMod = MlirNative.mlirModuleCreateEmpty(loc)

// ... IR 구축 ...

// 정리를 잊어버리면 메모리 누수 발생
MlirNative.mlirModuleDestroy(mlirMod)
MlirNative.mlirContextDestroy(ctx)
</code></pre>
<p>수동으로 <code>Destroy</code> 함수를 호출해야 한다. 예외가 발생하거나 조기 반환이 있으면 리소스가 누수된다.</p>
<p><strong>문제 2: 장황함</strong></p>
<pre><code class="language-fsharp">let state = MlirNative.mlirOperationStateGet(
    MlirStringRef.FromString("arith.constant"),
    location)
MlirNative.mlirOperationStateAddResults(&amp;state, 1, &amp;intType)
// ... 더 많은 state 조작 ...
let op = MlirNative.mlirOperationCreate(&amp;state)
</code></pre>
<p>Operation 하나를 만드는데 5-10줄의 코드가 필요하다. 반복적이고 오류가 발생하기 쉽다.</p>
<p><strong>문제 3: 타입 안전성 부족</strong></p>
<pre><code class="language-fsharp">let ctx = MlirNative.mlirContextCreate()
MlirNative.mlirContextDestroy(ctx)
// ctx는 이제 무효하지만, 타입 시스템이 이를 막지 못한다
let loc = MlirNative.mlirLocationUnknownGet(ctx) // 버그!
</code></pre>
<p>핸들을 해제한 후에도 여전히 사용할 수 있다. C API는 이를 막지 못한다.</p>
<p>이 장에서는 이러한 문제들을 해결하는 <strong>래퍼 레이어</strong>를 구축한다. 이 레이어는 원시 P/Invoke 바인딩을 관용적인 F# API로 감싸서 다음을 제공한다:</p>
<ul>
<li><strong>자동 리소스 관리</strong>: <code>IDisposable</code>과 <code>use</code> 키워드</li>
<li><strong>간결한 API</strong>: <code>OpBuilder.CreateConstant(42)</code> 같은 유창한 빌더</li>
<li><strong>생명주기 안전성</strong>: 부모 객체가 자식보다 먼저 파괴되는 것을 방지</li>
</ul>
<p>이 장을 마치면 튜토리얼의 나머지 부분에서 사용할 깔끔하고 안전한 MLIR API를 갖게 된다.</p>
<h2 id="소유권-문제"><a class="header" href="#소유권-문제">소유권 문제</a></h2>
<p>MLIR은 엄격한 소유권 계층 구조를 갖는다:</p>
<pre><code>Context (root)
  └─ Module
       └─ Operation
            └─ Region
                 └─ Block
                      └─ Operation
</code></pre>
<p>각 객체는 부모에 속한다:</p>
<ul>
<li><strong>Module</strong>은 <strong>Context</strong>가 소유한다</li>
<li><strong>Operation</strong>은 <strong>Block</strong>이 소유한다</li>
<li><strong>Block</strong>은 <strong>Region</strong>이 소유한다</li>
<li><strong>Region</strong>은 <strong>Operation</strong>이 소유한다</li>
</ul>
<p>C++에서는 이 소유권이 자동으로 관리된다 (RAII와 unique_ptr). 부모가 파괴되면 자식도 자동으로 파괴된다.</p>
<p>P/Invoke에서는 이 소유권을 수동으로 관리해야 한다. 문제는 부모를 먼저 파괴하면 자식 핸들이 무효가 된다는 것이다:</p>
<pre><code class="language-fsharp">// 버그가 있는 코드
let ctx = MlirNative.mlirContextCreate()
let loc = MlirNative.mlirLocationUnknownGet(ctx)
let mlirMod = MlirNative.mlirModuleCreateEmpty(loc)

// Context를 먼저 파괴
MlirNative.mlirContextDestroy(ctx)

// Module 핸들이 이제 무효 - 위험한 포인터!
MlirNative.mlirModuleGetOperation(mlirMod) // 세그멘테이션 폴트
</code></pre>
<p>F#의 가비지 컬렉터는 MLIR의 소유권 규칙을 알지 못한다. 따라서 우리가 강제해야 한다.</p>
<p><strong>해결책:</strong> F# 래퍼는 부모 객체에 대한 참조를 저장한다. 자식이 살아있는 한 부모는 가비지 컬렉트되지 않는다.</p>
<pre><code class="language-fsharp">type Module(context: Context, location: Location) =
    let handle = MlirNative.mlirModuleCreateEmpty(location.Handle)
    let contextRef = context  // 부모 참조 유지 - Context가 먼저 GC되는 것을 방지

    member _.Handle = handle

    interface IDisposable with
        member _.Dispose() =
            MlirNative.mlirModuleDestroy(handle)
</code></pre>
<h2 id="context-래퍼"><a class="header" href="#context-래퍼">Context 래퍼</a></h2>
<p>MLIR의 최상위 객체인 Context부터 시작한다. 새 파일 <code>MlirWrapper.fs</code>를 만든다:</p>
<pre><code class="language-fsharp">namespace MlirWrapper

open System
open MlirBindings

/// MLIR Context를 나타낸다. 모든 MLIR 객체의 소유자이며 메모리 관리를 담당한다.
/// Context는 dialect와 type을 등록하고 IR 구성을 위한 전역 환경을 제공한다.
type Context() =
    let mutable handle = MlirNative.mlirContextCreate()
    let mutable disposed = false

    /// 기본 MLIR context 핸들
    member _.Handle = handle

    /// 이 context에 dialect를 로드한다.
    /// dialect: 로드할 dialect의 이름 (예: "arith", "func", "llvm")
    member _.LoadDialect(dialect: string) =
        if disposed then
            raise (ObjectDisposedException("Context"))

        MlirStringRef.WithString dialect (fun nameRef -&gt;
            MlirNative.mlirContextGetOrLoadDialect(handle, nameRef)
            |&gt; ignore)

    interface IDisposable with
        member this.Dispose() =
            this.Dispose(true)
            GC.SuppressFinalize(this)

    member private _.Dispose(disposing: bool) =
        if not disposed then
            if disposing then
                // 관리 리소스 정리 (이 경우 없음)
                ()

            // 비관리 리소스 정리
            MlirNative.mlirContextDestroy(handle)
            handle &lt;- Unchecked.defaultof&lt;_&gt;
            disposed &lt;- true
</code></pre>
<blockquote>
<p><strong>설계 결정:</strong> <code>disposed</code> 플래그는 이중 해제를 방지한다. 동일한 Context에서 <code>Dispose()</code>를 두 번 호출하는 것은 안전하다 (두 번째 호출은 아무 작업도 하지 않는다).</p>
</blockquote>
<p><strong>사용 예:</strong></p>
<pre><code class="language-fsharp">let example () =
    use ctx = new Context()          // Context 생성
    ctx.LoadDialect("arith")         // Arithmetic dialect 로드
    ctx.LoadDialect("func")          // Function dialect 로드

    // ctx 사용...
    printfn "Context created: %A" ctx.Handle

    // 스코프가 끝나면 자동으로 Dispose 호출됨 - mlirContextDestroy 호출
</code></pre>
<p>F#의 <code>use</code> 키워드는 C#의 <code>using</code>과 동일하다. 스코프가 끝나면 자동으로 <code>Dispose()</code>를 호출한다. 예외가 발생해도 정리가 보장된다.</p>
<h2 id="location-래퍼"><a class="header" href="#location-래퍼">Location 래퍼</a></h2>
<p>Location은 MLIR의 가벼운 값 타입이다. 리소스를 소유하지 않으므로 <code>IDisposable</code>이 필요하지 않다:</p>
<pre><code class="language-fsharp">/// MLIR IR에서 소스 위치를 나타낸다. 컴파일 오류 보고에 사용된다.
type Location =
    | Unknown of Context
    | FileLineCol of Context * filename: string * line: int * col: int

    /// 기본 MLIR location 핸들을 반환한다
    member this.Handle =
        match this with
        | Unknown ctx -&gt;
            MlirNative.mlirLocationUnknownGet(ctx.Handle)

        | FileLineCol (ctx, filename, line, col) -&gt;
            MlirStringRef.WithString filename (fun filenameRef -&gt;
                MlirNative.mlirLocationFileLineColGet(
                    ctx.Handle,
                    filenameRef,
                    uint32 line,
                    uint32 col))
</code></pre>
<blockquote>
<p><strong>설계 결정:</strong> 모든 MLIR 타입이 <code>IDisposable</code>을 필요로 하는 것은 아니다. Location, Type, Attribute는 값 타입이며 Context가 소유한다. 명시적 정리가 필요 없다.</p>
</blockquote>
<p><strong>사용 예:</strong></p>
<pre><code class="language-fsharp">use ctx = new Context()

let loc1 = Location.Unknown(ctx)
let loc2 = Location.FileLineCol(ctx, "example.fun", 10, 5)

printfn "Unknown location: %A" loc1.Handle
printfn "File location: %A" loc2.Handle
</code></pre>
<h2 id="module-래퍼"><a class="header" href="#module-래퍼">Module 래퍼</a></h2>
<p>Module은 MLIR IR의 최상위 컨테이너다. 여러 함수와 전역 선언을 포함한다:</p>
<pre><code class="language-fsharp">/// MLIR Module - 최상위 IR 컨테이너. 함수와 전역 선언을 포함한다.
type Module(context: Context, location: Location) =
    let handle = MlirNative.mlirModuleCreateEmpty(location.Handle)
    let contextRef = context  // Context 참조 유지 - 조기 GC 방지
    let mutable disposed = false

    /// 기본 MLIR module 핸들
    member _.Handle = handle

    /// 이 module이 속한 context
    member _.Context = contextRef

    /// 이 module의 body block을 반환한다 (최상위 operation들을 포함)
    member _.Body =
        let op = MlirNative.mlirModuleGetOperation(handle)
        let region = MlirNative.mlirOperationGetRegion(op, 0n)
        MlirNative.mlirRegionGetFirstBlock(region)

    /// MLIR IR을 검증한다. 모든 operation이 올바른 형식인지 확인한다.
    member _.Verify() =
        let op = MlirNative.mlirModuleGetOperation(handle)
        MlirNative.mlirOperationVerify(op)

    /// MLIR IR을 문자열로 출력한다
    member _.Print() =
        let op = MlirNative.mlirModuleGetOperation(handle)
        MlirHelpers.operationToString(op)

    interface IDisposable with
        member this.Dispose() =
            this.Dispose(true)
            GC.SuppressFinalize(this)

    member private _.Dispose(disposing: bool) =
        if not disposed then
            if disposing then
                ()

            MlirNative.mlirModuleDestroy(handle)
            disposed &lt;- true
</code></pre>
<blockquote>
<p><strong>설계 결정:</strong> <code>contextRef</code> 필드는 Module이 존재하는 한 Context가 가비지 컬렉트되지 않도록 보장한다. 이는 소유권 안전성의 핵심이다.</p>
</blockquote>
<p><strong>사용 예:</strong></p>
<pre><code class="language-fsharp">use ctx = new Context()
ctx.LoadDialect("func")

let loc = Location.Unknown(ctx)
use mlirMod = new Module(ctx, loc)

// IR 구축...

if mlirMod.Verify() then
    printfn "Module IR:\n%s" (mlirMod.Print())
else
    failwith "IR verification failed"
</code></pre>
<h2 id="opbuilder-ir-구축을-위한-유창한-api"><a class="header" href="#opbuilder-ir-구축을-위한-유창한-api">OpBuilder: IR 구축을 위한 유창한 API</a></h2>
<p>Operation을 만드는 것은 MLIR에서 가장 복잡한 작업이다. 원시 C API는 다음과 같다:</p>
<pre><code class="language-fsharp">// 원시 P/Invoke - 15줄
let mutable state = MlirNative.mlirOperationStateGet(
    MlirStringRef.FromString("arith.constant"), location)

let mutable intType = MlirNative.mlirIntegerTypeGet(ctx, 32u)
MlirNative.mlirOperationStateAddResults(&amp;state, 1, &amp;intType)

let value = 42
let mutable attr = MlirNative.mlirIntegerAttrGet(intType, int64 value)
let mutable attrName = MlirStringRef.FromString("value")
MlirNative.mlirOperationStateAddAttributes(&amp;state, 1, &amp;attrName, &amp;attr)

let op = MlirNative.mlirOperationCreate(&amp;state)
</code></pre>
<p>이것을 한 줄로 줄이고 싶다:</p>
<pre><code class="language-fsharp">let op = builder.CreateConstant(42, intType, location)
</code></pre>
<p><code>OpBuilder</code> 클래스가 이를 가능하게 한다:</p>
<pre><code class="language-fsharp">/// MLIR operation을 구축하기 위한 유창한 빌더 API.
/// 원시 operation state 조작을 숨기고 일반적인 operation에 대한 고수준 메서드를 제공한다.
type OpBuilder(context: Context) =
    let contextRef = context

    /// i32 타입을 반환한다
    member _.I32Type() =
        MlirNative.mlirIntegerTypeGet(contextRef.Handle, 32u)

    /// i64 타입을 반환한다
    member _.I64Type() =
        MlirNative.mlirIntegerTypeGet(contextRef.Handle, 64u)

    /// 함수 타입을 생성한다 (inputs -&gt; results)
    member _.FunctionType(inputs: MlirType[], results: MlirType[]) =
        let mutable inputsArray = inputs
        let mutable resultsArray = results
        MlirNative.mlirFunctionTypeGet(
            contextRef.Handle,
            unativeint inputs.Length,
            &amp;&amp;inputsArray.[0],
            unativeint results.Length,
            &amp;&amp;resultsArray.[0])

    /// 정수 상수 operation을 생성한다: arith.constant
    member _.CreateConstant(value: int, typ: MlirType, location: Location) =
        let mutable state = MlirNative.mlirOperationStateGet(
            MlirStringRef.FromString("arith.constant"),
            location.Handle)

        // 결과 타입 추가
        let mutable resultType = typ
        MlirNative.mlirOperationStateAddResults(&amp;state, 1n, &amp;&amp;resultType)

        // value attribute 추가
        let mutable attr = MlirNative.mlirIntegerAttrGet(typ, int64 value)
        let mutable attrName = MlirStringRef.FromString("value")
        MlirNative.mlirOperationStateAddAttributes(&amp;state, 1n, &amp;&amp;attrName, &amp;&amp;attr)

        MlirNative.mlirOperationCreate(&amp;state)

    /// 함수 operation을 생성한다: func.func
    member _.CreateFunction(name: string, funcType: MlirType, location: Location) =
        let mutable state = MlirNative.mlirOperationStateGet(
            MlirStringRef.FromString("func.func"),
            location.Handle)

        // sym_name attribute 추가 (함수 이름)
        MlirStringRef.WithString name (fun nameRef -&gt;
            let mutable attr = MlirNative.mlirStringAttrGet(contextRef.Handle, nameRef)
            let mutable attrName = MlirStringRef.FromString("sym_name")
            MlirNative.mlirOperationStateAddAttributes(&amp;state, 1n, &amp;&amp;attrName, &amp;&amp;attr))

        // function_type attribute 추가
        let mutable funcTypeAttr = MlirNative.mlirTypeAttrGet(funcType)
        let mutable funcTypeAttrName = MlirStringRef.FromString("function_type")
        MlirNative.mlirOperationStateAddAttributes(&amp;state, 1n, &amp;&amp;funcTypeAttrName, &amp;&amp;funcTypeAttr)

        // body region 추가
        let mutable numRegions = 1n
        MlirNative.mlirOperationStateAddOwnedRegions(&amp;state, numRegions)

        MlirNative.mlirOperationCreate(&amp;state)

    /// return operation을 생성한다: func.return
    member _.CreateReturn(values: MlirValue[], location: Location) =
        let mutable state = MlirNative.mlirOperationStateGet(
            MlirStringRef.FromString("func.return"),
            location.Handle)

        // operand 추가
        if values.Length &gt; 0 then
            let mutable operands = values
            MlirNative.mlirOperationStateAddOperands(&amp;state, unativeint values.Length, &amp;&amp;operands.[0])

        MlirNative.mlirOperationCreate(&amp;state)

    /// Block에서 operation의 결과 value를 가져온다
    member _.GetResult(op: MlirOperation, index: int) =
        MlirNative.mlirOperationGetResult(op, unativeint index)
</code></pre>
<blockquote>
<p><strong>설계 결정:</strong> <code>OpBuilder</code>는 MLIR의 복잡성 대부분을 숨긴다. 일반적인 operation (constant, function, return)에 대해 고수준 메서드를 제공한다. 드물게 사용되는 operation은 직접 원시 API를 사용할 수 있다.</p>
</blockquote>
<h2 id="타입-헬퍼"><a class="header" href="#타입-헬퍼">타입 헬퍼</a></h2>
<p>타입 생성을 더 편리하게 만드는 모듈:</p>
<pre><code class="language-fsharp">/// MLIR 타입 생성을 위한 헬퍼 함수들
module MLIRType =
    /// i32 타입을 반환한다
    let i32 (ctx: Context) =
        MlirNative.mlirIntegerTypeGet(ctx.Handle, 32u)

    /// i64 타입을 반환한다
    let i64 (ctx: Context) =
        MlirNative.mlirIntegerTypeGet(ctx.Handle, 64u)

    /// 함수 타입을 생성한다
    let func (ctx: Context) (inputs: MlirType[]) (results: MlirType[]) =
        let mutable inputsArray = inputs
        let mutable resultsArray = results
        MlirNative.mlirFunctionTypeGet(
            ctx.Handle,
            unativeint inputs.Length,
            (if inputs.Length &gt; 0 then &amp;&amp;inputsArray.[0] else nativeint 0),
            unativeint results.Length,
            (if results.Length &gt; 0 then &amp;&amp;resultsArray.[0] else nativeint 0))
</code></pre>
<h2 id="모두-함께-사용하기"><a class="header" href="#모두-함께-사용하기">모두 함께 사용하기</a></h2>
<p>이제 래퍼를 사용하여 Chapter 02의 “hello-mlir” 예제를 다시 작성해 본다. 비교를 위해 두 버전을 나란히 보자:</p>
<p><strong>원시 P/Invoke 버전 (Chapter 02):</strong></p>
<pre><code class="language-fsharp">// 35+ 줄, 수동 정리, 장황함
let ctx = MlirNative.mlirContextCreate()

MlirStringRef.WithString "arith" (fun dialectName -&gt;
    MlirNative.mlirContextGetOrLoadDialect(ctx, dialectName) |&gt; ignore)

MlirStringRef.WithString "func" (fun dialectName -&gt;
    MlirNative.mlirContextGetOrLoadDialect(ctx, dialectName) |&gt; ignore)

let loc = MlirNative.mlirLocationUnknownGet(ctx)
let mlirMod = MlirNative.mlirModuleCreateEmpty(loc)

// ... 더 많은 장황한 코드 ...

MlirNative.mlirModuleDestroy(mlirMod)
MlirNative.mlirContextDestroy(ctx)
</code></pre>
<p><strong>래퍼 버전 (Chapter 04):</strong></p>
<pre><code class="language-fsharp">// 20줄, 자동 정리, 간결함
open MlirWrapper

let buildHelloMlir () =
    use ctx = new Context()
    ctx.LoadDialect("arith")
    ctx.LoadDialect("func")

    let loc = Location.Unknown(ctx)
    use mlirMod = new Module(ctx, loc)

    let builder = OpBuilder(ctx)
    let i32Type = builder.I32Type()

    // 함수 타입 생성: () -&gt; i32
    let funcType = builder.FunctionType([||], [| i32Type |])

    // 함수 operation 생성
    let funcOp = builder.CreateFunction("return_forty_two", funcType, loc)

    // 함수 body의 첫 번째 region과 block 가져오기
    let bodyRegion = MlirNative.mlirOperationGetRegion(funcOp, 0n)
    let entryBlock = MlirNative.mlirRegionGetFirstBlock(bodyRegion)

    // entry block이 비어있는지 확인하고, 비어있으면 새로 생성
    let block =
        if MlirNative.mlirBlockIsNull(entryBlock) then
            let newBlock = MlirNative.mlirBlockCreate(0n, nativeint 0, nativeint 0)
            MlirNative.mlirRegionAppendOwnedBlock(bodyRegion, newBlock)
            newBlock
        else
            entryBlock

    // 상수 operation 생성: %c42 = arith.constant 42 : i32
    let constOp = builder.CreateConstant(42, i32Type, loc)
    MlirNative.mlirBlockAppendOwnedOperation(block, constOp)

    // 상수의 결과 value 가져오기
    let constValue = builder.GetResult(constOp, 0)

    // return operation 생성: return %c42 : i32
    let returnOp = builder.CreateReturn([| constValue |], loc)
    MlirNative.mlirBlockAppendOwnedOperation(block, returnOp)

    // 함수를 module에 추가
    MlirNative.mlirBlockAppendOwnedOperation(mlirMod.Body, funcOp)

    // 검증 및 출력
    if mlirMod.Verify() then
        printfn "Generated MLIR:\n%s" (mlirMod.Print())
    else
        failwith "Module verification failed"

    // use가 자동으로 정리 처리
</code></pre>
<p><strong>개선 사항:</strong></p>
<ol>
<li><strong>자동 정리</strong>: <code>use</code> 키워드가 <code>Dispose()</code>를 자동으로 호출한다</li>
<li><strong>간결성</strong>: <code>builder.CreateConstant(42, i32Type, loc)</code> vs. 15줄의 state 조작</li>
<li><strong>타입 안전성</strong>: Context 참조가 Module이 살아있는 동안 유지됨을 보장</li>
<li><strong>가독성</strong>: 의도가 명확하고 보일러플레이트가 적음</li>
</ol>
<h2 id="완전한-래퍼-모듈-리스팅"><a class="header" href="#완전한-래퍼-모듈-리스팅">완전한 래퍼 모듈 리스팅</a></h2>
<p>다음은 완전한 <code>MlirWrapper.fs</code> 파일이다:</p>
<pre><code class="language-fsharp">namespace MlirWrapper

open System
open MlirBindings

/// MLIR Context - 모든 MLIR 객체의 소유자
type Context() =
    let mutable handle = MlirNative.mlirContextCreate()
    let mutable disposed = false

    member _.Handle = handle

    member _.LoadDialect(dialect: string) =
        if disposed then
            raise (ObjectDisposedException("Context"))

        MlirStringRef.WithString dialect (fun nameRef -&gt;
            MlirNative.mlirContextGetOrLoadDialect(handle, nameRef)
            |&gt; ignore)

    interface IDisposable with
        member this.Dispose() =
            this.Dispose(true)
            GC.SuppressFinalize(this)

    member private _.Dispose(disposing: bool) =
        if not disposed then
            if disposing then
                ()
            MlirNative.mlirContextDestroy(handle)
            handle &lt;- Unchecked.defaultof&lt;_&gt;
            disposed &lt;- true

/// MLIR Location - 소스 위치 정보
type Location =
    | Unknown of Context
    | FileLineCol of Context * filename: string * line: int * col: int

    member this.Handle =
        match this with
        | Unknown ctx -&gt;
            MlirNative.mlirLocationUnknownGet(ctx.Handle)
        | FileLineCol (ctx, filename, line, col) -&gt;
            MlirStringRef.WithString filename (fun filenameRef -&gt;
                MlirNative.mlirLocationFileLineColGet(
                    ctx.Handle, filenameRef, uint32 line, uint32 col))

/// MLIR Module - 최상위 IR 컨테이너
type Module(context: Context, location: Location) =
    let handle = MlirNative.mlirModuleCreateEmpty(location.Handle)
    let contextRef = context
    let mutable disposed = false

    member _.Handle = handle
    member _.Context = contextRef

    member _.Body =
        let op = MlirNative.mlirModuleGetOperation(handle)
        let region = MlirNative.mlirOperationGetRegion(op, 0n)
        MlirNative.mlirRegionGetFirstBlock(region)

    member _.Verify() =
        let op = MlirNative.mlirModuleGetOperation(handle)
        MlirNative.mlirOperationVerify(op)

    member _.Print() =
        let op = MlirNative.mlirModuleGetOperation(handle)
        MlirHelpers.operationToString(op)

    interface IDisposable with
        member this.Dispose() =
            this.Dispose(true)
            GC.SuppressFinalize(this)

    member private _.Dispose(disposing: bool) =
        if not disposed then
            if disposing then
                ()
            MlirNative.mlirModuleDestroy(handle)
            disposed &lt;- true

/// Operation 빌더 - 유창한 IR 구축 API
type OpBuilder(context: Context) =
    let contextRef = context

    member _.I32Type() =
        MlirNative.mlirIntegerTypeGet(contextRef.Handle, 32u)

    member _.I64Type() =
        MlirNative.mlirIntegerTypeGet(contextRef.Handle, 64u)

    member _.FunctionType(inputs: MlirType[], results: MlirType[]) =
        let mutable inputsArray = inputs
        let mutable resultsArray = results
        MlirNative.mlirFunctionTypeGet(
            contextRef.Handle,
            unativeint inputs.Length,
            (if inputs.Length &gt; 0 then &amp;&amp;inputsArray.[0] else nativeint 0),
            unativeint results.Length,
            (if results.Length &gt; 0 then &amp;&amp;resultsArray.[0] else nativeint 0))

    member _.CreateConstant(value: int, typ: MlirType, location: Location) =
        let mutable state = MlirNative.mlirOperationStateGet(
            MlirStringRef.FromString("arith.constant"), location.Handle)

        let mutable resultType = typ
        MlirNative.mlirOperationStateAddResults(&amp;state, 1n, &amp;&amp;resultType)

        let mutable attr = MlirNative.mlirIntegerAttrGet(typ, int64 value)
        let mutable attrName = MlirStringRef.FromString("value")
        MlirNative.mlirOperationStateAddAttributes(&amp;state, 1n, &amp;&amp;attrName, &amp;&amp;attr)

        MlirNative.mlirOperationCreate(&amp;state)

    member _.CreateFunction(name: string, funcType: MlirType, location: Location) =
        let mutable state = MlirNative.mlirOperationStateGet(
            MlirStringRef.FromString("func.func"), location.Handle)

        MlirStringRef.WithString name (fun nameRef -&gt;
            let mutable attr = MlirNative.mlirStringAttrGet(contextRef.Handle, nameRef)
            let mutable attrName = MlirStringRef.FromString("sym_name")
            MlirNative.mlirOperationStateAddAttributes(&amp;state, 1n, &amp;&amp;attrName, &amp;&amp;attr))

        let mutable funcTypeAttr = MlirNative.mlirTypeAttrGet(funcType)
        let mutable funcTypeAttrName = MlirStringRef.FromString("function_type")
        MlirNative.mlirOperationStateAddAttributes(&amp;state, 1n, &amp;&amp;funcTypeAttrName, &amp;&amp;funcTypeAttr)

        let mutable numRegions = 1n
        MlirNative.mlirOperationStateAddOwnedRegions(&amp;state, numRegions)

        MlirNative.mlirOperationCreate(&amp;state)

    member _.CreateReturn(values: MlirValue[], location: Location) =
        let mutable state = MlirNative.mlirOperationStateGet(
            MlirStringRef.FromString("func.return"), location.Handle)

        if values.Length &gt; 0 then
            let mutable operands = values
            MlirNative.mlirOperationStateAddOperands(&amp;state, unativeint values.Length, &amp;&amp;operands.[0])

        MlirNative.mlirOperationCreate(&amp;state)

    member _.GetResult(op: MlirOperation, index: int) =
        MlirNative.mlirOperationGetResult(op, unativeint index)

/// 타입 생성 헬퍼
module MLIRType =
    let i32 (ctx: Context) =
        MlirNative.mlirIntegerTypeGet(ctx.Handle, 32u)

    let i64 (ctx: Context) =
        MlirNative.mlirIntegerTypeGet(ctx.Handle, 64u)

    let func (ctx: Context) (inputs: MlirType[]) (results: MlirType[]) =
        let mutable inputsArray = inputs
        let mutable resultsArray = results
        MlirNative.mlirFunctionTypeGet(
            ctx.Handle,
            unativeint inputs.Length,
            (if inputs.Length &gt; 0 then &amp;&amp;inputsArray.[0] else nativeint 0),
            unativeint results.Length,
            (if results.Length &gt; 0 then &amp;&amp;resultsArray.[0] else nativeint 0))
</code></pre>
<h2 id="배운-것"><a class="header" href="#배운-것">배운 것</a></h2>
<p>이 장에서 다음을 배웠다:</p>
<ol>
<li><strong>소유권 관리</strong>: MLIR의 계층적 소유권과 F#에서 부모 참조로 이를 강제하는 방법</li>
<li><strong>IDisposable 패턴</strong>: 자동 리소스 정리를 위한 <code>use</code> 키워드</li>
<li><strong>빌더 패턴</strong>: 복잡한 API를 간단한 메서드 호출로 감싸는 <code>OpBuilder</code></li>
<li><strong>타입 안전성</strong>: 장황함 없이 컴파일 시점 타입 검사를 제공하는 F# 래퍼</li>
</ol>
<h2 id="다음-단계-1"><a class="header" href="#다음-단계-1">다음 단계</a></h2>
<p>Chapter 05에서는 이 래퍼 레이어를 사용하여 <strong>완전한 컴파일러</strong>를 구축한다. 정수 리터럴을 갖는 간단한 FunLang 프로그램을 파싱하고, MLIR IR로 변환하며, LLVM dialect로 낮추고, 네이티브 바이너리로 컴파일하여 실행할 것이다.</p>
<p>이것이 Phase 1의 정점이다 – 실제 코드를 실행하는 것이다!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-05-산술-컴파일러---첫-번째-네이티브-바이너리"><a class="header" href="#chapter-05-산술-컴파일러---첫-번째-네이티브-바이너리">Chapter 05: 산술 컴파일러 - 첫 번째 네이티브 바이너리</a></h1>
<h2 id="소개-5"><a class="header" href="#소개-5">소개</a></h2>
<p>지금까지의 여정:</p>
<ul>
<li><strong>Chapter 00</strong>: LLVM/MLIR을 빌드하고 .NET SDK를 설치했다</li>
<li><strong>Chapter 01</strong>: MLIR 개념 (dialect, operation, region, block, SSA)을 배웠다</li>
<li><strong>Chapter 02</strong>: F#에서 처음으로 MLIR IR을 생성했다</li>
<li><strong>Chapter 03</strong>: 완전한 P/Invoke 바인딩 모듈을 구축했다</li>
<li><strong>Chapter 04</strong>: 안전하고 관용적인 F# 래퍼 레이어를 만들었다</li>
</ul>
<p>이제 보상을 받을 시간이다.</p>
<p>이 장에서는 <strong>실제 컴파일러</strong>를 구축한다. 소스 코드를 입력으로 받아 실행 가능한 네이티브 바이너리를 출력하는 컴파일러다. 단순화를 위해 FunLang의 매우 작은 부분집합, 즉 <strong>정수 리터럴</strong>만 다룬다. 이것이 사소해 보일 수 있지만 전체 컴파일 파이프라인을 보여준다:</p>
<pre><code>Source code → AST → MLIR IR → Lowering → LLVM IR → Object file → Native binary
</code></pre>
<p>이 장을 마치면 <code>42</code>를 네이티브 실행 파일로 컴파일하고 실행하여 프로그램 종료 코드로 <code>42</code>를 볼 수 있다.</p>
<blockquote>
<p><strong>마일스톤:</strong> 이것은 Phase 1의 정점이다. 이 장 이후에는 실제 코드를 컴파일하고 실행하는 작동하는 컴파일러를 갖게 된다!</p>
</blockquote>
<h2 id="funlang-부분집합"><a class="header" href="#funlang-부분집합">FunLang 부분집합</a></h2>
<p>지금은 단 하나의 구문만 지원한다:</p>
<pre><code>program ::= &lt;integer&gt;
</code></pre>
<p>예시:</p>
<ul>
<li><code>42</code></li>
<li><code>0</code></li>
<li><code>1337</code></li>
</ul>
<p>이 프로그램은 정수를 종료 코드로 반환한다. Unix에서는 <code>$?</code>로 확인할 수 있다:</p>
<pre><code class="language-bash">./program
echo $?  # 42 출력
</code></pre>
<p>단순해 보이지만 이것은 다음을 포함한 <strong>완전한 컴파일 파이프라인</strong>을 요구한다:</p>
<ol>
<li>소스를 AST로 파싱</li>
<li>AST를 MLIR IR로 변환</li>
<li>MLIR IR 검증</li>
<li>LLVM dialect로 낮추기</li>
<li>LLVM IR로 변환</li>
<li>오브젝트 파일 생성</li>
<li>실행 파일로 링크</li>
</ol>
<h2 id="컴파일러-파이프라인-개요"><a class="header" href="#컴파일러-파이프라인-개요">컴파일러 파이프라인 개요</a></h2>
<p>전체 파이프라인을 시각화해 본다:</p>
<pre><code>┌─────────────┐
│   42        │  소스 코드 (문자열)
└──────┬──────┘
       │ parse
       ▼
┌─────────────┐
│ IntLiteral  │  타입 있는 AST
│   value=42  │
└──────┬──────┘
       │ translateToMlir
       ▼
┌──────────────────────────────┐
│ func.func @main() -&gt; i32 {   │  MLIR IR (high-level)
│   %c = arith.constant 42     │
│   return %c                  │
│ }                            │
└──────┬───────────────────────┘
       │ mlirPassManagerRun
       │ (convert-to-llvm)
       ▼
┌──────────────────────────────┐
│ llvm.func @main() -&gt; i32 {   │  MLIR IR (LLVM dialect)
│   %c = llvm.mlir.constant 42 │
│   llvm.return %c             │
│ }                            │
└──────┬───────────────────────┘
       │ mlirTranslateModuleToLLVMIR
       ▼
┌──────────────────────────────┐
│ define i32 @main() {         │  LLVM IR
│   ret i32 42                 │
│ }                            │
└──────┬───────────────────────┘
       │ llc -filetype=obj
       ▼
┌─────────────┐
│ program.o   │  오브젝트 파일 (ELF/Mach-O)
└──────┬──────┘
       │ cc -o program
       ▼
┌─────────────┐
│ ./program   │  네이티브 실행 파일
└─────────────┘
</code></pre>
<p>각 단계를 하나씩 구현해 본다.</p>
<h2 id="1단계-ast-정의와-파싱"><a class="header" href="#1단계-ast-정의와-파싱">1단계: AST 정의와 파싱</a></h2>
<p>먼저 FunLang AST의 부분집합을 정의한다. 새 파일 <code>Ast.fs</code>를 만든다:</p>
<pre><code class="language-fsharp">namespace FunLangCompiler

/// FunLang 표현식 AST
type Expr =
    | IntLiteral of int

/// 최상위 프로그램
type Program =
    { expr: Expr }
</code></pre>
<p>극도로 단순하다. 프로그램은 하나의 표현식이고, 표현식은 정수 리터럴이다.</p>
<p>이제 파서를 작성한다. 실제 프로젝트에서는 LangTutorial의 파서를 재사용할 것이다. 여기서는 단순성을 위해 <code>int.Parse</code>를 사용한다:</p>
<pre><code class="language-fsharp">/// 간단한 파서 - 문자열을 정수로 파싱
module Parser =
    open System

    let parse (source: string) : Program =
        let trimmed = source.Trim()
        match Int32.TryParse(trimmed) with
        | (true, value) -&gt;
            { expr = IntLiteral value }
        | (false, _) -&gt;
            failwithf "Parse error: expected integer, got '%s'" trimmed
</code></pre>
<p><strong>테스트:</strong></p>
<pre><code class="language-fsharp">let program = Parser.parse "42"
// { expr = IntLiteral 42 }
</code></pre>
<h2 id="2단계-ast를-mlir로-변환"><a class="header" href="#2단계-ast를-mlir로-변환">2단계: AST를 MLIR로 변환</a></h2>
<p>이제 핵심 컴파일 단계다. AST를 MLIR IR로 변환한다. 목표는 다음 IR을 생성하는 것이다:</p>
<pre><code class="language-mlir">module {
  func.func @main() -&gt; i32 {
    %c42 = arith.constant 42 : i32
    return %c42 : i32
  }
}
</code></pre>
<p>새 파일 <code>CodeGen.fs</code>를 만든다:</p>
<pre><code class="language-fsharp">namespace FunLangCompiler

open System
open MlirWrapper
open MlirBindings

/// AST를 MLIR IR로 변환
module CodeGen =

    /// 표현식을 MLIR value로 컴파일
    let rec compileExpr
        (builder: OpBuilder)
        (block: MlirBlock)
        (location: Location)
        (expr: Expr)
        : MlirValue =

        match expr with
        | IntLiteral value -&gt;
            // arith.constant operation 생성
            let i32Type = builder.I32Type()
            let constOp = builder.CreateConstant(value, i32Type, location)

            // block에 operation 추가
            MlirNative.mlirBlockAppendOwnedOperation(block, constOp)

            // 결과 value 반환
            builder.GetResult(constOp, 0)

    /// 프로그램을 MLIR module로 컴파일
    let translateToMlir (program: Program) : Module =
        let ctx = new Context()
        ctx.LoadDialect("arith")
        ctx.LoadDialect("func")

        let loc = Location.Unknown(ctx)
        let mlirMod = new Module(ctx, loc)

        let builder = OpBuilder(ctx)
        let i32Type = builder.I32Type()

        // main 함수 생성: () -&gt; i32
        let funcType = builder.FunctionType([||], [| i32Type |])
        let funcOp = builder.CreateFunction("main", funcType, loc)

        // 함수 body에 entry block 생성
        let bodyRegion = MlirNative.mlirOperationGetRegion(funcOp, 0n)
        let entryBlock = MlirNative.mlirBlockCreate(0n, nativeint 0, nativeint 0)
        MlirNative.mlirRegionAppendOwnedBlock(bodyRegion, entryBlock)

        // 표현식 컴파일 (상수 생성)
        let resultValue = compileExpr builder entryBlock loc program.expr

        // return operation 생성
        let returnOp = builder.CreateReturn([| resultValue |], loc)
        MlirNative.mlirBlockAppendOwnedOperation(entryBlock, returnOp)

        // 함수를 module에 추가
        MlirNative.mlirBlockAppendOwnedOperation(mlirMod.Body, funcOp)

        mlirMod
</code></pre>
<blockquote>
<p><strong>설계 결정:</strong> <code>compileExpr</code>은 재귀적이다. 현재는 IntLiteral만 처리하지만, 나중 장에서 더 많은 케이스 (BinaryOp, IfThenElse, FunctionCall 등)를 추가할 것이다.</p>
</blockquote>
<p><strong>테스트:</strong></p>
<pre><code class="language-fsharp">let program = Parser.parse "42"
let mlirMod = CodeGen.translateToMlir program
printfn "%s" (mlirMod.Print())
</code></pre>
<p><strong>출력:</strong></p>
<pre><code class="language-mlir">module {
  func.func @main() -&gt; i32 {
    %0 = arith.constant 42 : i32
    return %0 : i32
  }
}
</code></pre>
<h2 id="3단계-mlir-검증"><a class="header" href="#3단계-mlir-검증">3단계: MLIR 검증</a></h2>
<p>MLIR은 강력한 검증 인프라를 제공한다. 모든 operation이 올바른 형식인지 확인한다:</p>
<ul>
<li>모든 block이 terminator (return, branch 등)로 끝나는가?</li>
<li>SSA dominance 규칙이 존중되는가?</li>
<li>타입이 일치하는가?</li>
</ul>
<p><code>CodeGen.fs</code>에 검증 단계를 추가한다:</p>
<pre><code class="language-fsharp">    /// MLIR module을 검증. 실패 시 예외 발생.
    let verify (mlirMod: Module) =
        if not (mlirMod.Verify()) then
            eprintfn "MLIR verification failed:"
            eprintfn "%s" (mlirMod.Print())
            failwith "MLIR IR is invalid"
</code></pre>
<p><strong>사용:</strong></p>
<pre><code class="language-fsharp">let mlirMod = CodeGen.translateToMlir program
CodeGen.verify mlirMod  // 실패 시 예외 발생
</code></pre>
<blockquote>
<p><strong>마일스톤:</strong> 이 시점에서 올바른 MLIR IR을 생성할 수 있다. 다음 단계는 LLVM으로 낮추는 것이다.</p>
</blockquote>
<h2 id="4단계-llvm-dialect로-낮추기"><a class="header" href="#4단계-llvm-dialect로-낮추기">4단계: LLVM Dialect로 낮추기</a></h2>
<p>MLIR IR은 계층적이다. 고수준 dialect (<code>arith</code>, <code>func</code>)에서 시작하여 LLVM dialect로 점진적으로 낮춘다. 이를 <strong>progressive lowering</strong>이라고 한다 (Chapter 01 참조).</p>
<p>MLIR의 pass manager를 사용하여 변환을 수행한다:</p>
<pre><code class="language-fsharp">namespace FunLangCompiler

open MlirBindings

/// MLIR lowering pass
module Lowering =

    /// arith와 func dialect를 LLVM dialect로 낮춘다
    let lowerToLLVMDialect (mlirMod: Module) =
        let ctx = mlirMod.Context

        // Pass manager 생성
        let pm = MlirNative.mlirPassManagerCreate(ctx.Handle)

        // convert-func-to-llvm pass 추가
        MlirStringRef.WithString "convert-func-to-llvm" (fun passName -&gt;
            let pass = MlirNative.mlirCreateConversionPass(passName)
            MlirNative.mlirPassManagerAddOwnedPass(pm, pass))

        // convert-arith-to-llvm pass 추가
        MlirStringRef.WithString "convert-arith-to-llvm" (fun passName -&gt;
            let pass = MlirNative.mlirCreateConversionPass(passName)
            MlirNative.mlirPassManagerAddOwnedPass(pm, pass))

        // Pass 실행
        let moduleOp = MlirNative.mlirModuleGetOperation(mlirMod.Handle)
        let success = MlirNative.mlirPassManagerRunOnOp(pm, moduleOp)

        if not success then
            failwith "MLIR lowering failed"

        // Pass manager 정리
        MlirNative.mlirPassManagerDestroy(pm)
</code></pre>
<blockquote>
<p><strong>아키텍처 노트:</strong> Pass는 MLIR의 강력한 기능이다. 각 pass는 IR을 변환한다 (최적화, 낮추기, 분석). 여러 pass를 체인으로 연결하여 복잡한 변환을 구성할 수 있다.</p>
</blockquote>
<p><strong>변환 전 (high-level):</strong></p>
<pre><code class="language-mlir">func.func @main() -&gt; i32 {
  %c42 = arith.constant 42 : i32
  return %c42 : i32
}
</code></pre>
<p><strong>변환 후 (LLVM dialect):</strong></p>
<pre><code class="language-mlir">llvm.func @main() -&gt; i32 {
  %c42 = llvm.mlir.constant(42 : i32) : i32
  llvm.return %c42 : i32
}
</code></pre>
<p>차이를 주목한다:</p>
<ul>
<li><code>func.func</code> → <code>llvm.func</code></li>
<li><code>arith.constant</code> → <code>llvm.mlir.constant</code></li>
<li><code>return</code> → <code>llvm.return</code></li>
</ul>
<p>이제 IR이 LLVM IR로 변환할 준비가 되었다.</p>
<h2 id="5단계-llvm-ir-변환"><a class="header" href="#5단계-llvm-ir-변환">5단계: LLVM IR 변환</a></h2>
<p>MLIR은 LLVM IR로 변환하는 빌트인 변환기를 제공한다. <code>Lowering.fs</code>에 추가한다:</p>
<pre><code class="language-fsharp">    open System.Runtime.InteropServices

    /// MLIR module (LLVM dialect)을 LLVM IR 문자열로 변환
    let translateToLLVMIR (mlirMod: Module) : string =
        let ctx = mlirMod.Context
        let moduleOp = MlirNative.mlirModuleGetOperation(mlirMod.Handle)

        // LLVM context 생성
        let llvmCtx = MlirNative.llvmContextCreate()

        // MLIR을 LLVM IR로 변환
        let llvmModule = MlirNative.mlirTranslateModuleToLLVMIR(
            moduleOp,
            llvmCtx)

        if llvmModule = nativeint 0 then
            failwith "Failed to translate MLIR to LLVM IR"

        // LLVM IR을 문자열로 출력
        let irString = MlirNative.llvmPrintModuleToString(llvmModule)

        // 정리
        MlirNative.llvmDisposeModule(llvmModule)
        MlirNative.llvmContextDispose(llvmCtx)

        Marshal.PtrToStringAnsi(irString)
</code></pre>
<blockquote>
<p><strong>구현 참고:</strong> MLIR C API는 LLVM IR로 변환하는 <code>mlirTranslateModuleToLLVMIR</code>을 제공한다. 그런 다음 LLVM C API (<code>llvmPrintModuleToString</code>)를 사용하여 문자열화한다.</p>
</blockquote>
<p><strong>출력 (LLVM IR):</strong></p>
<pre><code class="language-llvm">define i32 @main() {
  ret i32 42
}
</code></pre>
<p>완벽하다! 이것은 순수한 LLVM IR이다. MLIR 개념이 전혀 없다.</p>
<h2 id="6단계-오브젝트-파일-생성"><a class="header" href="#6단계-오브젝트-파일-생성">6단계: 오브젝트 파일 생성</a></h2>
<p>이제 LLVM IR을 네이티브 머신 코드로 컴파일해야 한다. LLVM의 <code>llc</code> 도구를 사용한다:</p>
<pre><code class="language-fsharp">namespace FunLangCompiler

open System
open System.IO
open System.Diagnostics

/// 네이티브 코드 생성
module NativeCodeGen =

    /// LLVM IR을 오브젝트 파일로 컴파일 (llc 사용)
    let emitObjectFile (llvmIR: string) (outputPath: string) =
        // 임시 .ll 파일에 LLVM IR 쓰기
        let llFile = Path.GetTempFileName() + ".ll"
        File.WriteAllText(llFile, llvmIR)

        try
            // llc 실행: .ll → .o
            let psi = ProcessStartInfo()
            psi.FileName &lt;- "llc"
            psi.Arguments &lt;- sprintf "-filetype=obj -o %s %s" outputPath llFile
            psi.RedirectStandardOutput &lt;- true
            psi.RedirectStandardError &lt;- true
            psi.UseShellExecute &lt;- false

            let proc = Process.Start(psi)
            proc.WaitForExit()

            if proc.ExitCode &lt;&gt; 0 then
                let stderr = proc.StandardError.ReadToEnd()
                failwithf "llc failed:\n%s" stderr

            printfn "Generated object file: %s" outputPath

        finally
            // 임시 파일 정리
            File.Delete(llFile)
</code></pre>
<blockquote>
<p><strong>도구 요구사항:</strong> <code>llc</code>는 LLVM 도구체인의 일부다. Chapter 00에서 LLVM을 빌드했다면 <code>$HOME/mlir-install/bin/llc</code>에 있다. PATH에 있는지 확인한다.</p>
</blockquote>
<p><strong>사용:</strong></p>
<pre><code class="language-fsharp">let llvmIR = Lowering.translateToLLVMIR mlirMod
NativeCodeGen.emitObjectFile llvmIR "program.o"
</code></pre>
<p>이제 <code>program.o</code>가 있다 – ELF 오브젝트 파일 (Linux) 또는 Mach-O (macOS).</p>
<h2 id="7단계-실행-파일로-링크"><a class="header" href="#7단계-실행-파일로-링크">7단계: 실행 파일로 링크</a></h2>
<p>마지막 단계는 오브젝트 파일을 실행 파일로 링크하는 것이다. 시스템 링커 (<code>cc</code> 또는 <code>clang</code>)를 사용한다:</p>
<pre><code class="language-fsharp">    /// 오브젝트 파일을 실행 파일로 링크 (cc 사용)
    let linkExecutable (objectPath: string) (outputPath: string) =
        let psi = ProcessStartInfo()
        psi.FileName &lt;- "cc"  // 또는 "clang"
        psi.Arguments &lt;- sprintf "-o %s %s" outputPath objectPath
        psi.RedirectStandardOutput &lt;- true
        psi.RedirectStandardError &lt;- true
        psi.UseShellExecute &lt;- false

        let proc = Process.Start(psi)
        proc.WaitForExit()

        if proc.ExitCode &lt;&gt; 0 then
            let stderr = proc.StandardError.ReadToEnd()
            failwithf "Linking failed:\n%s" stderr

        printfn "Generated executable: %s" outputPath
</code></pre>
<p><strong>사용:</strong></p>
<pre><code class="language-fsharp">NativeCodeGen.linkExecutable "program.o" "program"
</code></pre>
<p>완료! <code>./program</code> 실행 파일이 생성되었다.</p>
<h2 id="완전한-컴파일러-드라이버"><a class="header" href="#완전한-컴파일러-드라이버">완전한 컴파일러 드라이버</a></h2>
<p>모든 것을 <code>Compiler.fs</code>에 하나로 모은다:</p>
<pre><code class="language-fsharp">namespace FunLangCompiler

open System
open System.IO

/// 메인 컴파일러 드라이버
module Compiler =

    /// 소스 파일을 네이티브 실행 파일로 컴파일
    let compile (sourceFile: string) (outputFile: string) =
        printfn "=== FunLang Compiler ==="
        printfn "Source: %s" sourceFile
        printfn "Output: %s" outputFile
        printfn ""

        // 1단계: 파싱
        printfn "[1/7] Parsing..."
        let source = File.ReadAllText(sourceFile)
        let program = Parser.parse source
        printfn "  AST: %A" program

        // 2단계: MLIR로 변환
        printfn "[2/7] Translating to MLIR..."
        let mlirMod = CodeGen.translateToMlir program
        printfn "  MLIR (high-level):"
        printfn "%s" (mlirMod.Print())

        // 3단계: 검증
        printfn "[3/7] Verifying MLIR..."
        CodeGen.verify mlirMod
        printfn "  ✓ Verification passed"

        // 4단계: LLVM dialect로 낮추기
        printfn "[4/7] Lowering to LLVM dialect..."
        Lowering.lowerToLLVMDialect mlirMod
        printfn "  MLIR (LLVM dialect):"
        printfn "%s" (mlirMod.Print())

        // 5단계: LLVM IR로 변환
        printfn "[5/7] Translating to LLVM IR..."
        let llvmIR = Lowering.translateToLLVMIR mlirMod
        printfn "  LLVM IR:"
        printfn "%s" llvmIR

        // 6단계: 오브젝트 파일 생성
        printfn "[6/7] Emitting object file..."
        let objectFile = outputFile + ".o"
        NativeCodeGen.emitObjectFile llvmIR objectFile

        // 7단계: 링크
        printfn "[7/7] Linking executable..."
        NativeCodeGen.linkExecutable objectFile outputFile

        // 정리
        mlirMod.Dispose()

        printfn ""
        printfn "=== Compilation successful ==="
        printfn "Run: ./%s" outputFile
</code></pre>
<h2 id="실행해-보기"><a class="header" href="#실행해-보기">실행해 보기</a></h2>
<p>테스트 프로그램을 작성한다:</p>
<pre><code class="language-bash">echo "42" &gt; test.fun
</code></pre>
<p>컴파일한다:</p>
<pre><code class="language-bash">dotnet fsi Compiler.fs -- test.fun program
</code></pre>
<p><strong>출력:</strong></p>
<pre><code>=== FunLang Compiler ===
Source: test.fun
Output: program

[1/7] Parsing...
  AST: { expr = IntLiteral 42 }
[2/7] Translating to MLIR...
  MLIR (high-level):
module {
  func.func @main() -&gt; i32 {
    %0 = arith.constant 42 : i32
    return %0 : i32
  }
}
[3/7] Verifying MLIR...
  ✓ Verification passed
[4/7] Lowering to LLVM dialect...
  MLIR (LLVM dialect):
module {
  llvm.func @main() -&gt; i32 {
    %0 = llvm.mlir.constant(42 : i32) : i32
    llvm.return %0 : i32
  }
}
[5/7] Translating to LLVM IR...
  LLVM IR:
define i32 @main() {
  ret i32 42
}
[6/7] Emitting object file...
Generated object file: program.o
[7/7] Linking executable...
Generated executable: program

=== Compilation successful ===
Run: ./program
</code></pre>
<p>실행한다:</p>
<pre><code class="language-bash">./program
echo $?
</code></pre>
<p><strong>출력:</strong></p>
<pre><code>42
</code></pre>
<blockquote>
<p><strong>마일스톤:</strong> 축하한다! 실제 코드를 컴파일하고 실행했다! 🎉</p>
</blockquote>
<h2 id="구축한-것"><a class="header" href="#구축한-것">구축한 것</a></h2>
<p>이 장에서 다음을 성취했다:</p>
<ol>
<li>
<p><strong>완전한 컴파일 파이프라인</strong>:</p>
<ul>
<li>소스 → AST (파싱)</li>
<li>AST → MLIR IR (코드 생성)</li>
<li>MLIR 검증</li>
<li>High-level dialect → LLVM dialect (progressive lowering)</li>
<li>MLIR → LLVM IR (변환)</li>
<li>LLVM IR → 오브젝트 파일 (<code>llc</code>)</li>
<li>오브젝트 파일 → 실행 파일 (링커)</li>
</ul>
</li>
<li>
<p><strong>실제 컴파일러</strong>: 단순하지만 이것은 실제 컴파일러다. 텍스트를 받아 네이티브 머신 코드를 생성한다.</p>
</li>
<li>
<p><strong>확장 가능한 아키텍처</strong>: <code>compileExpr</code>은 재귀적이다. 나중 장에서 더 많은 표현식 타입을 추가할 것이다:</p>
<ul>
<li>Chapter 06: 이진 연산 (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>)</li>
<li>Chapter 07: Let 바인딩과 변수</li>
<li>Chapter 08: If/then/else</li>
<li>Chapter 09: 함수와 재귀</li>
<li>Chapter 10+: 클로저, 패턴 매칭, 리스트</li>
</ul>
</li>
</ol>
<h2 id="다음-단계-2"><a class="header" href="#다음-단계-2">다음 단계</a></h2>
<p><strong>Phase 1 완료!</strong> 다음 phase에서는:</p>
<ul>
<li><strong>Phase 2</strong>: 산술 연산자, let 바인딩, if/else</li>
<li><strong>Phase 3</strong>: 함수와 재귀</li>
<li><strong>Phase 4</strong>: 클로저와 고차 함수</li>
<li><strong>Phase 5</strong>: 커스텀 MLIR dialect (Appendix 참조)</li>
<li><strong>Phase 6</strong>: 패턴 매칭과 데이터 구조</li>
<li><strong>Phase 7</strong>: 최적화와 마무리</li>
</ul>
<p><strong>Appendix를 읽는 것을 잊지 마라</strong>: 커스텀 MLIR dialect를 C++에서 정의하고 F#에서 사용하는 방법을 다룬다. 이것은 Phase 5의 기초가 된다.</p>
<hr>
<p><strong>Phase 1의 정점에 도달했다. 실제 컴파일러를 구축했다!</strong></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-06-산술-표현식---연산자와-비교"><a class="header" href="#chapter-06-산술-표현식---연산자와-비교">Chapter 06: 산술 표현식 - 연산자와 비교</a></h1>
<h2 id="소개-6"><a class="header" href="#소개-6">소개</a></h2>
<p>Chapter 05에서 정수 리터럴 하나만 컴파일하는 최소한의 컴파일러를 구축했다. <code>42</code>를 입력으로 받아 네이티브 바이너리로 출력하는 전체 파이프라인이 작동한다. 하지만 실제 프로그램을 작성하려면 산술 연산자가 필요하다.</p>
<p>이 장에서는 다음을 추가한다:</p>
<ul>
<li><strong>이진 연산자</strong>: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> (정수 산술)</li>
<li><strong>비교 연산자</strong>: <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>=</code>, <code>&lt;&gt;</code> (i1 boolean 반환)</li>
<li><strong>단항 연산자</strong>: <code>-</code> (부정)</li>
<li><strong>출력 기능</strong>: <code>print</code> 함수로 결과를 stdout에 출력</li>
</ul>
<p>이 장을 마치면 <code>10 + 3 * 4</code>와 같은 표현식을 컴파일하고, 비교를 수행하고, 결과를 화면에 출력하는 완전한 계산기 컴파일러를 갖게 된다.</p>
<blockquote>
<p><strong>중요:</strong> 산술 연산은 MLIR의 <code>arith</code> dialect를 사용한다 (Chapter 01의 primer에서 배웠다). 이 dialect는 SSA 형태의 연산을 제공하며 LLVM dialect로 깔끔하게 낮춰진다.</p>
</blockquote>
<h2 id="확장된-ast-정의"><a class="header" href="#확장된-ast-정의">확장된 AST 정의</a></h2>
<p>Chapter 05의 AST는 <code>IntLiteral</code> 하나만 가졌다. 이제 표현식을 확장한다:</p>
<pre><code class="language-fsharp">namespace FunLangCompiler

/// 이진 연산자
type Operator =
    | Add       // +
    | Subtract  // -
    | Multiply  // *
    | Divide    // /

/// 비교 연산자
type CompareOp =
    | LessThan       // &lt;
    | GreaterThan    // &gt;
    | LessEqual      // &lt;=
    | GreaterEqual   // &gt;=
    | Equal          // =
    | NotEqual       // &lt;&gt;

/// 단항 연산자
type UnaryOp =
    | Negate  // -

/// FunLang 표현식 AST
type Expr =
    | IntLiteral of int
    | BinaryOp of Operator * Expr * Expr       // 예: Add(IntLiteral 10, IntLiteral 20)
    | UnaryOp of UnaryOp * Expr                // 예: Negate(IntLiteral 42)
    | Comparison of CompareOp * Expr * Expr    // 예: LessThan(IntLiteral 5, IntLiteral 10)

/// 최상위 프로그램
type Program =
    { expr: Expr }
</code></pre>
<p><strong>설계 결정:</strong></p>
<ul>
<li><strong>Operator와 CompareOp 분리</strong>: 산술 연산은 i32를 반환하지만, 비교는 i1 (boolean)을 반환한다. 타입 시스템이 다르므로 별도의 타입으로 구분한다.</li>
<li><strong>UnaryOp은 확장 가능</strong>: 지금은 Negate만 있지만 나중에 논리 부정 (<code>not</code>) 등을 추가할 수 있다.</li>
</ul>
<p><strong>AST 예시:</strong></p>
<pre><code class="language-fsharp">// Source: 10 + 3 * 4
BinaryOp(Add,
  IntLiteral 10,
  BinaryOp(Multiply,
    IntLiteral 3,
    IntLiteral 4))

// Source: -(5 + 10)
UnaryOp(Negate,
  BinaryOp(Add,
    IntLiteral 5,
    IntLiteral 10))

// Source: 5 &lt; 10
Comparison(LessThan,
  IntLiteral 5,
  IntLiteral 10)
</code></pre>
<blockquote>
<p><strong>파서 노트:</strong> 실제 파서는 연산자 우선순위를 처리해야 한다 (<code>*</code>가 <code>+</code>보다 높음). 이 장에서는 코드 생성에 집중하므로 파서 구현은 생략한다. LangTutorial의 파서를 재사용하거나 간단한 재귀 하강 파서를 작성하면 된다.</p>
</blockquote>
<h2 id="arith-dialect-연산-생성"><a class="header" href="#arith-dialect-연산-생성">arith Dialect 연산 생성</a></h2>
<p>Chapter 03-04에서 구축한 <code>OpBuilder.CreateOperation</code> 패턴을 사용하여 arith dialect 연산을 생성한다. 개별 P/Invoke 대신 generic operation builder를 사용하는 것이 더 유연하고 유지보수가 쉽다.</p>
<p><strong>CodeGen.fs에서 연산 생성 헬퍼:</strong></p>
<pre><code class="language-fsharp">/// Create operation, append to block, return result value
let private emitOp (ctx: CompileContext) name resultTypes operands attrs regions =
    let op = ctx.Builder.CreateOperation(name, ctx.Location, resultTypes, operands, attrs, regions)
    ctx.Builder.AppendOperationToBlock(ctx.Block, op)
    op
</code></pre>
<p><strong>산술 연산 생성 예시:</strong></p>
<pre><code class="language-fsharp">// arith.addi: 정수 덧셈
| Add(left, right, _) -&gt;
    let leftVal = compileExpr ctx left
    let rightVal = compileExpr ctx right
    let i32Type = builder.I32Type()
    let op = emitOp ctx "arith.addi" [| i32Type |] [| leftVal; rightVal |] [||] [||]
    builder.GetResult(op, 0)

// arith.subi: 정수 뺄셈
| Subtract(left, right, _) -&gt;
    let leftVal = compileExpr ctx left
    let rightVal = compileExpr ctx right
    let op = emitOp ctx "arith.subi" [| i32Type |] [| leftVal; rightVal |] [||] [||]
    builder.GetResult(op, 0)

// arith.muli: 정수 곱셈
| Multiply(left, right, _) -&gt;
    let leftVal = compileExpr ctx left
    let rightVal = compileExpr ctx right
    let op = emitOp ctx "arith.muli" [| i32Type |] [| leftVal; rightVal |] [||] [||]
    builder.GetResult(op, 0)

// arith.divsi: 부호 있는 정수 나눗셈
| Divide(left, right, _) -&gt;
    let leftVal = compileExpr ctx left
    let rightVal = compileExpr ctx right
    let op = emitOp ctx "arith.divsi" [| i32Type |] [| leftVal; rightVal |] [||] [||]
    builder.GetResult(op, 0)
</code></pre>
<p><strong>비교 연산 - arith.cmpi:</strong></p>
<p>비교 연산은 predicate 속성이 필요하다. <strong>중요:</strong> predicate는 반드시 <strong>i64 타입</strong>의 IntegerAttr로 전달해야 한다:</p>
<pre><code class="language-fsharp">// arith.cmpi predicate 값:
//   0 = eq (equal)
//   1 = ne (not equal)
//   2 = slt (signed less than)
//   3 = sle (signed less or equal)
//   4 = sgt (signed greater than)
//   5 = sge (signed greater or equal)

| Equal(left, right, _) -&gt;
    let leftVal = compileExpr ctx left
    let rightVal = compileExpr ctx right
    let i64Type = builder.I64Type()  // 주의: i64 타입!
    let predicateAttr = builder.IntegerAttr(0L, i64Type)  // eq = 0
    let i1Type = builder.I1Type()  // 결과는 i1 (boolean)
    let op = emitOp ctx "arith.cmpi" [| i1Type |]
                [| leftVal; rightVal |]
                [| builder.NamedAttr("predicate", predicateAttr) |]
                [||]
    builder.GetResult(op, 0)
</code></pre>
<blockquote>
<p><strong>핵심 발견:</strong> MLIR의 ArithOps.td 정의에 따르면 predicate 속성은 i64 타입이어야 한다. i32를 사용하면 “attribute ‘predicate’ expected integer type of width 64” 에러가 발생한다.</p>
</blockquote>
<p><strong>연산자 매핑 표:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>FunLang Operator</th><th>MLIR Operation</th><th>타입 시그니처</th></tr>
</thead>
<tbody>
<tr><td><code>+</code></td><td><code>arith.addi</code></td><td><code>(i32, i32) -&gt; i32</code></td></tr>
<tr><td><code>-</code></td><td><code>arith.subi</code></td><td><code>(i32, i32) -&gt; i32</code></td></tr>
<tr><td><code>*</code></td><td><code>arith.muli</code></td><td><code>(i32, i32) -&gt; i32</code></td></tr>
<tr><td><code>/</code></td><td><code>arith.divsi</code></td><td><code>(i32, i32) -&gt; i32</code> (부호 있는 나눗셈)</td></tr>
<tr><td><code>&lt;</code></td><td><code>arith.cmpi slt</code></td><td><code>(i32, i32) -&gt; i1</code></td></tr>
<tr><td><code>&gt;</code></td><td><code>arith.cmpi sgt</code></td><td><code>(i32, i32) -&gt; i1</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>arith.cmpi sle</code></td><td><code>(i32, i32) -&gt; i1</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>arith.cmpi sge</code></td><td><code>(i32, i32) -&gt; i1</code></td></tr>
<tr><td><code>=</code></td><td><code>arith.cmpi eq</code></td><td><code>(i32, i32) -&gt; i1</code></td></tr>
<tr><td><code>&lt;&gt;</code></td><td><code>arith.cmpi ne</code></td><td><code>(i32, i32) -&gt; i1</code></td></tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>C API 노트:</strong> MLIR C API는 <code>mlir-c/Dialect/Arith.h</code>에서 arith dialect 연산을 노출한다. 실제 함수 이름은 위와 다를 수 있다 (예: <code>mlirArithAddiOpCreate</code> vs <code>mlirArithAddiCreate</code>). MLIR 설치의 헤더 파일을 확인하여 정확한 시그니처를 사용한다.</p>
</blockquote>
<p><strong>arith.cmpi predicate 값:</strong></p>
<pre><code class="language-fsharp">/// arith.cmpi predicate enum
module ArithCmpIPredicate =
    let eq = 0    // equal
    let ne = 1    // not equal
    let slt = 2   // signed less than
    let sle = 3   // signed less or equal
    let sgt = 4   // signed greater than
    let sge = 5   // signed greater or equal
    let ult = 6   // unsigned less than (나중에 사용)
    let ule = 7   // unsigned less or equal
    let ugt = 8   // unsigned greater than
    let uge = 9   // unsigned greater or equal
</code></pre>
<h2 id="boolean-리터럴과-논리-연산자"><a class="header" href="#boolean-리터럴과-논리-연산자">Boolean 리터럴과 논리 연산자</a></h2>
<p>비교 연산 외에도 boolean 리터럴 (<code>true</code>, <code>false</code>)과 논리 연산자 (<code>&amp;&amp;</code>, <code>||</code>)를 지원해야 한다.</p>
<h3 id="boolean-리터럴-컴파일"><a class="header" href="#boolean-리터럴-컴파일">Boolean 리터럴 컴파일</a></h3>
<p>Boolean 값은 i1 타입 (1-bit integer)으로 표현된다:</p>
<pre><code class="language-fsharp">| Bool(b, _) -&gt;
    let i1Type = builder.I1Type()
    let value = if b then 1L else 0L
    let valueAttr = builder.IntegerAttr(value, i1Type)
    let op = emitOp ctx "arith.constant" [| i1Type |] [||]
                [| builder.NamedAttr("value", valueAttr) |] [||]
    builder.GetResult(op, 0)
</code></pre>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">%true = arith.constant true    // 또는 arith.constant 1 : i1
%false = arith.constant false  // 또는 arith.constant 0 : i1
</code></pre>
<h3 id="논리-andor-연산자"><a class="header" href="#논리-andor-연산자">논리 AND/OR 연산자</a></h3>
<p>논리 연산자는 <code>arith.andi</code>와 <code>arith.ori</code>를 사용한다:</p>
<pre><code class="language-fsharp">| And(left, right, _) -&gt;
    let leftVal = compileExpr ctx left
    let rightVal = compileExpr ctx right
    let i1Type = builder.I1Type()
    let op = emitOp ctx "arith.andi" [| i1Type |] [| leftVal; rightVal |] [||] [||]
    builder.GetResult(op, 0)

| Or(left, right, _) -&gt;
    let leftVal = compileExpr ctx left
    let rightVal = compileExpr ctx right
    let i1Type = builder.I1Type()
    let op = emitOp ctx "arith.ori" [| i1Type |] [| leftVal; rightVal |] [||] [||]
    builder.GetResult(op, 0)
</code></pre>
<blockquote>
<p><strong>주의:</strong> 이 구현은 **비단락 평가 (non-short-circuit evaluation)**이다. 양쪽 피연산자가 항상 평가된다. 진정한 단락 평가를 위해서는 <code>scf.if</code>를 사용해야 한다 (Chapter 08 참조).</p>
</blockquote>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">// true &amp;&amp; false
%a = arith.constant true
%b = arith.constant false
%result = arith.andi %a, %b : i1  // 결과: false

// true || false
%result = arith.ori %a, %b : i1   // 결과: true
</code></pre>
<h2 id="코드-생성-패턴"><a class="header" href="#코드-생성-패턴">코드 생성 패턴</a></h2>
<p>실제 구현에서는 개별 P/Invoke 대신 generic <code>CreateOperation</code> 패턴을 사용한다. 이것이 더 유지보수하기 쉽고 확장성이 좋다.</p>
<p><strong>설계 결정:</strong></p>
<ul>
<li><strong>Generic 패턴</strong>: <code>CreateOperation(name, resultTypes, operands, attrs, regions)</code> 형식으로 모든 연산을 생성할 수 있다</li>
<li><strong>emitOp 헬퍼</strong>: CompileContext를 받아 operation 생성, block에 추가, operation 반환을 하나로 묶는다</li>
<li><strong>부정 구현</strong>: <code>-expr</code>은 <code>0 - expr</code>로 변환한다. 별도의 arith.negate 연산이 없으므로 이것이 표준 방법이다</li>
<li><strong>타입 일관성</strong>: 모든 정수는 i32, 모든 boolean은 i1로 컴파일한다</li>
</ul>
<h2 id="공통-에러-1부"><a class="header" href="#공통-에러-1부">공통 에러 (1부)</a></h2>
<h3 id="에러-1-잘못된-정수-타입-사용-i64-vs-i32"><a class="header" href="#에러-1-잘못된-정수-타입-사용-i64-vs-i32">에러 1: 잘못된 정수 타입 사용 (i64 vs i32)</a></h3>
<p><strong>증상:</strong></p>
<pre><code>MLIR verification failed:
  Type mismatch: expected i32, got i64
</code></pre>
<p><strong>원인:</strong>
MLIR은 타입이 엄격하다. 상수를 i64로 생성했지만 함수 시그니처는 i32를 요구하는 경우.</p>
<p><strong>해결:</strong></p>
<pre><code class="language-fsharp">// WRONG: i64 타입 사용
let i64Type = builder.Context.GetIntegerType(64)
let attr = builder.Context.GetIntegerAttr(i64Type, 42L)

// CORRECT: i32 타입 사용
let i32Type = builder.Context.GetIntegerType(32)
let attr = builder.Context.GetIntegerAttr(i32Type, 42L)
</code></pre>
<p><strong>규칙:</strong> 모든 FunLang 정수는 i32로 컴파일한다. 타입을 일관되게 유지한다.</p>
<h3 id="에러-2-연산자-우선순위를-파서에서-처리하지-않음"><a class="header" href="#에러-2-연산자-우선순위를-파서에서-처리하지-않음">에러 2: 연산자 우선순위를 파서에서 처리하지 않음</a></h3>
<p><strong>증상:</strong></p>
<pre><code>Source: 10 + 3 * 4
Expected: 22
Actual: 52  (잘못된 결과)
</code></pre>
<p><strong>원인:</strong>
파서가 우선순위를 무시하고 왼쪽에서 오른쪽으로 파싱하여 <code>(10 + 3) * 4 = 52</code>가 됨.</p>
<p><strong>해결:</strong>
파서에서 연산자 우선순위를 구현한다:</p>
<ul>
<li>곱셈/나눗셈 (<code>*</code>, <code>/</code>)이 덧셈/뺄셈 (<code>+</code>, <code>-</code>)보다 우선순위가 높다.</li>
<li>비교 연산자는 산술 연산보다 우선순위가 낮다.</li>
</ul>
<p><strong>재귀 하강 파서 예시:</strong></p>
<pre><code class="language-fsharp">// Precedence climbing algorithm
// additive := multiplicative (('+' | '-') multiplicative)*
// multiplicative := primary (('*' | '/') primary)*
// primary := number | '(' additive ')'
</code></pre>
<blockquote>
<p><strong>파서 구현은 이 장의 범위를 벗어난다.</strong> LangTutorial의 기존 파서를 사용하거나 FParsec 같은 파서 라이브러리를 사용한다.</p>
</blockquote>
<h2 id="산술-표현식을-위한-코드-생성"><a class="header" href="#산술-표현식을-위한-코드-생성">산술 표현식을 위한 코드 생성</a></h2>
<p>이제 Chapter 05의 <code>compileExpr</code>을 확장하여 모든 산술 표현식을 처리한다.</p>
<p><strong>CodeGen.fs</strong> 수정:</p>
<pre><code class="language-fsharp">namespace FunLangCompiler

open System
open MlirWrapper
open MlirBindings

module CodeGen =

    /// 표현식을 MLIR value로 컴파일 (재귀적)
    let rec compileExpr
        (builder: OpBuilder)
        (block: MlirBlock)
        (location: Location)
        (expr: Expr)
        : MlirValue =

        match expr with
        | IntLiteral value -&gt;
            // arith.constant operation 생성
            let i32Type = builder.I32Type()
            let attr = builder.Context.GetIntegerAttr(i32Type, int64 value)
            let constOp = builder.CreateConstant(attr, location)
            MlirNative.mlirBlockAppendOwnedOperation(block, constOp)
            builder.GetResult(constOp, 0)

        | BinaryOp(op, lhs, rhs) -&gt;
            // 왼쪽 피연산자 컴파일 (재귀)
            let lhsVal = compileExpr builder block location lhs

            // 오른쪽 피연산자 컴파일 (재귀)
            let rhsVal = compileExpr builder block location rhs

            // 이진 연산 생성
            let binOp = builder.CreateArithBinaryOp(op, lhsVal, rhsVal, location)
            MlirNative.mlirBlockAppendOwnedOperation(block, binOp)
            builder.GetResult(binOp, 0)

        | UnaryOp(Negate, expr) -&gt;
            // 피연산자 컴파일
            let val = compileExpr builder block location expr

            // 부정 연산 생성 (0 - val)
            let negOp = builder.CreateArithNegate(val, location)
            MlirNative.mlirBlockAppendOwnedOperation(block, negOp)
            builder.GetResult(negOp, 0)

        | Comparison(compareOp, lhs, rhs) -&gt;
            // 피연산자 컴파일
            let lhsVal = compileExpr builder block location lhs
            let rhsVal = compileExpr builder block location rhs

            // 비교 연산 생성 (i1 반환)
            let cmpOp = builder.CreateArithCompare(compareOp, lhsVal, rhsVal, location)
            MlirNative.mlirBlockAppendOwnedOperation(block, cmpOp)
            builder.GetResult(cmpOp, 0)

    /// 프로그램을 MLIR module로 컴파일
    let translateToMlir (program: Program) : Module =
        let ctx = new Context()
        ctx.LoadDialect("arith")
        ctx.LoadDialect("func")

        let loc = Location.Unknown(ctx)
        let mlirMod = new Module(ctx, loc)

        let builder = OpBuilder(ctx)
        let i32Type = builder.I32Type()

        // main 함수 생성: () -&gt; i32
        let funcType = builder.FunctionType([||], [| i32Type |])
        let funcOp = builder.CreateFunction("main", funcType, loc)

        // 함수 body에 entry block 생성
        let bodyRegion = MlirNative.mlirOperationGetRegion(funcOp, 0n)
        let entryBlock = MlirNative.mlirBlockCreate(0n, nativeint 0, nativeint 0)
        MlirNative.mlirRegionAppendOwnedBlock(bodyRegion, entryBlock)

        // 표현식 컴파일 (재귀적으로 모든 연산 처리)
        let resultValue = compileExpr builder entryBlock loc program.expr

        // return operation 생성
        let returnOp = builder.CreateReturn([| resultValue |], loc)
        MlirNative.mlirBlockAppendOwnedOperation(entryBlock, returnOp)

        // 함수를 module에 추가
        MlirNative.mlirBlockAppendOwnedOperation(mlirMod.Body, funcOp)

        mlirMod

    /// MLIR module을 검증
    let verify (mlirMod: Module) =
        if not (mlirMod.Verify()) then
            eprintfn "MLIR verification failed:"
            eprintfn "%s" (mlirMod.Print())
            failwith "MLIR IR is invalid"
</code></pre>
<p><strong>SSA 형태 유지:</strong></p>
<p>재귀 호출이 SSA 형태를 자연스럽게 유지한다는 것을 주목한다:</p>
<ul>
<li>각 <code>compileExpr</code> 호출은 새로운 SSA value를 반환한다.</li>
<li>중복 계산이 없다 (각 표현식은 정확히 한 번만 평가된다).</li>
<li>지배 관계가 자동으로 유지된다 (하위 표현식이 먼저 평가된다).</li>
</ul>
<p><strong>예시: 복잡한 표현식 컴파일</strong></p>
<pre><code class="language-fsharp">// Source: 10 + 3 * 4
let ast = BinaryOp(Add,
            IntLiteral 10,
            BinaryOp(Multiply,
              IntLiteral 3,
              IntLiteral 4))

let mlirMod = CodeGen.translateToMlir { expr = ast }
printfn "%s" (mlirMod.Print())
</code></pre>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">module {
  func.func @main() -&gt; i32 {
    %c10 = arith.constant 10 : i32
    %c3 = arith.constant 3 : i32
    %c4 = arith.constant 4 : i32
    %0 = arith.muli %c3, %c4 : i32     // 3 * 4 = 12
    %1 = arith.addi %c10, %0 : i32     // 10 + 12 = 22
    func.return %1 : i32
  }
}
</code></pre>
<p><strong>동작 분석:</strong></p>
<ol>
<li>상수 10, 3, 4가 생성된다 (<code>arith.constant</code>)</li>
<li>먼저 곱셈 계산: <code>%0 = 3 * 4</code> (하위 표현식이 먼저)</li>
<li>그 다음 덧셈: <code>%1 = 10 + %0</code></li>
<li>결과 반환: <code>return %1</code></li>
</ol>
<blockquote>
<p><strong>중요:</strong> 연산 순서는 AST 구조가 결정한다. 파서가 올바른 우선순위로 AST를 구축하면 코드 생성이 자동으로 올바른 평가 순서를 생성한다.</p>
</blockquote>
<p><strong>비교 예시:</strong></p>
<pre><code class="language-fsharp">// Source: 5 &lt; 10
let ast = Comparison(LessThan, IntLiteral 5, IntLiteral 10)

let mlirMod = CodeGen.translateToMlir { expr = ast }
printfn "%s" (mlirMod.Print())
</code></pre>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">module {
  func.func @main() -&gt; i32 {
    %c5 = arith.constant 5 : i32
    %c10 = arith.constant 10 : i32
    %0 = arith.cmpi slt, %c5, %c10 : i32  // returns i1
    // 문제: %0은 i1이지만 함수는 i32를 반환해야 함!
    func.return %0 : i32  // TYPE ERROR!
  }
}
</code></pre>
<p><strong>타입 불일치 문제:</strong> 비교는 i1 (boolean)을 반환하지만 main 함수는 i32를 기대한다. 이를 해결하려면 boolean을 정수로 확장해야 한다:</p>
<pre><code class="language-fsharp">// compileExpr 수정 (Comparison 케이스)
| Comparison(compareOp, lhs, rhs) -&gt;
    let lhsVal = compileExpr builder block location lhs
    let rhsVal = compileExpr builder block location rhs

    // 비교 연산 (i1 반환)
    let cmpOp = builder.CreateArithCompare(compareOp, lhsVal, rhsVal, location)
    MlirNative.mlirBlockAppendOwnedOperation(block, cmpOp)
    let cmpVal = builder.GetResult(cmpOp, 0)

    // i1 -&gt; i32 확장 (zero extend)
    let i32Type = builder.I32Type()
    let extOp = builder.CreateArithExtUI(cmpVal, i32Type, location)  // unsigned extend
    MlirNative.mlirBlockAppendOwnedOperation(block, extOp)
    builder.GetResult(extOp, 0)
</code></pre>
<p><strong>생성된 MLIR IR (수정 후):</strong></p>
<pre><code class="language-mlir">module {
  func.func @main() -&gt; i32 {
    %c5 = arith.constant 5 : i32
    %c10 = arith.constant 10 : i32
    %0 = arith.cmpi slt, %c5, %c10 : i32   // returns i1
    %1 = arith.extui %0 : i1 to i32        // i1 -&gt; i32 (0 or 1)
    func.return %1 : i32
  }
}
</code></pre>
<p>이제 비교 결과가 정수로 반환된다 (true = 1, false = 0).</p>
<p><strong>단항 부정 예시:</strong></p>
<pre><code class="language-fsharp">// Source: -(10 + 5)
let ast = UnaryOp(Negate, BinaryOp(Add, IntLiteral 10, IntLiteral 5))

let mlirMod = CodeGen.translateToMlir { expr = ast }
printfn "%s" (mlirMod.Print())
</code></pre>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">module {
  func.func @main() -&gt; i32 {
    %c10 = arith.constant 10 : i32
    %c5 = arith.constant 5 : i32
    %0 = arith.addi %c10, %c5 : i32     // 10 + 5 = 15
    %c0 = arith.constant 0 : i32
    %1 = arith.subi %c0, %0 : i32       // 0 - 15 = -15
    func.return %1 : i32
  }
}
</code></pre>
<h2 id="출력-기능-추가-printf로-결과-출력"><a class="header" href="#출력-기능-추가-printf로-결과-출력">출력 기능 추가: printf로 결과 출력</a></h2>
<p>지금까지 프로그램은 결과를 종료 코드로만 반환했다. 이제 <code>printf</code>를 사용하여 stdout에 출력하는 기능을 추가한다.</p>
<h3 id="llvmcall-연산을-위한-pinvoke-바인딩"><a class="header" href="#llvmcall-연산을-위한-pinvoke-바인딩">llvm.call 연산을 위한 P/Invoke 바인딩</a></h3>
<p>LLVM dialect는 외부 함수를 호출하는 <code>llvm.call</code> 연산을 제공한다.</p>
<p><strong>MlirBindings.fs</strong>에 추가:</p>
<pre><code class="language-fsharp">    // ===== LLVM dialect operations =====

    /// llvm.call: 외부 함수 호출
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirLLVMCallCreate(
        MlirContext context,
        MlirLocation location,
        MlirValue callee,
        MlirValue[] args,
        int numArgs)

    /// llvm.mlir.global: 전역 문자열 상수
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirLLVMGlobalCreate(
        MlirContext context,
        MlirLocation location,
        MlirType type,
        MlirAttribute initializer,
        MlirStringRef name)

    /// llvm.mlir.addressof: 전역 변수의 주소 가져오기
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirLLVMAddressOfCreate(
        MlirContext context,
        MlirLocation location,
        MlirStringRef globalName)
</code></pre>
<blockquote>
<p><strong>C API 경고:</strong> 실제 MLIR C API는 LLVM dialect에 대한 직접 지원이 제한적일 수 있다. 필요한 경우 Chapter 05의 Appendix 패턴 (C++ wrapper)을 사용한다.</p>
</blockquote>
<h3 id="printf-함수-선언-생성"><a class="header" href="#printf-함수-선언-생성">printf 함수 선언 생성</a></h3>
<p>printf를 호출하려면 먼저 함수 선언과 전역 포맷 문자열이 필요하다.</p>
<p><strong>CodeGen.fs</strong>에 헬퍼 함수 추가:</p>
<pre><code class="language-fsharp">    /// printf 함수 선언 생성 (module 레벨)
    let createPrintfDeclaration (builder: OpBuilder) (mlirMod: Module) (location: Location) =
        // printf 시그니처: (i8*, ...) -&gt; i32
        let i8Type = builder.Context.GetIntegerType(8)
        let i8PtrType = builder.Context.GetPointerType(i8Type)
        let i32Type = builder.I32Type()

        // func.func @printf(%fmt: !llvm.ptr&lt;i8&gt;, ...) -&gt; i32 attributes { sym_visibility = "private" }
        let printfType = builder.FunctionType([| i8PtrType |], [| i32Type |])
        let printfOp = builder.CreateFunction("printf", printfType, location)

        // 가변 인자 속성 추가 (실제 구현에서는 속성 API 필요)
        // 여기서는 단순화를 위해 생략

        MlirNative.mlirBlockAppendOwnedOperation(mlirMod.Body, printfOp)

    /// 전역 포맷 문자열 생성: "%d\n\0"
    let createFormatString (builder: OpBuilder) (mlirMod: Module) (location: Location) : string =
        let formatStrName = ".str.fmt"
        let formatStrValue = "%d\n\0"

        // LLVM global 생성
        let i8Type = builder.Context.GetIntegerType(8)
        let arrayType = builder.Context.GetArrayType(i8Type, formatStrValue.Length)
        let strAttr = builder.Context.GetStringAttr(formatStrValue)

        let globalOp = builder.CreateLLVMGlobal(arrayType, strAttr, formatStrName, location)
        MlirNative.mlirBlockAppendOwnedOperation(mlirMod.Body, globalOp)

        formatStrName

    /// print_int 헬퍼 함수 생성: 정수를 출력
    let createPrintIntHelper
        (builder: OpBuilder)
        (mlirMod: Module)
        (location: Location)
        (formatStrName: string)
        =

        // func.func @print_int(%arg: i32) -&gt; i32
        let i32Type = builder.I32Type()
        let funcType = builder.FunctionType([| i32Type |], [| i32Type |])
        let funcOp = builder.CreateFunction("print_int", funcType, location)

        // 함수 body
        let bodyRegion = MlirNative.mlirOperationGetRegion(funcOp, 0n)
        let entryBlock = MlirNative.mlirBlockCreate(1n, &amp;i32Type, nativeint 0)  // 1 argument
        MlirNative.mlirRegionAppendOwnedBlock(bodyRegion, entryBlock)

        // 인자 가져오기
        let arg = MlirNative.mlirBlockGetArgument(entryBlock, 0n)

        // 포맷 문자열 주소 가져오기
        let formatStrOp = builder.CreateLLVMAddressOf(formatStrName, location)
        MlirNative.mlirBlockAppendOwnedOperation(entryBlock, formatStrOp)
        let formatStrPtr = builder.GetResult(formatStrOp, 0)

        // printf 호출
        let printfCallOp = builder.CreateLLVMCall("printf", [| formatStrPtr; arg |], location)
        MlirNative.mlirBlockAppendOwnedOperation(entryBlock, printfCallOp)

        // 인자를 그대로 반환 (print는 부수 효과)
        let returnOp = builder.CreateReturn([| arg |], location)
        MlirNative.mlirBlockAppendOwnedOperation(entryBlock, returnOp)

        MlirNative.mlirBlockAppendOwnedOperation(mlirMod.Body, funcOp)
</code></pre>
<h3 id="main-함수에서-print_int-호출"><a class="header" href="#main-함수에서-print_int-호출">main 함수에서 print_int 호출</a></h3>
<p>이제 main 함수를 수정하여 결과를 출력하도록 한다:</p>
<pre><code class="language-fsharp">    /// 프로그램을 MLIR module로 컴파일 (print 지원)
    let translateToMlirWithPrint (program: Program) : Module =
        let ctx = new Context()
        ctx.LoadDialect("arith")
        ctx.LoadDialect("func")
        ctx.LoadDialect("llvm")

        let loc = Location.Unknown(ctx)
        let mlirMod = new Module(ctx, loc)

        let builder = OpBuilder(ctx)
        let i32Type = builder.I32Type()

        // printf 선언과 print_int 헬퍼 생성
        createPrintfDeclaration builder mlirMod loc
        let formatStrName = createFormatString builder mlirMod loc
        createPrintIntHelper builder mlirMod loc formatStrName

        // main 함수 생성
        let funcType = builder.FunctionType([||], [| i32Type |])
        let funcOp = builder.CreateFunction("main", funcType, loc)

        let bodyRegion = MlirNative.mlirOperationGetRegion(funcOp, 0n)
        let entryBlock = MlirNative.mlirBlockCreate(0n, nativeint 0, nativeint 0)
        MlirNative.mlirRegionAppendOwnedBlock(bodyRegion, entryBlock)

        // 표현식 컴파일
        let resultValue = compileExpr builder entryBlock loc program.expr

        // print_int 호출
        let printOp = builder.CreateFunctionCall("print_int", [| resultValue |], loc)
        MlirNative.mlirBlockAppendOwnedOperation(entryBlock, printOp)
        let printedVal = builder.GetResult(printOp, 0)

        // 결과 반환
        let returnOp = builder.CreateReturn([| printedVal |], loc)
        MlirNative.mlirBlockAppendOwnedOperation(entryBlock, returnOp)

        MlirNative.mlirBlockAppendOwnedOperation(mlirMod.Body, funcOp)

        mlirMod
</code></pre>
<p><strong>생성된 MLIR IR (전체):</strong></p>
<pre><code class="language-mlir">module {
  // printf 선언
  func.func private @printf(!llvm.ptr&lt;i8&gt;, ...) -&gt; i32

  // 포맷 문자열
  llvm.mlir.global private constant @.str.fmt("%d\n\00")

  // print_int 헬퍼
  func.func @print_int(%arg0: i32) -&gt; i32 {
    %fmt = llvm.mlir.addressof @.str.fmt : !llvm.ptr&lt;array&lt;4 x i8&gt;&gt;
    %fmt_ptr = llvm.bitcast %fmt : !llvm.ptr&lt;array&lt;4 x i8&gt;&gt; to !llvm.ptr&lt;i8&gt;
    %result = llvm.call @printf(%fmt_ptr, %arg0) : (!llvm.ptr&lt;i8&gt;, i32) -&gt; i32
    func.return %arg0 : i32
  }

  // main 함수
  func.func @main() -&gt; i32 {
    %c10 = arith.constant 10 : i32
    %c3 = arith.constant 3 : i32
    %c4 = arith.constant 4 : i32
    %0 = arith.muli %c3, %c4 : i32
    %1 = arith.addi %c10, %0 : i32
    %2 = func.call @print_int(%1) : (i32) -&gt; i32
    func.return %2 : i32
  }
}
</code></pre>
<p><strong>실행 결과:</strong></p>
<pre><code class="language-bash">$ ./program
22
$ echo $?
22
</code></pre>
<p>결과가 stdout에 출력되고 종료 코드로도 반환된다!</p>
<h2 id="완전한-컴파일러-드라이버-1"><a class="header" href="#완전한-컴파일러-드라이버-1">완전한 컴파일러 드라이버</a></h2>
<p>Chapter 05의 컴파일러 드라이버를 업데이트하여 새로운 기능을 지원한다:</p>
<p><strong>Compiler.fs 업데이트:</strong></p>
<pre><code class="language-fsharp">namespace FunLangCompiler

open System
open System.IO

module Compiler =

    /// 소스 파일을 네이티브 실행 파일로 컴파일
    let compile (sourceFile: string) (outputFile: string) (withPrint: bool) =
        printfn "=== FunLang Compiler ==="
        printfn "Source: %s" sourceFile
        printfn "Output: %s" outputFile
        printfn ""

        // 1단계: 파싱
        printfn "[1/7] Parsing..."
        let source = File.ReadAllText(sourceFile)
        let program = Parser.parse source  // 실제 파서 사용 (LangTutorial 재사용)
        printfn "  AST: %A" program

        // 2단계: MLIR로 변환
        printfn "[2/7] Translating to MLIR..."
        let mlirMod =
            if withPrint then
                CodeGen.translateToMlirWithPrint program
            else
                CodeGen.translateToMlir program
        printfn "  MLIR (high-level):"
        printfn "%s" (mlirMod.Print())

        // 3단계: 검증
        printfn "[3/7] Verifying MLIR..."
        CodeGen.verify mlirMod
        printfn "  ✓ Verification passed"

        // 4-7단계: Lowering, LLVM IR, object file, linking (Chapter 05와 동일)
        Lowering.lowerToLLVMDialect mlirMod
        let llvmIR = Lowering.translateToLLVMIR mlirMod
        let objectFile = outputFile + ".o"
        NativeCodeGen.emitObjectFile llvmIR objectFile
        NativeCodeGen.linkExecutable objectFile outputFile

        mlirMod.Dispose()

        printfn ""
        printfn "=== Compilation successful ==="
        printfn "Run: ./%s" outputFile

[&lt;EntryPoint&gt;]
let main args =
    if args.Length &lt; 2 then
        eprintfn "Usage: compiler &lt;source.fun&gt; &lt;output&gt; [--print]"
        exit 1

    let sourceFile = args.[0]
    let outputFile = args.[1]
    let withPrint = args.Length &gt; 2 &amp;&amp; args.[2] = "--print"

    Compiler.compile sourceFile outputFile withPrint
    0
</code></pre>
<p><strong>사용 예시:</strong></p>
<pre><code class="language-bash"># 결과를 출력하지 않음 (종료 코드만)
$ dotnet run test.fun program

# 결과를 출력함 (stdout + 종료 코드)
$ dotnet run test.fun program --print
$ ./program
22
</code></pre>
<h2 id="공통-에러-2부"><a class="header" href="#공통-에러-2부">공통 에러 (2부)</a></h2>
<h3 id="에러-3-비교가-i1을-반환하지만-i32가-필요한-곳에서-사용"><a class="header" href="#에러-3-비교가-i1을-반환하지만-i32가-필요한-곳에서-사용">에러 3: 비교가 i1을 반환하지만 i32가 필요한 곳에서 사용</a></h3>
<p><strong>증상:</strong></p>
<pre><code>MLIR verification failed:
  Type mismatch in func.return: expected i32, got i1
</code></pre>
<p><strong>원인:</strong>
비교 연산은 i1 (boolean)을 반환하지만 main 함수는 i32를 반환해야 한다.</p>
<p><strong>해결:</strong>
i1을 i32로 확장한다:</p>
<pre><code class="language-fsharp">// arith.extui 사용 (zero extend)
let extOp = builder.CreateArithExtUI(cmpVal, i32Type, location)
</code></pre>
<p><strong>또는</strong> main 함수가 i1을 반환하도록 변경 (덜 일반적):</p>
<pre><code class="language-fsharp">// main 함수 시그니처를 i1으로 변경 (비권장)
let funcType = builder.FunctionType([||], [| builder.Context.GetIntegerType(1) |])
</code></pre>
<p><strong>권장 방법:</strong> 항상 i32로 확장한다. Unix 종료 코드는 8비트 정수이므로 boolean을 정수로 표현하는 것이 자연스럽다.</p>
<h3 id="에러-4-0으로-나누기-런타임-vs-컴파일-타임"><a class="header" href="#에러-4-0으로-나누기-런타임-vs-컴파일-타임">에러 4: 0으로 나누기 (런타임 vs 컴파일 타임)</a></h3>
<p><strong>증상:</strong></p>
<pre><code class="language-bash">$ ./program
Floating point exception (core dumped)
</code></pre>
<p><strong>원인:</strong>
<code>10 / 0</code>과 같은 표현식이 런타임에 0으로 나누기를 시도한다.</p>
<p><strong>컴파일 타임 해결:</strong>
AST를 분석하여 상수 0으로 나누기를 감지한다:</p>
<pre><code class="language-fsharp">| BinaryOp(Divide, lhs, IntLiteral 0) -&gt;
    failwith "Compile error: division by zero"
</code></pre>
<p><strong>런타임 해결 (더 일반적):</strong>
동적 검사 코드를 삽입한다:</p>
<pre><code class="language-fsharp">| BinaryOp(Divide, lhs, rhs) -&gt;
    let lhsVal = compileExpr builder block location lhs
    let rhsVal = compileExpr builder block location rhs

    // rhsVal == 0 검사
    let zero = builder.CreateConstant(0, builder.I32Type(), location)
    let isZero = builder.CreateArithCmpi(ArithCmpIPredicate.eq, rhsVal, zero, location)

    // if (rhsVal == 0) abort() else lhs / rhs
    // scf.if 사용 (Chapter 08에서 다룸)
    // 지금은 단순화를 위해 생략
</code></pre>
<p><strong>실용적 접근:</strong> 대부분의 컴파일러는 0으로 나누기를 런타임 에러로 남긴다. 프로그램이 SIGFPE로 종료되는 것이 예상 동작이다.</p>
<h3 id="에러-5-printf-포맷-문자열에-null-terminator-누락"><a class="header" href="#에러-5-printf-포맷-문자열에-null-terminator-누락">에러 5: printf 포맷 문자열에 null terminator 누락</a></h3>
<p><strong>증상:</strong></p>
<pre><code class="language-bash">$ ./program
22ݠ�(garbage characters)
</code></pre>
<p><strong>원인:</strong>
C 문자열은 null terminator (<code>\0</code>)가 필요하다. <code>"%d\n"</code> 대신 <code>"%d\n\0"</code>를 사용해야 한다.</p>
<p><strong>해결:</strong></p>
<pre><code class="language-fsharp">// WRONG: null terminator 없음
let formatStrValue = "%d\n"

// CORRECT: null terminator 포함
let formatStrValue = "%d\n\0"
</code></pre>
<p><strong>MLIR IR:</strong></p>
<pre><code class="language-mlir">// CORRECT
llvm.mlir.global private constant @.str.fmt("%d\0A\00") : !llvm.array&lt;4 x i8&gt;
</code></pre>
<h3 id="에러-6-arith-연산-후-llvm-dialect로-낮추기-잊음"><a class="header" href="#에러-6-arith-연산-후-llvm-dialect로-낮추기-잊음">에러 6: arith 연산 후 LLVM dialect로 낮추기 잊음</a></h3>
<p><strong>증상:</strong></p>
<pre><code>Translation error: Unhandled operation 'arith.addi'
</code></pre>
<p><strong>원인:</strong>
arith dialect를 LLVM IR로 변환하려면 먼저 LLVM dialect로 낮춰야 한다.</p>
<p><strong>해결:</strong>
Lowering 단계에서 <code>convert-arith-to-llvm</code> pass를 실행한다:</p>
<pre><code class="language-fsharp">// Pass manager에 추가
MlirStringRef.WithString "convert-arith-to-llvm" (fun passName -&gt;
    let pass = MlirNative.mlirCreateConversionPass(passName)
    MlirNative.mlirPassManagerAddOwnedPass(pm, pass))
</code></pre>
<p><strong>Pass 순서:</strong></p>
<ol>
<li><code>convert-func-to-llvm</code></li>
<li><code>convert-arith-to-llvm</code></li>
<li><code>reconcile-unrealized-casts</code></li>
<li>그 다음 <code>mlirTranslateModuleToLLVMIR</code></li>
</ol>
<h2 id="구현-시-주의사항-common-pitfalls"><a class="header" href="#구현-시-주의사항-common-pitfalls">구현 시 주의사항 (Common Pitfalls)</a></h2>
<p>실제 구현에서 발견된 중요한 주의사항들:</p>
<h3 id="1-arithcmpi-predicate는-i64-타입이어야-한다"><a class="header" href="#1-arithcmpi-predicate는-i64-타입이어야-한다">1. arith.cmpi predicate는 i64 타입이어야 한다</a></h3>
<pre><code class="language-fsharp">// WRONG: i32 타입 predicate
let predicateAttr = builder.IntegerAttr(0L, builder.I32Type())

// CORRECT: i64 타입 predicate
let predicateAttr = builder.IntegerAttr(0L, builder.I64Type())
</code></pre>
<p>MLIR ArithOps.td 정의에서 predicate는 64비트 정수 속성으로 정의되어 있다. i32를 사용하면 검증 에러가 발생한다.</p>
<h3 id="2-비교-연산-결과는-i1-정수-연산-결과는-i32"><a class="header" href="#2-비교-연산-결과는-i1-정수-연산-결과는-i32">2. 비교 연산 결과는 i1, 정수 연산 결과는 i32</a></h3>
<pre><code class="language-fsharp">// 비교 연산: i1 결과
let op = emitOp ctx "arith.cmpi" [| builder.I1Type() |] ...

// 산술 연산: i32 결과
let op = emitOp ctx "arith.addi" [| builder.I32Type() |] ...
</code></pre>
<h3 id="3-boolean-리터럴은-i1-타입의-arithconstant"><a class="header" href="#3-boolean-리터럴은-i1-타입의-arithconstant">3. Boolean 리터럴은 i1 타입의 arith.constant</a></h3>
<pre><code class="language-fsharp">// Boolean true/false
let i1Type = builder.I1Type()
let value = if b then 1L else 0L
let valueAttr = builder.IntegerAttr(value, i1Type)  // i1 타입으로 생성
</code></pre>
<h3 id="4-비단락-평가에-주의"><a class="header" href="#4-비단락-평가에-주의">4. 비단락 평가에 주의</a></h3>
<p><code>arith.andi</code>와 <code>arith.ori</code>는 양쪽 피연산자를 모두 평가한다. 부수 효과가 있는 표현식에서 문제가 될 수 있다. 진정한 단락 평가가 필요하면 <code>scf.if</code>를 사용한다.</p>
<h2 id="장-요약"><a class="header" href="#장-요약">장 요약</a></h2>
<p>이 장에서 다음을 성취했다:</p>
<ol>
<li><strong>확장된 AST</strong>: 이진 연산자, 비교, 단항 부정, boolean 리터럴, 논리 연산자를 지원하는 표현식 타입</li>
<li><strong>Generic 연산 생성</strong>: <code>CreateOperation</code> 패턴으로 arith dialect 연산 생성</li>
<li><strong>비교 연산</strong>: arith.cmpi와 i64 predicate 속성</li>
<li><strong>Boolean 지원</strong>: i1 타입, arith.andi/ori 논리 연산자</li>
<li><strong>재귀 코드 생성</strong>: SSA 형태를 유지하며 복잡한 표현식 컴파일</li>
<li><strong>출력 기능</strong>: printf를 통한 결과 출력</li>
<li><strong>완전한 예제</strong>: MLIR IR 출력을 보여주는 실행 가능한 코드</li>
</ol>
<p><strong>독자가 할 수 있는 것:</strong></p>
<ul>
<li><code>10 + 3 * 4</code> 컴파일 → 네이티브 바이너리 → 실행 → 결과: 22 ✓</li>
<li><code>5 &lt; 10</code> 컴파일 → boolean 반환 (1 = true) ✓</li>
<li><code>-42</code> 컴파일 → 부정 연산 ✓</li>
<li><code>print(10 + 20)</code> 컴파일 → stdout 출력: 30 ✓</li>
</ul>
<p><strong>다음 장 미리보기:</strong></p>
<p>Chapter 07에서는 <strong>let 바인딩</strong>을 추가한다:</p>
<pre><code class="language-fsharp">let x = 10 in
let y = 20 in
x + y
</code></pre>
<p>이것은 다음을 도입한다:</p>
<ul>
<li>변수 이름과 SSA value 간의 환경 (symbol table)</li>
<li>중첩된 스코프 (nested scopes)</li>
<li>변수 섀도잉 (shadowing) vs 뮤테이션 (mutation)</li>
</ul>
<p><strong>Phase 2는 계속된다!</strong></p>
<hr>
<p><strong>이제 독자는 산술 표현식을 컴파일하고 결과를 출력할 수 있다!</strong></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-07-let-바인딩과-ssa-형태"><a class="header" href="#chapter-07-let-바인딩과-ssa-형태">Chapter 07: Let 바인딩과 SSA 형태</a></h1>
<h2 id="소개-7"><a class="header" href="#소개-7">소개</a></h2>
<p>프로그래밍에서 변수는 필수적이다. 값을 이름에 바인딩하고, 나중에 그 이름을 참조하여 값을 재사용한다. Chapter 06까지는 표현식을 직접 계산했지만, 실제 프로그램을 작성하려면 중간 결과를 저장하고 참조할 수 있어야 한다.</p>
<p>이 장에서는 <strong>let 바인딩</strong>을 추가한다:</p>
<pre><code class="language-fsharp">let x = 10 in
let y = 20 in
x + y
</code></pre>
<p>함수형 언어의 let 바인딩은 명령형 언어의 변수 할당과 다르다:</p>
<ul>
<li><strong>명령형</strong>: <code>x = 5; x = 10;</code> (뮤테이션 - 값이 변경됨)</li>
<li><strong>함수형</strong>: <code>let x = 5 in let x = 10 in x</code> (섀도잉 - 새로운 바인딩 생성, 뮤테이션 아님)</li>
</ul>
<p><strong>핵심 통찰력:</strong> let 바인딩은 **불변(immutable)**이다. 이것이 MLIR의 SSA (Static Single Assignment) 형태와 완벽하게 일치한다. 함수형 프로그래밍은 SSA를 자연스럽게 표현한다!</p>
<p>이 장을 마치면:</p>
<ul>
<li>let 바인딩을 컴파일하여 네이티브 바이너리로 만들 수 있다</li>
<li>중첩된 바인딩과 스코프를 이해한다</li>
<li>SSA 형태가 무엇이고 왜 중요한지 안다</li>
<li>환경 전달(environment passing)로 변수를 관리하는 방법을 안다</li>
</ul>
<blockquote>
<p><strong>중요:</strong> 이 장은 SSA 개념을 소개한다. SSA는 현대 컴파일러의 핵심 기술이며, MLIR은 SSA를 기본으로 한다.</p>
</blockquote>
<h2 id="ssa-형태-설명"><a class="header" href="#ssa-형태-설명">SSA 형태 설명</a></h2>
<h3 id="ssa란-무엇인가"><a class="header" href="#ssa란-무엇인가">SSA란 무엇인가?</a></h3>
<p>**SSA (Static Single Assignment)**는 중간 표현(IR)의 속성이다:</p>
<blockquote>
<p><strong>정의:</strong> 각 변수는 프로그램에서 정확히 한 번만 할당된다.</p>
</blockquote>
<p>예시:</p>
<pre><code class="language-fsharp">// SSA가 아님 (명령형):
x = 5
x = 10  // x가 두 번 할당됨!

// SSA (함수형):
let x1 = 5 in    // x1은 한 번만 할당
let x2 = 10 in   // x2는 한 번만 할당
x2
</code></pre>
<p>MLIR IR에서 SSA value는 <code>%</code> 기호로 표시된다:</p>
<pre><code class="language-mlir">%x = arith.constant 5 : i32      // %x 정의 (한 번만)
%y = arith.addi %x, %x : i32     // %x 사용 (여러 번 가능)
%z = arith.muli %y, %x : i32     // %x, %y 사용
</code></pre>
<p>각 SSA value (<code>%x</code>, <code>%y</code>, <code>%z</code>)는 정확히 한 번만 정의된다. 사용은 여러 번 가능하다.</p>
<h3 id="왜-ssa가-중요한가"><a class="header" href="#왜-ssa가-중요한가">왜 SSA가 중요한가?</a></h3>
<p>SSA 형태는 컴파일러 최적화를 극적으로 단순화한다:</p>
<h4 id="1-상수-전파-constant-propagation"><a class="header" href="#1-상수-전파-constant-propagation">1. 상수 전파 (Constant Propagation)</a></h4>
<pre><code class="language-mlir">// SSA 형태
%c5 = arith.constant 5 : i32
%result = arith.addi %c5, %c5 : i32

// 최적화: %c5가 상수임을 알고 있으므로
%c10 = arith.constant 10 : i32  // 컴파일 타임에 계산
</code></pre>
<p>SSA value는 한 번만 정의되므로, 정의를 추적하여 상수 값을 전파할 수 있다.</p>
<h4 id="2-죽은-코드-제거-dead-code-elimination"><a class="header" href="#2-죽은-코드-제거-dead-code-elimination">2. 죽은 코드 제거 (Dead Code Elimination)</a></h4>
<pre><code class="language-mlir">// SSA 형태
%unused = arith.constant 42 : i32  // 정의되지만 사용되지 않음
%result = arith.constant 10 : i32
func.return %result : i32

// 최적화: %unused는 사용되지 않으므로 제거 가능
</code></pre>
<p>SSA value가 사용되지 않으면 정의도 불필요하다. 쉽게 감지하고 제거할 수 있다.</p>
<h4 id="3-레지스터-할당-register-allocation"><a class="header" href="#3-레지스터-할당-register-allocation">3. 레지스터 할당 (Register Allocation)</a></h4>
<pre><code class="language-mlir">%x = arith.constant 5 : i32       // %x의 수명 시작
%y = arith.constant 10 : i32      // %y의 수명 시작
%z = arith.addi %x, %y : i32      // %x, %y 사용 (%x, %y 수명 끝)
func.return %z : i32               // %z 사용 (%z 수명 끝)
</code></pre>
<p>SSA value의 수명(lifetime)이 명확하다:</p>
<ul>
<li>정의 지점에서 시작</li>
<li>마지막 사용 지점에서 끝</li>
</ul>
<p>레지스터 할당기가 수명 분석을 쉽게 수행하여 레지스터를 효율적으로 재사용할 수 있다.</p>
<h3 id="let-바인딩은-자연스럽게-ssa다"><a class="header" href="#let-바인딩은-자연스럽게-ssa다">Let 바인딩은 자연스럽게 SSA다</a></h3>
<p>함수형 언어의 let 바인딩은 불변이므로, 변환 없이 SSA로 직접 매핑된다:</p>
<pre><code class="language-fsharp">// FunLang 소스
let x = 5 in
x + x
</code></pre>
<p><strong>MLIR IR로 변환:</strong></p>
<pre><code class="language-mlir">func.func @main() -&gt; i32 {
  %x = arith.constant 5 : i32      // let x = 5
  %result = arith.addi %x, %x : i32  // x + x
  func.return %result : i32
}
</code></pre>
<p><code>let x = 5</code>가 SSA value <code>%x</code>의 <strong>단일 정의</strong>가 된다. 추가 작업이 필요 없다!</p>
<h3 id="명령형-언어와의-대비"><a class="header" href="#명령형-언어와의-대비">명령형 언어와의 대비</a></h3>
<p>명령형 언어는 변수 뮤테이션을 허용하므로 SSA 변환이 필요하다:</p>
<pre><code class="language-c">// C 코드 (SSA 아님)
int x = 5;
int y = x + x;
x = 10;       // 뮤테이션!
int z = x + y;
</code></pre>
<p><strong>SSA로 변환 (컴파일러가 수행):</strong></p>
<pre><code class="language-mlir">%x_0 = arith.constant 5 : i32       // x = 5
%y = arith.addi %x_0, %x_0 : i32    // y = x + x
%x_1 = arith.constant 10 : i32      // x = 10 (새로운 SSA value)
%z = arith.addi %x_1, %y : i32      // z = x + y
</code></pre>
<p>각 “할당“이 새로운 SSA value를 생성한다 (<code>%x_0</code>, <code>%x_1</code>). 이것이 SSA 변환(SSA conversion)이다.</p>
<p><strong>함수형 언어의 이점:</strong> 뮤테이션이 없으므로 SSA 변환이 불필요하다. let 바인딩이 이미 SSA다!</p>
<h3 id="섀도잉-새로운-값-뮤테이션-아님"><a class="header" href="#섀도잉-새로운-값-뮤테이션-아님">섀도잉: 새로운 값, 뮤테이션 아님</a></h3>
<p>함수형 언어에서 같은 이름을 다시 바인딩하면 어떻게 될까?</p>
<pre><code class="language-fsharp">let x = 5 in
let x = 10 in
x
</code></pre>
<p>이것은 **섀도잉(shadowing)**이다:</p>
<pre><code class="language-mlir">func.func @main() -&gt; i32 {
  %x = arith.constant 5 : i32      // 첫 번째 x 바인딩
  %x_0 = arith.constant 10 : i32   // 두 번째 x 바인딩 (새로운 값)
  func.return %x_0 : i32            // 내부 x 사용
}
</code></pre>
<p><strong>핵심:</strong> MLIR은 자동으로 고유한 이름을 생성한다 (<code>%x</code>, <code>%x_0</code>, <code>%x_1</code>, …). 섀도잉은 새로운 SSA value를 만들 뿐, 기존 값을 변경하지 않는다.</p>
<p>외부 <code>%x</code>는 여전히 존재하지만 내부 스코프에서는 가려진다 (shadowed). 스코프가 끝나면 외부 <code>%x</code>가 다시 보인다.</p>
<h3 id="ssa의-제약"><a class="header" href="#ssa의-제약">SSA의 제약</a></h3>
<p>SSA에서 <strong>제어 흐름(control flow)</strong> 합류 지점에서는 어떻게 될까?</p>
<pre><code class="language-fsharp">let x = if condition then 10 else 20 in
x + x
</code></pre>
<p>if 표현식이 두 가지 다른 값 (10 또는 20)을 생성할 수 있다. 어떤 SSA value를 <code>x</code>에 바인딩해야 할까?</p>
<p><strong>해답:</strong> MLIR은 <strong>block arguments</strong>를 사용한다. Chapter 08 (제어 흐름)에서 자세히 다룰 것이다. 지금은 let 바인딩이 단순한 값 바인딩이며 조건부 바인딩이 없다는 점만 기억하자.</p>
<h3 id="ssa-요약"><a class="header" href="#ssa-요약">SSA 요약</a></h3>
<p><strong>SSA 형태:</strong></p>
<ul>
<li>각 value는 정확히 한 번만 정의된다</li>
<li>사용은 여러 번 가능하다</li>
<li>컴파일러 최적화를 단순화한다</li>
<li>MLIR은 SSA를 기본으로 한다</li>
</ul>
<p><strong>Let 바인딩과 SSA:</strong></p>
<ul>
<li>함수형 언어의 let 바인딩은 불변이다</li>
<li>불변 = 자연스러운 SSA 형태</li>
<li>섀도잉은 새로운 SSA value를 생성한다</li>
<li>뮤테이션이 없으므로 SSA 변환이 불필요하다</li>
</ul>
<blockquote>
<p><strong>명심:</strong> SSA는 이론이 아니라 실용이다. 모든 현대 컴파일러 (LLVM, GCC, MLIR)는 SSA를 사용한다. 함수형 언어는 SSA를 “무료로” 얻는다!</p>
</blockquote>
<h2 id="확장된-ast-let과-var"><a class="header" href="#확장된-ast-let과-var">확장된 AST: Let과 Var</a></h2>
<p>이제 AST에 let 바인딩과 변수 참조를 추가한다.</p>
<p><strong>Ast.fs</strong> 수정:</p>
<pre><code class="language-fsharp">namespace FunLangCompiler

/// 이진 연산자 (Chapter 06)
type Operator =
    | Add
    | Subtract
    | Multiply
    | Divide

/// 비교 연산자 (Chapter 06)
type CompareOp =
    | LessThan
    | GreaterThan
    | LessEqual
    | GreaterEqual
    | Equal
    | NotEqual

/// 단항 연산자 (Chapter 06)
type UnaryOp =
    | Negate

/// FunLang 표현식 AST
type Expr =
    | IntLiteral of int
    | BinaryOp of Operator * Expr * Expr
    | UnaryOp of UnaryOp * Expr
    | Comparison of CompareOp * Expr * Expr
    // NEW: let 바인딩과 변수 참조
    | Let of name: string * binding: Expr * body: Expr
    | Var of name: string

/// 최상위 프로그램
type Program =
    { expr: Expr }
</code></pre>
<p><strong>새로운 케이스 설명:</strong></p>
<h3 id="let-of-name--binding--body"><a class="header" href="#let-of-name--binding--body">Let of name * binding * body</a></h3>
<pre><code class="language-fsharp">| Let of name: string * binding: Expr * body: Expr
</code></pre>
<p><strong>의미:</strong> <code>let {name} = {binding} in {body}</code></p>
<p><strong>필드:</strong></p>
<ul>
<li><code>name</code>: 바인딩할 변수 이름 (예: “x”)</li>
<li><code>binding</code>: 변수에 바인딩할 표현식 (예: <code>IntLiteral 10</code>)</li>
<li><code>body</code>: 바인딩이 유효한 스코프 (예: <code>BinaryOp(Add, Var "x", Var "x")</code>)</li>
</ul>
<p><strong>예시:</strong></p>
<pre><code class="language-fsharp">// FunLang: let x = 10 in x + x
Let("x",
  IntLiteral 10,
  BinaryOp(Add, Var "x", Var "x"))
</code></pre>
<p><strong>스코프:</strong> <code>body</code> 표현식 내에서만 <code>name</code>이 유효하다. 스코프 밖에서는 변수가 존재하지 않는다.</p>
<h3 id="var-of-name"><a class="header" href="#var-of-name">Var of name</a></h3>
<pre><code class="language-fsharp">| Var of name: string
</code></pre>
<p><strong>의미:</strong> 변수 참조 - 이전에 바인딩된 변수의 값을 사용한다.</p>
<p><strong>필드:</strong></p>
<ul>
<li><code>name</code>: 참조할 변수 이름 (예: “x”)</li>
</ul>
<p><strong>예시:</strong></p>
<pre><code class="language-fsharp">// FunLang: x
Var "x"
</code></pre>
<p><strong>바인딩 필요:</strong> <code>Var "x"</code>를 사용하려면 스코프에서 <code>x</code>가 바인딩되어 있어야 한다. 바인딩되지 않은 변수를 참조하면 컴파일 에러다.</p>
<h3 id="중첩된-let-바인딩"><a class="header" href="#중첩된-let-바인딩">중첩된 Let 바인딩</a></h3>
<pre><code class="language-fsharp">// FunLang:
// let x = 10 in
// let y = 20 in
// x + y

Let("x",
  IntLiteral 10,
  Let("y",
    IntLiteral 20,
    BinaryOp(Add, Var "x", Var "y")))
</code></pre>
<p><strong>스코프 중첩:</strong></p>
<ul>
<li>외부 let (<code>x</code>)의 body는 내부 let (<code>y</code>)이다</li>
<li>내부 let의 body에서 <code>x</code>와 <code>y</code> 모두 보인다</li>
<li>내부 스코프는 외부 스코프를 “확장“한다</li>
</ul>
<h3 id="섀도잉-예시"><a class="header" href="#섀도잉-예시">섀도잉 예시</a></h3>
<pre><code class="language-fsharp">// FunLang:
// let x = 5 in
// let x = x + 1 in
// x

Let("x",
  IntLiteral 5,
  Let("x",
    BinaryOp(Add, Var "x", IntLiteral 1),  // 외부 x 사용
    Var "x"))  // 내부 x 반환
</code></pre>
<p><strong>섀도잉 동작:</strong></p>
<ul>
<li>두 번째 <code>Let("x", ...)</code>: 새로운 <code>x</code> 바인딩</li>
<li><code>BinaryOp(Add, Var "x", ...)</code>: 여기서 <code>Var "x"</code>는 <strong>외부 x</strong> (값 5)를 참조한다</li>
<li><code>body</code>의 <code>Var "x"</code>: 여기서 <code>Var "x"</code>는 <strong>내부 x</strong> (값 6)를 참조한다</li>
</ul>
<p><strong>결과:</strong> 6을 반환한다.</p>
<h3 id="ast-완전한-예시"><a class="header" href="#ast-완전한-예시">AST 완전한 예시</a></h3>
<pre><code class="language-fsharp">// FunLang:
// let x = 10 in
// let y = 20 in
// let z = x + y in
// z * 2

Let("x",
  IntLiteral 10,
  Let("y",
    IntLiteral 20,
    Let("z",
      BinaryOp(Add, Var "x", Var "y"),
      BinaryOp(Multiply, Var "z", IntLiteral 2))))
</code></pre>
<p><strong>예상 결과:</strong></p>
<ul>
<li>x = 10</li>
<li>y = 20</li>
<li>z = x + y = 30</li>
<li>z * 2 = 60</li>
</ul>
<p>이 AST를 컴파일하면 60을 반환하는 네이티브 바이너리가 생성된다.</p>
<h2 id="환경-개념-environment"><a class="header" href="#환경-개념-environment">환경 개념 (Environment)</a></h2>
<p>변수를 컴파일하려면 **환경(environment)**이 필요하다.</p>
<h3 id="환경이란"><a class="header" href="#환경이란">환경이란?</a></h3>
<p><strong>정의:</strong> 환경은 변수 이름을 SSA value에 매핑하는 자료구조다.</p>
<p><strong>타입 정의:</strong></p>
<pre><code class="language-fsharp">/// 변수 이름 -&gt; MLIR SSA value 매핑
type Env = Map&lt;string, MlirValue&gt;
</code></pre>
<p>F#의 <code>Map</code> 타입은 불변 딕셔너리다. 키-값 쌍을 저장하며, 함수형 방식으로 확장할 수 있다.</p>
<h3 id="환경-연산"><a class="header" href="#환경-연산">환경 연산</a></h3>
<h4 id="1-빈-환경-생성"><a class="header" href="#1-빈-환경-생성">1. 빈 환경 생성</a></h4>
<pre><code class="language-fsharp">let emptyEnv : Env = Map.empty
</code></pre>
<p>프로그램 시작 시 환경은 비어 있다. 아직 변수가 바인딩되지 않았다.</p>
<h4 id="2-환경-확장-바인딩-추가"><a class="header" href="#2-환경-확장-바인딩-추가">2. 환경 확장 (바인딩 추가)</a></h4>
<pre><code class="language-fsharp">// x를 %c5 SSA value에 바인딩
let env = Map.empty
let env' = env.Add("x", someValue)
</code></pre>
<p><code>env.Add(name, value)</code>는 새로운 환경을 반환한다. 기존 환경 <code>env</code>는 변경되지 않는다 (불변성).</p>
<h4 id="3-변수-조회"><a class="header" href="#3-변수-조회">3. 변수 조회</a></h4>
<pre><code class="language-fsharp">// x의 SSA value 찾기
match env.TryFind("x") with
| Some(value) -&gt; value  // x가 바인딩되어 있음
| None -&gt; failwith "Unbound variable: x"  // x가 바인딩되지 않음
</code></pre>
<p><code>TryFind</code>는 <code>Option</code> 타입을 반환한다:</p>
<ul>
<li><code>Some(value)</code>: 변수가 환경에 존재</li>
<li><code>None</code>: 변수가 존재하지 않음 (컴파일 에러)</li>
</ul>
<h3 id="환경과-스코프"><a class="header" href="#환경과-스코프">환경과 스코프</a></h3>
<p>스코프는 환경을 통해 구현된다:</p>
<pre><code class="language-fsharp">// let x = 10 in let y = 20 in x + y
// 각 let이 환경을 확장한다

let env0 = Map.empty             // 초기 환경 (비어 있음)

// let x = 10
let env1 = env0.Add("x", %c10)   // env1 = { x -&gt; %c10 }

// let y = 20
let env2 = env1.Add("y", %c20)   // env2 = { x -&gt; %c10, y -&gt; %c20 }

// x + y (env2에서 x와 y 조회)
// x = %c10, y = %c20
</code></pre>
<p><strong>환경 스택 다이어그램:</strong></p>
<pre><code>let x = 5 in       env = { x -&gt; %c5 }
  let y = 10 in    env = { x -&gt; %c5, y -&gt; %c10 }
    x + y          lookup x, lookup y -&gt; arith.addi %c5, %c10
</code></pre>
<p>각 let 바인딩이 환경에 새로운 항목을 추가한다. 내부 스코프의 환경은 외부 스코프의 모든 바인딩을 포함한다.</p>
<h3 id="섀도잉과-환경"><a class="header" href="#섀도잉과-환경">섀도잉과 환경</a></h3>
<p>같은 이름을 다시 바인딩하면?</p>
<pre><code class="language-fsharp">// let x = 5 in let x = 10 in x
let env0 = Map.empty
let env1 = env0.Add("x", %c5)   // env1 = { x -&gt; %c5 }
let env2 = env1.Add("x", %c10)  // env2 = { x -&gt; %c10 }

// env2에서 x 조회 -&gt; %c10 (새로운 바인딩)
</code></pre>
<p><code>Map.Add</code>는 기존 키가 있으면 값을 덮어쓴다. 하지만 <code>env1</code>은 변경되지 않는다 (불변):</p>
<pre><code class="language-fsharp">// env1에서 x 조회 -&gt; 여전히 %c5
// env2에서 x 조회 -&gt; %c10
</code></pre>
<p>이것이 <strong>스코프 기반 섀도잉</strong>이다. 내부 스코프가 끝나면 외부 바인딩이 다시 보인다:</p>
<pre><code class="language-fsharp">// let x = 5 in (let x = 10 in x) + x
//               ^^^^^^^^^^^^^   ^^^
//               내부 x = 10     외부 x = 5

let env0 = Map.empty
let env1 = env0.Add("x", %c5)

// 내부 스코프
let env2 = env1.Add("x", %c10)
// 내부 body에서 x 조회 -&gt; %c10

// 외부 스코프로 돌아옴 (env1 사용)
// 외부 body에서 x 조회 -&gt; %c5
</code></pre>
<p><strong>결과:</strong> <code>10 + 5 = 15</code></p>
<h3 id="환경-전달-패턴"><a class="header" href="#환경-전달-패턴">환경 전달 패턴</a></h3>
<p>실제 구현에서는 환경을 <code>CompileContext</code> 레코드의 필드로 관리한다:</p>
<pre><code class="language-fsharp">/// Compilation context - 모든 컴파일 상태를 하나로 묶음
type CompileContext = {
    Context: Context
    Builder: OpBuilder
    Location: Location
    Block: MlirBlock  // Current block to append operations to
    Env: Map&lt;string, MlirValue&gt;  // Variable name -&gt; SSA value mapping
}

let rec compileExpr (ctx: CompileContext) (expr: Expr) : MlirValue =
  let builder = ctx.Builder
  match expr with
  | IntLiteral n -&gt; ...  // ctx.Env 사용 안 함
  | Var(name, _) -&gt;
      // ctx.Env에서 변수 조회
      match ctx.Env.TryFind(name) with
      | Some value -&gt; value
      | None -&gt; failwithf "Unbound variable: %s" name
  | Let(name, binding, body, _) -&gt;
      // 1. binding 표현식 컴파일 (현재 ctx 사용)
      let bindVal = compileExpr ctx binding
      // 2. ctx 확장 (immutable update)
      let extendedEnv = ctx.Env.Add(name, bindVal)
      let ctx' = { ctx with Env = extendedEnv }
      // 3. body 표현식 컴파일 (확장된 ctx' 사용)
      compileExpr ctx' body
  | BinaryOp(op, lhs, rhs) -&gt;
      // 재귀 호출에 ctx 전달
      let lhsVal = compileExpr ctx lhs
      let rhsVal = compileExpr ctx rhs
      ...
</code></pre>
<p><strong>핵심:</strong> <code>{ ctx with Env = extendedEnv }</code> 패턴으로 불변 레코드를 업데이트한다. F#의 record update syntax는 새로운 레코드를 생성하므로 기존 ctx는 변경되지 않는다.</p>
<p><strong>핵심 패턴:</strong></p>
<ul>
<li><code>compileExpr</code>이 <code>env</code> 파라미터를 받는다</li>
<li>모든 재귀 호출에서 <code>env</code>를 전달한다</li>
<li><code>Let</code> 케이스에서 <code>env</code>를 확장하고 body에 전달한다</li>
<li><code>Var</code> 케이스에서 <code>env</code>를 조회한다</li>
</ul>
<p>이것이 **환경 전달(environment passing)**이다. 함수형 프로그래밍에서 흔한 패턴이다.</p>
<h3 id="환경-요약"><a class="header" href="#환경-요약">환경 요약</a></h3>
<p><strong>환경:</strong></p>
<ul>
<li>변수 이름 -&gt; SSA value 매핑</li>
<li>F# <code>Map&lt;string, MlirValue&gt;</code> 타입</li>
<li>불변 자료구조</li>
</ul>
<p><strong>연산:</strong></p>
<ul>
<li><code>Map.empty</code>: 빈 환경</li>
<li><code>env.Add(name, value)</code>: 바인딩 추가 (새 환경 반환)</li>
<li><code>env.TryFind(name)</code>: 변수 조회 (Option 반환)</li>
</ul>
<p><strong>스코프:</strong></p>
<ul>
<li>각 let 바인딩이 환경을 확장한다</li>
<li>내부 스코프는 외부 바인딩을 모두 포함한다</li>
<li>섀도잉은 <code>Map.Add</code>로 구현된다</li>
</ul>
<p><strong>환경 전달:</strong></p>
<ul>
<li><code>compileExpr</code>에 <code>env</code> 파라미터 추가</li>
<li>재귀 호출에서 <code>env</code> 전달</li>
<li><code>Let</code> 케이스에서 <code>env</code> 확장</li>
</ul>
<blockquote>
<p><strong>다음 섹션:</strong> 환경을 사용하여 let 바인딩을 MLIR IR로 컴파일하는 코드를 작성한다!</p>
</blockquote>
<h2 id="환경을-사용한-코드-생성"><a class="header" href="#환경을-사용한-코드-생성">환경을 사용한 코드 생성</a></h2>
<p>이제 Chapter 06의 <code>compileExpr</code>을 확장하여 let 바인딩과 변수를 처리한다.</p>
<h3 id="compileexpr-시그니처-변경"><a class="header" href="#compileexpr-시그니처-변경">compileExpr 시그니처 변경</a></h3>
<p>먼저 환경 파라미터를 추가한다:</p>
<pre><code class="language-fsharp">// 기존 (Chapter 06):
let rec compileExpr
    (builder: OpBuilder)
    (block: MlirBlock)
    (location: Location)
    (expr: Expr)
    : MlirValue = ...

// 새로운 (Chapter 07):
let rec compileExpr
    (builder: OpBuilder)
    (block: MlirBlock)
    (location: Location)
    (expr: Expr)
    (env: Env)        // 환경 추가!
    : MlirValue = ...
</code></pre>
<p><strong>환경 타입 정의:</strong></p>
<pre><code class="language-fsharp">/// 변수 이름 -&gt; MLIR SSA value 매핑
type Env = Map&lt;string, MlirValue&gt;
</code></pre>
<h3 id="let-케이스-구현"><a class="header" href="#let-케이스-구현">Let 케이스 구현</a></h3>
<pre><code class="language-fsharp">| Let(name, binding, body) -&gt;
    // 1. binding 표현식 컴파일 (현재 환경 사용)
    let bindVal = compileExpr builder block location binding env

    // 2. 환경 확장: name -&gt; bindVal 매핑 추가
    let env' = env.Add(name, bindVal)

    // 3. body 표현식 컴파일 (확장된 환경 사용)
    compileExpr builder block location body env'
</code></pre>
<p><strong>동작 설명:</strong></p>
<ol>
<li><code>binding</code> 표현식을 먼저 컴파일한다. 이것이 변수에 바인딩될 값이다.</li>
<li>현재 환경 <code>env</code>를 확장하여 <code>name</code>을 <code>bindVal</code>에 매핑한다. 새로운 환경 <code>env'</code>가 생성된다.</li>
<li><code>body</code> 표현식을 컴파일할 때 확장된 환경 <code>env'</code>를 사용한다. body 내에서 <code>name</code>을 참조할 수 있다.</li>
</ol>
<p><strong>핵심:</strong> let 바인딩은 MLIR IR에 새로운 연산을 생성하지 않는다. 단지 환경을 확장하고 body를 컴파일할 뿐이다. SSA value는 <code>binding</code> 표현식에서 이미 생성되었다.</p>
<h3 id="var-케이스-구현"><a class="header" href="#var-케이스-구현">Var 케이스 구현</a></h3>
<pre><code class="language-fsharp">| Var(name) -&gt;
    // 환경에서 변수 조회
    match env.TryFind(name) with
    | Some(value) -&gt; value  // 바인딩된 SSA value 반환
    | None -&gt; failwithf "Unbound variable: %s" name  // 컴파일 에러
</code></pre>
<p><strong>동작 설명:</strong></p>
<ul>
<li><code>env.TryFind(name)</code>으로 변수를 조회한다.</li>
<li>바인딩되어 있으면 (<code>Some(value)</code>) 해당 SSA value를 반환한다.</li>
<li>바인딩되지 않았으면 (<code>None</code>) 에러를 발생시킨다.</li>
</ul>
<p><strong>중요:</strong> 변수 참조는 MLIR IR에 새로운 연산을 생성하지 않는다. 단지 기존 SSA value를 반환할 뿐이다. 이것이 SSA의 핵심이다!</p>
<h3 id="기존-케이스-업데이트"><a class="header" href="#기존-케이스-업데이트">기존 케이스 업데이트</a></h3>
<p>모든 기존 케이스에서 재귀 호출에 <code>env</code>를 전달해야 한다:</p>
<pre><code class="language-fsharp">| IntLiteral value -&gt;
    // 환경 사용 안 함 (리터럴은 변수를 참조하지 않음)
    let i32Type = builder.I32Type()
    let attr = builder.Context.GetIntegerAttr(i32Type, int64 value)
    let constOp = builder.CreateConstant(attr, location)
    MlirNative.mlirBlockAppendOwnedOperation(block, constOp)
    builder.GetResult(constOp, 0)

| BinaryOp(op, lhs, rhs) -&gt;
    // 재귀 호출에 env 전달
    let lhsVal = compileExpr builder block location lhs env
    let rhsVal = compileExpr builder block location rhs env
    let binOp = builder.CreateArithBinaryOp(op, lhsVal, rhsVal, location)
    MlirNative.mlirBlockAppendOwnedOperation(block, binOp)
    builder.GetResult(binOp, 0)

| UnaryOp(Negate, expr) -&gt;
    // 재귀 호출에 env 전달
    let val = compileExpr builder block location expr env
    let negOp = builder.CreateArithNegate(val, location)
    MlirNative.mlirBlockAppendOwnedOperation(block, negOp)
    builder.GetResult(negOp, 0)

| Comparison(compareOp, lhs, rhs) -&gt;
    // 재귀 호출에 env 전달
    let lhsVal = compileExpr builder block location lhs env
    let rhsVal = compileExpr builder block location rhs env
    let cmpOp = builder.CreateArithCompare(compareOp, lhsVal, rhsVal, location)
    MlirNative.mlirBlockAppendOwnedOperation(block, cmpOp)
    let cmpVal = builder.GetResult(cmpOp, 0)
    // i1 -&gt; i32 확장 (Chapter 06과 동일)
    let i32Type = builder.I32Type()
    let extOp = builder.CreateArithExtUI(cmpVal, i32Type, location)
    MlirNative.mlirBlockAppendOwnedOperation(block, extOp)
    builder.GetResult(extOp, 0)
</code></pre>
<p><strong>패턴:</strong> 모든 재귀 호출에서 현재 환경 <code>env</code>를 그대로 전달한다. Let 케이스만 환경을 확장한다.</p>
<h3 id="완전한-codegenfs-리스팅"><a class="header" href="#완전한-codegenfs-리스팅">완전한 CodeGen.fs 리스팅</a></h3>
<p><strong>CodeGen.fs</strong> (환경 지원 버전):</p>
<pre><code class="language-fsharp">namespace FunLangCompiler

open System
open MlirWrapper
open MlirBindings

module CodeGen =

    /// 변수 이름 -&gt; MLIR SSA value 매핑
    type Env = Map&lt;string, MlirValue&gt;

    /// 표현식을 MLIR value로 컴파일 (재귀적, 환경 전달)
    let rec compileExpr
        (builder: OpBuilder)
        (block: MlirBlock)
        (location: Location)
        (expr: Expr)
        (env: Env)
        : MlirValue =

        match expr with
        | IntLiteral value -&gt;
            let i32Type = builder.I32Type()
            let attr = builder.Context.GetIntegerAttr(i32Type, int64 value)
            let constOp = builder.CreateConstant(attr, location)
            MlirNative.mlirBlockAppendOwnedOperation(block, constOp)
            builder.GetResult(constOp, 0)

        | Var(name) -&gt;
            match env.TryFind(name) with
            | Some(value) -&gt; value
            | None -&gt; failwithf "Unbound variable: %s" name

        | Let(name, binding, body) -&gt;
            let bindVal = compileExpr builder block location binding env
            let env' = env.Add(name, bindVal)
            compileExpr builder block location body env'

        | BinaryOp(op, lhs, rhs) -&gt;
            let lhsVal = compileExpr builder block location lhs env
            let rhsVal = compileExpr builder block location rhs env
            let binOp = builder.CreateArithBinaryOp(op, lhsVal, rhsVal, location)
            MlirNative.mlirBlockAppendOwnedOperation(block, binOp)
            builder.GetResult(binOp, 0)

        | UnaryOp(Negate, expr) -&gt;
            let val = compileExpr builder block location expr env
            let negOp = builder.CreateArithNegate(val, location)
            MlirNative.mlirBlockAppendOwnedOperation(block, negOp)
            builder.GetResult(negOp, 0)

        | Comparison(compareOp, lhs, rhs) -&gt;
            let lhsVal = compileExpr builder block location lhs env
            let rhsVal = compileExpr builder block location rhs env
            let cmpOp = builder.CreateArithCompare(compareOp, lhsVal, rhsVal, location)
            MlirNative.mlirBlockAppendOwnedOperation(block, cmpOp)
            let cmpVal = builder.GetResult(cmpOp, 0)
            let i32Type = builder.I32Type()
            let extOp = builder.CreateArithExtUI(cmpVal, i32Type, location)
            MlirNative.mlirBlockAppendOwnedOperation(block, extOp)
            builder.GetResult(extOp, 0)

    /// Compile a FunLang expression into a function that returns i32
    let compileToFunction (ctx: Context) (funcName: string) (expr: Expr) : Module =
        let loc = Location.Unknown ctx
        let mlirMod = new Module(ctx, loc)
        let builder = OpBuilder(ctx)

        let i32Type = builder.I32Type()
        let funcType = builder.FunctionType([||], [| i32Type |])

        // Create function body
        let region = builder.CreateRegion()
        let entryBlock = builder.CreateBlock([||], loc)
        builder.AppendBlockToRegion(region, entryBlock)

        // Compile expression into the entry block
        let compileCtx = {
            Context = ctx
            Builder = builder
            Location = loc
            Block = entryBlock
            Env = Map.empty  // 빈 환경에서 시작
        }
        let resultVal = compileExpr compileCtx expr

        // Return the result
        let returnOp = builder.CreateOperation(
            "func.return", loc,
            [||], [| resultVal |], [||], [||])
        builder.AppendOperationToBlock(entryBlock, returnOp)

        // Create func.func with C interface for JIT
        let unitAttr = MlirNative.mlirUnitAttrGet(ctx.Handle)
        let funcOp = builder.CreateOperation(
            "func.func", loc,
            [||], [||],
            [| builder.NamedAttr("sym_name", builder.StringAttr(funcName))
               builder.NamedAttr("function_type", builder.TypeAttr(funcType))
               builder.NamedAttr("llvm.emit_c_interface", unitAttr) |],
            [| region |])
        builder.AppendOperationToBlock(mlirMod.Body, funcOp)

        mlirMod

    /// MLIR module 검증
    let verify (mlirMod: Module) =
        if not (mlirMod.Verify()) then
            eprintfn "MLIR verification failed:"
            eprintfn "%s" (mlirMod.Print())
            failwith "MLIR IR is invalid"
</code></pre>
<p><strong>주목할 점:</strong></p>
<ul>
<li><code>compileExpr</code>이 <code>env</code> 파라미터를 받는다</li>
<li><code>translateToMlir</code>에서 빈 환경 (<code>Map.empty</code>)으로 시작한다</li>
<li>모든 재귀 호출에서 <code>env</code>를 전달한다</li>
</ul>
<h2 id="중첩된-let-바인딩-1"><a class="header" href="#중첩된-let-바인딩-1">중첩된 Let 바인딩</a></h2>
<p>중첩된 let 바인딩이 어떻게 컴파일되는지 보자.</p>
<p><strong>FunLang 소스:</strong></p>
<pre><code class="language-fsharp">let x = 10 in
let y = 20 in
let z = x + y in
z * 2
</code></pre>
<p><strong>AST:</strong></p>
<pre><code class="language-fsharp">Let("x",
  IntLiteral 10,
  Let("y",
    IntLiteral 20,
    Let("z",
      BinaryOp(Add, Var "x", Var "y"),
      BinaryOp(Multiply, Var "z", IntLiteral 2))))
</code></pre>
<p><strong>컴파일 과정:</strong></p>
<ol>
<li>
<p><strong>Let(“x”, IntLiteral 10, …)</strong></p>
<ul>
<li><code>binding</code> 컴파일: <code>%c10 = arith.constant 10 : i32</code></li>
<li><code>env0 = {}</code></li>
<li><code>env1 = env0.Add("x", %c10) = { x -&gt; %c10 }</code></li>
<li><code>body</code> 컴파일 (env1 사용)</li>
</ul>
</li>
<li>
<p><strong>Let(“y”, IntLiteral 20, …)</strong> (env1에서)</p>
<ul>
<li><code>binding</code> 컴파일: <code>%c20 = arith.constant 20 : i32</code></li>
<li><code>env2 = env1.Add("y", %c20) = { x -&gt; %c10, y -&gt; %c20 }</code></li>
<li><code>body</code> 컴파일 (env2 사용)</li>
</ul>
</li>
<li>
<p><strong>Let(“z”, BinaryOp(Add, Var “x”, Var “y”), …)</strong> (env2에서)</p>
<ul>
<li><code>binding</code> 컴파일:
<ul>
<li><code>Var "x"</code>: env2에서 조회 → %c10</li>
<li><code>Var "y"</code>: env2에서 조회 → %c20</li>
<li><code>%z = arith.addi %c10, %c20 : i32</code></li>
</ul>
</li>
<li><code>env3 = env2.Add("z", %z) = { x -&gt; %c10, y -&gt; %c20, z -&gt; %z }</code></li>
<li><code>body</code> 컴파일 (env3 사용)</li>
</ul>
</li>
<li>
<p><strong>BinaryOp(Multiply, Var “z”, IntLiteral 2)</strong> (env3에서)</p>
<ul>
<li><code>Var "z"</code>: env3에서 조회 → %z</li>
<li><code>IntLiteral 2</code>: <code>%c2 = arith.constant 2 : i32</code></li>
<li><code>%result = arith.muli %z, %c2 : i32</code></li>
</ul>
</li>
</ol>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">module {
  func.func @main() -&gt; i32 {
    %c10 = arith.constant 10 : i32      // let x = 10
    %c20 = arith.constant 20 : i32      // let y = 20
    %z = arith.addi %c10, %c20 : i32    // let z = x + y
    %c2 = arith.constant 2 : i32
    %result = arith.muli %z, %c2 : i32  // z * 2
    func.return %result : i32
  }
}
</code></pre>
<p><strong>분석:</strong></p>
<ul>
<li>각 let 바인딩이 SSA value를 생성한다</li>
<li>변수 참조는 기존 SSA value를 재사용한다</li>
<li>명시적인 저장/로드 연산이 없다 (모든 것이 레지스터에 있다)</li>
<li>SSA value가 자유롭게 흐른다 (%c10과 %c20이 %z에서 사용됨)</li>
</ul>
<p><strong>실행:</strong></p>
<pre><code class="language-bash">$ ./program
$ echo $?
60
</code></pre>
<p>예상대로 60을 반환한다!</p>
<h2 id="변수-섀도잉"><a class="header" href="#변수-섀도잉">변수 섀도잉</a></h2>
<p>섀도잉이 어떻게 작동하는지 보자.</p>
<p><strong>FunLang 소스:</strong></p>
<pre><code class="language-fsharp">let x = 5 in
let x = x + 1 in
x
</code></pre>
<p><strong>AST:</strong></p>
<pre><code class="language-fsharp">Let("x",
  IntLiteral 5,
  Let("x",
    BinaryOp(Add, Var "x", IntLiteral 1),
    Var "x"))
</code></pre>
<p><strong>컴파일 과정:</strong></p>
<ol>
<li>
<p><strong>첫 번째 Let(“x”, IntLiteral 5, …)</strong></p>
<ul>
<li><code>binding</code>: <code>%x = arith.constant 5 : i32</code></li>
<li><code>env1 = { x -&gt; %x }</code></li>
</ul>
</li>
<li>
<p><strong>두 번째 Let(“x”, BinaryOp(Add, Var “x”, IntLiteral 1), …)</strong> (env1에서)</p>
<ul>
<li><code>binding</code>:
<ul>
<li><code>Var "x"</code>: env1에서 조회 → %x (값 5)</li>
<li><code>IntLiteral 1</code>: <code>%c1 = arith.constant 1 : i32</code></li>
<li><code>%x_0 = arith.addi %x, %c1 : i32</code></li>
</ul>
</li>
<li><code>env2 = env1.Add("x", %x_0) = { x -&gt; %x_0 }</code>  ← 섀도잉!</li>
</ul>
</li>
<li>
<p><strong>Var “x”</strong> (env2에서)</p>
<ul>
<li>env2에서 조회 → %x_0 (값 6)</li>
</ul>
</li>
</ol>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">module {
  func.func @main() -&gt; i32 {
    %x = arith.constant 5 : i32        // 외부 x
    %c1 = arith.constant 1 : i32
    %x_0 = arith.addi %x, %c1 : i32    // 내부 x = 외부 x + 1
    func.return %x_0 : i32              // 내부 x 반환
  }
}
</code></pre>
<p><strong>핵심 통찰력:</strong></p>
<ul>
<li>MLIR은 자동으로 고유한 이름을 생성한다 (<code>%x</code>, <code>%x_0</code>)</li>
<li>두 번째 <code>Let("x", ...)</code>에서 <code>binding</code> 표현식은 <strong>외부 x</strong>를 참조한다 (env1에서 컴파일)</li>
<li>body 표현식은 <strong>내부 x</strong>를 참조한다 (env2에서 컴파일)</li>
<li>섀도잉은 새로운 SSA value를 생성하지, 기존 value를 변경하지 않는다</li>
</ul>
<p><strong>실행:</strong></p>
<pre><code class="language-bash">$ ./program
$ echo $?
6
</code></pre>
<p>예상대로 6을 반환한다!</p>
<h2 id="완전한-예시와-드라이버"><a class="header" href="#완전한-예시와-드라이버">완전한 예시와 드라이버</a></h2>
<p>이제 완전한 컴파일러 드라이버를 작성하자.</p>
<p><strong>Main.fs 예시:</strong></p>
<pre><code class="language-fsharp">namespace FunLangCompiler

open System

module Main =

    [&lt;EntryPoint&gt;]
    let main args =
        printfn "=== FunLang Compiler with Let Bindings ==="

        // 예시: let x = 10 in let y = 20 in x + y
        let ast =
            Let("x",
              IntLiteral 10,
              Let("y",
                IntLiteral 20,
                BinaryOp(Add, Var "x", Var "y")))

        let program = { expr = ast }

        printfn "AST: %A" ast
        printfn ""

        // MLIR로 컴파일
        printfn "Compiling to MLIR..."
        let mlirMod = CodeGen.translateToMlir program
        printfn "%s" (mlirMod.Print())

        // 검증
        printfn "Verifying..."
        CodeGen.verify mlirMod
        printfn "✓ Verification passed"

        // Lowering과 네이티브 코드 생성 (Chapter 05와 동일)
        Lowering.lowerToLLVMDialect mlirMod
        let llvmIR = Lowering.translateToLLVMIR mlirMod
        NativeCodeGen.emitObjectFile llvmIR "program.o"
        NativeCodeGen.linkExecutable "program.o" "program"

        mlirMod.Dispose()

        printfn ""
        printfn "=== Compilation successful ==="
        printfn "Run: ./program"
        printfn "Expected output (exit code): 30"

        0
</code></pre>
<p><strong>컴파일과 실행:</strong></p>
<pre><code class="language-bash">$ dotnet run
=== FunLang Compiler with Let Bindings ===
AST: Let ("x", IntLiteral 10, Let ("y", IntLiteral 20, BinaryOp (Add, Var "x", Var "y")))

Compiling to MLIR...
module {
  func.func @main() -&gt; i32 {
    %c10 = arith.constant 10 : i32
    %c20 = arith.constant 20 : i32
    %0 = arith.addi %c10, %c20 : i32
    func.return %0 : i32
  }
}
Verifying...
✓ Verification passed
[... lowering과 linking ...]

=== Compilation successful ===
Run: ./program
Expected output (exit code): 30

$ ./program
$ echo $?
30
</code></pre>
<p>완벽하다!</p>
<h2 id="공통-에러"><a class="header" href="#공통-에러">공통 에러</a></h2>
<h3 id="에러-1-바인딩되지-않은-변수-참조"><a class="header" href="#에러-1-바인딩되지-않은-변수-참조">에러 1: 바인딩되지 않은 변수 참조</a></h3>
<p><strong>증상:</strong></p>
<pre><code>Exception: Unbound variable: y
</code></pre>
<p><strong>원인:</strong></p>
<p>변수가 스코프에 없는데 참조하려고 했다.</p>
<p><strong>예시:</strong></p>
<pre><code class="language-fsharp">// WRONG: y가 바인딩되지 않음
let x = 10 in
y + x
</code></pre>
<p><strong>해결:</strong></p>
<p>변수를 사용하기 전에 let 바인딩으로 정의한다:</p>
<pre><code class="language-fsharp">// CORRECT
let x = 10 in
let y = 20 in
y + x
</code></pre>
<h3 id="에러-2-스코프-밖에서-변수-사용"><a class="header" href="#에러-2-스코프-밖에서-변수-사용">에러 2: 스코프 밖에서 변수 사용</a></h3>
<p><strong>증상:</strong></p>
<pre><code>Exception: Unbound variable: x
</code></pre>
<p><strong>원인:</strong></p>
<p>변수가 스코프 밖에서 사용되었다.</p>
<p><strong>예시:</strong></p>
<pre><code class="language-fsharp">// WRONG: 두 번째 x는 스코프 밖
(let x = 10 in x + x) + x
//                      ^ x는 여기서 바인딩되지 않음
</code></pre>
<p>let 바인딩의 스코프는 <code>body</code> 표현식까지만이다. 밖에서는 보이지 않는다.</p>
<p><strong>해결:</strong></p>
<p>필요한 스코프 전체를 감싸거나, 바인딩을 외부로 이동한다:</p>
<pre><code class="language-fsharp">// CORRECT: x를 외부에서 바인딩
let x = 10 in
(x + x) + x
</code></pre>
<h3 id="에러-3-환경을-재귀-호출에-전달하지-않음"><a class="header" href="#에러-3-환경을-재귀-호출에-전달하지-않음">에러 3: 환경을 재귀 호출에 전달하지 않음</a></h3>
<p><strong>증상:</strong></p>
<pre><code>Compilation error: 'env' is not defined
</code></pre>
<p><strong>원인:</strong></p>
<p><code>compileExpr</code> 재귀 호출에서 <code>env</code> 파라미터를 빠뜨렸다.</p>
<p><strong>예시:</strong></p>
<pre><code class="language-fsharp">// WRONG: env 파라미터 누락
| BinaryOp(op, lhs, rhs) -&gt;
    let lhsVal = compileExpr builder block location lhs  // env 없음!
    ...
</code></pre>
<p><strong>해결:</strong></p>
<p>모든 <code>compileExpr</code> 호출에 <code>env</code>를 전달한다:</p>
<pre><code class="language-fsharp">// CORRECT
| BinaryOp(op, lhs, rhs) -&gt;
    let lhsVal = compileExpr builder block location lhs env
    let rhsVal = compileExpr builder block location rhs env
    ...
</code></pre>
<p><strong>패턴:</strong> 각 케이스를 추가할 때마다 재귀 호출에 <code>env</code>를 전달하는지 확인한다.</p>
<h3 id="에러-4-let-바인딩에서-환경-확장-잊음"><a class="header" href="#에러-4-let-바인딩에서-환경-확장-잊음">에러 4: Let 바인딩에서 환경 확장 잊음</a></h3>
<p><strong>증상:</strong></p>
<p>변수가 body에서 보이지 않는다.</p>
<p><strong>원인:</strong></p>
<p><code>Let</code> 케이스에서 <code>env.Add</code>를 호출했지만 확장된 환경을 body에 전달하지 않았다.</p>
<p><strong>예시:</strong></p>
<pre><code class="language-fsharp">// WRONG: 확장된 환경을 사용하지 않음
| Let(name, binding, body) -&gt;
    let bindVal = compileExpr builder block location binding env
    let env' = env.Add(name, bindVal)
    compileExpr builder block location body env  // env' 대신 env 사용!
</code></pre>
<p><strong>해결:</strong></p>
<p>확장된 환경 <code>env'</code>를 body에 전달한다:</p>
<pre><code class="language-fsharp">// CORRECT
| Let(name, binding, body) -&gt;
    let bindVal = compileExpr builder block location binding env
    let env' = env.Add(name, bindVal)
    compileExpr builder block location body env'  // env' 사용!
</code></pre>
<h3 id="에러-5-섀도잉을-뮤테이션으로-착각"><a class="header" href="#에러-5-섀도잉을-뮤테이션으로-착각">에러 5: 섀도잉을 뮤테이션으로 착각</a></h3>
<p><strong>개념 오류:</strong></p>
<pre><code class="language-fsharp">// 이것은 뮤테이션이 아니다!
let x = 5 in
let x = 10 in
x
</code></pre>
<p><strong>설명:</strong></p>
<p>이것은 변수 “x“를 덮어쓰는 것이 아니다. 새로운 바인딩을 만드는 것이다:</p>
<ul>
<li>외부 <code>x</code>는 값 5를 가진 SSA value <code>%x</code></li>
<li>내부 <code>x</code>는 값 10을 가진 SSA value <code>%x_0</code></li>
<li>두 value 모두 존재한다 (외부 x는 변경되지 않음)</li>
</ul>
<p><strong>MLIR IR 확인:</strong></p>
<pre><code class="language-mlir">%x = arith.constant 5 : i32    // 외부 x (여전히 존재)
%x_0 = arith.constant 10 : i32  // 내부 x (새로운 value)
func.return %x_0 : i32
</code></pre>
<h2 id="장-요약-1"><a class="header" href="#장-요약-1">장 요약</a></h2>
<p>이 장에서 다음을 성취했다:</p>
<ol>
<li><strong>SSA 형태 이해</strong>: 각 value는 한 번만 정의되며, 이것이 컴파일러 최적화를 단순화한다</li>
<li><strong>Let 바인딩 추가</strong>: 함수형 언어의 불변 바인딩이 SSA와 자연스럽게 일치한다</li>
<li><strong>환경 구현</strong>: <code>Map&lt;string, MlirValue&gt;</code>로 변수 스코프 관리</li>
<li><strong>환경 전달 패턴</strong>: 재귀 함수에 환경을 전달하여 중첩 스코프 구현</li>
<li><strong>섀도잉 vs 뮤테이션</strong>: 섀도잉은 새로운 SSA value를 생성하지, 기존 value를 변경하지 않는다</li>
<li><strong>완전한 예제</strong>: 중첩된 let 바인딩이 올바른 MLIR IR로 컴파일된다</li>
</ol>
<p><strong>독자가 할 수 있는 것:</strong></p>
<ul>
<li><code>let x = 5 in x + x</code> 컴파일 → 네이티브 바이너리 → 결과: 10 ✓</li>
<li><code>let x = 10 in let y = 20 in x + y</code> 컴파일 → 결과: 30 ✓</li>
<li>섀도잉 이해: <code>let x = 5 in let x = 10 in x</code> → 결과: 10 ✓</li>
<li>환경 전달로 스코프 관리 ✓</li>
<li>스코프 에러 디버깅 (바인딩되지 않은 변수) ✓</li>
</ul>
<p><strong>핵심 개념:</strong></p>
<ul>
<li><strong>SSA 형태</strong>: 각 value는 한 번만 정의된다</li>
<li><strong>Let 바인딩 = SSA value</strong>: 불변 바인딩이 SSA를 자연스럽게 표현한다</li>
<li><strong>환경 = 변수 스코프</strong>: Map으로 변수 이름을 SSA value에 매핑한다</li>
<li><strong>환경 전달 = 스코프 중첩</strong>: 재귀 호출로 스코프를 확장한다</li>
<li><strong>섀도잉 ≠ 뮤테이션</strong>: 새로운 value 생성, 기존 value 변경 아님</li>
</ul>
<p><strong>다음 장 미리보기:</strong></p>
<p>Chapter 08에서는 **제어 흐름 (if/else)**을 추가한다:</p>
<pre><code class="language-fsharp">let x = if 5 &lt; 10 then 42 else 0 in
x + x
</code></pre>
<p>이것은 다음을 도입한다:</p>
<ul>
<li><strong>scf.if</strong> 연산: 구조화된 제어 흐름</li>
<li><strong>Block arguments</strong>: MLIR의 PHI 노드 대안</li>
<li><strong>scf.yield</strong>: 분기에서 값 반환</li>
<li><strong>SSA at control flow merges</strong>: 조건부 값을 어떻게 SSA로 표현하는가</li>
</ul>
<p><strong>Phase 2는 계속된다!</strong></p>
<hr>
<p><strong>이제 독자는 let 바인딩과 변수를 컴파일하고, SSA 형태를 이해한다!</strong></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-08-제어-흐름과-block-arguments"><a class="header" href="#chapter-08-제어-흐름과-block-arguments">Chapter 08: 제어 흐름과 Block Arguments</a></h1>
<h2 id="소개-8"><a class="header" href="#소개-8">소개</a></h2>
<p>프로그래밍에서 조건부 실행은 필수다. 조건에 따라 다른 코드 경로를 실행하는 능력은 모든 실용적인 프로그램의 핵심이다.</p>
<p>함수형 언어에서 **if/then/else는 표현식(expression)**이다. 명령형 언어의 문(statement)이 아니라, 값을 생성하는 표현식이다:</p>
<pre><code class="language-fsharp">// 함수형 스타일 - if는 값을 반환한다
let result = if condition then 42 else 0

// 명령형 스타일과 대비
int result;
if (condition) {
    result = 42;
} else {
    result = 0;
}
</code></pre>
<p>함수형 스타일에서 if 표현식은 <strong>값을 생성</strong>한다. 두 분기(then/else) 중 하나가 실행되고, 그 결과가 if 표현식의 값이 된다.</p>
<p><strong>컴파일 도전과제:</strong> SSA 형태에서 두 분기가 어떻게 하나의 값으로 합쳐지는가?</p>
<pre><code class="language-fsharp">let x = if condition then 10 else 20 in
x + x
</code></pre>
<p>조건이 true면 <code>x = 10</code>, false면 <code>x = 20</code>이다. 하지만 SSA 형태에서 <code>x</code>는 단일 SSA value여야 한다. 두 분기의 값을 어떻게 합칠까?</p>
<p><strong>MLIR의 우아한 해답:</strong> <strong>Block Arguments</strong></p>
<p>전통적인 SSA는 PHI 노드를 사용하지만, MLIR은 더 깔끔한 방식을 제공한다. 이 장에서 MLIR의 block arguments와 <code>scf.if</code> 연산을 배운다.</p>
<p>이 장을 마치면:</p>
<ul>
<li>if/then/else 표현식을 네이티브 바이너리로 컴파일할 수 있다</li>
<li>Block arguments와 PHI 노드의 차이를 이해한다</li>
<li>MLIR의 <code>scf.if</code> 연산과 <code>scf.yield</code> 종결자를 사용할 수 있다</li>
<li>제어 흐름 합류 지점에서 SSA 값이 어떻게 병합되는지 안다</li>
</ul>
<blockquote>
<p><strong>중요:</strong> Block arguments는 MLIR의 핵심 혁신이다. PHI 노드의 복잡성을 제거하고 SSA 형태를 더 명확하게 만든다.</p>
</blockquote>
<h2 id="phi-노드-문제"><a class="header" href="#phi-노드-문제">PHI 노드 문제</a></h2>
<h3 id="전통적인-ssa-phi-노드"><a class="header" href="#전통적인-ssa-phi-노드">전통적인 SSA: PHI 노드</a></h3>
<p>LLVM IR과 전통적인 SSA 형태는 <strong>PHI 노드</strong>를 사용하여 제어 흐름 합류 지점에서 값을 병합한다.</p>
<p><strong>LLVM IR 예시:</strong></p>
<pre><code class="language-llvm">define i32 @example(i1 %cond) {
entry:
  br i1 %cond, label %then, label %else

then:
  %a = add i32 10, 1
  br label %merge

else:
  %b = add i32 20, 1
  br label %merge

merge:
  %result = phi i32 [ %a, %then ], [ %b, %else ]
  ret i32 %result
}
</code></pre>
<p><strong>동작 설명:</strong></p>
<ol>
<li><code>entry</code> 블록에서 조건 분기 (<code>br i1 %cond</code>)</li>
<li><code>then</code> 블록: <code>%a = 11</code> 계산 후 <code>merge</code>로 이동</li>
<li><code>else</code> 블록: <code>%b = 21</code> 계산 후 <code>merge</code>로 이동</li>
<li><code>merge</code> 블록: <strong>PHI 노드</strong>가 선택
<ul>
<li><code>%then</code> 블록에서 왔으면 <code>%a</code> 사용</li>
<li><code>%else</code> 블록에서 왔으면 <code>%b</code> 사용</li>
</ul>
</li>
</ol>
<p>PHI 노드는 “어느 블록에서 왔는가“에 따라 값을 선택한다. 표기법: <code>phi type [ value1, pred1 ], [ value2, pred2 ]</code></p>
<h3 id="phi-노드의-문제점"><a class="header" href="#phi-노드의-문제점">PHI 노드의 문제점</a></h3>
<h4 id="1-블록-시작-위치-제약"><a class="header" href="#1-블록-시작-위치-제약">1. 블록 시작 위치 제약</a></h4>
<p>PHI 노드는 <strong>반드시 블록의 시작</strong>에 있어야 한다:</p>
<pre><code class="language-llvm">merge:
  %result = phi i32 [ %a, %then ], [ %b, %else ]  ; PHI는 여기!
  %x = add i32 %result, 1                          ; 일반 연산은 PHI 뒤
  ; PHI를 여기에 추가할 수 없다 - 순서 규칙 위반
</code></pre>
<p>이 제약은 코드 생성을 복잡하게 만든다. PHI 노드를 먼저 모으고, 일반 연산을 뒤에 배치해야 한다.</p>
<h4 id="2-lost-copy-problem"><a class="header" href="#2-lost-copy-problem">2. Lost Copy Problem</a></h4>
<p>PHI 노드의 의미는 “블록 진입 시” 값을 선택하는 것이다. 하지만 실제 구현에서는 <strong>선행 블록의 끝</strong>에서 값을 복사한다:</p>
<pre><code class="language-llvm">then:
  %a = add i32 10, 1
  ; 실제로는 여기서 %a를 %result로 복사
  br label %merge

merge:
  %result = phi i32 [ %a, %then ], [ %b, %else ]
  ; %result는 이미 복사된 값을 가진다
</code></pre>
<p>이것이 <strong>lost copy problem</strong>이다:</p>
<ul>
<li>PHI 노드는 “merge 블록 진입 시” 선택하는 것처럼 보인다</li>
<li>실제 구현은 “선행 블록 종료 시” 복사한다</li>
<li>의미론과 구현의 불일치</li>
</ul>
<h4 id="3-dominance-frontier-계산"><a class="header" href="#3-dominance-frontier-계산">3. Dominance Frontier 계산</a></h4>
<p>PHI 노드를 올바르게 배치하려면 <strong>dominance frontier</strong> 알고리즘이 필요하다:</p>
<pre><code>// 어디에 PHI 노드를 삽입해야 할까?
// 복잡한 제어 흐름에서는 자명하지 않다
if (cond1) {
  x = 10;
} else if (cond2) {
  x = 20;
} else {
  x = 30;
}
// 여기서 x에 PHI 노드가 필요하다
// 하지만 몇 개의 선행 블록이 있는가?
</code></pre>
<p>Dominance frontier는 “변수가 재정의되는 모든 블록의 지배 경계“를 계산한다. 알고리즘이 복잡하고 구현이 어렵다.</p>
<h4 id="4-가독성-문제"><a class="header" href="#4-가독성-문제">4. 가독성 문제</a></h4>
<p>PHI 노드는 직관적이지 않다:</p>
<pre><code class="language-llvm">%result = phi i32 [ %a, %then ], [ %b, %else ]
; 이것이 무엇을 의미하는가?
; "then에서 왔으면 %a, else에서 왔으면 %b"
; 함수 호출처럼 보이지만 실제로는 특별한 의미를 가진다
</code></pre>
<p>초보자가 PHI 노드를 이해하기 어렵다. 특별한 규칙(블록 시작, 순서 지정, edge 의미론)을 배워야 한다.</p>
<h3 id="phi-노드-요약"><a class="header" href="#phi-노드-요약">PHI 노드 요약</a></h3>
<p><strong>PHI 노드의 특징:</strong></p>
<ul>
<li>제어 흐름 합류 지점에서 값을 병합한다</li>
<li>블록 시작에 위치해야 한다 (특별한 위치 규칙)</li>
<li>Lost copy problem - 의미론과 구현의 불일치</li>
<li>Dominance frontier 계산 필요</li>
<li>가독성이 낮다</li>
</ul>
<p><strong>MLIR의 해답:</strong> Block Arguments - PHI 노드를 대체하는 더 깔끔한 방식</p>
<h2 id="block-arguments-in-mlir"><a class="header" href="#block-arguments-in-mlir">Block Arguments in MLIR</a></h2>
<p>MLIR은 PHI 노드 대신 <strong>block arguments</strong>를 사용한다.</p>
<h3 id="block-arguments-개념"><a class="header" href="#block-arguments-개념">Block Arguments 개념</a></h3>
<p><strong>핵심 아이디어:</strong> 기본 블록(basic block)도 함수처럼 파라미터를 받을 수 있다.</p>
<p>함수는 인자를 받는다:</p>
<pre><code class="language-fsharp">let add(x: int, y: int) = x + y
</code></pre>
<p><strong>MLIR에서는 블록도 인자를 받는다:</strong></p>
<pre><code class="language-mlir">^myblock(%arg0: i32, %arg1: i32):
  %sum = arith.addi %arg0, %arg1 : i32
  ...
</code></pre>
<p><code>^myblock</code>은 두 개의 i32 인자를 받는다. 블록으로 분기할 때 값을 전달한다:</p>
<pre><code class="language-mlir">cf.br ^myblock(%value1, %value2 : i32, i32)
</code></pre>
<p>이것은 함수 호출과 유사하다: <code>myblock(value1, value2)</code></p>
<h3 id="block-arguments-vs-phi-nodes"><a class="header" href="#block-arguments-vs-phi-nodes">Block Arguments vs PHI Nodes</a></h3>
<p>같은 예시를 block arguments로 작성하면:</p>
<p><strong>MLIR with Block Arguments:</strong></p>
<pre><code class="language-mlir">func.func @example(%cond: i1) -&gt; i32 {
  cf.cond_br %cond, ^then, ^else

^then:
  %a = arith.constant 11 : i32
  cf.br ^merge(%a : i32)

^else:
  %b = arith.constant 21 : i32
  cf.br ^merge(%b : i32)

^merge(%result: i32):
  func.return %result : i32
}
</code></pre>
<p><strong>차이점 분석:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>측면</th><th>PHI 노드 (LLVM)</th><th>Block Arguments (MLIR)</th></tr>
</thead>
<tbody>
<tr><td><strong>값 전달</strong></td><td><code>phi i32 [ %a, %then ], [ %b, %else ]</code></td><td><code>cf.br ^merge(%a : i32)</code></td></tr>
<tr><td><strong>의미론</strong></td><td>“어느 블록에서 왔는가”</td><td>“블록 호출 시 인자 전달”</td></tr>
<tr><td><strong>위치 제약</strong></td><td>블록 시작에만 가능</td><td>블록 인자로 선언 (일반 파라미터)</td></tr>
<tr><td><strong>가독성</strong></td><td>특별한 문법, edge 리스트</td><td>함수 호출과 유사</td></tr>
</tbody>
</table>
</div>
<p><strong>핵심 통찰력:</strong></p>
<ul>
<li><strong>PHI 노드:</strong> “merge 블록이 선행 블록을 검사하여 값을 선택”</li>
<li><strong>Block Arguments:</strong> “선행 블록이 merge 블록에 값을 전달” (함수 호출처럼)</li>
</ul>
<p>Block arguments는 제어의 역전(inversion of control)이다:</p>
<ul>
<li>PHI: pull 방식 (merge 블록이 값을 가져온다)</li>
<li>Block Arguments: push 방식 (선행 블록이 값을 전달한다)</li>
</ul>
<h3 id="block-arguments의-장점"><a class="header" href="#block-arguments의-장점">Block Arguments의 장점</a></h3>
<h4 id="1-통일된-의미론"><a class="header" href="#1-통일된-의미론">1. 통일된 의미론</a></h4>
<p>함수 인자와 블록 인자가 같은 개념이다:</p>
<pre><code class="language-mlir">// 함수 인자
func.func @foo(%arg: i32) -&gt; i32 {
  ...
}

// 블록 인자 (동일한 문법!)
^myblock(%arg: i32):
  ...
</code></pre>
<p>배울 것이 하나다. 함수를 이해하면 블록도 이해한다.</p>
<h4 id="2-lost-copy-problem-해결"><a class="header" href="#2-lost-copy-problem-해결">2. Lost Copy Problem 해결</a></h4>
<p>Block arguments는 의미론과 구현이 일치한다:</p>
<pre><code class="language-mlir">^then:
  %a = arith.constant 11 : i32
  cf.br ^merge(%a : i32)  ; 명시적으로 %a 전달
</code></pre>
<p>“분기할 때 값을 전달한다“는 의미가 명확하다. Lost copy problem이 없다.</p>
<h4 id="3-위치-제약-없음"><a class="header" href="#3-위치-제약-없음">3. 위치 제약 없음</a></h4>
<p>Block arguments는 블록 파라미터다. 블록 내 어디서든 일반 value처럼 사용할 수 있다:</p>
<pre><code class="language-mlir">^merge(%result: i32):
  %x = arith.constant 1 : i32
  %y = arith.addi %result, %x : i32  ; %result 사용
  func.return %y : i32
</code></pre>
<p>특별한 위치 규칙이 없다. 블록 파라미터는 블록 내 모든 곳에서 유효하다.</p>
<h4 id="4-가독성"><a class="header" href="#4-가독성">4. 가독성</a></h4>
<p>코드가 더 명확하다:</p>
<pre><code class="language-mlir">cf.br ^merge(%a : i32)  ; "merge 블록을 %a와 함께 호출"
^merge(%result: i32):   ; "merge 블록은 %result 파라미터를 받는다"
</code></pre>
<p>함수 호출 비유가 자연스럽다. 초보자가 쉽게 이해한다.</p>
<h3 id="block-arguments-예시"><a class="header" href="#block-arguments-예시">Block Arguments 예시</a></h3>
<p><strong>복잡한 제어 흐름:</strong></p>
<pre><code class="language-mlir">func.func @complex(%x: i32) -&gt; i32 {
  %c0 = arith.constant 0 : i32
  %c10 = arith.constant 10 : i32

  %cond1 = arith.cmpi slt, %x, %c0 : i32
  cf.cond_br %cond1, ^negative, ^nonnegative

^negative:
  %neg = arith.constant -1 : i32
  cf.br ^merge(%neg : i32)

^nonnegative:
  %cond2 = arith.cmpi sgt, %x, %c10 : i32
  cf.cond_br %cond2, ^large, ^small

^large:
  %l = arith.constant 1 : i32
  cf.br ^merge(%l : i32)

^small:
  cf.br ^merge(%c0 : i32)

^merge(%result: i32):
  func.return %result : i32
}
</code></pre>
<p><strong>동작:</strong></p>
<ul>
<li><code>x &lt; 0</code>: ^negative → ^merge(-1)</li>
<li><code>x &gt; 10</code>: ^nonnegative → ^large → ^merge(1)</li>
<li><code>0 ≤ x ≤ 10</code>: ^nonnegative → ^small → ^merge(0)</li>
</ul>
<p><code>^merge</code> 블록은 세 곳에서 호출된다. 각 선행 블록이 값을 전달한다. Block argument <code>%result</code>가 전달된 값을 받는다.</p>
<p><strong>PHI 노드로 작성했다면:</strong></p>
<pre><code class="language-llvm">merge:
  %result = phi i32 [ %neg, %negative ], [ %l, %large ], [ %c0, %small ]
</code></pre>
<p>어느 쪽이 더 명확한가? Block arguments가 push 방식으로 값을 전달하므로 추적하기 쉽다.</p>
<h3 id="block-arguments-요약"><a class="header" href="#block-arguments-요약">Block Arguments 요약</a></h3>
<p><strong>Block Arguments:</strong></p>
<ul>
<li>기본 블록이 함수처럼 파라미터를 받는다</li>
<li>분기 시 값을 전달: <code>cf.br ^block(%value : type)</code></li>
<li>블록 선언에서 파라미터 정의: <code>^block(%arg: type):</code></li>
</ul>
<p><strong>장점:</strong></p>
<ul>
<li>함수 인자와 통일된 의미론</li>
<li>Lost copy problem 해결</li>
<li>위치 제약 없음</li>
<li>가독성 향상</li>
</ul>
<p><strong>PHI 노드 대비:</strong></p>
<ul>
<li>PHI는 pull (merge가 선택), Block Arguments는 push (선행이 전달)</li>
<li>PHI는 특별한 규칙, Block Arguments는 일반 파라미터</li>
</ul>
<blockquote>
<p><strong>다음 섹션:</strong> MLIR의 고수준 제어 흐름인 <code>scf.if</code> 연산을 배운다!</p>
</blockquote>
<h2 id="scfif-고수준-제어-흐름"><a class="header" href="#scfif-고수준-제어-흐름">scf.if: 고수준 제어 흐름</a></h2>
<p>Block arguments를 직접 사용하는 것은 저수준(low-level) 방식이다. MLIR은 **구조화된 제어 흐름(Structured Control Flow)**을 위한 <code>scf</code> dialect를 제공한다.</p>
<h3 id="scf-dialect-소개"><a class="header" href="#scf-dialect-소개">scf Dialect 소개</a></h3>
<p><strong>scf (Structured Control Flow) dialect:</strong></p>
<ul>
<li>고수준 제어 흐름 연산 제공</li>
<li><code>scf.if</code>, <code>scf.for</code>, <code>scf.while</code> 등</li>
<li>구조화된 방식으로 제어 흐름 표현</li>
<li>나중에 저수준 <code>cf</code> dialect로 lowering된다</li>
</ul>
<p><strong>Progressive Lowering 철학:</strong></p>
<pre><code>scf.if (high-level)
  ↓ lowering pass
cf.cond_br (low-level branches)
  ↓ lowering pass
llvm.cond_br (LLVM IR)
</code></pre>
<p>사용자는 고수준 <code>scf.if</code>를 사용한다. 컴파일러가 자동으로 저수준 분기로 변환한다.</p>
<h3 id="scfif-문법"><a class="header" href="#scfif-문법">scf.if 문법</a></h3>
<p><strong>기본 형태:</strong></p>
<pre><code class="language-mlir">%result = scf.if %condition -&gt; (result_type) {
  // then region
  scf.yield %then_value : result_type
} else {
  // else region
  scf.yield %else_value : result_type
}
</code></pre>
<p><strong>구성 요소:</strong></p>
<ol>
<li><strong>%condition</strong>: i1 타입의 boolean 값</li>
<li><strong>-&gt; (result_type)</strong>: 반환할 타입 선언</li>
<li><strong>then region</strong>: 조건이 true일 때 실행</li>
<li><strong>else region</strong>: 조건이 false일 때 실행</li>
<li><strong>scf.yield</strong>: 각 region의 종결자, 값을 반환</li>
</ol>
<p><strong>중요:</strong> 양쪽 region이 <strong>같은 타입</strong>을 yield해야 한다!</p>
<h3 id="scfif-예시"><a class="header" href="#scfif-예시">scf.if 예시</a></h3>
<p><strong>간단한 예시:</strong></p>
<pre><code class="language-mlir">func.func @example(%cond: i1) -&gt; i32 {
  %result = scf.if %cond -&gt; (i32) {
    %c42 = arith.constant 42 : i32
    scf.yield %c42 : i32
  } else {
    %c0 = arith.constant 0 : i32
    scf.yield %c0 : i32
  }
  func.return %result : i32
}
</code></pre>
<p><strong>동작:</strong></p>
<ul>
<li><code>%cond</code>가 true: then region 실행 → <code>%c42</code> yield → <code>%result = 42</code></li>
<li><code>%cond</code>가 false: else region 실행 → <code>%c0</code> yield → <code>%result = 0</code></li>
</ul>
<p><strong>핵심:</strong> <code>scf.if</code>는 <strong>표현식</strong>이다. 값을 반환한다 (<code>%result</code>). if/then/else의 함수형 의미론!</p>
<h3 id="scfyield-종결자"><a class="header" href="#scfyield-종결자">scf.yield 종결자</a></h3>
<p><strong>scf.yield의 역할:</strong></p>
<pre><code class="language-mlir">scf.yield %value : type
</code></pre>
<ul>
<li>Region의 **종결자(terminator)**다</li>
<li>Region을 종료하고 값을 반환한다</li>
<li>함수의 <code>return</code>과 유사하지만, region에서 사용한다</li>
</ul>
<p><strong>중요 규칙:</strong></p>
<ol>
<li>
<p><strong>모든 region은 종결자가 필요하다</strong></p>
<pre><code class="language-mlir">scf.if %cond -&gt; (i32) {
  %c42 = arith.constant 42 : i32
  // 에러! scf.yield 누락
}
</code></pre>
</li>
<li>
<p><strong>yield 타입이 일치해야 한다</strong></p>
<pre><code class="language-mlir">// 에러! then은 i32, else는 i1
scf.if %cond -&gt; (i32) {
  %c42 = arith.constant 42 : i32
  scf.yield %c42 : i32
} else {
  %true = arith.constant 1 : i1
  scf.yield %true : i1  // 타입 불일치!
}
</code></pre>
</li>
<li>
<p><strong>선언된 결과 타입과 일치해야 한다</strong></p>
<pre><code class="language-mlir">// 에러! -&gt; (i32) 선언했지만 i64 yield
%result = scf.if %cond -&gt; (i32) {
  %c42 = arith.constant 42 : i64
  scf.yield %c42 : i64  // 타입 불일치!
}
</code></pre>
</li>
</ol>
<h3 id="scfif의-장점"><a class="header" href="#scfif의-장점">scf.if의 장점</a></h3>
<h4 id="1-타입-안전성"><a class="header" href="#1-타입-안전성">1. 타입 안전성</a></h4>
<p>결과 타입을 미리 선언한다 (<code>-&gt; (i32)</code>). 컴파일러가 양쪽 region을 검증한다.</p>
<pre><code class="language-mlir">%result = scf.if %cond -&gt; (i32) {
  scf.yield %then_val : i32
} else {
  scf.yield %else_val : i32
}
// 컴파일러: "양쪽 모두 i32를 yield하는가?" ✓
</code></pre>
<h4 id="2-구조화된-형태"><a class="header" href="#2-구조화된-형태">2. 구조화된 형태</a></h4>
<p><code>scf.if</code>는 블록 구조가 명확하다:</p>
<ul>
<li>then region</li>
<li>else region</li>
<li>둘 다 명확한 시작과 끝</li>
</ul>
<p>저수준 분기(<code>cf.cond_br</code>)는 임의의 블록으로 점프할 수 있다 (덜 구조화됨).</p>
<h4 id="3-변환-용이성"><a class="header" href="#3-변환-용이성">3. 변환 용이성</a></h4>
<p>고수준 구조는 최적화와 분석이 쉽다:</p>
<ul>
<li>Dead branch elimination</li>
<li>Condition hoisting</li>
<li>Pattern matching</li>
</ul>
<p>저수준 분기는 제어 흐름 그래프(CFG) 분석이 필요하다.</p>
<h3 id="scfif에서-cfcond_br로-lowering"><a class="header" href="#scfif에서-cfcond_br로-lowering">scf.if에서 cf.cond_br로 Lowering</a></h3>
<p><code>scf.if</code>는 나중에 <code>cf.cond_br</code>와 block arguments로 변환된다.</p>
<p><strong>High-level (scf.if):</strong></p>
<pre><code class="language-mlir">%result = scf.if %cond -&gt; (i32) {
  %c42 = arith.constant 42 : i32
  scf.yield %c42 : i32
} else {
  %c0 = arith.constant 0 : i32
  scf.yield %c0 : i32
}
func.return %result : i32
</code></pre>
<p><strong>Lowering 후 (cf.cond_br + block arguments):</strong></p>
<pre><code class="language-mlir">cf.cond_br %cond, ^then, ^else

^then:
  %c42 = arith.constant 42 : i32
  cf.br ^merge(%c42 : i32)

^else:
  %c0 = arith.constant 0 : i32
  cf.br ^merge(%c0 : i32)

^merge(%result: i32):
  func.return %result : i32
</code></pre>
<p><strong>변환 과정:</strong></p>
<ol>
<li><code>scf.if</code>의 then region → <code>^then</code> 블록</li>
<li><code>scf.if</code>의 else region → <code>^else</code> 블록</li>
<li><code>scf.yield</code> → <code>cf.br ^merge(value)</code></li>
<li><code>scf.if</code>의 결과 → <code>^merge</code> 블록의 block argument</li>
</ol>
<p><strong>자동 변환:</strong> <code>--convert-scf-to-cf</code> pass가 이 변환을 수행한다. 사용자는 신경 쓰지 않아도 된다!</p>
<h3 id="multiple-results"><a class="header" href="#multiple-results">Multiple Results</a></h3>
<p><code>scf.if</code>는 여러 값을 반환할 수 있다:</p>
<pre><code class="language-mlir">%x, %y = scf.if %cond -&gt; (i32, i32) {
  %a = arith.constant 10 : i32
  %b = arith.constant 20 : i32
  scf.yield %a, %b : i32, i32
} else {
  %c = arith.constant 30 : i32
  %d = arith.constant 40 : i32
  scf.yield %c, %d : i32, i32
}
// %x, %y는 (10, 20) 또는 (30, 40)
</code></pre>
<p><strong>Lowering 후:</strong></p>
<pre><code class="language-mlir">^merge(%x: i32, %y: i32):
  // %x, %y는 block arguments
</code></pre>
<p>Block arguments도 여러 개 가질 수 있다. <code>scf.if</code>의 유연성이 그대로 lowering된다.</p>
<h3 id="scfif-요약"><a class="header" href="#scfif-요약">scf.if 요약</a></h3>
<p><strong>scf.if 연산:</strong></p>
<ul>
<li>고수준 구조화된 제어 흐름</li>
<li>결과 타입 선언: <code>-&gt; (type)</code></li>
<li>양쪽 region이 같은 타입 yield</li>
<li><code>scf.yield</code> 종결자로 값 반환</li>
</ul>
<p><strong>장점:</strong></p>
<ul>
<li>타입 안전성</li>
<li>구조화된 형태</li>
<li>최적화 용이성</li>
<li>Progressive lowering: scf → cf → llvm</li>
</ul>
<p><strong>다음:</strong> F# P/Invoke 바인딩을 추가하여 <code>scf.if</code>와 <code>scf.yield</code>를 생성한다!</p>
<h2 id="pinvoke-바인딩-scf-dialect"><a class="header" href="#pinvoke-바인딩-scf-dialect">P/Invoke 바인딩: SCF Dialect</a></h2>
<p>이제 F#에서 SCF dialect 연산을 사용할 수 있도록 P/Invoke 바인딩을 추가한다.</p>
<h3 id="mlir-c-api-for-scf"><a class="header" href="#mlir-c-api-for-scf">MLIR C API for SCF</a></h3>
<p>MLIR C API는 <code>mlir-c/Dialect/SCF.h</code> 헤더에서 SCF dialect 지원을 제공한다.</p>
<p><strong>주요 함수:</strong></p>
<pre><code class="language-c">// mlir-c/Dialect/SCF.h

// scf.if operation 생성
MlirOperation mlirSCFIfCreate(
    MlirLocation location,
    MlirValue condition,
    bool hasElse
);

// scf.yield operation 생성
MlirOperation mlirSCFYieldCreate(
    MlirLocation location,
    intptr_t nResults,
    MlirValue const *results
);

// scf.if의 then/else region 접근
MlirRegion mlirSCFIfGetThenRegion(MlirOperation ifOp);
MlirRegion mlirSCFIfGetElseRegion(MlirOperation ifOp);
</code></pre>
<p><strong>Note:</strong> 실제 MLIR C API에서 SCF dialect 지원은 제한적일 수 있다. 필요한 함수가 없으면 C++ shim을 작성한다 (Appendix 참조).</p>
<h3 id="f-pinvoke-바인딩"><a class="header" href="#f-pinvoke-바인딩">F# P/Invoke 바인딩</a></h3>
<p><strong>MlirBindings.fs에 추가:</strong></p>
<pre><code class="language-fsharp">namespace MlirBindings

open System
open System.Runtime.InteropServices

module MlirNative =
    // ... 기존 바인딩 ...

    // ===== SCF Dialect Operations =====

    /// scf.if operation 생성
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirSCFIfCreate(
        MlirLocation location,
        MlirValue condition,
        bool hasElse
    )

    /// scf.yield operation 생성
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirSCFYieldCreate(
        MlirLocation location,
        nativeint nResults,
        MlirValue[] results
    )

    /// scf.if의 then region 가져오기
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirRegion mlirSCFIfGetThenRegion(MlirOperation ifOp)

    /// scf.if의 else region 가져오기
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirRegion mlirSCFIfGetElseRegion(MlirOperation ifOp)

    /// operation의 결과 개수 설정 (scf.if 결과 타입용)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirOperationSetResultTypes(
        MlirOperation operation,
        nativeint nTypes,
        MlirType[] types
    )
</code></pre>
<p><strong>바인딩 설명:</strong></p>
<ol>
<li>
<p><strong>mlirSCFIfCreate</strong>: <code>scf.if</code> operation 생성</p>
<ul>
<li><code>location</code>: operation 위치</li>
<li><code>condition</code>: i1 타입 boolean 값</li>
<li><code>hasElse</code>: else region 포함 여부 (true면 then/else, false면 then만)</li>
</ul>
</li>
<li>
<p><strong>mlirSCFYieldCreate</strong>: <code>scf.yield</code> operation 생성</p>
<ul>
<li><code>nResults</code>: yield할 값 개수</li>
<li><code>results</code>: yield할 값 배열</li>
</ul>
</li>
<li>
<p><strong>mlirSCFIfGetThenRegion/ElseRegion</strong>: region 접근</p>
<ul>
<li><code>scf.if</code>는 내부에 then/else region을 가진다</li>
<li>Region에 블록을 추가하고 연산을 작성한다</li>
</ul>
</li>
</ol>
<h3 id="c-api-제약과-대안"><a class="header" href="#c-api-제약과-대안">C API 제약과 대안</a></h3>
<p>MLIR C API의 SCF dialect 지원은 완전하지 않을 수 있다. 특히:</p>
<ul>
<li><code>scf.if</code> 결과 타입 설정 API가 명확하지 않을 수 있다</li>
<li>Region builder API가 제한적일 수 있다</li>
</ul>
<p><strong>대안 1: Operation State Builder 사용</strong></p>
<p>MLIR C API의 일반 operation builder를 사용:</p>
<pre><code class="language-fsharp">let createScfIf (builder: OpBuilder) (condition: MlirValue) (resultTypes: MlirType[]) (location: MlirLocation) =
    let opName = MlirHelpers.fromString("scf.if")
    let state = MlirNative.mlirOperationStateGet(opName, location)

    // operand 추가 (condition)
    MlirNative.mlirOperationStateAddOperands(state, 1n, [| condition |])

    // 결과 타입 추가
    MlirNative.mlirOperationStateAddResults(state, nativeint resultTypes.Length, resultTypes)

    // region 추가 (then, else)
    MlirNative.mlirOperationStateAddOwnedRegions(state, 2n, [| thenRegion; elseRegion |])

    // operation 생성
    MlirNative.mlirOperationCreate(state)
</code></pre>
<p><strong>대안 2: C++ Shim 작성</strong></p>
<p>Appendix (Chapter 01-03에서 다룬 C++ dialect wrapper 패턴)에 따라 C++ shim을 작성:</p>
<pre><code class="language-cpp">// mlir_scf_wrapper.cpp
extern "C" {

MlirOperation mlirCreateSCFIf(
    MlirLocation location,
    MlirValue condition,
    MlirType* resultTypes,
    intptr_t numResults,
    bool hasElse
) {
    // C++ MLIR API 사용
    mlir::OpBuilder builder(...);
    auto ifOp = builder.create&lt;mlir::scf::IfOp&gt;(
        unwrap(location),
        llvm::ArrayRef&lt;mlir::Type&gt;(...),
        unwrap(condition),
        hasElse
    );
    return wrap(ifOp.getOperation());
}

} // extern "C"
</code></pre>
<p>이 shim을 컴파일하여 F#에서 호출한다.</p>
<p><strong>권장 방안:</strong> 먼저 C API를 시도하고, 부족하면 C++ shim을 작성한다. Chapter 01 Appendix가 이미 패턴을 확립했다.</p>
<h3 id="opbuilder-헬퍼-메서드"><a class="header" href="#opbuilder-헬퍼-메서드">OpBuilder 헬퍼 메서드</a></h3>
<p>고수준 래퍼를 <code>OpBuilder</code> 클래스에 추가한다:</p>
<p><strong>MlirWrapper.fs에 추가:</strong></p>
<pre><code class="language-fsharp">type OpBuilder(context: Context) =
    // ... 기존 메서드 ...

    /// scf.if operation 생성
    member this.CreateScfIf(condition: MlirValue, resultTypes: MlirType[], location: MlirLocation) : MlirOperation =
        let ifOp = MlirNative.mlirSCFIfCreate(location, condition, true)

        // 결과 타입 설정 (C API 함수 사용)
        MlirNative.mlirOperationSetResultTypes(ifOp, nativeint resultTypes.Length, resultTypes)

        ifOp

    /// scf.if의 then region에 블록 추가
    member this.GetThenBlock(ifOp: MlirOperation) : MlirBlock =
        let thenRegion = MlirNative.mlirSCFIfGetThenRegion(ifOp)
        let block = MlirNative.mlirBlockCreate(0n, nativeint 0, nativeint 0)
        MlirNative.mlirRegionAppendOwnedBlock(thenRegion, block)
        block

    /// scf.if의 else region에 블록 추가
    member this.GetElseBlock(ifOp: MlirOperation) : MlirBlock =
        let elseRegion = MlirNative.mlirSCFIfGetElseRegion(ifOp)
        let block = MlirNative.mlirBlockCreate(0n, nativeint 0, nativeint 0)
        MlirNative.mlirRegionAppendOwnedBlock(elseRegion, block)
        block

    /// scf.yield operation 생성
    member this.CreateScfYield(results: MlirValue[], location: MlirLocation) : MlirOperation =
        MlirNative.mlirSCFYieldCreate(location, nativeint results.Length, results)
</code></pre>
<p><strong>사용 예시:</strong></p>
<pre><code class="language-fsharp">// scf.if operation 생성
let i32Type = builder.I32Type()
let ifOp = builder.CreateScfIf(condition, [| i32Type |], location)

// then region 작성
let thenBlock = builder.GetThenBlock(ifOp)
// ... thenBlock에 연산 추가 ...
let thenYield = builder.CreateScfYield([| thenValue |], location)
MlirNative.mlirBlockAppendOwnedOperation(thenBlock, thenYield)

// else region 작성
let elseBlock = builder.GetElseBlock(ifOp)
// ... elseBlock에 연산 추가 ...
let elseYield = builder.CreateScfYield([| elseValue |], location)
MlirNative.mlirBlockAppendOwnedOperation(elseBlock, elseYield)
</code></pre>
<h3 id="dialect-로딩"><a class="header" href="#dialect-로딩">Dialect 로딩</a></h3>
<p>SCF dialect를 사용하려면 context에 로드해야 한다:</p>
<pre><code class="language-fsharp">let ctx = new Context()
ctx.LoadDialect("arith")
ctx.LoadDialect("func")
ctx.LoadDialect("scf")  // SCF dialect 로드!
</code></pre>
<p>이것으로 <code>scf.if</code>와 <code>scf.yield</code> 연산을 사용할 준비가 완료되었다!</p>
<h3 id="pinvoke-바인딩-요약"><a class="header" href="#pinvoke-바인딩-요약">P/Invoke 바인딩 요약</a></h3>
<p><strong>추가한 바인딩:</strong></p>
<ul>
<li><code>mlirSCFIfCreate</code>: scf.if operation 생성</li>
<li><code>mlirSCFYieldCreate</code>: scf.yield operation 생성</li>
<li><code>mlirSCFIfGetThenRegion/ElseRegion</code>: region 접근</li>
</ul>
<p><strong>OpBuilder 헬퍼:</strong></p>
<ul>
<li><code>CreateScfIf</code>: scf.if 생성 + 결과 타입 설정</li>
<li><code>GetThenBlock/GetElseBlock</code>: region에 블록 추가</li>
<li><code>CreateScfYield</code>: scf.yield 생성</li>
</ul>
<p><strong>C API 제약:</strong></p>
<ul>
<li>C API가 불완전하면 C++ shim 작성 (Appendix 패턴 따름)</li>
<li>Operation State Builder를 일반 대안으로 사용</li>
</ul>
<p><strong>다음 섹션:</strong> AST에 If 케이스를 추가하고, 코드 생성을 구현한다!</p>
<h2 id="ast-확장-if-표현식과-boolean-리터럴"><a class="header" href="#ast-확장-if-표현식과-boolean-리터럴">AST 확장: If 표현식과 Boolean 리터럴</a></h2>
<p>이제 AST에 if 표현식과 boolean 리터럴을 추가한다.</p>
<h3 id="expr-타입-확장"><a class="header" href="#expr-타입-확장">Expr 타입 확장</a></h3>
<p><strong>Ast.fs 수정:</strong></p>
<pre><code class="language-fsharp">namespace FunLangCompiler

/// 이진 연산자 (Chapter 06)
type Operator =
    | Add
    | Subtract
    | Multiply
    | Divide

/// 비교 연산자 (Chapter 06)
type CompareOp =
    | LessThan
    | GreaterThan
    | LessEqual
    | GreaterEqual
    | Equal
    | NotEqual

/// 단항 연산자 (Chapter 06)
type UnaryOp =
    | Negate

/// FunLang 표현식 AST
type Expr =
    | IntLiteral of int
    | BinaryOp of Operator * Expr * Expr
    | UnaryOp of UnaryOp * Expr
    | Comparison of CompareOp * Expr * Expr
    | Let of name: string * binding: Expr * body: Expr
    | Var of name: string
    // NEW: If 표현식과 Boolean 리터럴
    | If of condition: Expr * thenBranch: Expr * elseBranch: Expr
    | Bool of bool

/// 최상위 프로그램
type Program =
    { expr: Expr }
</code></pre>
<p><strong>새로운 케이스 설명:</strong></p>
<h3 id="if-of-condition--thenbranch--elsebranch"><a class="header" href="#if-of-condition--thenbranch--elsebranch">If of condition * thenBranch * elseBranch</a></h3>
<pre><code class="language-fsharp">| If of condition: Expr * thenBranch: Expr * elseBranch: Expr
</code></pre>
<p><strong>의미:</strong> <code>if {condition} then {thenBranch} else {elseBranch}</code></p>
<p><strong>필드:</strong></p>
<ul>
<li><code>condition</code>: 조건 표현식 (i1 boolean 값을 생성해야 함)</li>
<li><code>thenBranch</code>: 조건이 true일 때 실행하는 표현식</li>
<li><code>elseBranch</code>: 조건이 false일 때 실행하는 표현식</li>
</ul>
<p><strong>타입 제약:</strong></p>
<ul>
<li><code>condition</code>은 i1 타입을 생성해야 한다</li>
<li><code>thenBranch</code>와 <code>elseBranch</code>는 <strong>같은 타입</strong>을 생성해야 한다</li>
</ul>
<p><strong>예시:</strong></p>
<pre><code class="language-fsharp">// FunLang: if 5 &lt; 10 then 42 else 0
If(
  Comparison(LessThan, IntLiteral 5, IntLiteral 10),
  IntLiteral 42,
  IntLiteral 0
)
</code></pre>
<h3 id="bool-of-bool"><a class="header" href="#bool-of-bool">Bool of bool</a></h3>
<pre><code class="language-fsharp">| Bool of bool
</code></pre>
<p><strong>의미:</strong> Boolean 리터럴 - <code>true</code> 또는 <code>false</code></p>
<p><strong>필드:</strong></p>
<ul>
<li><code>bool</code>: F# boolean 값 (true 또는 false)</li>
</ul>
<p><strong>예시:</strong></p>
<pre><code class="language-fsharp">// FunLang: if true then 1 else 0
If(
  Bool true,
  IntLiteral 1,
  IntLiteral 0
)
</code></pre>
<p><strong>MLIR로 컴파일:</strong> <code>Bool true</code> → <code>arith.constant 1 : i1</code>, <code>Bool false</code> → <code>arith.constant 0 : i1</code></p>
<h3 id="ast-예시"><a class="header" href="#ast-예시">AST 예시</a></h3>
<p><strong>간단한 if:</strong></p>
<pre><code class="language-fsharp">// FunLang: if true then 42 else 0
If(Bool true, IntLiteral 42, IntLiteral 0)
</code></pre>
<p><strong>비교 조건:</strong></p>
<pre><code class="language-fsharp">// FunLang: if 5 &lt; 10 then 1 else 0
If(
  Comparison(LessThan, IntLiteral 5, IntLiteral 10),
  IntLiteral 1,
  IntLiteral 0
)
</code></pre>
<p><strong>let 바인딩과 결합:</strong></p>
<pre><code class="language-fsharp">// FunLang: let x = 5 in if x &gt; 0 then x * 2 else 0
Let("x",
  IntLiteral 5,
  If(
    Comparison(GreaterThan, Var "x", IntLiteral 0),
    BinaryOp(Multiply, Var "x", IntLiteral 2),
    IntLiteral 0
  )
)
</code></pre>
<h2 id="boolean-표현식"><a class="header" href="#boolean-표현식">Boolean 표현식</a></h2>
<p>Boolean 값은 MLIR에서 <strong>i1 타입</strong> (1-bit integer)으로 표현된다.</p>
<h3 id="boolean-타입-i1"><a class="header" href="#boolean-타입-i1">Boolean 타입: i1</a></h3>
<p>MLIR은 boolean을 위한 전용 타입이 없다. 대신 1-bit integer (<code>i1</code>)를 사용한다:</p>
<pre><code class="language-mlir">%true = arith.constant 1 : i1    // Boolean true
%false = arith.constant 0 : i1   // Boolean false
</code></pre>
<p><strong>i1의 값:</strong></p>
<ul>
<li><code>1</code>: true</li>
<li><code>0</code>: false</li>
</ul>
<h3 id="boolean-리터럴-컴파일-1"><a class="header" href="#boolean-리터럴-컴파일-1">Boolean 리터럴 컴파일</a></h3>
<p><code>Bool</code> 케이스를 i1 상수로 컴파일한다:</p>
<pre><code class="language-fsharp">| Bool(value) -&gt;
    let i1Type = builder.Context.GetIntegerType(1)  // 1-bit integer
    let intValue = if value then 1L else 0L
    let attr = builder.Context.GetIntegerAttr(i1Type, intValue)
    let constOp = builder.CreateConstant(attr, location)
    MlirNative.mlirBlockAppendOwnedOperation(block, constOp)
    builder.GetResult(constOp, 0)
</code></pre>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">// Bool true
%true = arith.constant 1 : i1

// Bool false
%false = arith.constant 0 : i1
</code></pre>
<h3 id="비교-연산은-이미-i1을-반환한다"><a class="header" href="#비교-연산은-이미-i1을-반환한다">비교 연산은 이미 i1을 반환한다</a></h3>
<p>Chapter 06에서 구현한 비교 연산 (<code>arith.cmpi</code>)은 i1을 반환한다:</p>
<pre><code class="language-mlir">%c5 = arith.constant 5 : i32
%c10 = arith.constant 10 : i32
%cond = arith.cmpi slt, %c5, %c10 : i32  // 결과는 i1
</code></pre>
<p><strong>중요:</strong> if 조건으로 비교 연산을 사용할 때, i1 → i32 확장(<code>arith.extui</code>)을 제거해야 한다!</p>
<p>Chapter 06에서는 main 함수 반환을 위해 i1을 i32로 확장했다:</p>
<pre><code class="language-fsharp">// Chapter 06 코드 (비교 결과를 i32로 확장)
| Comparison(compareOp, lhs, rhs) -&gt;
    let lhsVal = compileExpr builder block location lhs env
    let rhsVal = compileExpr builder block location rhs env
    let cmpOp = builder.CreateArithCompare(compareOp, lhsVal, rhsVal, location)
    MlirNative.mlirBlockAppendOwnedOperation(block, cmpOp)
    let cmpVal = builder.GetResult(cmpOp, 0)  // i1 값
    // i1 -&gt; i32 확장
    let i32Type = builder.I32Type()
    let extOp = builder.CreateArithExtUI(cmpVal, i32Type, location)
    MlirNative.mlirBlockAppendOwnedOperation(block, extOp)
    builder.GetResult(extOp, 0)  // i32 반환
</code></pre>
<p><strong>문제:</strong> if 조건은 i1이 필요한데, 위 코드는 i32를 반환한다!</p>
<p><strong>해결 방안:</strong> 컨텍스트에 따라 확장 여부를 결정한다:</p>
<ul>
<li>if 조건: i1 그대로 사용</li>
<li>main 함수 반환: i32로 확장</li>
</ul>
<p><strong>간단한 접근:</strong> Comparison 케이스가 i1을 반환하도록 하고, main 함수에서만 확장한다.</p>
<p><strong>수정된 Comparison 케이스:</strong></p>
<pre><code class="language-fsharp">| Comparison(compareOp, lhs, rhs) -&gt;
    let lhsVal = compileExpr builder block location lhs env
    let rhsVal = compileExpr builder block location rhs env
    let cmpOp = builder.CreateArithCompare(compareOp, lhsVal, rhsVal, location)
    MlirNative.mlirBlockAppendOwnedOperation(block, cmpOp)
    builder.GetResult(cmpOp, 0)  // i1 반환 (확장 안 함)
</code></pre>
<p><strong>main 함수에서 확장:</strong></p>
<pre><code class="language-fsharp">let resultValue = compileExpr builder entryBlock loc program.expr env

// 결과가 i1이면 i32로 확장 (main 함수 반환용)
let resultType = MlirNative.mlirValueGetType(resultValue)
let finalResult =
    if MlirNative.mlirTypeIsI1(resultType) then
        let i32Type = builder.I32Type()
        let extOp = builder.CreateArithExtUI(resultValue, i32Type, loc)
        MlirNative.mlirBlockAppendOwnedOperation(entryBlock, extOp)
        builder.GetResult(extOp, 0)
    else
        resultValue
</code></pre>
<h3 id="boolean-연산-선택-사항"><a class="header" href="#boolean-연산-선택-사항">Boolean 연산 (선택 사항)</a></h3>
<p>Boolean 값에 논리 연산을 적용할 수 있다:</p>
<p><strong>AND:</strong></p>
<pre><code class="language-mlir">%a = arith.constant 1 : i1
%b = arith.constant 0 : i1
%result = arith.andi %a, %b : i1  // 결과: 0 (false)
</code></pre>
<p><strong>OR:</strong></p>
<pre><code class="language-mlir">%result = arith.ori %a, %b : i1  // 결과: 1 (true)
</code></pre>
<p><strong>NOT (XOR with 1):</strong></p>
<pre><code class="language-mlir">%c1 = arith.constant 1 : i1
%result = arith.xori %a, %c1 : i1  // a의 반대
</code></pre>
<p><strong>AST 추가 (나중에):</strong></p>
<p>Phase 2에서는 boolean 연산을 추가하지 않는다. if/then/else만으로 충분하다. 필요하면 나중에 추가한다.</p>
<h2 id="ifthenelse-코드-생성"><a class="header" href="#ifthenelse-코드-생성">If/Then/Else 코드 생성</a></h2>
<p>이제 If 케이스를 scf.if로 컴파일한다.</p>
<h3 id="if-케이스-구현"><a class="header" href="#if-케이스-구현">If 케이스 구현</a></h3>
<p>실제 구현에서는 <code>CreateOperation</code>과 Region 생성 패턴을 사용한다:</p>
<p><strong>CodeGen.fs에 추가:</strong></p>
<pre><code class="language-fsharp">| If(cond, thenExpr, elseExpr, _) -&gt;
    // 1. Compile condition (must be i1 type)
    let condVal = compileExpr ctx cond

    // 2. Determine result type (assume i32 for now - FunLang is well-typed)
    let resultType = i32Type

    // 3. Create THEN region
    let thenRegion = builder.CreateRegion()
    let thenBlock = builder.CreateBlock([||], ctx.Location)
    builder.AppendBlockToRegion(thenRegion, thenBlock)

    // Compile then expression in new block context
    let thenCtx = { ctx with Block = thenBlock }
    let thenVal = compileExpr thenCtx thenExpr

    // Add scf.yield terminator to then block
    let thenYieldOp = builder.CreateOperation(
        "scf.yield", ctx.Location,
        [||], [| thenVal |], [||], [||])
    builder.AppendOperationToBlock(thenBlock, thenYieldOp)

    // 4. Create ELSE region
    let elseRegion = builder.CreateRegion()
    let elseBlock = builder.CreateBlock([||], ctx.Location)
    builder.AppendBlockToRegion(elseRegion, elseBlock)

    // Compile else expression in new block context
    let elseCtx = { ctx with Block = elseBlock }
    let elseVal = compileExpr elseCtx elseExpr

    // Add scf.yield terminator to else block
    let elseYieldOp = builder.CreateOperation(
        "scf.yield", ctx.Location,
        [||], [| elseVal |], [||], [||])
    builder.AppendOperationToBlock(elseBlock, elseYieldOp)

    // 5. Create scf.if operation
    let ifOp = builder.CreateOperation(
        "scf.if", ctx.Location,
        [| resultType |],              // result types
        [| condVal |],                 // operands (condition only)
        [||],                          // no attributes
        [| thenRegion; elseRegion |])  // regions: then, else

    builder.AppendOperationToBlock(ctx.Block, ifOp)
    builder.GetResult(ifOp, 0)
</code></pre>
<p><strong>핵심 패턴:</strong></p>
<ul>
<li><strong>Region 생성</strong>: <code>builder.CreateRegion()</code> → <code>builder.CreateBlock([||], loc)</code> → <code>builder.AppendBlockToRegion</code></li>
<li><strong>Context 전환</strong>: 각 region에서 <code>{ ctx with Block = thenBlock }</code>로 새 컨텍스트 생성</li>
<li><strong>scf.yield 종결자</strong>: 반드시 각 region의 끝에 추가해야 함</li>
<li><strong>Region 순서</strong>: <code>[| thenRegion; elseRegion |]</code> - then이 첫 번째, else가 두 번째</li>
</ul>
<p><strong>동작 설명:</strong></p>
<ol>
<li><strong>조건 컴파일:</strong> <code>condition</code> 표현식을 컴파일하여 i1 값을 얻는다</li>
<li><strong>결과 타입:</strong> if 표현식의 결과 타입 (여기서는 i32로 가정)</li>
<li><strong>scf.if 생성:</strong> <code>CreateScfIf</code>로 operation 생성</li>
<li><strong>Then region:</strong> thenBranch 컴파일 → scf.yield로 값 반환</li>
<li><strong>Else region:</strong> elseBranch 컴파일 → scf.yield로 값 반환</li>
<li><strong>Operation 추가:</strong> scf.if를 부모 블록에 추가</li>
<li><strong>결과 사용:</strong> scf.if의 결과 (SSA value)를 반환</li>
</ol>
<p><strong>핵심:</strong> 각 region에서 <code>compileExpr</code>를 호출할 때 <strong>해당 region의 블록</strong>을 전달한다. 이렇게 하면 연산이 올바른 region에 추가된다.</p>
<h3 id="예시-if-true-then-42-else-0"><a class="header" href="#예시-if-true-then-42-else-0">예시: if true then 42 else 0</a></h3>
<p><strong>AST:</strong></p>
<pre><code class="language-fsharp">If(Bool true, IntLiteral 42, IntLiteral 0)
</code></pre>
<p><strong>컴파일 과정:</strong></p>
<ol>
<li><code>Bool true</code> 컴파일: <code>%true = arith.constant 1 : i1</code></li>
<li><code>scf.if</code> 생성</li>
<li>Then region:
<ul>
<li><code>IntLiteral 42</code> 컴파일: <code>%c42 = arith.constant 42 : i32</code></li>
<li><code>scf.yield %c42</code></li>
</ul>
</li>
<li>Else region:
<ul>
<li><code>IntLiteral 0</code> 컴파일: <code>%c0 = arith.constant 0 : i32</code></li>
<li><code>scf.yield %c0</code></li>
</ul>
</li>
<li>scf.if 결과: <code>%result</code></li>
</ol>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">module {
  func.func @main() -&gt; i32 {
    %true = arith.constant 1 : i1
    %result = scf.if %true -&gt; (i32) {
      %c42 = arith.constant 42 : i32
      scf.yield %c42 : i32
    } else {
      %c0 = arith.constant 0 : i32
      scf.yield %c0 : i32
    }
    func.return %result : i32
  }
}
</code></pre>
<p><strong>실행:</strong></p>
<pre><code class="language-bash">$ ./program
$ echo $?
42
</code></pre>
<p>조건이 true이므로 42를 반환한다!</p>
<h3 id="예시-if-5--10-then-1-else-0"><a class="header" href="#예시-if-5--10-then-1-else-0">예시: if 5 &lt; 10 then 1 else 0</a></h3>
<p><strong>AST:</strong></p>
<pre><code class="language-fsharp">If(
  Comparison(LessThan, IntLiteral 5, IntLiteral 10),
  IntLiteral 1,
  IntLiteral 0
)
</code></pre>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">module {
  func.func @main() -&gt; i32 {
    %c5 = arith.constant 5 : i32
    %c10 = arith.constant 10 : i32
    %cond = arith.cmpi slt, %c5, %c10 : i32  // i1 결과
    %result = scf.if %cond -&gt; (i32) {
      %c1 = arith.constant 1 : i32
      scf.yield %c1 : i32
    } else {
      %c0 = arith.constant 0 : i32
      scf.yield %c0 : i32
    }
    func.return %result : i32
  }
}
</code></pre>
<p><strong>실행:</strong></p>
<pre><code class="language-bash">$ ./program
$ echo $?
1
</code></pre>
<p>5 &lt; 10이 true이므로 1을 반환한다!</p>
<h2 id="lowering-pass-업데이트"><a class="header" href="#lowering-pass-업데이트">Lowering Pass 업데이트</a></h2>
<p>SCF dialect를 사용하므로 lowering pass에 <code>--convert-scf-to-cf</code>를 추가해야 한다.</p>
<h3 id="pass-pipeline"><a class="header" href="#pass-pipeline">Pass Pipeline</a></h3>
<p>실제 구현에서는 <code>PassManager.AddPipeline</code>을 사용하여 단일 문자열로 pass pipeline을 지정한다:</p>
<p><strong>CodeGen.fs의 compileAndRun 함수:</strong></p>
<pre><code class="language-fsharp">/// Compile, lower to LLVM, and JIT execute an expression
let compileAndRun (source: string) : int32 =
    use ctx = new Context()
    ctx.LoadStandardDialects()
    MlirNative.mlirRegisterAllLLVMTranslations(ctx.Handle)

    let expr = parse source "&lt;string&gt;"
    use mlirMod = compileToFunction ctx "main" expr

    // Lower to LLVM
    // Conversion order:
    // 1. convert-scf-to-cf - Convert scf.if to cf.br/cf.cond_br
    // 2. convert-arith-to-llvm - Convert arith ops to LLVM dialect
    // 3. convert-cf-to-llvm - Convert cf branches to LLVM dialect
    // 4. convert-func-to-llvm - Convert func dialect to LLVM dialect
    // 5. reconcile-unrealized-casts - Clean up any unrealized casts
    use pm = new PassManager(ctx)
    pm.AddPipeline("builtin.module(convert-scf-to-cf,convert-arith-to-llvm,convert-cf-to-llvm,convert-func-to-llvm,reconcile-unrealized-casts)")
    if not (pm.Run(mlirMod)) then
        failwith "Pass pipeline failed"

    // JIT execute
    use ee = new ExecutionEngine(mlirMod, 0)
    // ... JIT 실행 코드 ...
</code></pre>
<p><strong>Pass 순서가 중요하다:</strong></p>
<ol>
<li><strong>convert-scf-to-cf</strong>: <code>scf.if</code> → <code>cf.cond_br</code> + block arguments</li>
<li><strong>convert-arith-to-llvm</strong>: <code>arith.constant</code>, <code>arith.addi</code> → LLVM dialect</li>
<li><strong>convert-cf-to-llvm</strong>: <code>cf.br</code>, <code>cf.cond_br</code> → LLVM dialect branches</li>
<li><strong>convert-func-to-llvm</strong>: <code>func.func</code>, <code>func.return</code> → LLVM dialect</li>
<li><strong>reconcile-unrealized-casts</strong>: 중간 cast 연산 정리</li>
</ol>
<blockquote>
<p><strong>주의:</strong> cf dialect도 로드해야 한다. <code>LoadStandardDialects()</code>에 포함되어 있다.</p>
</blockquote>
<h3 id="mlirbindingsfs에-pass-추가"><a class="header" href="#mlirbindingsfs에-pass-추가">MlirBindings.fs에 Pass 추가</a></h3>
<p><strong>MlirBindings.fs에 추가:</strong></p>
<pre><code class="language-fsharp">/// SCF to CF 변환 pass 생성
[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirPass mlirCreateConversionConvertSCFToCFPass()
</code></pre>
<p><strong>Note:</strong> 함수 이름은 MLIR C API 버전에 따라 다를 수 있다. <code>mlir-c/Conversion/Passes.h</code> 헤더를 확인한다.</p>
<h3 id="lowering-후-mlir-ir"><a class="header" href="#lowering-후-mlir-ir">Lowering 후 MLIR IR</a></h3>
<p><strong>scf.if lowering 전:</strong></p>
<pre><code class="language-mlir">func.func @main() -&gt; i32 {
  %c5 = arith.constant 5 : i32
  %c10 = arith.constant 10 : i32
  %cond = arith.cmpi slt, %c5, %c10 : i32
  %result = scf.if %cond -&gt; (i32) {
    %c1 = arith.constant 1 : i32
    scf.yield %c1 : i32
  } else {
    %c0 = arith.constant 0 : i32
    scf.yield %c0 : i32
  }
  func.return %result : i32
}
</code></pre>
<p><strong>scf.if lowering 후 (cf dialect):</strong></p>
<pre><code class="language-mlir">func.func @main() -&gt; i32 {
  %c5 = arith.constant 5 : i32
  %c10 = arith.constant 10 : i32
  %cond = arith.cmpi slt, %c5, %c10 : i32
  cf.cond_br %cond, ^then, ^else

^then:
  %c1 = arith.constant 1 : i32
  cf.br ^merge(%c1 : i32)

^else:
  %c0 = arith.constant 0 : i32
  cf.br ^merge(%c0 : i32)

^merge(%result: i32):
  func.return %result : i32
}
</code></pre>
<p><strong>핵심:</strong></p>
<ul>
<li><code>scf.if</code> → <code>cf.cond_br</code> + 블록</li>
<li><code>scf.yield</code> → <code>cf.br ^merge(value)</code></li>
<li>Block argument <code>%result</code>가 PHI 역할</li>
</ul>
<h2 id="let-바인딩과-if-결합"><a class="header" href="#let-바인딩과-if-결합">Let 바인딩과 If 결합</a></h2>
<p>Let 바인딩과 if 표현식을 결합한 예시를 보자.</p>
<p><strong>FunLang 소스:</strong></p>
<pre><code class="language-fsharp">let x = 5 in
if x &gt; 0 then x * 2 else 0
</code></pre>
<p><strong>AST:</strong></p>
<pre><code class="language-fsharp">Let("x",
  IntLiteral 5,
  If(
    Comparison(GreaterThan, Var "x", IntLiteral 0),
    BinaryOp(Multiply, Var "x", IntLiteral 2),
    IntLiteral 0
  )
)
</code></pre>
<p><strong>컴파일 과정:</strong></p>
<ol>
<li>
<p><code>Let("x", IntLiteral 5, ...)</code></p>
<ul>
<li><code>IntLiteral 5</code> 컴파일: <code>%c5 = arith.constant 5 : i32</code></li>
<li><code>env' = env.Add("x", %c5)</code></li>
<li>Body 컴파일 (env’ 사용)</li>
</ul>
</li>
<li>
<p><code>If(...)</code> (env’에서)</p>
<ul>
<li>Condition: <code>Comparison(GreaterThan, Var "x", IntLiteral 0)</code>
<ul>
<li><code>Var "x"</code>: env’에서 조회 → %c5</li>
<li><code>IntLiteral 0</code>: <code>%c0 = arith.constant 0 : i32</code></li>
<li><code>%cond = arith.cmpi sgt, %c5, %c0 : i32</code></li>
</ul>
</li>
<li>Then: <code>BinaryOp(Multiply, Var "x", IntLiteral 2)</code>
<ul>
<li><code>Var "x"</code>: env’에서 조회 → %c5</li>
<li><code>IntLiteral 2</code>: <code>%c2 = arith.constant 2 : i32</code></li>
<li><code>%then_val = arith.muli %c5, %c2 : i32</code></li>
</ul>
</li>
<li>Else: <code>IntLiteral 0</code>
<ul>
<li><code>%else_val = arith.constant 0 : i32</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">module {
  func.func @main() -&gt; i32 {
    %c5 = arith.constant 5 : i32          // let x = 5
    %c0 = arith.constant 0 : i32
    %cond = arith.cmpi sgt, %c5, %c0 : i32  // x &gt; 0
    %result = scf.if %cond -&gt; (i32) {
      %c2 = arith.constant 2 : i32
      %then_val = arith.muli %c5, %c2 : i32  // x * 2
      scf.yield %then_val : i32
    } else {
      %else_val = arith.constant 0 : i32
      scf.yield %else_val : i32
    }
    func.return %result : i32
  }
}
</code></pre>
<p><strong>실행:</strong></p>
<pre><code class="language-bash">$ ./program
$ echo $?
10
</code></pre>
<p>x = 5, x &gt; 0이 true, x * 2 = 10!</p>
<h3 id="중첩된-if"><a class="header" href="#중첩된-if">중첩된 If</a></h3>
<p>if 안에 if를 넣을 수도 있다:</p>
<pre><code class="language-fsharp">// FunLang: if x &gt; 0 then (if x &lt; 10 then 1 else 2) else 0
If(
  Comparison(GreaterThan, Var "x", IntLiteral 0),
  If(
    Comparison(LessThan, Var "x", IntLiteral 10),
    IntLiteral 1,
    IntLiteral 2
  ),
  IntLiteral 0
)
</code></pre>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">%outer_cond = arith.cmpi sgt, %x, %c0 : i32
%result = scf.if %outer_cond -&gt; (i32) {
  %inner_cond = arith.cmpi slt, %x, %c10 : i32
  %inner_result = scf.if %inner_cond -&gt; (i32) {
    %c1 = arith.constant 1 : i32
    scf.yield %c1 : i32
  } else {
    %c2 = arith.constant 2 : i32
    scf.yield %c2 : i32
  }
  scf.yield %inner_result : i32
} else {
  %c0 = arith.constant 0 : i32
  scf.yield %c0 : i32
}
</code></pre>
<p>중첩된 scf.if가 올바르게 생성된다!</p>
<h2 id="공통-에러-1"><a class="header" href="#공통-에러-1">공통 에러</a></h2>
<h3 id="에러-1-조건이-i32인데-i1이-필요"><a class="header" href="#에러-1-조건이-i32인데-i1이-필요">에러 1: 조건이 i32인데 i1이 필요</a></h3>
<p><strong>증상:</strong></p>
<pre><code>MLIR verification failed:
'scf.if' op operand #0 must be 1-bit signless integer, but got 'i32'
</code></pre>
<p><strong>원인:</strong></p>
<p>if 조건에 i32 값을 전달했다.</p>
<p><strong>해결:</strong></p>
<p>조건은 반드시 i1 타입이어야 한다:</p>
<ul>
<li>Boolean 리터럴: <code>Bool true</code> → <code>arith.constant 1 : i1</code></li>
<li>비교 연산: <code>arith.cmpi</code> → i1 결과</li>
<li>i32를 i1로 변환하지 말고, 비교 연산을 사용한다</li>
</ul>
<pre><code class="language-fsharp">// WRONG: i32를 조건으로 사용
let x = IntLiteral 5
If(x, ..., ...)  // 에러! x는 i32

// CORRECT: 비교 연산 사용
If(Comparison(GreaterThan, x, IntLiteral 0), ..., ...)
</code></pre>
<h3 id="에러-2-scfyield-타입-불일치"><a class="header" href="#에러-2-scfyield-타입-불일치">에러 2: scf.yield 타입 불일치</a></h3>
<p><strong>증상:</strong></p>
<pre><code>MLIR verification failed:
'scf.yield' op types mismatch between then and else regions
</code></pre>
<p><strong>원인:</strong></p>
<p>then region과 else region이 다른 타입을 yield했다.</p>
<p><strong>해결:</strong></p>
<p>양쪽 region이 같은 타입을 yield해야 한다:</p>
<pre><code class="language-fsharp">// WRONG: then은 i32, else는 i1
If(cond,
  IntLiteral 42,        // i32
  Bool true)            // i1 - 타입 불일치!

// CORRECT: 둘 다 i32
If(cond,
  IntLiteral 42,        // i32
  IntLiteral 0)         // i32
</code></pre>
<h3 id="에러-3-scfyield-누락"><a class="header" href="#에러-3-scfyield-누락">에러 3: scf.yield 누락</a></h3>
<p><strong>증상:</strong></p>
<pre><code>MLIR verification failed:
Region does not have a terminator
</code></pre>
<p><strong>원인:</strong></p>
<p>then 또는 else region에 scf.yield를 추가하지 않았다.</p>
<p><strong>해결:</strong></p>
<p>모든 region은 종결자가 필요하다. 코드 생성 시 항상 scf.yield를 추가한다:</p>
<pre><code class="language-fsharp">// 올바른 코드 생성 패턴
let thenBlock = builder.GetThenBlock(ifOp)
let thenVal = compileExpr builder thenBlock location thenExpr env
let thenYield = builder.CreateScfYield([| thenVal |], location)
MlirNative.mlirBlockAppendOwnedOperation(thenBlock, thenYield)  // 필수!
</code></pre>
<h3 id="에러-4-convert-scf-to-cf-pass-누락"><a class="header" href="#에러-4-convert-scf-to-cf-pass-누락">에러 4: –convert-scf-to-cf pass 누락</a></h3>
<p><strong>증상:</strong></p>
<pre><code>Failed to translate MLIR to LLVM IR:
Unhandled operation: scf.if
</code></pre>
<p><strong>원인:</strong></p>
<p>Lowering pass에서 SCF → CF 변환을 실행하지 않았다.</p>
<p><strong>해결:</strong></p>
<p>Pass manager에 <code>--convert-scf-to-cf</code>를 추가한다:</p>
<pre><code class="language-fsharp">let scfToCfPass = MlirNative.mlirCreateConversionConvertSCFToCFPass()
MlirNative.mlirPassManagerAddOwnedPass(pm, scfToCfPass)
</code></pre>
<p>Pass 순서: SCF → CF → Arith → Func → Reconcile</p>
<h2 id="구현-시-주의사항-common-pitfalls-1"><a class="header" href="#구현-시-주의사항-common-pitfalls-1">구현 시 주의사항 (Common Pitfalls)</a></h2>
<p>실제 구현에서 발견된 중요한 주의사항들:</p>
<h3 id="1-region-내부의-block-context"><a class="header" href="#1-region-내부의-block-context">1. Region 내부의 Block Context</a></h3>
<p>각 region에서 표현식을 컴파일할 때 <strong>해당 region의 블록</strong>을 컨텍스트에 전달해야 한다:</p>
<pre><code class="language-fsharp">// CORRECT: region별로 새 컨텍스트 생성
let thenCtx = { ctx with Block = thenBlock }
let thenVal = compileExpr thenCtx thenExpr

// WRONG: 부모 블록 사용하면 연산이 잘못된 위치에 생성됨
let thenVal = compileExpr ctx thenExpr  // ctx.Block은 부모 블록!
</code></pre>
<h3 id="2-scfyield-종결자-필수"><a class="header" href="#2-scfyield-종결자-필수">2. scf.yield 종결자 필수</a></h3>
<p>모든 region은 반드시 종결자로 끝나야 한다. <code>scf.yield</code>가 없으면 MLIR 검증이 실패한다:</p>
<pre><code class="language-fsharp">// 반드시 yield 추가
let thenYieldOp = builder.CreateOperation(
    "scf.yield", ctx.Location,
    [||], [| thenVal |], [||], [||])
builder.AppendOperationToBlock(thenBlock, thenYieldOp)
</code></pre>
<h3 id="3-if-결과-타입-고정"><a class="header" href="#3-if-결과-타입-고정">3. if 결과 타입 고정</a></h3>
<p>현재 구현에서는 if 결과 타입을 i32로 고정했다. FunLang은 well-typed 언어이므로 양쪽 branch가 같은 타입을 반환한다고 가정한다:</p>
<pre><code class="language-fsharp">// 결과 타입 고정 (실제로는 타입 추론 필요할 수 있음)
let resultType = i32Type
</code></pre>
<h3 id="4-pass-pipeline-순서"><a class="header" href="#4-pass-pipeline-순서">4. Pass Pipeline 순서</a></h3>
<p>scf → cf → llvm 순서로 lowering해야 한다. scf.if를 직접 LLVM으로 변환할 수 없다:</p>
<pre><code class="language-fsharp">// CORRECT: scf.if → cf.cond_br → llvm branches
"builtin.module(convert-scf-to-cf,convert-arith-to-llvm,convert-cf-to-llvm,convert-func-to-llvm,reconcile-unrealized-casts)"
</code></pre>
<h3 id="5-cf-dialect-로드"><a class="header" href="#5-cf-dialect-로드">5. cf dialect 로드</a></h3>
<p>scf-to-cf 변환을 사용하면 cf dialect가 필요하다. <code>LoadStandardDialects()</code>에 포함시켜야 한다.</p>
<h2 id="장-요약-2"><a class="header" href="#장-요약-2">장 요약</a></h2>
<p>이 장에서 다음을 성취했다:</p>
<ol>
<li><strong>PHI 노드 문제 이해</strong>: 위치 제약, lost copy problem, dominance frontier 계산</li>
<li><strong>Block Arguments 학습</strong>: MLIR의 우아한 대안, 함수 인자와 통일된 의미론</li>
<li><strong>scf.if 연산 사용</strong>: 고수준 구조화된 제어 흐름, scf.yield 종결자</li>
<li><strong>Region 생성 패턴</strong>: CreateRegion → CreateBlock → AppendBlockToRegion</li>
<li><strong>AST 확장</strong>: If 표현식과 Bool 리터럴 추가</li>
<li><strong>Boolean 타입</strong>: i1 (1-bit integer), true = 1, false = 0</li>
<li><strong>코드 생성 구현</strong>: If 케이스를 scf.if + regions로 컴파일</li>
<li><strong>Lowering pass 업데이트</strong>: scf→cf→llvm 순서 pipeline</li>
<li><strong>완전한 예제</strong>: if/then/else와 let 바인딩 결합</li>
</ol>
<p><strong>독자가 할 수 있는 것:</strong></p>
<ul>
<li><code>if true then 42 else 0</code> 컴파일 → 네이티브 바이너리 → 결과: 42 ✓</li>
<li><code>if 5 &lt; 10 then 1 else 0</code> 컴파일 → 결과: 1 ✓</li>
<li><code>let x = 5 in if x &gt; 0 then x * 2 else 0</code> 컴파일 → 결과: 10 ✓</li>
<li>Block arguments vs PHI 노드 차이 이해 ✓</li>
<li>scf.if lowering 과정 이해 ✓</li>
<li>Boolean 타입 (i1) 사용 ✓</li>
<li>타입 불일치 에러 디버깅 ✓</li>
</ul>
<p><strong>핵심 개념:</strong></p>
<ul>
<li><strong>Block Arguments &gt; PHI 노드</strong>: 깔끔한 의미론, push vs pull</li>
<li><strong>scf.if = 표현식</strong>: 값을 반환, 함수형 의미론</li>
<li><strong>scf.yield = 종결자</strong>: Region에서 값 반환, return과 유사</li>
<li><strong>i1 타입 = Boolean</strong>: 1 = true, 0 = false</li>
<li><strong>Progressive Lowering</strong>: scf → cf → llvm</li>
</ul>
<p><strong>다음 장 미리보기:</strong></p>
<p>Chapter 09에서는 <strong>메모리 관리</strong>를 다룬다:</p>
<ul>
<li>Stack vs Heap 할당</li>
<li><code>memref.alloca</code> (stack allocation)</li>
<li><code>memref.alloc</code> (heap allocation)</li>
<li><strong>Boehm GC 통합</strong> (garbage collection)</li>
</ul>
<p>Phase 2의 마지막 장이다. Phase 3에서는 함수와 클로저를 구현할 것이다!</p>
<hr>
<p><strong>이제 독자는 if/then/else 제어 흐름을 컴파일하고, block arguments와 scf.if를 이해한다!</strong></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-09-메모리-관리와-boehm-gc"><a class="header" href="#chapter-09-메모리-관리와-boehm-gc">Chapter 09: 메모리 관리와 Boehm GC</a></h1>
<h2 id="소개-9"><a class="header" href="#소개-9">소개</a></h2>
<p>지금까지 FunLang 컴파일러는 모든 값을 SSA 레지스터로 처리했다. 정수, boolean, 심지어 let 바인딩도 메모리 연산 없이 SSA value로만 표현했다.</p>
<pre><code class="language-mlir">func.func @main() -&gt; i32 {
  %c5 = arith.constant 5 : i32       // SSA value (레지스터)
  %c10 = arith.constant 10 : i32     // SSA value (레지스터)
  %sum = arith.addi %c5, %c10 : i32  // SSA value (레지스터)
  func.return %sum : i32
}
</code></pre>
<p>이 접근 방식은 단순한 표현식에서는 완벽하게 작동한다. 하지만 앞으로 구현할 기능은 <strong>메모리 할당</strong>이 필요하다:</p>
<ul>
<li><strong>클로저(Closures)</strong>: 외부 스코프의 변수를 캡처하는 함수</li>
<li><strong>데이터 구조</strong>: 리스트, 튜플, 문자열 등 동적 크기 데이터</li>
<li><strong>함수에서 반환되는 값</strong>: 함수 스코프를 벗어나 생존하는 값</li>
</ul>
<p>이 장에서는 메모리 관리 전략을 학습한다:</p>
<ul>
<li>Stack vs Heap 할당 전략</li>
<li>MLIR의 <code>memref</code> dialect</li>
<li><strong>Boehm GC</strong> 통합 (자동 메모리 회수)</li>
</ul>
<p><strong>중요한 관점:</strong> Phase 2 프로그램은 아직 메모리 할당이 필요하지 않다. 하지만 Phase 3 (함수와 클로저)에 들어가기 전에 GC 인프라를 미리 준비한다. “필요하기 전에 왜 GC가 필요한지“를 이해하는 것이 목표다.</p>
<p>이 장을 마치면:</p>
<ul>
<li>Stack과 heap의 차이를 이해한다</li>
<li>어떤 값이 stack에, 어떤 값이 heap에 가는지 안다</li>
<li>MLIR의 <code>memref</code> 연산을 사용할 수 있다</li>
<li>Boehm GC를 빌드하고 링킹할 수 있다</li>
<li>왜 클로저에 GC가 필요한지 이해한다</li>
</ul>
<blockquote>
<p><strong>Preview:</strong> Phase 3에서 클로저를 구현할 때, 이 장에서 준비한 GC가 바로 사용된다!</p>
</blockquote>
<h2 id="메모리-관리-전략"><a class="header" href="#메모리-관리-전략">메모리 관리 전략</a></h2>
<p>프로그램이 실행될 때 두 종류의 메모리 영역을 사용한다: <strong>Stack</strong>과 <strong>Heap</strong>.</p>
<h3 id="stack-할당"><a class="header" href="#stack-할당">Stack 할당</a></h3>
<p>**Stack (스택)**은 함수 호출 시 자동으로 관리되는 메모리 영역이다.</p>
<p><strong>Stack에 저장되는 것:</strong></p>
<ul>
<li>함수 파라미터</li>
<li>지역 변수</li>
<li>임시 계산 값</li>
<li>함수 반환 주소</li>
</ul>
<p><strong>Stack의 특징:</strong></p>
<ol>
<li>
<p><strong>자동 할당 및 해제</strong></p>
<pre><code class="language-c">int foo() {
    int x = 5;    // Stack에 할당
    int y = 10;   // Stack에 할당
    return x + y;
    // 함수 종료 시 x, y 자동 해제
}
</code></pre>
</li>
<li>
<p><strong>빠른 할당</strong></p>
<ul>
<li>Stack pointer만 이동 (포인터 연산 한 번)</li>
<li>별도의 할당자(allocator) 불필요</li>
</ul>
</li>
<li>
<p><strong>LIFO (Last-In-First-Out) 구조</strong></p>
<pre><code>foo() 호출:
┌──────────────┐
│ foo의 지역변수│ ← stack top
├──────────────┤
│ main의 지역변수│
├──────────────┤
│    ...       │
└──────────────┘

foo() 종료:
┌──────────────┐
│ main의 지역변수│ ← stack top (foo의 프레임 제거됨)
├──────────────┤
│    ...       │
└──────────────┘
</code></pre>
</li>
<li>
<p><strong>크기 제한</strong></p>
<ul>
<li>Stack 크기는 고정 (보통 1-8MB)</li>
<li>너무 많은 지역 변수나 깊은 재귀는 stack overflow 유발</li>
</ul>
</li>
</ol>
<p><strong>언제 stack을 사용하는가:</strong></p>
<ul>
<li>함수 내부에서만 사용되는 값</li>
<li>크기가 컴파일 타임에 결정되는 값</li>
<li>함수 종료 시 사라져도 되는 값</li>
</ul>
<h3 id="heap-할당"><a class="header" href="#heap-할당">Heap 할당</a></h3>
<p>**Heap (힙)**은 명시적으로 할당하고 해제하는 메모리 영역이다.</p>
<p><strong>Heap에 저장되는 것:</strong></p>
<ul>
<li>함수 스코프를 벗어나 생존하는 값</li>
<li>동적 크기 데이터 (런타임에 크기 결정)</li>
<li>여러 함수/클로저가 공유하는 값</li>
</ul>
<p><strong>Heap의 특징:</strong></p>
<ol>
<li>
<p><strong>명시적 할당</strong></p>
<pre><code class="language-c">void* ptr = malloc(100);  // Heap에 100바이트 할당
// ... ptr 사용 ...
free(ptr);                // 명시적 해제 필요
</code></pre>
</li>
<li>
<p><strong>느린 할당</strong></p>
<ul>
<li>할당자가 적절한 메모리 블록을 찾아야 함</li>
<li>Fragmentation (단편화) 관리 필요</li>
</ul>
</li>
<li>
<p><strong>유연한 생명주기</strong></p>
<pre><code class="language-c">int* create_value() {
    int* p = malloc(sizeof(int));
    *p = 42;
    return p;  // 함수 종료 후에도 값이 살아있다
}
</code></pre>
</li>
<li>
<p><strong>크기 제한이 크다</strong></p>
<ul>
<li>Heap은 시스템 전체 가용 메모리를 사용할 수 있다</li>
<li>Stack보다 훨씬 큰 데이터 구조 가능</li>
</ul>
</li>
</ol>
<p><strong>언제 heap을 사용하는가:</strong></p>
<ul>
<li>함수에서 반환되는 값</li>
<li>동적 크기 데이터 (리스트 길이를 런타임에 결정)</li>
<li>여러 클로저가 공유하는 환경</li>
</ul>
<h3 id="funlang의-메모리-전략"><a class="header" href="#funlang의-메모리-전략">FunLang의 메모리 전략</a></h3>
<p><strong>Phase 2 (현재):</strong></p>
<ul>
<li>모든 값이 SSA 레지스터</li>
<li>정수와 boolean만 존재</li>
<li>메모리 할당이 전혀 없다</li>
</ul>
<pre><code class="language-mlir">// Phase 2: 모든 것이 SSA value
func.func @main() -&gt; i32 {
  %c5 = arith.constant 5 : i32      // 레지스터
  %c10 = arith.constant 10 : i32    // 레지스터
  %sum = arith.addi %c5, %c10 : i32 // 레지스터
  func.return %sum : i32
}
</code></pre>
<p><strong>Phase 3 (클로저):</strong></p>
<ul>
<li>클로저가 환경을 캡처</li>
<li><strong>캡처된 환경은 heap에 할당</strong> (함수를 벗어나 생존)</li>
<li>GC가 자동으로 회수</li>
</ul>
<pre><code class="language-mlir">// Phase 3 예시 (preview):
// let x = 5 in (fun y -&gt; x + y)  // 클로저가 x를 캡처
func.func @main() -&gt; !closure {
  %c5 = arith.constant 5 : i32

  // 클로저 환경을 heap에 할당
  %env_size = arith.constant 8 : i64  // x를 저장할 공간
  %env = llvm.call @GC_malloc(%env_size) : (i64) -&gt; !llvm.ptr

  // x를 환경에 저장
  llvm.store %c5, %env : !llvm.ptr

  // 클로저 생성 (함수 포인터 + 환경 포인터)
  %closure = funlang.create_closure @lambda, %env
  func.return %closure : !closure
}
</code></pre>
<p><strong>Phase 6 (데이터 구조):</strong></p>
<ul>
<li>리스트, 튜플, 문자열</li>
<li>모두 heap에 할당</li>
<li>GC가 관리</li>
</ul>
<h3 id="stack-vs-heap-다이어그램"><a class="header" href="#stack-vs-heap-다이어그램">Stack vs Heap 다이어그램</a></h3>
<pre><code>함수 호출 스택                      Heap (GC 관리)
┌─────────────────────┐            ┌─────────────────────┐
│ main() 프레임       │            │ 클로저 환경 #1      │
│ - return addr       │     ┌─────&gt;│ - x = 5            │
│ - local: result     │─────┘      │ - y = 10           │
│ - temp: %c5, %c10   │            ├─────────────────────┤
├─────────────────────┤            │ 리스트 노드         │
│ foo() 프레임        │            │ - head = 1         │
│ - return addr       │            │ - tail = ...       │
│ - param: x          │            └─────────────────────┘
│ - local: y          │                     ↑
└─────────────────────┘                     │
   (함수 종료 시 자동 해제)           (GC가 회수)
</code></pre>
<p><strong>핵심 차이:</strong></p>
<ul>
<li><strong>Stack</strong>: 함수 스코프에 묶임, 자동 해제, 빠름</li>
<li><strong>Heap</strong>: 스코프 독립, 명시적 할당/해제, 유연함</li>
</ul>
<h3 id="왜-funlang은-heap이-필요한가"><a class="header" href="#왜-funlang은-heap이-필요한가">왜 FunLang은 Heap이 필요한가?</a></h3>
<p><strong>클로저가 핵심 이유다:</strong></p>
<pre><code class="language-fsharp">// FunLang 예시
let makeAdder = fun x -&gt;
    fun y -&gt; x + y

let add5 = makeAdder 5   // 클로저: x=5를 캡처
let add10 = makeAdder 10 // 클로저: x=10을 캡처

add5 3    // 결과: 8  (x=5 사용)
add10 3   // 결과: 13 (x=10 사용)
</code></pre>
<p><strong>문제:</strong></p>
<ul>
<li><code>makeAdder 5</code>가 반환될 때, <code>x=5</code>는 어디에 저장되는가?</li>
<li><code>makeAdder</code> 함수는 이미 종료되었다 (stack 프레임 해제됨)</li>
<li>하지만 <code>add5</code>를 호출할 때 <code>x=5</code>가 필요하다!</li>
</ul>
<p><strong>해답:</strong> <code>x=5</code>를 <strong>heap에 할당</strong>한다. 클로저는 heap 포인터를 가진다.</p>
<pre><code>makeAdder(5) 실행:
1. Heap에 환경 할당: { x: 5 }
2. 클로저 생성: (function_ptr, env_ptr)
3. makeAdder 종료 (stack 해제)
4. 클로저 반환 (env_ptr는 여전히 유효)

add5(3) 호출:
1. env_ptr에서 x 로드: x = 5
2. y = 3 (파라미터)
3. x + y = 8 반환
</code></pre>
<p><strong>GC 없이는?</strong></p>
<ul>
<li>수동으로 <code>free(env_ptr)</code> 호출 필요</li>
<li>언제 해제? <code>add5</code>가 더 이상 사용되지 않을 때</li>
<li>하지만 <code>add5</code>가 다른 변수에 할당되었다면?</li>
<li><strong>복잡성 폭발!</strong> → Garbage Collection 필요</li>
</ul>
<h2 id="mlir-memref-dialect-개요"><a class="header" href="#mlir-memref-dialect-개요">MLIR memref Dialect 개요</a></h2>
<p>MLIR은 메모리 연산을 위해 <strong>memref (memory reference)</strong> dialect를 제공한다.</p>
<h3 id="memref-타입"><a class="header" href="#memref-타입">memref 타입</a></h3>
<p><strong>memref</strong>는 “메모리 영역에 대한 참조“를 나타낸다:</p>
<pre><code class="language-mlir">memref&lt;10xi32&gt;           // 10개의 i32 배열
memref&lt;1xi32&gt;            // 단일 i32 (크기 1 배열)
memref&lt;5x5xf32&gt;          // 5×5 float 행렬
memref&lt;*xi32&gt;            // 동적 크기 i32 배열
</code></pre>
<p><strong>구성:</strong></p>
<ul>
<li><code>memref&lt;shape x type&gt;</code>: shape은 차원, type은 요소 타입</li>
<li><code>memref&lt;1xi32&gt;</code>: 하나의 i32를 저장하는 메모리 영역</li>
</ul>
<h3 id="stack-할당-memrefalloca"><a class="header" href="#stack-할당-memrefalloca">Stack 할당: memref.alloca</a></h3>
<p><strong>Stack에 메모리를 할당</strong>하는 연산:</p>
<pre><code class="language-mlir">func.func @stack_example() -&gt; i32 {
  // Stack에 i32 하나 할당
  %stack = memref.alloca() : memref&lt;1xi32&gt;

  %c0 = arith.constant 0 : index      // 인덱스 0
  %c42 = arith.constant 42 : i32      // 값 42

  // Stack에 값 저장
  memref.store %c42, %stack[%c0] : memref&lt;1xi32&gt;

  // Stack에서 값 로드
  %loaded = memref.load %stack[%c0] : memref&lt;1xi32&gt;

  func.return %loaded : i32
  // 함수 종료 시 stack 자동 해제
}
</code></pre>
<p><strong>동작:</strong></p>
<ol>
<li><code>memref.alloca</code>: Stack에 공간 할당</li>
<li><code>memref.store</code>: 메모리에 값 쓰기</li>
<li><code>memref.load</code>: 메모리에서 값 읽기</li>
<li>함수 종료: Stack 자동 해제</li>
</ol>
<p><strong>인덱스 타입:</strong></p>
<ul>
<li><code>index</code>: MLIR의 배열 인덱스 전용 타입</li>
<li>플랫폼에 따라 i32 또는 i64로 lowering됨</li>
</ul>
<p><strong>LLVM IR로 lowering:</strong></p>
<pre><code class="language-llvm">define i32 @stack_example() {
  %stack = alloca i32, i32 1         ; Stack 할당
  store i32 42, i32* %stack          ; 저장
  %loaded = load i32, i32* %stack    ; 로드
  ret i32 %loaded
}
</code></pre>
<h3 id="heap-할당-memrefalloc"><a class="header" href="#heap-할당-memrefalloc">Heap 할당: memref.alloc</a></h3>
<p><strong>Heap에 메모리를 할당</strong>하는 연산:</p>
<pre><code class="language-mlir">func.func @heap_example() -&gt; memref&lt;10xi32&gt; {
  // Heap에 i32 배열 10개 할당
  %heap = memref.alloc() : memref&lt;10xi32&gt;

  // ... heap 사용 ...

  // 명시적 해제 (수동 메모리 관리)
  // memref.dealloc %heap : memref&lt;10xi32&gt;

  func.return %heap : memref&lt;10xi32&gt;
  // heap은 함수 종료 후에도 유효
}
</code></pre>
<p><strong>동작:</strong></p>
<ol>
<li><code>memref.alloc</code>: Heap에 메모리 할당 (malloc과 유사)</li>
<li>메모리 사용</li>
<li><code>memref.dealloc</code>: 명시적 해제 (free와 유사)
<ul>
<li><strong>주의:</strong> 수동 해제는 에러 유발 (use-after-free, double-free)</li>
<li>FunLang은 GC를 사용하므로 dealloc을 호출하지 않는다!</li>
</ul>
</li>
</ol>
<p><strong>LLVM IR로 lowering:</strong></p>
<pre><code class="language-llvm">define ptr @heap_example() {
  ; malloc 호출
  %size = mul i64 10, 4                    ; 10 * sizeof(i32)
  %heap = call ptr @malloc(i64 %size)

  ; ... heap 사용 ...

  ret ptr %heap
}
</code></pre>
<h3 id="memrefload와-memrefstore"><a class="header" href="#memrefload와-memrefstore">memref.load와 memref.store</a></h3>
<p><strong>메모리 읽기/쓰기:</strong></p>
<pre><code class="language-mlir">// 쓰기
memref.store %value, %memref[%index] : memref&lt;10xi32&gt;

// 읽기
%loaded = memref.load %memref[%index] : memref&lt;10xi32&gt;
</code></pre>
<p><strong>다차원 배열:</strong></p>
<pre><code class="language-mlir">// 5×5 행렬
%matrix = memref.alloc() : memref&lt;5x5xi32&gt;
%c1 = arith.constant 1 : index
%c2 = arith.constant 2 : index
%c42 = arith.constant 42 : i32

// matrix[1][2] = 42
memref.store %c42, %matrix[%c1, %c2] : memref&lt;5x5xi32&gt;

// value = matrix[1][2]
%value = memref.load %matrix[%c1, %c2] : memref&lt;5x5xi32&gt;
</code></pre>
<h3 id="phase-2에서-memref를-사용하지-않는-이유"><a class="header" href="#phase-2에서-memref를-사용하지-않는-이유">Phase 2에서 memref를 사용하지 않는 이유</a></h3>
<p><strong>Phase 2 프로그램은 SSA 레지스터만으로 충분하다:</strong></p>
<pre><code class="language-mlir">// Phase 2 스타일 (SSA only)
func.func @main() -&gt; i32 {
  %x = arith.constant 5 : i32      // SSA value
  %y = arith.constant 10 : i32     // SSA value
  %sum = arith.addi %x, %y : i32   // SSA value
  func.return %sum : i32
}

// memref 스타일로 작성하면? (불필요하게 복잡)
func.func @main() -&gt; i32 {
  %x_mem = memref.alloca() : memref&lt;1xi32&gt;
  %c0 = arith.constant 0 : index
  %c5 = arith.constant 5 : i32
  memref.store %c5, %x_mem[%c0] : memref&lt;1xi32&gt;

  %y_mem = memref.alloca() : memref&lt;1xi32&gt;
  %c10 = arith.constant 10 : i32
  memref.store %c10, %y_mem[%c0] : memref&lt;1xi32&gt;

  %x = memref.load %x_mem[%c0] : memref&lt;1xi32&gt;
  %y = memref.load %y_mem[%c0] : memref&lt;1xi32&gt;
  %sum = arith.addi %x, %y : i32
  func.return %sum : i32
}
</code></pre>
<p>첫 번째 버전이 훨씬 간단하다! SSA 레지스터만으로 충분하면 memref를 사용할 필요가 없다.</p>
<p><strong>memref가 필요한 경우:</strong></p>
<ul>
<li>값이 함수 스코프를 벗어나야 할 때 (클로저 환경)</li>
<li>포인터가 필요할 때 (데이터 구조 간 참조)</li>
<li>Mutation이 필요할 때 (SSA는 immutable)</li>
</ul>
<h3 id="memref-요약"><a class="header" href="#memref-요약">memref 요약</a></h3>
<p><strong>memref dialect:</strong></p>
<ul>
<li>MLIR의 메모리 연산 추상화</li>
<li><code>memref.alloca</code>: Stack 할당 (자동 해제)</li>
<li><code>memref.alloc</code>: Heap 할당 (수동 해제 또는 GC)</li>
<li><code>memref.load/store</code>: 메모리 읽기/쓰기</li>
</ul>
<p><strong>Phase 2 vs Phase 3:</strong></p>
<ul>
<li>Phase 2: SSA 레지스터만 사용 (memref 불필요)</li>
<li>Phase 3: 클로저 환경 → heap 할당 → memref 필요</li>
</ul>
<p><strong>다음 섹션:</strong> 왜 Garbage Collection이 필요한가?</p>
<h2 id="왜-garbage-collection이-필요한가"><a class="header" href="#왜-garbage-collection이-필요한가">왜 Garbage Collection이 필요한가</a></h2>
<p>Heap 메모리는 명시적으로 할당하고 해제해야 한다. 하지만 수동 메모리 관리는 <strong>매우 어렵고 에러가 많다</strong>.</p>
<h3 id="수동-메모리-관리의-문제"><a class="header" href="#수동-메모리-관리의-문제">수동 메모리 관리의 문제</a></h3>
<h4 id="1-use-after-free"><a class="header" href="#1-use-after-free">1. Use-After-Free</a></h4>
<p><strong>freed 메모리에 접근:</strong></p>
<pre><code class="language-c">int* ptr = malloc(sizeof(int));
*ptr = 42;
free(ptr);        // 메모리 해제
printf("%d\n", *ptr);  // 에러! freed 메모리 접근
</code></pre>
<p><strong>결과:</strong></p>
<ul>
<li>Undefined behavior (프로그램 crash 또는 잘못된 값)</li>
<li>보안 취약점 (공격자가 freed 메모리를 재사용)</li>
</ul>
<h4 id="2-double-free"><a class="header" href="#2-double-free">2. Double-Free</a></h4>
<p><strong>같은 메모리를 두 번 해제:</strong></p>
<pre><code class="language-c">int* ptr = malloc(sizeof(int));
free(ptr);
free(ptr);  // 에러! 이미 freed된 메모리
</code></pre>
<p><strong>결과:</strong></p>
<ul>
<li>Heap 메타데이터 손상</li>
<li>프로그램 crash</li>
</ul>
<h4 id="3-memory-leak"><a class="header" href="#3-memory-leak">3. Memory Leak</a></h4>
<p><strong>메모리 해제를 잊음:</strong></p>
<pre><code class="language-c">void leak() {
    int* ptr = malloc(sizeof(int));
    *ptr = 42;
    return;  // ptr을 free하지 않음!
}

// leak()을 1000번 호출하면?
for (int i = 0; i &lt; 1000; i++) {
    leak();  // 메모리 누수: 1000 * sizeof(int) 바이트
}
</code></pre>
<p><strong>결과:</strong></p>
<ul>
<li>메모리 사용량 계속 증가</li>
<li>Out-of-memory 에러</li>
</ul>
<h3 id="클로저가-수동-메모리-관리를-어렵게-만드는-이유"><a class="header" href="#클로저가-수동-메모리-관리를-어렵게-만드는-이유">클로저가 수동 메모리 관리를 어렵게 만드는 이유</a></h3>
<p><strong>문제: 언제 클로저 환경을 해제하는가?</strong></p>
<pre><code class="language-fsharp">// FunLang 예시
let makeAdder x = fun y -&gt; x + y

let add5 = makeAdder 5   // 클로저 1: env = { x: 5 }
let add10 = makeAdder 10 // 클로저 2: env = { x: 10 }

// Q: env { x: 5 }를 언제 해제하는가?
// A: add5가 더 이상 사용되지 않을 때

// 하지만 이것이 언제인가?
let adders = [add5; add10]  // add5를 리스트에 저장
// 여기서 add5를 해제할 수 있는가? No! 리스트가 참조 중

let result = List.head adders 3  // add5 사용
// 이제 해제? 아직 adders가 add5를 가리킨다

// ... 프로그램 계속 실행 ...
</code></pre>
<p><strong>복잡성:</strong></p>
<ul>
<li><code>add5</code>가 언제 “더 이상 사용되지 않는가“를 결정하기 어렵다</li>
<li>여러 변수가 같은 클로저를 참조할 수 있다</li>
<li>클로저가 다른 클로저를 캡처할 수 있다 (환경이 중첩)</li>
</ul>
<p><strong>수동 관리 시도:</strong></p>
<pre><code class="language-fsharp">// 명시적 free 추가?
let add5 = makeAdder 5
// ... add5 사용 ...
free(add5)  // 하지만 다른 변수가 add5를 참조하면?

let alias = add5
free(add5)  // alias는 이제 invalid pointer!
</code></pre>
<p><strong>불가능한 이유:</strong></p>
<ul>
<li>참조 추적이 필요 (누가 클로저를 가리키는가?)</li>
<li>런타임 추적 메커니즘 필요</li>
<li><strong>이미 Garbage Collector를 구현하는 것과 같다!</strong></li>
</ul>
<h3 id="클로저-생명주기-예시"><a class="header" href="#클로저-생명주기-예시">클로저 생명주기 예시</a></h3>
<p><strong>복잡한 시나리오:</strong></p>
<pre><code class="language-fsharp">let outer x =
    let inner y =
        fun z -&gt; x + y + z  // x와 y를 모두 캡처
    inner

let f = outer 5 10   // f는 클로저, env = { x: 5, y: 10 }

// outer 함수는 종료됨 (stack 해제)
// 하지만 env { x: 5, y: 10 }은 heap에 살아있어야 함

let result = f 3     // x=5, y=10, z=3 → 18

// 언제 env를 해제?
// f가 더 이상 참조되지 않을 때
</code></pre>
<p><strong>Garbage Collector의 역할:</strong></p>
<ul>
<li>런타임에 객체 참조를 추적한다</li>
<li>더 이상 참조되지 않는 객체를 찾는다</li>
<li>자동으로 메모리를 회수한다</li>
</ul>
<h3 id="garbage-collection의-이점"><a class="header" href="#garbage-collection의-이점">Garbage Collection의 이점</a></h3>
<p><strong>1. 안전성</strong></p>
<ul>
<li>Use-after-free: 불가능 (GC가 사용 중인 객체를 해제하지 않음)</li>
<li>Double-free: 불가능 (GC가 한 번만 해제)</li>
<li>Memory leak: 최소화 (접근 불가능한 객체는 자동 회수)</li>
</ul>
<p><strong>2. 생산성</strong></p>
<ul>
<li>프로그래머가 메모리 관리를 신경 쓰지 않아도 됨</li>
<li>버그가 적다</li>
<li>코드가 간결해진다</li>
</ul>
<p><strong>3. 클로저 지원</strong></p>
<ul>
<li>클로저 환경의 생명주기를 자동 관리</li>
<li>복잡한 참조 그래프도 처리</li>
</ul>
<p><strong>트레이드오프:</strong></p>
<ul>
<li>성능: GC가 주기적으로 실행됨 (pause time)</li>
<li>메모리: GC는 약간의 메모리 오버헤드 존재</li>
<li><strong>FunLang의 선택:</strong> 클로저 지원을 위해 GC는 필수</li>
</ul>
<h3 id="gc-없이-클로저를-구현한다면"><a class="header" href="#gc-없이-클로저를-구현한다면">GC 없이 클로저를 구현한다면?</a></h3>
<p><strong>대안들:</strong></p>
<ol>
<li>
<p><strong>Reference Counting</strong></p>
<ul>
<li>각 객체의 참조 카운트 추적</li>
<li>카운트가 0이 되면 해제</li>
<li><strong>문제:</strong> 순환 참조 처리 불가
<pre><code class="language-fsharp">let rec loop x = fun y -&gt; loop y x  // 순환 참조!
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Arena Allocation</strong></p>
<ul>
<li>모든 객체를 arena에 할당</li>
<li>Arena 전체를 한 번에 해제</li>
<li><strong>문제:</strong> 클로저가 서로 다른 생명주기를 가질 때 비효율</li>
</ul>
</li>
<li>
<p><strong>Ownership System (Rust 스타일)</strong></p>
<ul>
<li>컴파일 타임에 생명주기 추적</li>
<li>런타임 오버헤드 없음</li>
<li><strong>문제:</strong> FunLang은 타입 추론 언어 (ownership 추가는 언어 복잡성 증가)</li>
</ul>
</li>
</ol>
<p><strong>결론:</strong> Garbage Collection이 가장 적합한 선택이다!</p>
<h3 id="왜-gc가-필요한가-요약"><a class="header" href="#왜-gc가-필요한가-요약">왜 GC가 필요한가 요약</a></h3>
<p><strong>문제:</strong></p>
<ul>
<li>클로저 환경은 heap에 할당해야 한다 (함수 스코프를 벗어남)</li>
<li>환경의 생명주기는 복잡하다 (여러 참조, 중첩, 순환)</li>
<li>수동 메모리 관리는 에러가 많다 (use-after-free, leak)</li>
</ul>
<p><strong>해답: Garbage Collection</strong></p>
<ul>
<li>런타임에 객체 참조를 추적한다</li>
<li>접근 불가능한 객체를 자동으로 회수한다</li>
<li>프로그래머가 메모리 관리를 신경 쓰지 않아도 된다</li>
</ul>
<p><strong>다음 섹션:</strong> Boehm GC 소개 - FunLang이 사용할 GC!</p>
<h2 id="boehm-gc-소개"><a class="header" href="#boehm-gc-소개">Boehm GC 소개</a></h2>
<p>FunLang은 <strong>Boehm-Demers-Weiser Garbage Collector</strong> (줄여서 Boehm GC 또는 bdwgc)를 사용한다.</p>
<h3 id="boehm-gc란"><a class="header" href="#boehm-gc란">Boehm GC란?</a></h3>
<p><strong>Boehm GC</strong>는 C와 C++을 위한 <strong>보수적(conservative) 가비지 컬렉터</strong>다.</p>
<p><strong>핵심 특징:</strong></p>
<ol>
<li>
<p><strong>Conservative Collection</strong></p>
<ul>
<li>“보수적“이란 정확한 타입 정보 없이 동작한다는 의미</li>
<li>Stack과 heap을 스캔하여 “포인터처럼 보이는 값“을 찾는다</li>
<li>값이 유효한 heap 주소 범위에 있으면 포인터로 간주한다</li>
</ul>
</li>
<li>
<p><strong>Drop-in Replacement for malloc/free</strong></p>
<pre><code class="language-c">// 기존 코드
int* ptr = malloc(sizeof(int) * 10);
// ... 사용 ...
free(ptr);

// Boehm GC 사용
int* ptr = GC_malloc(sizeof(int) * 10);
// ... 사용 ...
// free 불필요! GC가 자동으로 회수
</code></pre>
</li>
<li>
<p><strong>Battle-Tested</strong></p>
<ul>
<li>1988년부터 개발됨 (30년 이상 역사)</li>
<li>많은 프로그래밍 언어 구현에서 사용:
<ul>
<li>GNU Guile (Scheme)</li>
<li>Mono (.NET on Linux)</li>
<li>W3m (텍스트 브라우저)</li>
</ul>
</li>
<li>안정성이 검증됨</li>
</ul>
</li>
<li>
<p><strong>Thread-Safe</strong></p>
<ul>
<li>멀티스레드 환경에서 안전</li>
<li>적절한 초기화 필요 (<code>GC_INIT()</code>)</li>
</ul>
</li>
</ol>
<h3 id="왜-boehm-gc를-선택했는가"><a class="header" href="#왜-boehm-gc를-선택했는가">왜 Boehm GC를 선택했는가?</a></h3>
<p><strong>장점:</strong></p>
<ol>
<li>
<p><strong>컴파일러 변경 최소화</strong></p>
<ul>
<li>Stack map 불필요 (conservative 스캔)</li>
<li>Write barrier 불필요</li>
<li>GC를 위한 특별한 코드 생성 불필요</li>
</ul>
</li>
<li>
<p><strong>간단한 통합</strong></p>
<ul>
<li>C 라이브러리로 제공</li>
<li><code>GC_malloc</code> 호출만으로 사용 가능</li>
<li>기존 C runtime과 함께 링킹</li>
</ul>
</li>
<li>
<p><strong>안정성</strong></p>
<ul>
<li>오래 사용됨, 버그가 적다</li>
<li>다양한 플랫폼 지원 (Linux, macOS, Windows)</li>
</ul>
</li>
</ol>
<p><strong>단점:</strong></p>
<ol>
<li>
<p><strong>보수적 수집</strong></p>
<ul>
<li>False positive: 포인터가 아닌 값을 포인터로 오인</li>
<li>결과: 일부 객체가 회수되지 않을 수 있음 (메모리 누수)</li>
<li>실제로는 드물고, 대부분의 프로그램에서 문제없음</li>
</ul>
</li>
<li>
<p><strong>Stop-the-world GC</strong></p>
<ul>
<li>GC 실행 중 프로그램 전체가 일시 중지</li>
<li>Latency-critical 애플리케이션에는 부적합</li>
<li>FunLang은 교육용이므로 문제없음</li>
</ul>
</li>
</ol>
<h3 id="대안과-비교"><a class="header" href="#대안과-비교">대안과 비교</a></h3>
<p><strong>1. Reference Counting</strong></p>
<ul>
<li><strong>장점:</strong> 즉시 회수, 예측 가능</li>
<li><strong>단점:</strong> 순환 참조 처리 불가, 성능 오버헤드 (카운트 업데이트)</li>
<li><strong>FunLang:</strong> 클로저는 순환 참조 가능 → 부적합</li>
</ul>
<p><strong>2. LLVM Statepoints (Precise GC)</strong></p>
<ul>
<li><strong>장점:</strong> 정확한 수집 (false positive 없음)</li>
<li><strong>단점:</strong> 복잡한 컴파일러 지원 필요 (safepoint 삽입, stack map 생성)</li>
<li><strong>FunLang:</strong> 교육용으로는 너무 복잡 → 부적합</li>
</ul>
<p><strong>3. Custom Mark-Sweep GC</strong></p>
<ul>
<li><strong>장점:</strong> 완전한 제어</li>
<li><strong>단점:</strong> 구현이 어렵고 버그가 많음</li>
<li><strong>FunLang:</strong> Boehm GC가 이미 잘 동작 → 불필요</li>
</ul>
<p><strong>결론:</strong> Boehm GC가 FunLang에 가장 적합하다!</p>
<h3 id="boehm-gc-핵심-함수"><a class="header" href="#boehm-gc-핵심-함수">Boehm GC 핵심 함수</a></h3>
<p><strong>1. GC_INIT()</strong></p>
<pre><code class="language-c">GC_INIT();  // 프로그램 시작 시 한 번 호출
</code></pre>
<ul>
<li>GC를 초기화한다</li>
<li>반드시 <code>main()</code> 시작 부분이나 첫 <code>GC_malloc</code> 전에 호출</li>
<li>Thread-local storage 설정, heap 초기화</li>
</ul>
<p><strong>2. GC_malloc(size)</strong></p>
<pre><code class="language-c">void* ptr = GC_malloc(100);  // 100바이트 할당
</code></pre>
<ul>
<li>Heap에 메모리 할당</li>
<li><code>malloc</code>과 동일하게 사용</li>
<li>GC가 자동으로 회수 (free 불필요)</li>
</ul>
<p><strong>3. GC_malloc_atomic(size)</strong></p>
<pre><code class="language-c">void* ptr = GC_malloc_atomic(100);  // 포인터 없는 데이터
</code></pre>
<ul>
<li>포인터를 포함하지 않는 데이터용 할당</li>
<li>예: 문자열, 정수 배열</li>
<li>GC가 스캔하지 않음 (성능 향상)</li>
</ul>
<p><strong>4. GC_free(ptr)</strong> (선택 사항)</p>
<pre><code class="language-c">GC_free(ptr);  // 명시적 해제 (힌트)
</code></pre>
<ul>
<li>GC에게 “이 메모리를 즉시 회수해도 됨“을 알림</li>
<li>필수는 아님 (GC가 나중에 자동 회수)</li>
<li>성능 최적화용</li>
</ul>
<h3 id="conservative-gc-동작-원리"><a class="header" href="#conservative-gc-동작-원리">Conservative GC 동작 원리</a></h3>
<p><strong>1. Heap 스캔:</strong></p>
<pre><code>Heap:
┌────────────────┐ 0x1000
│ Object A       │
├────────────────┤ 0x1010
│ Object B       │
├────────────────┤ 0x1020
│ Free space     │
└────────────────┘
</code></pre>
<p><strong>2. Stack 스캔:</strong></p>
<pre><code>Stack:
┌────────────────┐
│ var1 = 0x1000  │ ← 포인터처럼 보임 (Object A 가리킴)
├────────────────┤
│ var2 = 42      │ ← 포인터 아님 (heap 범위 밖)
├────────────────┤
│ var3 = 0x1010  │ ← 포인터처럼 보임 (Object B 가리킴)
└────────────────┘
</code></pre>
<p><strong>3. Mark Phase:</strong></p>
<ul>
<li>Stack에서 <code>0x1000</code>, <code>0x1010</code> 발견</li>
<li>Object A와 Object B를 “live“로 표시</li>
</ul>
<p><strong>4. Sweep Phase:</strong></p>
<ul>
<li>Heap 전체를 스캔</li>
<li>“live” 표시 없는 객체 회수</li>
</ul>
<p><strong>False Positive 예시:</strong></p>
<pre><code class="language-c">int x = 0x1000;  // 우연히 heap 주소와 같은 정수
// GC는 x를 포인터로 오인할 수 있음
// 결과: 0x1000의 객체가 회수되지 않음 (누수)
</code></pre>
<p>실제로는 드물고, 대부분의 프로그램에서 문제없음.</p>
<h2 id="boehm-gc-빌드-및-설치"><a class="header" href="#boehm-gc-빌드-및-설치">Boehm GC 빌드 및 설치</a></h2>
<p>Boehm GC를 소스에서 빌드하거나 패키지 매니저로 설치할 수 있다.</p>
<h3 id="소스에서-빌드"><a class="header" href="#소스에서-빌드">소스에서 빌드</a></h3>
<p><strong>1. 저장소 클론:</strong></p>
<pre><code class="language-bash"># Boehm GC 저장소
git clone https://github.com/ivmai/bdwgc
cd bdwgc

# Atomic operations 라이브러리 (의존성)
git clone https://github.com/ivmai/libatomic_ops
</code></pre>
<p><strong>2. libatomic_ops 링크:</strong></p>
<pre><code class="language-bash"># bdwgc가 libatomic_ops를 찾을 수 있도록 심볼릭 링크 생성
ln -s $(pwd)/libatomic_ops $(pwd)/libatomic_ops
</code></pre>
<p>또는:</p>
<pre><code class="language-bash">cd bdwgc
ln -s ../libatomic_ops libatomic_ops
</code></pre>
<p><strong>3. Build 설정:</strong></p>
<pre><code class="language-bash">cd bdwgc
autoreconf -vif        # autoconf 파일 생성
automake --add-missing # 누락된 파일 추가
./configure --prefix=$HOME/boehm-gc --enable-threads=posix
</code></pre>
<p><strong>configure 옵션:</strong></p>
<ul>
<li><code>--prefix=$HOME/boehm-gc</code>: 설치 경로 (홈 디렉토리)</li>
<li><code>--enable-threads=posix</code>: 멀티스레드 지원 (POSIX threads)</li>
</ul>
<p><strong>4. 빌드 및 설치:</strong></p>
<pre><code class="language-bash">make -j$(nproc)        # 병렬 빌드 (CPU 코어 수만큼)
make check             # 테스트 실행 (선택 사항)
make install           # $HOME/boehm-gc에 설치
</code></pre>
<p><strong>5. 환경 변수 설정:</strong></p>
<pre><code class="language-bash"># 라이브러리 경로 추가
export LD_LIBRARY_PATH=$HOME/boehm-gc/lib:$LD_LIBRARY_PATH

# 헤더 경로 추가
export C_INCLUDE_PATH=$HOME/boehm-gc/include:$C_INCLUDE_PATH

# bashrc에 추가하여 영구 적용
echo 'export LD_LIBRARY_PATH=$HOME/boehm-gc/lib:$LD_LIBRARY_PATH' &gt;&gt; ~/.bashrc
echo 'export C_INCLUDE_PATH=$HOME/boehm-gc/include:$C_INCLUDE_PATH' &gt;&gt; ~/.bashrc
</code></pre>
<h3 id="패키지-매니저로-설치"><a class="header" href="#패키지-매니저로-설치">패키지 매니저로 설치</a></h3>
<p><strong>Ubuntu/Debian:</strong></p>
<pre><code class="language-bash">sudo apt update
sudo apt install libgc-dev
</code></pre>
<p><strong>macOS (Homebrew):</strong></p>
<pre><code class="language-bash">brew install bdw-gc
</code></pre>
<p><strong>Fedora/RHEL:</strong></p>
<pre><code class="language-bash">sudo dnf install gc-devel
</code></pre>
<p><strong>Arch Linux:</strong></p>
<pre><code class="language-bash">sudo pacman -S gc
</code></pre>
<p>패키지 매니저로 설치하면 환경 변수 설정이 자동으로 처리된다.</p>
<h3 id="설치-확인-1"><a class="header" href="#설치-확인-1">설치 확인</a></h3>
<p><strong>테스트 프로그램 작성:</strong></p>
<pre><code class="language-c">// test_gc.c
#include &lt;stdio.h&gt;
#include &lt;gc.h&gt;

int main() {
    GC_INIT();

    void* ptr = GC_malloc(100);
    if (ptr == NULL) {
        printf("GC_malloc failed\n");
        return 1;
    }

    printf("GC_malloc succeeded: %p\n", ptr);
    // GC_free 불필요 - GC가 자동 회수

    return 0;
}
</code></pre>
<p><strong>컴파일 및 실행:</strong></p>
<pre><code class="language-bash"># 소스 빌드한 경우
gcc test_gc.c -o test_gc -I$HOME/boehm-gc/include -L$HOME/boehm-gc/lib -lgc
./test_gc

# 패키지 매니저로 설치한 경우
gcc test_gc.c -o test_gc -lgc
./test_gc
</code></pre>
<p><strong>예상 출력:</strong></p>
<pre><code>GC_malloc succeeded: 0x7f1234567890
</code></pre>
<p>성공! Boehm GC가 올바르게 설치되었다.</p>
<h2 id="funlang-runtime-통합"><a class="header" href="#funlang-runtime-통합">FunLang Runtime 통합</a></h2>
<p>이제 FunLang 컴파일러가 생성하는 바이너리와 Boehm GC를 연결한다.</p>
<h3 id="c-runtime-작성"><a class="header" href="#c-runtime-작성">C Runtime 작성</a></h3>
<p><strong>runtime.c</strong> - FunLang 실행 환경:</p>
<pre><code class="language-c">// runtime.c - FunLang runtime with Boehm GC
#include &lt;stdio.h&gt;
#include &lt;gc.h&gt;

/**
 * GC 초기화
 * 프로그램 시작 시 한 번 호출
 */
void funlang_init() {
    GC_INIT();
}

/**
 * GC-managed 메모리 할당
 *
 * @param size 할당할 바이트 수
 * @return 할당된 메모리 포인터
 */
void* funlang_alloc(size_t size) {
    return GC_malloc(size);
}

/**
 * Atomic 메모리 할당 (포인터 없는 데이터용)
 *
 * @param size 할당할 바이트 수
 * @return 할당된 메모리 포인터
 */
void* funlang_alloc_atomic(size_t size) {
    return GC_malloc_atomic(size);
}

/**
 * 정수 출력 (Chapter 06에서 구현)
 *
 * @param value 출력할 정수 값
 */
void print_int(int value) {
    printf("%d\n", value);
}

/**
 * MLIR 컴파일된 main 함수
 * F# 컴파일러가 생성한 LLVM IR에서 정의됨
 */
extern int funlang_main();

/**
 * C 프로그램 진입점
 * GC 초기화 후 funlang_main 호출
 */
int main(int argc, char** argv) {
    funlang_init();
    int result = funlang_main();
    return result;
}
</code></pre>
<p><strong>Runtime 구조:</strong></p>
<ol>
<li><strong>funlang_init()</strong>: GC 초기화</li>
<li><strong>funlang_alloc()</strong>: Heap 할당 (Phase 3+에서 사용)</li>
<li><strong>print_int()</strong>: 정수 출력 (Phase 2에서 이미 사용 중)</li>
<li><strong>main()</strong>: GC 초기화 → funlang_main 호출</li>
</ol>
<h3 id="runtime-컴파일"><a class="header" href="#runtime-컴파일">Runtime 컴파일</a></h3>
<pre><code class="language-bash"># 소스 빌드한 경우
gcc -c runtime.c -o runtime.o -I$HOME/boehm-gc/include

# 패키지 매니저로 설치한 경우
gcc -c runtime.c -o runtime.o
</code></pre>
<p><strong>결과:</strong> <code>runtime.o</code> 오브젝트 파일 생성</p>
<h3 id="mlir에서-gc_malloc-호출"><a class="header" href="#mlir에서-gc_malloc-호출">MLIR에서 GC_malloc 호출</a></h3>
<p>Phase 3에서 클로저 환경을 heap에 할당할 때 사용할 패턴 (미리보기):</p>
<p><strong>1. GC_malloc 선언 (MLIR):</strong></p>
<pre><code class="language-mlir">// External function 선언
llvm.func @GC_malloc(i64) -&gt; !llvm.ptr attributes {
    sym_visibility = "private"
}
</code></pre>
<p><strong>2. Heap 할당 호출:</strong></p>
<pre><code class="language-mlir">func.func @allocate_closure_env() -&gt; !llvm.ptr {
    // 클로저 환경 크기 (예: 2개의 i64 값)
    %size = arith.constant 16 : i64  // 2 * 8 bytes

    // GC_malloc 호출
    %env = llvm.call @GC_malloc(%size) : (i64) -&gt; !llvm.ptr

    // env에 캡처된 값 저장
    // (Phase 3에서 구현)

    func.return %env : !llvm.ptr
}
</code></pre>
<p><strong>3. F# 코드 생성 패턴:</strong></p>
<pre><code class="language-fsharp">// MlirWrapper.fs에 추가할 헬퍼 메서드 (Phase 3)
type OpBuilder(context: Context) =
    // ... 기존 메서드 ...

    /// GC_malloc external function 선언
    member this.DeclareGCMalloc() : MlirOperation =
        let ptrType = this.LLVMPointerType()
        let i64Type = builder.Context.GetIntegerType(64)
        let funcType = MlirNative.mlirFunctionTypeGet(
            ctx.Handle,
            1n, [| i64Type |],
            1n, [| ptrType |]
        )

        let name = MlirHelpers.fromString("GC_malloc")
        let funcOp = MlirNative.mlirLLVMFuncCreate(location, name, funcType)

        // 가시성 속성 설정
        // ...

        funcOp

    /// GC_malloc 호출하여 메모리 할당
    member this.CallGCMalloc(size: MlirValue, location: MlirLocation) : MlirValue =
        let gcMalloc = // ... GC_malloc 함수 참조 ...
        let callOp = MlirNative.mlirLLVMCallCreate(
            location, gcMalloc, 1n, [| size |]
        )
        MlirNative.mlirOperationGetResult(callOp, 0)
</code></pre>
<p><strong>Phase 2에서는 사용하지 않지만</strong>, runtime.c에 <code>funlang_alloc</code>을 미리 정의하여 Phase 3에서 바로 사용할 수 있다.</p>
<h2 id="빌드-파이프라인-업데이트"><a class="header" href="#빌드-파이프라인-업데이트">빌드 파이프라인 업데이트</a></h2>
<p>Boehm GC를 포함한 완전한 빌드 파이프라인:</p>
<h3 id="단계별-빌드-과정"><a class="header" href="#단계별-빌드-과정">단계별 빌드 과정</a></h3>
<p><strong>1. FunLang 소스 → LLVM IR:</strong></p>
<pre><code class="language-bash"># F# 컴파일러 실행
dotnet run "let x = 5 in if x &gt; 0 then x * 2 else 0"

# 출력: output.ll (LLVM IR 파일)
</code></pre>
<p><strong>2. LLVM IR → Object 파일:</strong></p>
<pre><code class="language-bash">llc -filetype=obj output.ll -o output.o
</code></pre>
<p><strong>3. Runtime 컴파일:</strong></p>
<pre><code class="language-bash"># 소스 빌드한 경우
gcc -c runtime.c -o runtime.o -I$HOME/boehm-gc/include

# 패키지 매니저로 설치한 경우
gcc -c runtime.c -o runtime.o
</code></pre>
<p><strong>4. 링킹 (Boehm GC 포함):</strong></p>
<pre><code class="language-bash"># 소스 빌드한 경우
gcc output.o runtime.o -o program \
    -L$HOME/boehm-gc/lib -lgc \
    -Wl,-rpath,$HOME/boehm-gc/lib

# 패키지 매니저로 설치한 경우
gcc output.o runtime.o -o program -lgc
</code></pre>
<p><strong>링커 옵션 설명:</strong></p>
<ul>
<li><code>-L$HOME/boehm-gc/lib</code>: 라이브러리 검색 경로</li>
<li><code>-lgc</code>: Boehm GC 라이브러리 링크</li>
<li><code>-Wl,-rpath,$HOME/boehm-gc/lib</code>: 실행 시 라이브러리 경로 (RPATH)</li>
</ul>
<p><strong>5. 실행:</strong></p>
<pre><code class="language-bash">./program
echo $?   # Exit code 확인
</code></pre>
<h3 id="자동화된-빌드-스크립트"><a class="header" href="#자동화된-빌드-스크립트">자동화된 빌드 스크립트</a></h3>
<p><strong>build.sh:</strong></p>
<pre><code class="language-bash">#!/bin/bash
# FunLang 빌드 스크립트

set -e  # 에러 시 중단

FUNLANG_SRC="$1"
OUTPUT="program"

# 1. FunLang → LLVM IR
echo "Compiling FunLang to LLVM IR..."
dotnet run "$FUNLANG_SRC" &gt; output.ll

# 2. LLVM IR → Object
echo "Compiling LLVM IR to object file..."
llc -filetype=obj output.ll -o output.o

# 3. Runtime 컴파일 (필요 시)
if [ ! -f runtime.o ]; then
    echo "Compiling runtime..."
    gcc -c runtime.c -o runtime.o
fi

# 4. 링킹
echo "Linking with Boehm GC..."
if [ -d "$HOME/boehm-gc" ]; then
    # 소스 빌드
    gcc output.o runtime.o -o "$OUTPUT" \
        -L$HOME/boehm-gc/lib -lgc \
        -Wl,-rpath,$HOME/boehm-gc/lib
else
    # 패키지 매니저
    gcc output.o runtime.o -o "$OUTPUT" -lgc
fi

echo "Build complete: $OUTPUT"
</code></pre>
<p><strong>사용:</strong></p>
<pre><code class="language-bash">chmod +x build.sh
./build.sh "let x = 5 in x + x"
./program
</code></pre>
<h3 id="f-통합"><a class="header" href="#f-통합">F# 통합</a></h3>
<p><strong>Compiler.fs에 추가:</strong></p>
<pre><code class="language-fsharp">module Compiler =

    /// LLVM IR을 object 파일로 컴파일
    let compileToObject (llvmIR: string) (outputPath: string) =
        // LLVM IR을 파일에 쓰기
        let llPath = Path.ChangeExtension(outputPath, ".ll")
        File.WriteAllText(llPath, llvmIR)

        // llc 호출
        let llcArgs = sprintf "-filetype=obj %s -o %s" llPath outputPath
        let result = Process.Start("llc", llcArgs)
        result.WaitForExit()

        if result.ExitCode &lt;&gt; 0 then
            failwith "llc compilation failed"

    /// Object 파일과 runtime을 링킹
    let linkWithGC (objPath: string) (exePath: string) =
        let runtimePath = "runtime.o"

        // Boehm GC 경로 확인
        let gcPath = Environment.GetEnvironmentVariable("HOME") + "/boehm-gc"
        let hasSourceBuild = Directory.Exists(gcPath)

        let gccArgs =
            if hasSourceBuild then
                sprintf "%s %s -o %s -L%s/lib -lgc -Wl,-rpath,%s/lib"
                    objPath runtimePath exePath gcPath gcPath
            else
                sprintf "%s %s -o %s -lgc"
                    objPath runtimePath exePath

        let result = Process.Start("gcc", gccArgs)
        result.WaitForExit()

        if result.ExitCode &lt;&gt; 0 then
            failwith "gcc linking failed"

    /// 전체 컴파일 파이프라인
    let compileProgram (source: string) (outputExe: string) =
        // 1. Parse
        let ast = Parser.parse source

        // 2. MLIR IR 생성
        let mlirModule = CodeGen.compile ast

        // 3. Lowering
        Lowering.lowerToLLVMDialect mlirModule

        // 4. LLVM IR 변환
        let llvmIR = Lowering.translateToLLVMIR mlirModule

        // 5. Object 컴파일
        let objPath = Path.ChangeExtension(outputExe, ".o")
        compileToObject llvmIR objPath

        // 6. 링킹
        linkWithGC objPath outputExe

        printfn "Compilation successful: %s" outputExe
</code></pre>
<p><strong>사용:</strong></p>
<pre><code class="language-fsharp">// Program.fs
[&lt;EntryPoint&gt;]
let main argv =
    if argv.Length &lt; 1 then
        printfn "Usage: dotnet run &lt;source&gt; [output]"
        1
    else
        let source = argv.[0]
        let output = if argv.Length &gt; 1 then argv.[1] else "program"

        Compiler.compileProgram source output
        0
</code></pre>
<h2 id="phase-2-vs-phase-3-메모리-사용"><a class="header" href="#phase-2-vs-phase-3-메모리-사용">Phase 2 vs Phase 3+ 메모리 사용</a></h2>
<p>FunLang의 메모리 사용 패턴은 단계별로 진화한다.</p>
<h3 id="phase-2-현재"><a class="header" href="#phase-2-현재">Phase 2 (현재)</a></h3>
<p><strong>특징:</strong></p>
<ul>
<li>모든 값이 SSA 레지스터</li>
<li>메모리 할당 없음</li>
<li>GC 초기화되지만 사용되지 않음</li>
</ul>
<p><strong>생성되는 MLIR IR:</strong></p>
<pre><code class="language-mlir">module {
  func.func @funlang_main() -&gt; i32 {
    %c5 = arith.constant 5 : i32
    %c10 = arith.constant 10 : i32
    %sum = arith.addi %c5, %c10 : i32
    func.return %sum : i32
  }
}
</code></pre>
<p><strong>GC 호출:</strong> 없음 (<code>funlang_alloc</code> 호출 0회)</p>
<h3 id="phase-3-함수와-클로저"><a class="header" href="#phase-3-함수와-클로저">Phase 3 (함수와 클로저)</a></h3>
<p><strong>특징:</strong></p>
<ul>
<li>클로저가 환경을 캡처</li>
<li>환경은 heap에 할당 (<code>GC_malloc</code>)</li>
<li>GC가 죽은 클로저 회수</li>
</ul>
<p><strong>예시: 클로저 환경 할당</strong></p>
<pre><code class="language-mlir">// let makeAdder x = fun y -&gt; x + y
func.func @makeAdder(%x: i32) -&gt; !llvm.ptr {
    // 클로저 환경 할당 (x를 저장)
    %size = arith.constant 8 : i64
    %env = llvm.call @GC_malloc(%size) : (i64) -&gt; !llvm.ptr

    // x를 환경에 저장
    %x_i64 = arith.extsi %x : i32 to i64
    llvm.store %x_i64, %env : !llvm.ptr

    // 클로저 생성 (function pointer + env pointer)
    %closure = funlang.make_closure @lambda, %env

    func.return %closure : !llvm.ptr
}

// fun y -&gt; x + y
func.func private @lambda(%env: !llvm.ptr, %y: i32) -&gt; i32 {
    // 환경에서 x 로드
    %x_i64 = llvm.load %env : !llvm.ptr -&gt; i64
    %x = arith.trunci %x_i64 : i64 to i32

    // x + y
    %result = arith.addi %x, %y : i32
    func.return %result : i32
}
</code></pre>
<p><strong>GC 호출:</strong> <code>makeAdder</code> 호출마다 1회</p>
<h3 id="phase-6-데이터-구조"><a class="header" href="#phase-6-데이터-구조">Phase 6 (데이터 구조)</a></h3>
<p><strong>특징:</strong></p>
<ul>
<li>리스트, 튜플, 문자열 모두 heap 할당</li>
<li>재귀적 데이터 구조 (리스트의 tail)</li>
<li>GC가 복잡한 참조 그래프 처리</li>
</ul>
<p><strong>예시: 리스트 cons</strong></p>
<pre><code class="language-mlir">// cons(1, cons(2, nil))
func.func @build_list() -&gt; !llvm.ptr {
    // nil
    %nil = llvm.mlir.null : !llvm.ptr

    // cons(2, nil)
    %size = arith.constant 16 : i64  // head + tail
    %cons2 = llvm.call @GC_malloc(%size) : (i64) -&gt; !llvm.ptr
    %c2 = arith.constant 2 : i64
    llvm.store %c2, %cons2 : !llvm.ptr
    %tail_ptr = llvm.getelementptr %cons2[8] : !llvm.ptr
    llvm.store %nil, %tail_ptr : !llvm.ptr

    // cons(1, cons2)
    %cons1 = llvm.call @GC_malloc(%size) : (i64) -&gt; !llvm.ptr
    %c1 = arith.constant 1 : i64
    llvm.store %c1, %cons1 : !llvm.ptr
    %tail_ptr1 = llvm.getelementptr %cons1[8] : !llvm.ptr
    llvm.store %cons2, %tail_ptr1 : !llvm.ptr

    func.return %cons1 : !llvm.ptr
}
</code></pre>
<p><strong>GC 호출:</strong> cons 노드마다 1회</p>
<p><strong>메모리 그래프:</strong></p>
<pre><code>%cons1 ─→ [ head: 1 | tail: ─→ %cons2 ─→ [ head: 2 | tail: nil ] ]
</code></pre>
<p>GC는 <code>%cons1</code>이 접근 불가능해지면 전체 체인을 회수한다.</p>
<h3 id="메모리-사용-비교"><a class="header" href="#메모리-사용-비교">메모리 사용 비교</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Phase</th><th>할당 위치</th><th>GC 사용</th><th>복잡도</th></tr>
</thead>
<tbody>
<tr><td>Phase 2</td><td>SSA 레지스터만</td><td>초기화만 (호출 0회)</td><td>낮음</td></tr>
<tr><td>Phase 3</td><td>클로저 환경 → Heap</td><td>클로저 생성 시</td><td>중간</td></tr>
<tr><td>Phase 6</td><td>모든 데이터 구조 → Heap</td><td>거의 모든 연산</td><td>높음</td></tr>
</tbody>
</table>
</div>
<p><strong>핵심:</strong> Phase 2는 GC 인프라를 준비하지만, 실제 사용은 Phase 3부터다.</p>
<h2 id="공통-에러-및-해결"><a class="header" href="#공통-에러-및-해결">공통 에러 및 해결</a></h2>
<p>GC 통합 시 자주 발생하는 에러와 해결 방법:</p>
<h3 id="에러-1-gc_malloc-호출-시-segfault"><a class="header" href="#에러-1-gc_malloc-호출-시-segfault">에러 1: GC_malloc 호출 시 Segfault</a></h3>
<p><strong>증상:</strong></p>
<pre><code>Segmentation fault (core dumped)
</code></pre>
<p><strong>원인:</strong>
<code>GC_INIT()</code>을 호출하지 않고 <code>GC_malloc</code>을 사용했다.</p>
<p><strong>해결:</strong>
<code>main()</code> 시작 부분에서 <code>GC_INIT()</code> 호출:</p>
<pre><code class="language-c">int main() {
    GC_INIT();  // 필수!
    // ... 나머지 코드 ...
}
</code></pre>
<p><strong>FunLang runtime.c:</strong></p>
<pre><code class="language-c">void funlang_init() {
    GC_INIT();
}

int main(int argc, char** argv) {
    funlang_init();  // 첫 번째 호출
    // ...
}
</code></pre>
<h3 id="에러-2-linker-error---undefined-reference-to-gc_malloc"><a class="header" href="#에러-2-linker-error---undefined-reference-to-gc_malloc">에러 2: Linker Error - Undefined Reference to GC_malloc</a></h3>
<p><strong>증상:</strong></p>
<pre><code>undefined reference to `GC_malloc'
collect2: error: ld returned 1 exit status
</code></pre>
<p><strong>원인:</strong>
Boehm GC 라이브러리를 링킹하지 않았다.</p>
<p><strong>해결:</strong>
링킹 시 <code>-lgc</code> 옵션 추가:</p>
<pre><code class="language-bash">gcc output.o runtime.o -o program -lgc
</code></pre>
<p>또는 라이브러리 경로 지정:</p>
<pre><code class="language-bash">gcc output.o runtime.o -o program -L$HOME/boehm-gc/lib -lgc
</code></pre>
<h3 id="에러-3-실행-시-library-not-found"><a class="header" href="#에러-3-실행-시-library-not-found">에러 3: 실행 시 Library Not Found</a></h3>
<p><strong>증상:</strong></p>
<pre><code>error while loading shared libraries: libgc.so.1: cannot open shared object file
</code></pre>
<p><strong>원인:</strong>
실행 시 <code>libgc.so</code>를 찾을 수 없다.</p>
<p><strong>해결:</strong></p>
<p><strong>옵션 1: LD_LIBRARY_PATH 설정</strong></p>
<pre><code class="language-bash">export LD_LIBRARY_PATH=$HOME/boehm-gc/lib:$LD_LIBRARY_PATH
./program
</code></pre>
<p><strong>옵션 2: RPATH 사용 (권장)</strong></p>
<pre><code class="language-bash">gcc output.o runtime.o -o program \
    -L$HOME/boehm-gc/lib -lgc \
    -Wl,-rpath,$HOME/boehm-gc/lib
</code></pre>
<p>RPATH는 바이너리에 라이브러리 경로를 포함시킨다. <code>LD_LIBRARY_PATH</code> 설정 불필요.</p>
<h3 id="에러-4-gc가-메모리를-회수하지-않음"><a class="header" href="#에러-4-gc가-메모리를-회수하지-않음">에러 4: GC가 메모리를 회수하지 않음</a></h3>
<p><strong>증상:</strong>
프로그램 메모리 사용량이 계속 증가한다.</p>
<p><strong>원인:</strong>
Boehm GC는 보수적(conservative)이므로 일부 객체를 회수하지 못할 수 있다.</p>
<p><strong>확인 방법:</strong></p>
<pre><code class="language-c">#include &lt;gc.h&gt;

int main() {
    GC_INIT();

    for (int i = 0; i &lt; 1000000; i++) {
        void* ptr = GC_malloc(100);
        // ptr을 더 이상 사용하지 않음
    }

    // GC 통계 출력
    GC_gcollect();  // 강제 수집
    printf("Heap size: %zu\n", GC_get_heap_size());
    printf("Free bytes: %zu\n", GC_get_free_bytes());

    return 0;
}
</code></pre>
<p><strong>일반적인 경우:</strong></p>
<ul>
<li>Phase 2-3 프로그램에서는 문제없음</li>
<li>Conservative GC의 false positive는 드물다</li>
<li>메모리 누수가 심각하면 정확한(precise) GC 고려</li>
</ul>
<h3 id="에러-5-multi-threading-관련-crash"><a class="header" href="#에러-5-multi-threading-관련-crash">에러 5: Multi-threading 관련 Crash</a></h3>
<p><strong>증상:</strong>
멀티스레드 프로그램에서 random crash.</p>
<p><strong>원인:</strong>
GC를 멀티스레드 모드로 초기화하지 않았다.</p>
<p><strong>해결:</strong></p>
<p><strong>Phase 2-5:</strong> 싱글스레드만 사용하므로 문제없음.</p>
<p><strong>Phase 6+ (Future):</strong> 스레드 생성 시 GC-aware 함수 사용:</p>
<pre><code class="language-c">#include &lt;gc.h&gt;
#include &lt;pthread.h&gt;

void* thread_func(void* arg) {
    GC_pthread_create(...);  // GC-aware thread creation
    // ...
}
</code></pre>
<p>또는 빌드 시 thread-safe 옵션:</p>
<pre><code class="language-bash">./configure --enable-threads=posix
</code></pre>
<h2 id="장-요약-3"><a class="header" href="#장-요약-3">장 요약</a></h2>
<p>이 장에서 메모리 관리의 기초와 Boehm GC 통합을 완료했다.</p>
<h3 id="주요-성취"><a class="header" href="#주요-성취">주요 성취</a></h3>
<ol>
<li>
<p><strong>Stack vs Heap 이해</strong></p>
<ul>
<li>Stack: 함수 스코프, 자동 관리, LIFO</li>
<li>Heap: 유연한 생명주기, 명시적 할당/해제</li>
</ul>
</li>
<li>
<p><strong>FunLang 메모리 전략</strong></p>
<ul>
<li>Phase 2: SSA 레지스터만 사용</li>
<li>Phase 3+: 클로저 환경 → heap 할당</li>
</ul>
</li>
<li>
<p><strong>MLIR memref Dialect</strong></p>
<ul>
<li><code>memref.alloca</code>: Stack 할당</li>
<li><code>memref.alloc</code>: Heap 할당</li>
<li><code>memref.load/store</code>: 메모리 읽기/쓰기</li>
</ul>
</li>
<li>
<p><strong>GC 필요성 이해</strong></p>
<ul>
<li>수동 메모리 관리의 문제: use-after-free, leak, double-free</li>
<li>클로저가 복잡한 생명주기를 가진다</li>
<li>GC가 자동으로 회수한다</li>
</ul>
</li>
<li>
<p><strong>Boehm GC 통합</strong></p>
<ul>
<li>Conservative GC: 타입 정보 불필요</li>
<li><code>GC_INIT()</code>, <code>GC_malloc()</code> 사용</li>
<li>빌드 및 설치 완료</li>
</ul>
</li>
<li>
<p><strong>Runtime 작성</strong></p>
<ul>
<li><code>runtime.c</code>: GC 초기화, 메모리 할당 wrapper</li>
<li><code>funlang_main()</code> 호출 전에 <code>funlang_init()</code></li>
</ul>
</li>
<li>
<p><strong>빌드 파이프라인</strong></p>
<ul>
<li>FunLang → LLVM IR → Object → 링킹 (+ Boehm GC)</li>
<li>자동화 스크립트 및 F# 통합</li>
</ul>
</li>
<li>
<p><strong>에러 처리</strong></p>
<ul>
<li>GC_INIT 누락, 링킹 오류, 라이브러리 경로 문제 해결</li>
</ul>
</li>
</ol>
<h3 id="독자가-할-수-있는-것"><a class="header" href="#독자가-할-수-있는-것">독자가 할 수 있는 것</a></h3>
<ul>
<li>Stack과 heap의 차이를 설명할 수 있다 ✓</li>
<li>언제 heap 할당이 필요한지 안다 (클로저, 데이터 구조) ✓</li>
<li>Boehm GC를 빌드하고 설치할 수 있다 ✓</li>
<li><code>runtime.c</code>를 작성하여 GC를 초기화할 수 있다 ✓</li>
<li>FunLang 컴파일러 출력을 Boehm GC와 링킹할 수 있다 ✓</li>
<li>GC 관련 에러를 디버깅할 수 있다 ✓</li>
<li>왜 클로저가 GC를 필요로 하는지 이해한다 ✓</li>
</ul>
<h3 id="phase-2-완료"><a class="header" href="#phase-2-완료">Phase 2 완료!</a></h3>
<p><strong>Chapter 06:</strong> 산술 표현식 (+, -, *, /, 비교, 부정, print)
<strong>Chapter 07:</strong> Let 바인딩과 SSA 환경 전달
<strong>Chapter 08:</strong> 제어 흐름 (scf.if, block arguments, boolean)
<strong>Chapter 09:</strong> 메모리 관리 (stack/heap 전략, Boehm GC 통합)</p>
<p><strong>독자가 컴파일할 수 있는 프로그램:</strong></p>
<pre><code class="language-fsharp">// 복잡한 예시
let x = 5 in
let y = 10 in
if x &gt; 0 then
    if y &lt; 20 then
        x * y
    else
        x + y
else
    0
</code></pre>
<p><strong>생성되는 바이너리:</strong></p>
<ul>
<li>MLIR로 컴파일</li>
<li>LLVM IR로 lowering</li>
<li>Native object 생성</li>
<li>Boehm GC와 링킹</li>
<li>실행 가능한 바이너리!</li>
</ul>
<pre><code class="language-bash">$ ./program
$ echo $?
50
</code></pre>
<h3 id="phase-3-preview-함수와-클로저"><a class="header" href="#phase-3-preview-함수와-클로저">Phase 3 Preview: 함수와 클로저</a></h3>
<p>다음 Phase에서 다룰 내용:</p>
<p><strong>함수 정의:</strong></p>
<pre><code class="language-fsharp">let add = fun x -&gt; fun y -&gt; x + y
</code></pre>
<p><strong>클로저 캡처:</strong></p>
<pre><code class="language-fsharp">let makeAdder x = fun y -&gt; x + y
let add5 = makeAdder 5  // x=5를 캡처
</code></pre>
<p><strong>메모리 할당:</strong></p>
<ul>
<li>클로저 환경을 heap에 할당 (<code>GC_malloc</code>)</li>
<li>함수 포인터 + 환경 포인터 구조</li>
<li>GC가 죽은 클로저 회수</li>
</ul>
<p><strong>MLIR 연산:</strong></p>
<ul>
<li><code>llvm.call @GC_malloc</code>: Heap 할당</li>
<li><code>llvm.store</code>, <code>llvm.load</code>: 환경 읽기/쓰기</li>
<li>Function 타입과 호출 규약</li>
</ul>
<p><strong>이 장에서 준비한 GC 인프라가 바로 사용된다!</strong></p>
<hr>
<p><strong>독자는 이제 메모리 관리를 이해하고, Boehm GC를 통합했다. Phase 3로 가자!</strong></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-10-함수와-func-다이얼렉트"><a class="header" href="#chapter-10-함수와-func-다이얼렉트">Chapter 10: 함수와 func 다이얼렉트</a></h1>
<h2 id="소개-10"><a class="header" href="#소개-10">소개</a></h2>
<p>지금까지 FunLang 컴파일러는 **표현식(expression)**만 처리했다. Chapter 06부터 09까지 산술, 비교, let 바인딩, if 표현식을 컴파일하는 방법을 배웠다. 모든 것이 하나의 표현식이었고, 그 결과가 프로그램의 최종 값이었다.</p>
<pre><code class="language-fsharp">// 지금까지의 FunLang - 단일 표현식
let x = 10 in
let y = 20 in
if x &gt; y then x else y
</code></pre>
<p>이것은 단순한 스크립트에서는 작동하지만, 실제 프로그램은 <strong>재사용 가능한 코드 단위</strong>가 필요하다. 계산을 이름에 바인딩하고, 여러 곳에서 호출할 수 있어야 한다. 바로 **함수(function)**다.</p>
<p>이 장에서는 **최상위 명명된 함수(top-level named functions)**를 추가한다:</p>
<pre><code class="language-fsharp">// 함수 정의
let add x y = x + y

// 함수 호출
add 10 20   // 결과: 30
</code></pre>
<p><strong>중요한 범위 구분:</strong> 이 장은 <strong>Phase 3의 첫 단계</strong>로, 간단한 함수만 다룬다:</p>
<ul>
<li>최상위 함수 정의 (module-level functions)</li>
<li>함수 파라미터 (고정된 개수)</li>
<li>함수 호출 (call-by-value)</li>
<li>함수 반환값</li>
</ul>
<p><strong>제외되는 것 (Phase 4에서 다룸):</strong></p>
<ul>
<li><strong>클로저(Closures)</strong>: 외부 변수를 캡처하는 함수</li>
<li><strong>고차 함수(Higher-order functions)</strong>: 함수를 인자로 받거나 반환하는 함수</li>
<li><strong>익명 함수(Lambda expressions)</strong>: <code>fun x -&gt; x + 1</code></li>
</ul>
<p>왜 Phase 3과 Phase 4로 나누는가?</p>
<ul>
<li>Phase 3: 함수의 <strong>정적 측면</strong> (함수 정의, 호출, 재귀)</li>
<li>Phase 4: 함수의 <strong>동적 측면</strong> (클로저, 환경 캡처, 함수 값)</li>
</ul>
<p>Phase 3 함수는 C나 Java의 static method와 유사하다: 이름으로 호출하고, 외부 상태를 캡처하지 않는다. Phase 4에서 환경 캡처를 추가하면 진정한 함수형 언어가 된다.</p>
<p><strong>학습 목표:</strong></p>
<ul>
<li>MLIR func 다이얼렉트의 연산들 (<code>func.func</code>, <code>func.call</code>, <code>func.return</code>)</li>
<li>함수 파라미터를 block arguments로 표현하는 방법</li>
<li>함수 호출과 반환 값 처리</li>
<li>LLVM 호출 규약(calling convention)의 기초</li>
<li>재귀 함수의 작동 원리 (Chapter 11 preview)</li>
</ul>
<p>이 장을 마치면:</p>
<ul>
<li>다중 함수 정의를 포함한 FunLang 프로그램을 컴파일할 수 있다</li>
<li>함수가 MLIR IR로, 그리고 네이티브 코드로 변환되는 과정을 이해한다</li>
<li>함수 파라미터가 SSA value로 처리되는 원리를 안다</li>
<li>모듈 레벨 심볼 테이블이 어떻게 재귀를 가능하게 하는지 안다</li>
</ul>
<blockquote>
<p><strong>Preview:</strong> Chapter 11에서는 재귀와 상호 재귀를 다룬다. Chapter 10은 함수의 기초를 확립한다.</p>
</blockquote>
<h2 id="mlir-func-다이얼렉트"><a class="header" href="#mlir-func-다이얼렉트">MLIR func 다이얼렉트</a></h2>
<p>MLIR은 함수를 표현하기 위한 전용 다이얼렉트를 제공한다: <strong>func 다이얼렉트</strong>.</p>
<h3 id="func-다이얼렉트-개요"><a class="header" href="#func-다이얼렉트-개요">func 다이얼렉트 개요</a></h3>
<p><strong>func 다이얼렉트</strong>는 함수 정의와 호출을 표현하는 고수준 추상화다. C, C++, Rust 같은 언어의 함수와 동일한 개념이다.</p>
<p><strong>핵심 연산:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>연산</th><th>목적</th><th>예시</th></tr>
</thead>
<tbody>
<tr><td><code>func.func</code></td><td>함수 정의</td><td><code>func.func @add(%arg0: i32, %arg1: i32) -&gt; i32</code></td></tr>
<tr><td><code>func.call</code></td><td>함수 호출</td><td><code>%result = func.call @add(%x, %y) : (i32, i32) -&gt; i32</code></td></tr>
<tr><td><code>func.return</code></td><td>함수에서 값 반환</td><td><code>func.return %result : i32</code></td></tr>
</tbody>
</table>
</div>
<p><strong>func 다이얼렉트의 위치 (다이얼렉트 스택):</strong></p>
<pre><code>High-level:  func 다이얼렉트 (함수 추상화)
             scf 다이얼렉트 (제어 흐름)
             arith 다이얼렉트 (산술)
             ↓ (lowering passes)
Middle:      LLVM 다이얼렉트 (LLVM IR 추상화)
             ↓ (mlir-translate)
Low-level:   LLVM IR (define, call, ret)
             ↓ (llc)
Native:      Machine code (x86-64, ARM, etc.)
</code></pre>
<p>func 다이얼렉트는 <strong>고수준 추상화</strong>다. 플랫폼 독립적으로 함수를 정의하고, 나중에 LLVM 다이얼렉트로 내려가면서 호출 규약, 레지스터 할당, 스택 프레임 관리가 추가된다.</p>
<h3 id="funcfunc-연산-함수-정의"><a class="header" href="#funcfunc-연산-함수-정의">func.func 연산: 함수 정의</a></h3>
<p><code>func.func</code> 연산은 함수를 정의한다. C의 function definition, Java의 method declaration과 동일한 개념이다.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="language-mlir">func.func @function_name(%arg0: type0, %arg1: type1, ...) -&gt; return_type {
  // function body
  func.return %result : return_type
}
</code></pre>
<p><strong>구성 요소:</strong></p>
<ol>
<li><strong>Symbol name (<code>@function_name</code>)</strong>: 함수의 이름. <code>@</code> 기호는 모듈 레벨 심볼을 나타낸다.</li>
<li><strong>Parameters (<code>%arg0</code>, <code>%arg1</code>)</strong>: 함수의 파라미터. Block arguments로 표현된다.</li>
<li><strong>Function type (<code>(type0, type1) -&gt; return_type</code>)</strong>: 파라미터 타입과 반환 타입.</li>
<li><strong>Function body</strong>: 함수 본체. Region (영역) 내부에 블록을 포함한다.</li>
<li><strong>Terminator (<code>func.return</code>)</strong>: 함수 종료. 반환 값을 지정한다.</li>
</ol>
<p><strong>예시 1: 단순한 함수 (두 정수 더하기)</strong></p>
<pre><code class="language-mlir">func.func @add(%arg0: i32, %arg1: i32) -&gt; i32 {
  %result = arith.addi %arg0, %arg1 : i32
  func.return %result : i32
}
</code></pre>
<p><strong>해석:</strong></p>
<ul>
<li>함수 이름: <code>@add</code></li>
<li>파라미터: <code>%arg0</code> (i32), <code>%arg1</code> (i32)</li>
<li>반환 타입: i32</li>
<li>본체: <code>%arg0 + %arg1</code> 계산</li>
<li>반환: <code>%result</code> 값 반환</li>
</ul>
<p>이것은 C의 <code>int add(int arg0, int arg1) { return arg0 + arg1; }</code>와 동일하다.</p>
<p><strong>예시 2: 파라미터 없는 함수</strong></p>
<pre><code class="language-mlir">func.func @get_constant() -&gt; i32 {
  %c42 = arith.constant 42 : i32
  func.return %c42 : i32
}
</code></pre>
<p>파라미터가 없으면 괄호 내부가 비어있다: <code>()</code>.</p>
<p><strong>예시 3: 다중 연산을 포함하는 함수</strong></p>
<pre><code class="language-mlir">func.func @compute(%x: i32) -&gt; i32 {
  %c2 = arith.constant 2 : i32
  %doubled = arith.muli %x, %c2 : i32
  %c10 = arith.constant 10 : i32
  %result = arith.addi %doubled, %c10 : i32
  func.return %result : i32
}
</code></pre>
<p><strong>해석:</strong></p>
<ul>
<li><code>x * 2 + 10</code> 계산</li>
<li>중간 계산 (<code>%doubled</code>) 저장</li>
<li>최종 결과 반환</li>
</ul>
<h3 id="funccall-연산-함수-호출"><a class="header" href="#funccall-연산-함수-호출">func.call 연산: 함수 호출</a></h3>
<p><code>func.call</code> 연산은 함수를 호출한다. 함수 이름을 심볼 참조로 지정하고, 인자를 전달하고, 결과를 받는다.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="language-mlir">%result = func.call @function_name(%arg0, %arg1, ...) : (type0, type1, ...) -&gt; return_type
</code></pre>
<p><strong>구성 요소:</strong></p>
<ol>
<li><strong>Callee (<code>@function_name</code>)</strong>: 호출할 함수의 심볼 참조.</li>
<li><strong>Arguments (<code>%arg0</code>, <code>%arg1</code>)</strong>: 함수에 전달할 인자 (SSA values).</li>
<li><strong>Function type annotation</strong>: 함수의 시그니처 (파라미터 타입과 반환 타입).</li>
<li><strong>Result (<code>%result</code>)</strong>: 함수 호출의 결과 (SSA value).</li>
</ol>
<p><strong>예시 1: add 함수 호출</strong></p>
<pre><code class="language-mlir">func.func @main() -&gt; i32 {
  %c10 = arith.constant 10 : i32
  %c20 = arith.constant 20 : i32
  %sum = func.call @add(%c10, %c20) : (i32, i32) -&gt; i32
  func.return %sum : i32
}

func.func @add(%arg0: i32, %arg1: i32) -&gt; i32 {
  %result = arith.addi %arg0, %arg1 : i32
  func.return %result : i32
}
</code></pre>
<p><strong>실행 흐름:</strong></p>
<ol>
<li><code>@main</code> 함수 시작</li>
<li><code>%c10 = 10</code>, <code>%c20 = 20</code> 생성</li>
<li><code>@add</code> 함수 호출 (인자: 10, 20)</li>
<li><code>@add</code> 내부: <code>%arg0 = 10</code>, <code>%arg1 = 20</code></li>
<li><code>%result = 10 + 20 = 30</code> 계산</li>
<li><code>@add</code> 반환: 30</li>
<li><code>@main</code>에서 <code>%sum = 30</code> 저장</li>
<li><code>@main</code> 반환: 30</li>
</ol>
<p><strong>예시 2: 중첩 호출 (함수 결과를 다른 함수의 인자로 사용)</strong></p>
<pre><code class="language-mlir">func.func @main() -&gt; i32 {
  %c5 = arith.constant 5 : i32
  %doubled = func.call @double(%c5) : (i32) -&gt; i32
  %result = func.call @double(%doubled) : (i32) -&gt; i32
  func.return %result : i32
}

func.func @double(%x: i32) -&gt; i32 {
  %c2 = arith.constant 2 : i32
  %result = arith.muli %x, %c2 : i32
  func.return %result : i32
}
</code></pre>
<p><strong>실행:</strong></p>
<ul>
<li><code>double(5)</code> → 10</li>
<li><code>double(10)</code> → 20</li>
<li>최종 결과: 20</li>
</ul>
<h3 id="funcreturn-연산-함수-종료"><a class="header" href="#funcreturn-연산-함수-종료">func.return 연산: 함수 종료</a></h3>
<p><code>func.return</code> 연산은 함수를 종료하고 값을 반환한다. C의 <code>return</code> 문과 동일하다.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="language-mlir">func.return %value : type
</code></pre>
<p><strong>중요한 규칙:</strong></p>
<ol>
<li>
<p><strong>모든 함수는 func.return으로 끝나야 한다</strong>: <code>func.return</code>은 terminator operation이다. 함수 본체의 마지막 연산이어야 한다.</p>
</li>
<li>
<p><strong>반환 타입 일치</strong>: 반환 값의 타입은 함수 시그니처의 반환 타입과 일치해야 한다.</p>
<pre><code class="language-mlir">// 올바름
func.func @example() -&gt; i32 {
  %c42 = arith.constant 42 : i32
  func.return %c42 : i32  // i32 반환 (시그니처와 일치)
}

// 오류: 타입 불일치
func.func @wrong() -&gt; i32 {
  %c1 = arith.constant 1 : i1  // i1 타입
  func.return %c1 : i1  // 오류! i32를 반환해야 함
}
</code></pre>
</li>
<li>
<p><strong>Multiple returns (여러 반환 지점)</strong>: 함수는 여러 반환 지점을 가질 수 있다 (조건부).</p>
<pre><code class="language-mlir">func.func @abs(%x: i32) -&gt; i32 {
  %c0 = arith.constant 0 : i32
  %is_negative = arith.cmpi slt, %x, %c0 : i32
  %result = scf.if %is_negative -&gt; (i32) {
    %neg = arith.subi %c0, %x : i32
    scf.yield %neg : i32
  } else {
    scf.yield %x : i32
  }
  func.return %result : i32
}
</code></pre>
</li>
</ol>
<h3 id="함수-가시성-visibility"><a class="header" href="#함수-가시성-visibility">함수 가시성 (Visibility)</a></h3>
<p>함수는 <strong>가시성(visibility)</strong> 속성을 가질 수 있다:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>가시성</th><th>의미</th><th>사용 예</th></tr>
</thead>
<tbody>
<tr><td><code>public</code> (기본값)</td><td>모듈 외부에서 접근 가능</td><td><code>func.func @main() -&gt; i32</code></td></tr>
<tr><td><code>private</code></td><td>모듈 내부에서만 접근 가능</td><td><code>func.func private @helper() -&gt; i32</code></td></tr>
<tr><td><code>nested</code></td><td>부모 함수 내부에서만 접근 가능 (Phase 4에서 다룸)</td><td></td></tr>
</tbody>
</table>
</div>
<p><strong>예시: private 함수 (헬퍼 함수)</strong></p>
<pre><code class="language-mlir">// Public 함수 - 외부에서 호출 가능
func.func @main() -&gt; i32 {
  %result = func.call @helper() : () -&gt; i32
  func.return %result : i32
}

// Private 함수 - main에서만 호출 가능
func.func private @helper() -&gt; i32 {
  %c42 = arith.constant 42 : i32
  func.return %c42 : i32
}
</code></pre>
<p>Phase 3에서는 모든 함수가 <code>public</code>이다 (기본값). 가시성을 명시할 필요가 없다.</p>
<h3 id="함수와-심볼-테이블"><a class="header" href="#함수와-심볼-테이블">함수와 심볼 테이블</a></h3>
<p>MLIR 모듈은 **심볼 테이블(symbol table)**을 유지한다. 모든 <code>func.func</code> 연산은 모듈 레벨 심볼로 등록된다.</p>
<p><strong>핵심 특성:</strong></p>
<ol>
<li>
<p><strong>Flat namespace (평면 네임스페이스)</strong>: 모든 함수가 동일한 네임스페이스에 있다. 함수 정의 순서는 중요하지 않다.</p>
</li>
<li>
<p><strong>Forward references (전방 참조)</strong>: 함수를 정의하기 전에 호출할 수 있다.</p>
<pre><code class="language-mlir">// foo는 아직 정의되지 않았지만 호출 가능
func.func @main() -&gt; i32 {
  %result = func.call @foo() : () -&gt; i32
  func.return %result : i32
}

// 나중에 정의됨
func.func @foo() -&gt; i32 {
  %c42 = arith.constant 42 : i32
  func.return %c42 : i32
}
</code></pre>
</li>
<li>
<p><strong>재귀 가능</strong>: 함수가 자기 자신을 호출할 수 있다 (심볼이 모듈에 등록되므로).</p>
<pre><code class="language-mlir">func.func @factorial(%n: i32) -&gt; i32 {
  %c1 = arith.constant 1 : i32
  %is_one = arith.cmpi sle, %n, %c1 : i32
  %result = scf.if %is_one -&gt; (i32) {
    scf.yield %c1 : i32
  } else {
    %n_minus_1 = arith.subi %n, %c1 : i32
    %rec = func.call @factorial(%n_minus_1) : (i32) -&gt; i32  // 재귀 호출
    %product = arith.muli %n, %rec : i32
    scf.yield %product : i32
  }
  func.return %result : i32
}
</code></pre>
</li>
<li>
<p><strong>상호 재귀 가능</strong>: 두 함수가 서로를 호출할 수 있다.</p>
<pre><code class="language-mlir">func.func @is_even(%n: i32) -&gt; i1 {
  // ... calls @is_odd ...
}

func.func @is_odd(%n: i32) -&gt; i1 {
  // ... calls @is_even ...
}
</code></pre>
</li>
</ol>
<p>심볼 테이블 덕분에 함수 정의 순서나 전방 선언을 걱정할 필요가 없다. 모든 함수가 모듈 로드 시 등록된다.</p>
<h3 id="phase-2와의-비교-함수-vs-표현식"><a class="header" href="#phase-2와의-비교-함수-vs-표현식">Phase 2와의 비교: 함수 vs 표현식</a></h3>
<p>Phase 2에서는 모든 것이 단일 표현식이었다:</p>
<pre><code class="language-mlir">// Phase 2 스타일 - 단일 main 함수
func.func @main() -&gt; i32 {
  %c10 = arith.constant 10 : i32
  %c20 = arith.constant 20 : i32
  %sum = arith.addi %c10, %c20 : i32
  func.return %sum : i32
}
</code></pre>
<p>Phase 3에서는 재사용 가능한 함수를 정의한다:</p>
<pre><code class="language-mlir">// Phase 3 스타일 - 여러 함수
func.func @add(%a: i32, %b: i32) -&gt; i32 {
  %result = arith.addi %a, %b : i32
  func.return %result : i32
}

func.func @main() -&gt; i32 {
  %c10 = arith.constant 10 : i32
  %c20 = arith.constant 20 : i32
  %sum = func.call @add(%c10, %c20) : (i32, i32) -&gt; i32
  func.return %sum : i32
}
</code></pre>
<p><strong>차이점:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>측면</th><th>Phase 2 (표현식)</th><th>Phase 3 (함수)</th></tr>
</thead>
<tbody>
<tr><td>코드 조직</td><td>단일 main 함수</td><td>여러 함수 정의</td></tr>
<tr><td>재사용</td><td>불가능 (중복 코드)</td><td>가능 (함수 호출)</td></tr>
<tr><td>추상화</td><td>없음</td><td>함수 이름으로 추상화</td></tr>
<tr><td>모듈성</td><td>낮음</td><td>높음 (함수 단위)</td></tr>
<tr><td>컴파일 결과</td><td>단일 함수</td><td>여러 함수 심볼</td></tr>
</tbody>
</table>
</div>
<p>함수는 코드를 <strong>모듈화</strong>하고 <strong>재사용 가능</strong>하게 만든다. Phase 2의 표현식 컴파일러를 함수 본체 내부에서 재사용한다!</p>
<h2 id="ast-확장-fundef와-app"><a class="header" href="#ast-확장-fundef와-app">AST 확장: FunDef와 App</a></h2>
<p>FunLang에 함수를 추가하려면 AST를 확장해야 한다. 두 가지 새로운 노드가 필요하다:</p>
<ol>
<li><strong>FunDef</strong>: 함수 정의 (<code>let f x y = ...</code>)</li>
<li><strong>App</strong>: 함수 적용 (호출) (<code>f 10 20</code>)</li>
</ol>
<h3 id="fundef-함수-정의"><a class="header" href="#fundef-함수-정의">FunDef: 함수 정의</a></h3>
<p><strong>FunDef</strong>는 최상위 함수 정의를 표현한다.</p>
<p><strong>F# AST 정의:</strong></p>
<pre><code class="language-fsharp">type Expr =
    | Int of int
    | Bool of bool
    | Var of string
    | BinOp of Expr * Operator * Expr
    | UnaryOp of UnaryOperator * Expr
    | Compare of Expr * CompareOp * Expr
    | Let of string * Expr * Expr
    | If of Expr * Expr * Expr
    | App of string * Expr list              // NEW: 함수 호출
    // ... Lambda는 Phase 4에서 추가 ...

type FunDef = {                               // NEW: 함수 정의
    name: string                              // 함수 이름
    parameters: string list                   // 파라미터 이름 리스트
    body: Expr                                // 함수 본체 (표현식)
}

type Program = {                              // NEW: 프로그램 구조
    functions: FunDef list                    // 함수 정의 리스트
    main: Expr                                // Main 표현식
}
</code></pre>
<p><strong>예시: <code>let add x y = x + y</code></strong></p>
<pre><code class="language-fsharp">let addFunction = {
    name = "add"
    parameters = ["x"; "y"]
    body = BinOp(Var "x", Add, Var "y")
}
</code></pre>
<p><strong>구성 요소:</strong></p>
<ul>
<li><code>name</code>: 함수 이름 (<code>"add"</code>)</li>
<li><code>parameters</code>: 파라미터 이름 리스트 (<code>["x"; "y"]</code>)</li>
<li><code>body</code>: 함수 본체 (<code>x + y</code> 표현식)</li>
</ul>
<p><strong>예시: <code>let square x = x * x</code></strong></p>
<pre><code class="language-fsharp">let squareFunction = {
    name = "square"
    parameters = ["x"]
    body = BinOp(Var "x", Mul, Var "x")
}
</code></pre>
<p><strong>예시: 파라미터가 없는 함수 <code>let getConstant = 42</code></strong></p>
<pre><code class="language-fsharp">let constantFunction = {
    name = "getConstant"
    parameters = []                           // 빈 리스트
    body = Int 42
}
</code></pre>
<h3 id="app-함수-적용-호출"><a class="header" href="#app-함수-적용-호출">App: 함수 적용 (호출)</a></h3>
<p><strong>App</strong>는 함수 호출을 표현한다. 함수 이름과 인자 리스트를 포함한다.</p>
<p><strong>F# AST 정의:</strong></p>
<pre><code class="language-fsharp">type Expr =
    | ...
    | App of string * Expr list               // 함수 이름, 인자 리스트
</code></pre>
<p><strong>예시: <code>add 10 20</code></strong></p>
<pre><code class="language-fsharp">let callExpr = App("add", [Int 10; Int 20])
</code></pre>
<p><strong>구성 요소:</strong></p>
<ul>
<li>함수 이름: <code>"add"</code></li>
<li>인자 리스트: <code>[Int 10; Int 20]</code></li>
</ul>
<p><strong>예시: <code>square 5</code></strong></p>
<pre><code class="language-fsharp">let squareCall = App("square", [Int 5])
</code></pre>
<p><strong>예시: 중첩 호출 <code>add (square 3) (square 4)</code></strong></p>
<pre><code class="language-fsharp">let nestedCall =
    App("add", [
        App("square", [Int 3]);
        App("square", [Int 4])
    ])
</code></pre>
<p><strong>해석:</strong></p>
<ul>
<li><code>square 3</code> → 9</li>
<li><code>square 4</code> → 16</li>
<li><code>add 9 16</code> → 25</li>
</ul>
<h3 id="program-프로그램-구조"><a class="header" href="#program-프로그램-구조">Program: 프로그램 구조</a></h3>
<p>지금까지는 FunLang 프로그램이 단일 표현식이었다. 이제 <strong>여러 함수 정의 + main 표현식</strong>으로 구성된다.</p>
<p><strong>F# 정의:</strong></p>
<pre><code class="language-fsharp">type Program = {
    functions: FunDef list                    // 함수 정의 리스트
    main: Expr                                // Main 표현식
}
</code></pre>
<p><strong>예시 프로그램:</strong></p>
<pre><code class="language-fsharp">// FunLang 소스:
// let add x y = x + y
// let square x = x * x
// square (add 3 4)

let program = {
    functions = [
        { name = "add"
          parameters = ["x"; "y"]
          body = BinOp(Var "x", Add, Var "y") };
        { name = "square"
          parameters = ["x"]
          body = BinOp(Var "x", Mul, Var "x") }
    ]
    main = App("square", [App("add", [Int 3; Int 4])])
}
</code></pre>
<p><strong>실행:</strong></p>
<ol>
<li><code>add 3 4</code> → 7</li>
<li><code>square 7</code> → 49</li>
<li>최종 결과: 49</li>
</ol>
<p><strong>프로그램 구조 시각화:</strong></p>
<pre><code>Program
├── functions
│   ├── FunDef("add", ["x", "y"], x + y)
│   └── FunDef("square", ["x"], x * x)
└── main
    └── App("square", [App("add", [3, 4])])
</code></pre>
<h3 id="lambda는-어디에"><a class="header" href="#lambda는-어디에">Lambda는 어디에?</a></h3>
<p>함수형 언어의 핵심 기능인 **lambda (익명 함수)**는 어디에 있는가?</p>
<p><strong>Phase 3 범위: 최상위 명명된 함수만</strong></p>
<ul>
<li><code>let f x = ...</code> (함수 정의)</li>
<li><code>f 10</code> (함수 호출)</li>
</ul>
<p><strong>Phase 4에서 추가: Lambda와 클로저</strong></p>
<ul>
<li><code>fun x -&gt; x + 1</code> (익명 함수)</li>
<li><code>let makeAdder n = fun x -&gt; x + n</code> (클로저, 외부 변수 캡처)</li>
<li>함수를 값으로 전달 (고차 함수)</li>
</ul>
<p>Phase 3 함수는 <strong>정적</strong>이다:</p>
<ul>
<li>컴파일 타임에 모든 함수가 알려진다</li>
<li>함수 이름은 고정된 심볼이다</li>
<li>외부 환경을 캡처하지 않는다</li>
</ul>
<p>Phase 4 클로저는 <strong>동적</strong>이다:</p>
<ul>
<li>런타임에 클로저가 생성된다</li>
<li>클로저는 값처럼 전달된다</li>
<li>외부 환경을 캡처하고 유지한다</li>
</ul>
<p>Phase 3은 함수의 <strong>기초</strong>를 다진다. Phase 4는 그 위에 클로저를 추가한다.</p>
<h2 id="pinvoke-바인딩-func-다이얼렉트"><a class="header" href="#pinvoke-바인딩-func-다이얼렉트">P/Invoke 바인딩: func 다이얼렉트</a></h2>
<p>MLIR의 func 다이얼렉트 연산을 사용하려면 C API 바인딩이 필요하다. 이미 Phase 1에서 기본 바인딩을 작성했으므로, func 관련 함수를 추가한다.</p>
<h3 id="function-type-api"><a class="header" href="#function-type-api">Function Type API</a></h3>
<p>MLIR에서 함수는 <strong>function type</strong>을 가진다. Function type은 파라미터 타입과 반환 타입을 표현한다.</p>
<p><strong>Function type 생성:</strong></p>
<pre><code class="language-c">// C API
MlirType mlirFunctionTypeGet(
    MlirContext ctx,
    intptr_t numInputs,
    MlirType const *inputs,
    intptr_t numResults,
    MlirType const *results
);
</code></pre>
<p><strong>파라미터:</strong></p>
<ul>
<li><code>ctx</code>: MLIR context</li>
<li><code>numInputs</code>: 파라미터 개수</li>
<li><code>inputs</code>: 파라미터 타입 배열</li>
<li><code>numResults</code>: 반환 값 개수 (보통 0 또는 1)</li>
<li><code>results</code>: 반환 타입 배열</li>
</ul>
<p><strong>예시: <code>(i32, i32) -&gt; i32</code> 타입</strong></p>
<pre><code class="language-c">MlirType i32Type = mlirIntegerTypeGet(ctx, 32);
MlirType paramTypes[] = { i32Type, i32Type };  // 두 개의 i32 파라미터
MlirType resultTypes[] = { i32Type };          // 하나의 i32 반환값

MlirType funcType = mlirFunctionTypeGet(
    ctx,
    2, paramTypes,   // 2개 파라미터
    1, resultTypes   // 1개 반환값
);
</code></pre>
<p><strong>Function type 쿼리:</strong></p>
<pre><code class="language-c">// 파라미터 개수 가져오기
intptr_t mlirFunctionTypeGetNumInputs(MlirType type);

// 반환 값 개수 가져오기
intptr_t mlirFunctionTypeGetNumResults(MlirType type);

// N번째 파라미터 타입 가져오기
MlirType mlirFunctionTypeGetInput(MlirType type, intptr_t pos);

// N번째 반환 타입 가져오기
MlirType mlirFunctionTypeGetResult(MlirType type, intptr_t pos);
</code></pre>
<p><strong>F# P/Invoke 바인딩:</strong></p>
<pre><code class="language-fsharp">// MlirBindings.fs에 추가

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirType mlirFunctionTypeGet(
    MlirContext ctx,
    nativeint numInputs,
    [&lt;MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1s)&gt;] MlirType[] inputs,
    nativeint numResults,
    [&lt;MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3s)&gt;] MlirType[] results
)

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern nativeint mlirFunctionTypeGetNumInputs(MlirType funcType)

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern nativeint mlirFunctionTypeGetNumResults(MlirType funcType)

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirType mlirFunctionTypeGetInput(MlirType funcType, nativeint pos)

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirType mlirFunctionTypeGetResult(MlirType funcType, nativeint pos)
</code></pre>
<p><strong>사용 예시:</strong></p>
<pre><code class="language-fsharp">// (i32, i32) -&gt; i32 타입 생성
let i32Type = mlirIntegerTypeGet(ctx, 32u)
let paramTypes = [| i32Type; i32Type |]
let resultTypes = [| i32Type |]

let funcType = mlirFunctionTypeGet(
    ctx,
    2n, paramTypes,
    1n, resultTypes
)

// 타입 쿼리
let numParams = mlirFunctionTypeGetNumInputs(funcType)  // 2
let param0Type = mlirFunctionTypeGetInput(funcType, 0n)  // i32
</code></pre>
<h3 id="symbol-reference-attribute"><a class="header" href="#symbol-reference-attribute">Symbol Reference Attribute</a></h3>
<p>함수 호출 시 <strong>symbol reference</strong>가 필요하다. 심볼 참조는 <code>@function_name</code> 형태로, attribute로 표현된다.</p>
<p><strong>C API:</strong></p>
<pre><code class="language-c">// Flat symbol reference (단일 심볼)
MlirAttribute mlirFlatSymbolRefAttrGet(
    MlirContext ctx,
    MlirStringRef symbol
);
</code></pre>
<p><strong>F# P/Invoke 바인딩:</strong></p>
<pre><code class="language-fsharp">[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirAttribute mlirFlatSymbolRefAttrGet(
    MlirContext ctx,
    MlirStringRef symbol
)
</code></pre>
<p><strong>사용 예시:</strong></p>
<pre><code class="language-fsharp">// @add 심볼 참조 생성
let addSymbol = MlirStringRef.FromString("add")
let addSymbolAttr = mlirFlatSymbolRefAttrGet(ctx, addSymbol)
</code></pre>
<h3 id="generic-operation-creation-for-funcfunc"><a class="header" href="#generic-operation-creation-for-funcfunc">Generic Operation Creation for func.func</a></h3>
<p>MLIR C API는 <code>func.func</code> 전용 생성 함수를 제공하지 않는다. 대신 <strong>generic operation creation</strong>을 사용한다.</p>
<p><strong>func.func 연산 생성 단계:</strong></p>
<ol>
<li>
<p><strong>Operation state 초기화</strong></p>
<pre><code class="language-c">MlirOperationState state = mlirOperationStateGet(
    mlirStringRefCreateFromCString("func.func"),
    location
);
</code></pre>
</li>
<li>
<p><strong>Attributes 추가 (sym_name, function_type)</strong></p>
<pre><code class="language-c">// sym_name: 함수 이름
MlirAttribute nameAttr = mlirStringAttrGet(ctx, nameStringRef);
MlirNamedAttribute symNameAttr = {
    mlirIdentifierGet(ctx, mlirStringRefCreateFromCString("sym_name")),
    nameAttr
};

// function_type: 함수 타입
MlirAttribute typeAttr = mlirTypeAttrGet(functionType);
MlirNamedAttribute funcTypeAttr = {
    mlirIdentifierGet(ctx, mlirStringRefCreateFromCString("function_type")),
    typeAttr
};

MlirNamedAttribute attrs[] = { symNameAttr, funcTypeAttr };
mlirOperationStateAddAttributes(&amp;state, 2, attrs);
</code></pre>
</li>
<li>
<p><strong>Region 추가 (함수 본체)</strong></p>
<pre><code class="language-c">MlirRegion bodyRegion = mlirRegionCreate();
MlirBlock entryBlock = mlirBlockCreate(numParams, paramTypes, NULL);
mlirRegionAppendOwnedBlock(bodyRegion, entryBlock);
mlirOperationStateAddOwnedRegions(&amp;state, 1, &amp;bodyRegion);
</code></pre>
</li>
<li>
<p><strong>Operation 생성</strong></p>
<pre><code class="language-c">MlirOperation funcOp = mlirOperationCreate(&amp;state);
</code></pre>
</li>
</ol>
<p><strong>F# 헬퍼 함수 (OpBuilder에 추가 예정):</strong></p>
<pre><code class="language-fsharp">// OpBuilder.fs에 추가할 메서드 (다음 섹션에서 구현)
member this.CreateFuncOp(name: string, paramTypes: MlirType[], resultType: MlirType) =
    // ... implementation ...
</code></pre>
<h3 id="generic-operation-creation-for-funccall"><a class="header" href="#generic-operation-creation-for-funccall">Generic Operation Creation for func.call</a></h3>
<p><strong>func.call 연산 생성 단계:</strong></p>
<ol>
<li>
<p><strong>Operation state 초기화</strong></p>
<pre><code class="language-c">MlirOperationState state = mlirOperationStateGet(
    mlirStringRefCreateFromCString("func.call"),
    location
);
</code></pre>
</li>
<li>
<p><strong>Callee attribute 추가</strong></p>
<pre><code class="language-c">MlirAttribute calleeAttr = mlirFlatSymbolRefAttrGet(ctx, calleeSymbol);
MlirNamedAttribute attr = {
    mlirIdentifierGet(ctx, mlirStringRefCreateFromCString("callee")),
    calleeAttr
};
mlirOperationStateAddAttributes(&amp;state, 1, &amp;attr);
</code></pre>
</li>
<li>
<p><strong>Operands 추가 (인자)</strong></p>
<pre><code class="language-c">mlirOperationStateAddOperands(&amp;state, numArgs, argValues);
</code></pre>
</li>
<li>
<p><strong>Result types 추가</strong></p>
<pre><code class="language-c">mlirOperationStateAddResults(&amp;state, 1, &amp;resultType);
</code></pre>
</li>
<li>
<p><strong>Operation 생성</strong></p>
<pre><code class="language-c">MlirOperation callOp = mlirOperationCreate(&amp;state);
</code></pre>
</li>
</ol>
<p><strong>F# 헬퍼 함수:</strong></p>
<pre><code class="language-fsharp">member this.CreateFuncCall(calleeName: string, args: MlirValue[], resultType: MlirType) =
    // ... implementation ...
</code></pre>
<h3 id="complete-mlirbindingsfs-additions"><a class="header" href="#complete-mlirbindingsfs-additions">Complete MlirBindings.fs Additions</a></h3>
<p><strong>전체 추가 코드 (MlirBindings.fs):</strong></p>
<pre><code class="language-fsharp">// ============================================================
// Function Type API
// ============================================================

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirType mlirFunctionTypeGet(
    MlirContext ctx,
    nativeint numInputs,
    [&lt;MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1s)&gt;] MlirType[] inputs,
    nativeint numResults,
    [&lt;MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3s)&gt;] MlirType[] results
)

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern nativeint mlirFunctionTypeGetNumInputs(MlirType funcType)

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern nativeint mlirFunctionTypeGetNumResults(MlirType funcType)

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirType mlirFunctionTypeGetInput(MlirType funcType, nativeint pos)

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirType mlirFunctionTypeGetResult(MlirType funcType, nativeint pos)

// ============================================================
// Symbol Reference Attribute
// ============================================================

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirAttribute mlirFlatSymbolRefAttrGet(
    MlirContext ctx,
    MlirStringRef symbol
)

// ============================================================
// Block Arguments (for function parameters)
// ============================================================

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirValue mlirBlockGetArgument(
    MlirBlock block,
    nativeint pos
)

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern nativeint mlirBlockGetNumArguments(MlirBlock block)
</code></pre>
<p><strong>설명:</strong></p>
<ul>
<li><code>mlirFunctionTypeGet</code>: 함수 타입 생성</li>
<li><code>mlirFunctionTypeGetInput/GetResult</code>: 함수 타입 쿼리</li>
<li><code>mlirFlatSymbolRefAttrGet</code>: 심볼 참조 attribute 생성</li>
<li><code>mlirBlockGetArgument</code>: 블록의 N번째 argument 가져오기 (함수 파라미터)</li>
<li><code>mlirBlockGetNumArguments</code>: 블록의 argument 개수 (파라미터 개수)</li>
</ul>
<p>이 바인딩으로 func 다이얼렉트의 모든 연산을 생성할 수 있다!</p>
<h2 id="opbuilder-확장-func-연산-헬퍼"><a class="header" href="#opbuilder-확장-func-연산-헬퍼">OpBuilder 확장: func 연산 헬퍼</a></h2>
<p>P/Invoke 바인딩은 저수준 API다. 사용하기 편리한 F# 헬퍼 메서드를 OpBuilder 클래스에 추가한다.</p>
<h3 id="createfuncop-함수-생성"><a class="header" href="#createfuncop-함수-생성">CreateFuncOp: 함수 생성</a></h3>
<p><strong>목적:</strong> func.func 연산을 생성한다. 함수 이름, 파라미터 타입, 반환 타입을 받아 함수 operation을 반환한다.</p>
<p><strong>시그니처:</strong></p>
<pre><code class="language-fsharp">member this.CreateFuncOp(
    name: string,
    paramTypes: MlirType[],
    resultType: MlirType
) : MlirOperation
</code></pre>
<p><strong>구현:</strong></p>
<pre><code class="language-fsharp">member this.CreateFuncOp(name: string, paramTypes: MlirType[], resultType: MlirType) =
    let loc = this.UnknownLoc()

    // 1. Function type 생성
    let resultTypes = [| resultType |]
    let funcType = mlirFunctionTypeGet(
        this.Context,
        nativeint paramTypes.Length, paramTypes,
        1n, resultTypes
    )

    // 2. Operation state 초기화
    let opName = MlirStringRef.FromString("func.func")
    let mutable state = mlirOperationStateGet(opName, loc)

    // 3. sym_name attribute 추가
    let nameStr = MlirStringRef.FromString(name)
    let nameAttr = mlirStringAttrGet(this.Context, nameStr)
    let symNameId = mlirIdentifierGet(this.Context, MlirStringRef.FromString("sym_name"))
    let mutable symNameAttr = MlirNamedAttribute(symNameId, nameAttr)

    // 4. function_type attribute 추가
    let typeAttr = mlirTypeAttrGet(funcType)
    let funcTypeId = mlirIdentifierGet(this.Context, MlirStringRef.FromString("function_type"))
    let mutable funcTypeAttr = MlirNamedAttribute(funcTypeId, typeAttr)

    // 5. Attributes 추가
    let attrs = [| symNameAttr; funcTypeAttr |]
    mlirOperationStateAddAttributes(&amp;state, 2n, attrs)

    // 6. Body region 생성 (entry block with parameters)
    let bodyRegion = mlirRegionCreate()
    let entryBlock = mlirBlockCreate(
        nativeint paramTypes.Length,
        paramTypes,
        Array.zeroCreate paramTypes.Length  // Location array (null array)
    )
    mlirRegionAppendOwnedBlock(bodyRegion, entryBlock)

    let regions = [| bodyRegion |]
    mlirOperationStateAddOwnedRegions(&amp;state, 1n, regions)

    // 7. Operation 생성
    let funcOp = mlirOperationCreate(&amp;state)
    funcOp
</code></pre>
<p><strong>사용 예시:</strong></p>
<pre><code class="language-fsharp">let builder = new OpBuilder(ctx, module)

// func.func @add(%arg0: i32, %arg1: i32) -&gt; i32
let funcOp = builder.CreateFuncOp(
    "add",
    [| i32Type; i32Type |],
    i32Type
)

// 이제 funcOp 내부에 body를 추가해야 한다
</code></pre>
<p><strong>핵심 포인트:</strong></p>
<ul>
<li><code>paramTypes</code>는 블록 arguments의 타입이 된다</li>
<li>Entry block이 자동으로 생성되고 region에 추가된다</li>
<li>반환된 <code>MlirOperation</code>은 아직 비어있는 함수 (body를 채워야 함)</li>
</ul>
<h3 id="getfunctionentryblock-entry-block-가져오기"><a class="header" href="#getfunctionentryblock-entry-block-가져오기">GetFunctionEntryBlock: entry block 가져오기</a></h3>
<p>함수 본체를 작성하려면 entry block을 가져와야 한다.</p>
<p><strong>시그니처:</strong></p>
<pre><code class="language-fsharp">member this.GetFunctionEntryBlock(funcOp: MlirOperation) : MlirBlock
</code></pre>
<p><strong>구현:</strong></p>
<pre><code class="language-fsharp">member this.GetFunctionEntryBlock(funcOp: MlirOperation) =
    // func.func operation은 region을 하나 가진다
    let bodyRegion = mlirOperationGetRegion(funcOp, 0n)
    // Region의 첫 번째 block이 entry block
    mlirRegionGetFirstBlock(bodyRegion)
</code></pre>
<p><strong>사용 예시:</strong></p>
<pre><code class="language-fsharp">let funcOp = builder.CreateFuncOp("add", [| i32Type; i32Type |], i32Type)
let entryBlock = builder.GetFunctionEntryBlock(funcOp)

// 이제 entryBlock에 연산을 추가할 수 있다
builder.SetInsertionPointToEnd(entryBlock)
</code></pre>
<h3 id="getfunctionblockarg-파라미터-가져오기"><a class="header" href="#getfunctionblockarg-파라미터-가져오기">GetFunctionBlockArg: 파라미터 가져오기</a></h3>
<p>함수 파라미터는 entry block의 <strong>block arguments</strong>로 표현된다. 파라미터를 사용하려면 block argument를 가져와야 한다.</p>
<p><strong>시그니처:</strong></p>
<pre><code class="language-fsharp">member this.GetFunctionBlockArg(block: MlirBlock, index: int) : MlirValue
</code></pre>
<p><strong>구현:</strong></p>
<pre><code class="language-fsharp">member this.GetFunctionBlockArg(block: MlirBlock, index: int) =
    mlirBlockGetArgument(block, nativeint index)
</code></pre>
<p><strong>사용 예시:</strong></p>
<pre><code class="language-fsharp">let funcOp = builder.CreateFuncOp("add", [| i32Type; i32Type |], i32Type)
let entryBlock = builder.GetFunctionEntryBlock(funcOp)

// 파라미터 가져오기
let arg0 = builder.GetFunctionBlockArg(entryBlock, 0)  // %arg0
let arg1 = builder.GetFunctionBlockArg(entryBlock, 1)  // %arg1

// 파라미터를 사용하여 연산 수행
builder.SetInsertionPointToEnd(entryBlock)
let sum = builder.CreateArithBinaryOp(ArithOp.Addi, arg0, arg1, i32Type)
</code></pre>
<h3 id="createfunccall-함수-호출-생성"><a class="header" href="#createfunccall-함수-호출-생성">CreateFuncCall: 함수 호출 생성</a></h3>
<p><strong>시그니처:</strong></p>
<pre><code class="language-fsharp">member this.CreateFuncCall(
    calleeName: string,
    args: MlirValue[],
    resultType: MlirType
) : MlirValue
</code></pre>
<p><strong>구현:</strong></p>
<pre><code class="language-fsharp">member this.CreateFuncCall(calleeName: string, args: MlirValue[], resultType: MlirType) =
    let loc = this.UnknownLoc()

    // 1. Operation state 초기화
    let opName = MlirStringRef.FromString("func.call")
    let mutable state = mlirOperationStateGet(opName, loc)

    // 2. callee attribute 추가
    let calleeSymbol = MlirStringRef.FromString(calleeName)
    let calleeAttr = mlirFlatSymbolRefAttrGet(this.Context, calleeSymbol)
    let calleeId = mlirIdentifierGet(this.Context, MlirStringRef.FromString("callee"))
    let mutable calleeNamedAttr = MlirNamedAttribute(calleeId, calleeAttr)

    mlirOperationStateAddAttributes(&amp;state, 1n, [| calleeNamedAttr |])

    // 3. Operands 추가
    mlirOperationStateAddOperands(&amp;state, nativeint args.Length, args)

    // 4. Result type 추가
    mlirOperationStateAddResults(&amp;state, 1n, [| resultType |])

    // 5. Operation 생성
    let callOp = mlirOperationCreate(&amp;state)

    // 6. 현재 insertion point에 추가
    mlirBlockAppendOwnedOperation(this.currentBlock, callOp)

    // 7. Result value 반환
    mlirOperationGetResult(callOp, 0n)
</code></pre>
<p><strong>사용 예시:</strong></p>
<pre><code class="language-fsharp">builder.SetInsertionPointToEnd(mainBlock)

// func.call @add(%c10, %c20) : (i32, i32) -&gt; i32
let c10 = builder.CreateConstant(10, i32Type)
let c20 = builder.CreateConstant(20, i32Type)
let result = builder.CreateFuncCall("add", [| c10; c20 |], i32Type)
</code></pre>
<h3 id="createfuncreturn-함수-반환"><a class="header" href="#createfuncreturn-함수-반환">CreateFuncReturn: 함수 반환</a></h3>
<p><strong>시그니처:</strong></p>
<pre><code class="language-fsharp">member this.CreateFuncReturn(value: MlirValue) : unit
</code></pre>
<p><strong>구현:</strong></p>
<pre><code class="language-fsharp">member this.CreateFuncReturn(value: MlirValue) =
    let loc = this.UnknownLoc()

    // 1. Operation state 초기화
    let opName = MlirStringRef.FromString("func.return")
    let mutable state = mlirOperationStateGet(opName, loc)

    // 2. Operand 추가 (반환 값)
    mlirOperationStateAddOperands(&amp;state, 1n, [| value |])

    // 3. Operation 생성
    let returnOp = mlirOperationCreate(&amp;state)

    // 4. 현재 insertion point에 추가
    mlirBlockAppendOwnedOperation(this.currentBlock, returnOp)
</code></pre>
<p><strong>사용 예시:</strong></p>
<pre><code class="language-fsharp">builder.SetInsertionPointToEnd(entryBlock)
let sum = builder.CreateArithBinaryOp(ArithOp.Addi, arg0, arg1, i32Type)
builder.CreateFuncReturn(sum)
</code></pre>
<h3 id="완전한-함수-생성-예시"><a class="header" href="#완전한-함수-생성-예시">완전한 함수 생성 예시</a></h3>
<p><strong>전체 흐름 (add 함수 생성):</strong></p>
<pre><code class="language-fsharp">let builder = new OpBuilder(ctx, module)
let i32Type = builder.I32Type()

// 1. 함수 operation 생성
let funcOp = builder.CreateFuncOp("add", [| i32Type; i32Type |], i32Type)

// 2. Entry block 가져오기
let entryBlock = builder.GetFunctionEntryBlock(funcOp)

// 3. 파라미터 가져오기
let arg0 = builder.GetFunctionBlockArg(entryBlock, 0)
let arg1 = builder.GetFunctionBlockArg(entryBlock, 1)

// 4. Insertion point 설정
builder.SetInsertionPointToEnd(entryBlock)

// 5. 함수 본체 작성
let sum = builder.CreateArithBinaryOp(ArithOp.Addi, arg0, arg1, i32Type)

// 6. 반환
builder.CreateFuncReturn(sum)

// 7. 모듈에 함수 추가
builder.AddOperationToModule(funcOp)
</code></pre>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">func.func @add(%arg0: i32, %arg1: i32) -&gt; i32 {
  %0 = arith.addi %arg0, %arg1 : i32
  func.return %0 : i32
}
</code></pre>
<p>이 헬퍼 메서드들로 func 다이얼렉트 연산을 쉽게 생성할 수 있다!</p>
<h2 id="함수-파라미터와-block-arguments"><a class="header" href="#함수-파라미터와-block-arguments">함수 파라미터와 Block Arguments</a></h2>
<p>함수 파라미터는 MLIR에서 <strong>block arguments</strong>로 표현된다. 이것은 MLIR의 핵심 설계 원칙이며, Chapter 08에서 배운 block arguments 개념의 확장이다.</p>
<h3 id="파라미터는-변수가-아니다"><a class="header" href="#파라미터는-변수가-아니다">파라미터는 변수가 아니다</a></h3>
<p>전통적인 프로그래밍 언어에서 함수 파라미터는 “변수“처럼 보인다:</p>
<pre><code class="language-c">// C 함수
int add(int x, int y) {
    return x + y;
}
</code></pre>
<p>하지만 MLIR에서 파라미터는 <strong>block arguments</strong>다:</p>
<pre><code class="language-mlir">func.func @add(%arg0: i32, %arg1: i32) -&gt; i32 {
  %result = arith.addi %arg0, %arg1 : i32
  func.return %result : i32
}
</code></pre>
<p><strong>차이점:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>관점</th><th>변수 (C/Java)</th><th>Block Arguments (MLIR)</th></tr>
</thead>
<tbody>
<tr><td>저장 위치</td><td>스택 메모리 (또는 레지스터)</td><td>SSA value (레지스터 직접 사용)</td></tr>
<tr><td>초기화</td><td>함수 진입 시 스택에 복사</td><td>블록 진입 시 이미 존재</td></tr>
<tr><td>뮤테이션</td><td>가능 (재할당 가능)</td><td>불가능 (SSA, 한 번만 정의)</td></tr>
<tr><td>주소</td><td>주소 가져오기 가능 (<code>&amp;x</code>)</td><td>주소 없음 (값 자체)</td></tr>
</tbody>
</table>
</div>
<p>MLIR에서 파라미터는 <strong>이미 존재하는 SSA value</strong>다. 함수가 호출되면, 인자 값들이 entry block의 arguments로 전달된다.</p>
<h3 id="block-arguments-복습-chapter-08-연결"><a class="header" href="#block-arguments-복습-chapter-08-연결">Block Arguments 복습 (Chapter 08 연결)</a></h3>
<p>Chapter 08에서 <code>scf.if</code>의 block arguments를 배웠다:</p>
<pre><code class="language-mlir">%result = scf.if %condition -&gt; (i32) {
  %c10 = arith.constant 10 : i32
  scf.yield %c10 : i32
} else {
  %c20 = arith.constant 20 : i32
  scf.yield %c20 : i32
}
// %result는 block argument (scf.if의 결과)
</code></pre>
<p>함수 파라미터도 동일한 메커니즘이다:</p>
<pre><code class="language-mlir">func.func @example(%arg0: i32) -&gt; i32 {
  // %arg0는 entry block의 argument
  func.return %arg0 : i32
}
</code></pre>
<p><strong>공통점:</strong></p>
<ul>
<li>둘 다 <strong>block arguments</strong>다</li>
<li>둘 다 SSA values다</li>
<li>둘 다 블록 진입 시 이미 정의되어 있다</li>
</ul>
<p><strong>차이점:</strong></p>
<ul>
<li><code>scf.if</code> block arguments: 분기의 결과 값 (yield로 전달)</li>
<li>함수 block arguments: 함수의 입력 값 (호출자가 전달)</li>
</ul>
<h3 id="entry-block과-파라미터"><a class="header" href="#entry-block과-파라미터">Entry Block과 파라미터</a></h3>
<p>함수의 entry block은 함수 정의 시 자동으로 생성된다. 파라미터 개수만큼 block arguments를 가진다.</p>
<p><strong>예시: 파라미터가 3개인 함수</strong></p>
<pre><code class="language-mlir">func.func @sum3(%arg0: i32, %arg1: i32, %arg2: i32) -&gt; i32 {
  // Entry block은 3개의 arguments를 가진다:
  // - %arg0 (첫 번째 파라미터)
  // - %arg1 (두 번째 파라미터)
  // - %arg2 (세 번째 파라미터)

  %sum01 = arith.addi %arg0, %arg1 : i32
  %sum012 = arith.addi %sum01, %arg2 : i32
  func.return %sum012 : i32
}
</code></pre>
<p><strong>MLIR IR 구조 시각화:</strong></p>
<pre><code>func.func @sum3(...) {
^entry(%arg0: i32, %arg1: i32, %arg2: i32):
    // %arg0, %arg1, %arg2는 block arguments
    %sum01 = arith.addi %arg0, %arg1
    %sum012 = arith.addi %sum01, %arg2
    func.return %sum012
}
</code></pre>
<p>Entry block의 arguments는 함수 시그니처의 파라미터와 1:1 대응된다.</p>
<h3 id="파라미터와-환경-environment"><a class="header" href="#파라미터와-환경-environment">파라미터와 환경 (Environment)</a></h3>
<p>Chapter 07에서 let 바인딩을 위한 **환경(environment)**을 구현했다:</p>
<pre><code class="language-fsharp">type Environment = Map&lt;string, MlirValue&gt;
</code></pre>
<p>함수 파라미터도 환경에 추가해야 한다. 하지만 let 바인딩과는 다른 방식으로 처리한다:</p>
<p><strong>Let 바인딩:</strong></p>
<ul>
<li>표현식을 컴파일하여 SSA value 생성</li>
<li>환경에 추가</li>
<li>본체 표현식 컴파일</li>
</ul>
<p><strong>함수 파라미터:</strong></p>
<ul>
<li>Block arguments로 이미 존재</li>
<li>환경에 추가 (이름 → block argument 매핑)</li>
<li>본체 표현식 컴파일</li>
</ul>
<p><strong>코드 비교:</strong></p>
<pre><code class="language-fsharp">// Let 바인딩 (Phase 2)
| Let(name, valueExpr, bodyExpr) -&gt;
    let value = compileExpr builder env valueExpr  // 표현식 컴파일
    let newEnv = Map.add name value env            // 환경 확장
    compileExpr builder newEnv bodyExpr

// 함수 파라미터 (Phase 3)
let compileFuncDef builder (funcDef: FunDef) =
    // ...
    let entryBlock = builder.GetFunctionEntryBlock(funcOp)

    // 파라미터를 환경에 추가
    let initialEnv =
        funcDef.parameters
        |&gt; List.mapi (fun i name -&gt;
            let arg = builder.GetFunctionBlockArg(entryBlock, i)
            (name, arg)
        )
        |&gt; Map.ofList

    // 본체 컴파일 (환경 전달)
    let bodyValue = compileExpr builder initialEnv funcDef.body
    builder.CreateFuncReturn(bodyValue)
</code></pre>
<p><strong>핵심 차이:</strong></p>
<ul>
<li>Let 바인딩: <code>compileExpr</code>로 value 생성</li>
<li>함수 파라미터: <code>GetFunctionBlockArg</code>로 기존 value 가져오기</li>
</ul>
<h3 id="예시-함수-본체에서-파라미터-사용"><a class="header" href="#예시-함수-본체에서-파라미터-사용">예시: 함수 본체에서 파라미터 사용</a></h3>
<p><strong>FunLang 소스:</strong></p>
<pre><code class="language-fsharp">let double x = x + x
</code></pre>
<p><strong>AST:</strong></p>
<pre><code class="language-fsharp">{
    name = "double"
    parameters = ["x"]
    body = BinOp(Var "x", Add, Var "x")
}
</code></pre>
<p><strong>컴파일 과정:</strong></p>
<ol>
<li>
<p><strong>함수 operation 생성</strong></p>
<pre><code class="language-fsharp">let funcOp = builder.CreateFuncOp("double", [| i32Type |], i32Type)
</code></pre>
</li>
<li>
<p><strong>Entry block 가져오기</strong></p>
<pre><code class="language-fsharp">let entryBlock = builder.GetFunctionEntryBlock(funcOp)
</code></pre>
</li>
<li>
<p><strong>파라미터를 환경에 추가</strong></p>
<pre><code class="language-fsharp">let arg0 = builder.GetFunctionBlockArg(entryBlock, 0)  // %arg0
let env = Map.ofList [("x", arg0)]
</code></pre>
</li>
<li>
<p><strong>본체 컴파일 (<code>x + x</code>)</strong></p>
<pre><code class="language-fsharp">builder.SetInsertionPointToEnd(entryBlock)

// BinOp(Var "x", Add, Var "x")
// Var "x" → 환경에서 조회 → %arg0
let lhs = env.["x"]  // %arg0
let rhs = env.["x"]  // %arg0
let sum = builder.CreateArithBinaryOp(ArithOp.Addi, lhs, rhs, i32Type)
</code></pre>
</li>
<li>
<p><strong>반환</strong></p>
<pre><code class="language-fsharp">builder.CreateFuncReturn(sum)
</code></pre>
</li>
</ol>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">func.func @double(%arg0: i32) -&gt; i32 {
  %0 = arith.addi %arg0, %arg0 : i32
  func.return %0 : i32
}
</code></pre>
<h3 id="let-바인딩-vs-함수-파라미터-구분"><a class="header" href="#let-바인딩-vs-함수-파라미터-구분">Let 바인딩 vs 함수 파라미터 구분</a></h3>
<p>함수 본체 내부에서 let 바인딩과 파라미터를 모두 사용할 수 있다:</p>
<p><strong>FunLang 소스:</strong></p>
<pre><code class="language-fsharp">let compute x y =
    let doubled = x + x in
    doubled + y
</code></pre>
<p><strong>환경 변화 추적:</strong></p>
<pre><code class="language-fsharp">// 1. 초기 환경 (파라미터만)
env = { "x" -&gt; %arg0, "y" -&gt; %arg1 }

// 2. Let 바인딩 처리
// let doubled = x + x
let doubledValue = arith.addi %arg0, %arg0
env = { "x" -&gt; %arg0, "y" -&gt; %arg1, "doubled" -&gt; %0 }

// 3. 본체 표현식 (doubled + y)
let result = arith.addi %0, %arg1
</code></pre>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">func.func @compute(%arg0: i32, %arg1: i32) -&gt; i32 {
  %doubled = arith.addi %arg0, %arg0 : i32   // let doubled = x + x
  %result = arith.addi %doubled, %arg1 : i32 // doubled + y
  func.return %result : i32
}
</code></pre>
<p><strong>결론:</strong> 파라미터와 let 바인딩 모두 <strong>환경을 통해 관리</strong>된다. 차이점은 value의 출처뿐이다 (block argument vs 컴파일된 표현식).</p>
<h2 id="코드-생성-함수-정의"><a class="header" href="#코드-생성-함수-정의">코드 생성: 함수 정의</a></h2>
<p>이제 FunLang 함수 정의 (FunDef)를 MLIR func.func 연산으로 컴파일하는 <code>compileFuncDef</code> 함수를 작성한다.</p>
<h3 id="compilefuncdef-시그니처"><a class="header" href="#compilefuncdef-시그니처">compileFuncDef 시그니처</a></h3>
<pre><code class="language-fsharp">let compileFuncDef (builder: OpBuilder) (funcDef: FunDef) : unit =
    // ...
</code></pre>
<p><strong>입력:</strong></p>
<ul>
<li><code>builder</code>: OpBuilder (MLIR IR 생성 도구)</li>
<li><code>funcDef</code>: FunDef (FunLang 함수 정의)</li>
</ul>
<p><strong>출력:</strong></p>
<ul>
<li><code>unit</code> (모듈에 함수를 추가하는 부수 효과)</li>
</ul>
<h3 id="단계별-구현"><a class="header" href="#단계별-구현">단계별 구현</a></h3>
<p><strong>Step 1: 타입 준비</strong></p>
<p>파라미터 타입과 반환 타입을 준비한다. Phase 3에서는 모든 값이 i32다.</p>
<pre><code class="language-fsharp">let i32Type = builder.I32Type()
let paramTypes = Array.create funcDef.parameters.Length i32Type
let resultType = i32Type
</code></pre>
<p><strong>Step 2: 함수 operation 생성</strong></p>
<pre><code class="language-fsharp">let funcOp = builder.CreateFuncOp(funcDef.name, paramTypes, resultType)
</code></pre>
<p><strong>Step 3: Entry block 가져오기</strong></p>
<pre><code class="language-fsharp">let entryBlock = builder.GetFunctionEntryBlock(funcOp)
</code></pre>
<p><strong>Step 4: 초기 환경 구축 (파라미터 → block arguments)</strong></p>
<pre><code class="language-fsharp">let initialEnv =
    funcDef.parameters
    |&gt; List.mapi (fun i paramName -&gt;
        let arg = builder.GetFunctionBlockArg(entryBlock, i)
        (paramName, arg)
    )
    |&gt; Map.ofList
</code></pre>
<p><strong>Step 5: Insertion point 설정</strong></p>
<pre><code class="language-fsharp">builder.SetInsertionPointToEnd(entryBlock)
</code></pre>
<p><strong>Step 6: 본체 표현식 컴파일</strong></p>
<pre><code class="language-fsharp">let bodyValue = compileExpr builder initialEnv funcDef.body
</code></pre>
<p><code>compileExpr</code>는 Phase 2에서 작성한 함수다. 환경을 받아서 표현식을 컴파일한다.</p>
<p><strong>Step 7: func.return 삽입</strong></p>
<pre><code class="language-fsharp">builder.CreateFuncReturn(bodyValue)
</code></pre>
<p><strong>Step 8: 모듈에 함수 추가</strong></p>
<pre><code class="language-fsharp">builder.AddOperationToModule(funcOp)
</code></pre>
<h3 id="완전한-compilefuncdef-구현"><a class="header" href="#완전한-compilefuncdef-구현">완전한 compileFuncDef 구현</a></h3>
<pre><code class="language-fsharp">let compileFuncDef (builder: OpBuilder) (funcDef: FunDef) : unit =
    // 1. 타입 준비
    let i32Type = builder.I32Type()
    let paramTypes = Array.create funcDef.parameters.Length i32Type
    let resultType = i32Type

    // 2. 함수 operation 생성
    let funcOp = builder.CreateFuncOp(funcDef.name, paramTypes, resultType)

    // 3. Entry block 가져오기
    let entryBlock = builder.GetFunctionEntryBlock(funcOp)

    // 4. 초기 환경 구축 (파라미터 → block arguments)
    let initialEnv =
        funcDef.parameters
        |&gt; List.mapi (fun i paramName -&gt;
            let arg = builder.GetFunctionBlockArg(entryBlock, i)
            (paramName, arg)
        )
        |&gt; Map.ofList

    // 5. Insertion point 설정
    builder.SetInsertionPointToEnd(entryBlock)

    // 6. 본체 표현식 컴파일
    let bodyValue = compileExpr builder initialEnv funcDef.body

    // 7. func.return 삽입
    builder.CreateFuncReturn(bodyValue)

    // 8. 모듈에 함수 추가
    builder.AddOperationToModule(funcOp)
</code></pre>
<h3 id="예시-let-double-x--x--x"><a class="header" href="#예시-let-double-x--x--x">예시: let double x = x + x</a></h3>
<p><strong>FunDef:</strong></p>
<pre><code class="language-fsharp">{
    name = "double"
    parameters = ["x"]
    body = BinOp(Var "x", Add, Var "x")
}
</code></pre>
<p><strong>compileFuncDef 실행 과정:</strong></p>
<ol>
<li><code>paramTypes = [| i32Type |]</code>, <code>resultType = i32Type</code></li>
<li><code>funcOp = CreateFuncOp("double", [| i32 |], i32)</code></li>
<li><code>entryBlock = GetFunctionEntryBlock(funcOp)</code></li>
<li><code>arg0 = GetFunctionBlockArg(entryBlock, 0)</code>, <code>env = { "x" -&gt; %arg0 }</code></li>
<li><code>SetInsertionPointToEnd(entryBlock)</code></li>
<li><code>bodyValue = compileExpr builder env (BinOp(Var "x", Add, Var "x"))</code>
<ul>
<li><code>Var "x"</code> → <code>env.["x"]</code> → <code>%arg0</code></li>
<li><code>arith.addi %arg0, %arg0</code></li>
</ul>
</li>
<li><code>CreateFuncReturn(bodyValue)</code></li>
<li><code>AddOperationToModule(funcOp)</code></li>
</ol>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">func.func @double(%arg0: i32) -&gt; i32 {
  %0 = arith.addi %arg0, %arg0 : i32
  func.return %0 : i32
}
</code></pre>
<h3 id="예시-let-add-x-y--x--y"><a class="header" href="#예시-let-add-x-y--x--y">예시: let add x y = x + y</a></h3>
<p><strong>FunDef:</strong></p>
<pre><code class="language-fsharp">{
    name = "add"
    parameters = ["x"; "y"]
    body = BinOp(Var "x", Add, Var "y")
}
</code></pre>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">func.func @add(%arg0: i32, %arg1: i32) -&gt; i32 {
  %0 = arith.addi %arg0, %arg1 : i32
  func.return %0 : i32
}
</code></pre>
<h3 id="복잡한-예시-let-compute-x-y--x--x--y"><a class="header" href="#복잡한-예시-let-compute-x-y--x--x--y">복잡한 예시: let compute x y = (x + x) + y</a></h3>
<p><strong>FunDef:</strong></p>
<pre><code class="language-fsharp">{
    name = "compute"
    parameters = ["x"; "y"]
    body = BinOp(
        BinOp(Var "x", Add, Var "x"),
        Add,
        Var "y"
    )
}
</code></pre>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">func.func @compute(%arg0: i32, %arg1: i32) -&gt; i32 {
  %0 = arith.addi %arg0, %arg0 : i32      // x + x
  %1 = arith.addi %0, %arg1 : i32         // (x + x) + y
  func.return %1 : i32
}
</code></pre>
<p><code>compileExpr</code>가 재귀적으로 호출되어 중첩된 연산을 처리한다!</p>
<h2 id="코드-생성-함수-호출"><a class="header" href="#코드-생성-함수-호출">코드 생성: 함수 호출</a></h2>
<p>함수를 정의했으니 이제 호출할 수 있어야 한다. 함수 호출은 <code>App</code> 노드로 표현되며, <code>compileExpr</code>에 새로운 case를 추가한다.</p>
<h3 id="app-case-추가"><a class="header" href="#app-case-추가">App case 추가</a></h3>
<p><strong>compileExpr 확장:</strong></p>
<pre><code class="language-fsharp">let rec compileExpr (builder: OpBuilder) (env: Environment) (expr: Expr) : MlirValue =
    match expr with
    | Int n -&gt; builder.CreateConstant(n, builder.I32Type())
    | Bool b -&gt; builder.CreateConstant((if b then 1 else 0), builder.I1Type())
    | Var name -&gt;
        match Map.tryFind name env with
        | Some value -&gt; value
        | None -&gt; failwithf "Unbound variable: %s" name
    | BinOp(lhs, op, rhs) -&gt;
        let lhsValue = compileExpr builder env lhs
        let rhsValue = compileExpr builder env rhs
        builder.CreateArithBinaryOp(op, lhsValue, rhsValue, builder.I32Type())
    | Compare(lhs, op, rhs) -&gt;
        let lhsValue = compileExpr builder env lhs
        let rhsValue = compileExpr builder env rhs
        builder.CreateArithCompare(op, lhsValue, rhsValue)
    | Let(name, valueExpr, bodyExpr) -&gt;
        let value = compileExpr builder env valueExpr
        let newEnv = Map.add name value env
        compileExpr builder newEnv bodyExpr
    | If(condition, thenExpr, elseExpr) -&gt;
        let condValue = compileExpr builder env condition
        compileIfExpr builder env condValue thenExpr elseExpr
    | App(calleeName, argExprs) -&gt;                  // NEW: 함수 호출
        // Step 1: 인자 표현식들을 컴파일
        let argValues =
            argExprs
            |&gt; List.map (compileExpr builder env)
            |&gt; List.toArray

        // Step 2: 함수 호출 생성
        let resultType = builder.I32Type()
        builder.CreateFuncCall(calleeName, argValues, resultType)
</code></pre>
<h3 id="app-case-설명"><a class="header" href="#app-case-설명">App case 설명</a></h3>
<p><strong>Step 1: 인자 컴파일</strong></p>
<p>함수 호출 전에 모든 인자 표현식을 먼저 컴파일한다 (call-by-value 의미론).</p>
<pre><code class="language-fsharp">let argValues =
    argExprs
    |&gt; List.map (compileExpr builder env)
    |&gt; List.toArray
</code></pre>
<p><strong>예시:</strong></p>
<pre><code class="language-fsharp">// add (5 + 3) (10 * 2)
App("add", [
    BinOp(Int 5, Add, Int 3);
    BinOp(Int 10, Mul, Int 2)
])
</code></pre>
<p>인자 컴파일 결과:</p>
<ul>
<li><code>5 + 3</code> → <code>%0 = arith.addi ... (8)</code></li>
<li><code>10 * 2</code> → <code>%1 = arith.muli ... (20)</code></li>
<li><code>argValues = [| %0; %1 |]</code></li>
</ul>
<p><strong>Step 2: 함수 호출 생성</strong></p>
<pre><code class="language-fsharp">let resultType = builder.I32Type()
builder.CreateFuncCall(calleeName, argValues, resultType)
</code></pre>
<p><code>CreateFuncCall</code>이 <code>func.call</code> 연산을 생성하고 결과 SSA value를 반환한다.</p>
<h3 id="예시-double-5"><a class="header" href="#예시-double-5">예시: double 5</a></h3>
<p><strong>FunLang 표현식:</strong></p>
<pre><code class="language-fsharp">App("double", [Int 5])
</code></pre>
<p><strong>컴파일 과정:</strong></p>
<ol>
<li>인자 컴파일: <code>Int 5</code> → <code>%c5 = arith.constant 5 : i32</code></li>
<li>함수 호출: <code>CreateFuncCall("double", [| %c5 |], i32Type)</code></li>
</ol>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">%c5 = arith.constant 5 : i32
%0 = func.call @double(%c5) : (i32) -&gt; i32
</code></pre>
<h3 id="예시-add-10-20"><a class="header" href="#예시-add-10-20">예시: add 10 20</a></h3>
<p><strong>FunLang 표현식:</strong></p>
<pre><code class="language-fsharp">App("add", [Int 10; Int 20])
</code></pre>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">%c10 = arith.constant 10 : i32
%c20 = arith.constant 20 : i32
%0 = func.call @add(%c10, %c20) : (i32, i32) -&gt; i32
</code></pre>
<h3 id="중첩-호출-예시-double-add-3-4"><a class="header" href="#중첩-호출-예시-double-add-3-4">중첩 호출 예시: double (add 3 4)</a></h3>
<p><strong>FunLang 표현식:</strong></p>
<pre><code class="language-fsharp">App("double", [
    App("add", [Int 3; Int 4])
])
</code></pre>
<p><strong>컴파일 과정:</strong></p>
<ol>
<li>외부 호출의 인자 컴파일: <code>App("add", [Int 3; Int 4])</code>
<ul>
<li>내부 호출의 인자 컴파일: <code>Int 3</code> → <code>%c3</code>, <code>Int 4</code> → <code>%c4</code></li>
<li>내부 호출: <code>%inner = func.call @add(%c3, %c4)</code></li>
</ul>
</li>
<li>외부 호출: <code>%result = func.call @double(%inner)</code></li>
</ol>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">%c3 = arith.constant 3 : i32
%c4 = arith.constant 4 : i32
%inner = func.call @add(%c3, %c4) : (i32, i32) -&gt; i32
%result = func.call @double(%inner) : (i32) -&gt; i32
</code></pre>
<p>중첩 호출이 자연스럽게 처리된다!</p>
<h2 id="코드-생성-program-컴파일"><a class="header" href="#코드-생성-program-컴파일">코드 생성: Program 컴파일</a></h2>
<p>이제 전체 프로그램을 컴파일하는 <code>compileProgram</code> 함수를 작성한다. Program은 여러 함수 정의와 main 표현식으로 구성된다.</p>
<h3 id="compileprogram-시그니처"><a class="header" href="#compileprogram-시그니처">compileProgram 시그니처</a></h3>
<pre><code class="language-fsharp">let compileProgram (builder: OpBuilder) (program: Program) : unit =
    // ...
</code></pre>
<p><strong>입력:</strong></p>
<ul>
<li><code>builder</code>: OpBuilder</li>
<li><code>program</code>: Program (함수 정의 리스트 + main 표현식)</li>
</ul>
<p><strong>출력:</strong></p>
<ul>
<li><code>unit</code> (모듈에 함수들과 main을 추가)</li>
</ul>
<h3 id="단계별-구현-1"><a class="header" href="#단계별-구현-1">단계별 구현</a></h3>
<p><strong>Step 1: 모든 함수 정의 컴파일</strong></p>
<pre><code class="language-fsharp">// 함수 정의들을 모듈에 추가
program.functions
|&gt; List.iter (compileFuncDef builder)
</code></pre>
<p>각 FunDef를 <code>compileFuncDef</code>로 컴파일하여 모듈에 추가한다.</p>
<p><strong>Step 2: Main 함수 생성</strong></p>
<p>Main 표현식을 <code>@funlang_main</code> 함수로 컴파일한다. 이 함수가 프로그램의 진입점이 된다.</p>
<pre><code class="language-fsharp">// Main 함수 생성
let i32Type = builder.I32Type()
let mainFuncOp = builder.CreateFuncOp("funlang_main", [||], i32Type)
let mainBlock = builder.GetFunctionEntryBlock(mainFuncOp)
builder.SetInsertionPointToEnd(mainBlock)

// Main 표현식 컴파일 (빈 환경)
let resultValue = compileExpr builder Map.empty program.main

// Main 반환
builder.CreateFuncReturn(resultValue)
builder.AddOperationToModule(mainFuncOp)
</code></pre>
<p><strong>Step 3 (선택적): C main 함수 생성</strong></p>
<p>실행 가능한 바이너리를 만들려면 C의 <code>main</code> 함수가 필요하다. <code>runtime.c</code>에서 제공한다 (Chapter 09 참조).</p>
<pre><code class="language-c">// runtime.c
int funlang_main();

int main() {
    return funlang_main();
}
</code></pre>
<h3 id="완전한-compileprogram-구현"><a class="header" href="#완전한-compileprogram-구현">완전한 compileProgram 구현</a></h3>
<pre><code class="language-fsharp">let compileProgram (builder: OpBuilder) (program: Program) : unit =
    // 1. 모든 함수 정의 컴파일
    program.functions
    |&gt; List.iter (compileFuncDef builder)

    // 2. Main 함수 생성 (프로그램 진입점)
    let i32Type = builder.I32Type()
    let mainFuncOp = builder.CreateFuncOp("funlang_main", [||], i32Type)
    let mainBlock = builder.GetFunctionEntryBlock(mainFuncOp)
    builder.SetInsertionPointToEnd(mainBlock)

    // 3. Main 표현식 컴파일 (빈 환경 - 함수 파라미터 없음)
    let resultValue = compileExpr builder Map.empty program.main

    // 4. Main 반환
    builder.CreateFuncReturn(resultValue)
    builder.AddOperationToModule(mainFuncOp)
</code></pre>
<h3 id="함수-정의-순서와-심볼-테이블"><a class="header" href="#함수-정의-순서와-심볼-테이블">함수 정의 순서와 심볼 테이블</a></h3>
<p><strong>중요한 특성:</strong> 함수 정의 순서는 중요하지 않다!</p>
<p>MLIR 모듈의 심볼 테이블은 flat namespace다. 모든 <code>func.func</code> 연산이 모듈 로드 시 등록되므로, 정의 순서와 무관하게 호출할 수 있다.</p>
<p><strong>예시:</strong></p>
<pre><code class="language-fsharp">// 함수 정의 순서
let program = {
    functions = [
        { name = "bar"; parameters = []; body = App("foo", []) };  // foo를 호출
        { name = "foo"; parameters = []; body = Int 42 }           // foo 정의
    ]
    main = App("bar", [])
}
</code></pre>
<p><code>bar</code>가 <code>foo</code>를 호출하지만, <code>foo</code>는 나중에 정의된다. MLIR에서는 문제없다:</p>
<pre><code class="language-mlir">func.func @bar() -&gt; i32 {
  %0 = func.call @foo() : () -&gt; i32  // 전방 참조
  func.return %0 : i32
}

func.func @foo() -&gt; i32 {
  %c42 = arith.constant 42 : i32
  func.return %c42 : i32
}
</code></pre>
<h3 id="모든-함수가-모든-함수를-볼-수-있다"><a class="header" href="#모든-함수가-모든-함수를-볼-수-있다">모든 함수가 모든 함수를 볼 수 있다</a></h3>
<p>Flat namespace 덕분에 상호 재귀도 가능하다 (Chapter 11에서 자세히 다룸).</p>
<pre><code class="language-mlir">func.func @is_even(%n: i32) -&gt; i1 {
  // ... calls @is_odd ...
}

func.func @is_odd(%n: i32) -&gt; i1 {
  // ... calls @is_even ...
}
</code></pre>
<p>정의 순서와 무관하게 모든 함수가 서로를 참조할 수 있다.</p>
<h2 id="완전한-예시-여러-함수와-main"><a class="header" href="#완전한-예시-여러-함수와-main">완전한 예시: 여러 함수와 Main</a></h2>
<p>이제 완전한 프로그램 예시를 보자.</p>
<h3 id="funlang-소스"><a class="header" href="#funlang-소스">FunLang 소스</a></h3>
<pre><code class="language-fsharp">let square x = x * x
let sumSquares a b = square a + square b
sumSquares 3 4
</code></pre>
<p><strong>의미:</strong></p>
<ul>
<li><code>square 3</code> → 9</li>
<li><code>square 4</code> → 16</li>
<li><code>9 + 16</code> → 25</li>
</ul>
<h3 id="ast-표현"><a class="header" href="#ast-표현">AST 표현</a></h3>
<pre><code class="language-fsharp">let program = {
    functions = [
        { name = "square"
          parameters = ["x"]
          body = BinOp(Var "x", Mul, Var "x") };

        { name = "sumSquares"
          parameters = ["a"; "b"]
          body = BinOp(
              App("square", [Var "a"]),
              Add,
              App("square", [Var "b"])
          ) }
    ]
    main = App("sumSquares", [Int 3; Int 4])
}
</code></pre>
<h3 id="컴파일-과정"><a class="header" href="#컴파일-과정">컴파일 과정</a></h3>
<p><strong>1. square 함수 컴파일</strong></p>
<pre><code class="language-fsharp">compileFuncDef builder { name = "square"; parameters = ["x"]; body = ... }
</code></pre>
<p>생성된 MLIR IR:</p>
<pre><code class="language-mlir">func.func @square(%arg0: i32) -&gt; i32 {
  %0 = arith.muli %arg0, %arg0 : i32
  func.return %0 : i32
}
</code></pre>
<p><strong>2. sumSquares 함수 컴파일</strong></p>
<pre><code class="language-fsharp">compileFuncDef builder { name = "sumSquares"; parameters = ["a"; "b"]; body = ... }
</code></pre>
<p>본체 컴파일:</p>
<ul>
<li><code>App("square", [Var "a"])</code> → <code>%0 = func.call @square(%arg0)</code></li>
<li><code>App("square", [Var "b"])</code> → <code>%1 = func.call @square(%arg1)</code></li>
<li><code>BinOp(..., Add, ...)</code> → <code>%2 = arith.addi %0, %1</code></li>
</ul>
<p>생성된 MLIR IR:</p>
<pre><code class="language-mlir">func.func @sumSquares(%arg0: i32, %arg1: i32) -&gt; i32 {
  %0 = func.call @square(%arg0) : (i32) -&gt; i32
  %1 = func.call @square(%arg1) : (i32) -&gt; i32
  %2 = arith.addi %0, %1 : i32
  func.return %2 : i32
}
</code></pre>
<p><strong>3. Main 함수 컴파일</strong></p>
<pre><code class="language-fsharp">// main = App("sumSquares", [Int 3; Int 4])
</code></pre>
<p>생성된 MLIR IR:</p>
<pre><code class="language-mlir">func.func @funlang_main() -&gt; i32 {
  %c3 = arith.constant 3 : i32
  %c4 = arith.constant 4 : i32
  %0 = func.call @sumSquares(%c3, %c4) : (i32, i32) -&gt; i32
  func.return %0 : i32
}
</code></pre>
<h3 id="완전한-mlir-모듈"><a class="header" href="#완전한-mlir-모듈">완전한 MLIR 모듈</a></h3>
<pre><code class="language-mlir">module {
  func.func @square(%arg0: i32) -&gt; i32 {
    %0 = arith.muli %arg0, %arg0 : i32
    func.return %0 : i32
  }

  func.func @sumSquares(%arg0: i32, %arg1: i32) -&gt; i32 {
    %0 = func.call @square(%arg0) : (i32) -&gt; i32
    %1 = func.call @square(%arg1) : (i32) -&gt; i32
    %2 = arith.addi %0, %1 : i32
    func.return %2 : i32
  }

  func.func @funlang_main() -&gt; i32 {
    %c3 = arith.constant 3 : i32
    %c4 = arith.constant 4 : i32
    %0 = func.call @sumSquares(%c3, %c4) : (i32, i32) -&gt; i32
    func.return %0 : i32
  }
}
</code></pre>
<h3 id="lowering-to-llvm-dialect"><a class="header" href="#lowering-to-llvm-dialect">Lowering to LLVM Dialect</a></h3>
<p>MLIR의 <code>--convert-func-to-llvm</code> 패스를 적용하면 LLVM 다이얼렉트로 변환된다:</p>
<pre><code class="language-bash">mlir-opt --convert-func-to-llvm \
         --convert-arith-to-llvm \
         --convert-scf-to-cf \
         --convert-cf-to-llvm \
         input.mlir -o lowered.mlir
</code></pre>
<p><strong>Lowered MLIR (LLVM dialect):</strong></p>
<pre><code class="language-mlir">module {
  llvm.func @square(%arg0: i32) -&gt; i32 {
    %0 = llvm.mul %arg0, %arg0 : i32
    llvm.return %0 : i32
  }

  llvm.func @sumSquares(%arg0: i32, %arg1: i32) -&gt; i32 {
    %0 = llvm.call @square(%arg0) : (i32) -&gt; i32
    %1 = llvm.call @square(%arg1) : (i32) -&gt; i32
    %2 = llvm.add %0, %1 : i32
    llvm.return %2 : i32
  }

  llvm.func @funlang_main() -&gt; i32 {
    %c3 = llvm.mlir.constant(3 : i32) : i32
    %c4 = llvm.mlir.constant(4 : i32) : i32
    %0 = llvm.call @sumSquares(%c3, %c4) : (i32, i32) -&gt; i32
    llvm.return %0 : i32
  }
}
</code></pre>
<p><code>func.*</code> 연산이 <code>llvm.*</code> 연산으로 변환되었다!</p>
<h3 id="llvm-ir-변환"><a class="header" href="#llvm-ir-변환">LLVM IR 변환</a></h3>
<pre><code class="language-bash">mlir-translate --mlir-to-llvmir lowered.mlir -o output.ll
</code></pre>
<p><strong>LLVM IR:</strong></p>
<pre><code class="language-llvm">define i32 @square(i32 %0) {
  %2 = mul i32 %0, %0
  ret i32 %2
}

define i32 @sumSquares(i32 %0, i32 %1) {
  %3 = call i32 @square(i32 %0)
  %4 = call i32 @square(i32 %1)
  %5 = add i32 %3, %4
  ret i32 %5
}

define i32 @funlang_main() {
  %1 = call i32 @sumSquares(i32 3, i32 4)
  ret i32 %1
}
</code></pre>
<h3 id="컴파일과-실행"><a class="header" href="#컴파일과-실행">컴파일과 실행</a></h3>
<pre><code class="language-bash"># LLVM IR을 object file로 컴파일
llc -filetype=obj output.ll -o funlang.o

# runtime.c와 링크
cc runtime.c funlang.o -o program

# 실행
./program
echo $?  # 25 (3*3 + 4*4)
</code></pre>
<p>프로그램이 실행되어 <code>25</code>를 반환한다!</p>
<h2 id="호출-규약-calling-convention"><a class="header" href="#호출-규약-calling-convention">호출 규약 (Calling Convention)</a></h2>
<p>함수 호출이 실제로 어떻게 동작하는지 이해하려면 **호출 규약(calling convention)**을 알아야 한다.</p>
<h3 id="호출-규약이란"><a class="header" href="#호출-규약이란">호출 규약이란?</a></h3>
<p><strong>호출 규약</strong>은 함수 호출 시 인자, 반환 값, 레지스터, 스택이 어떻게 관리되는지 정의하는 규칙이다.</p>
<p><strong>규약에 포함되는 내용:</strong></p>
<ol>
<li><strong>인자 전달 방법</strong>: 레지스터? 스택? 어떤 순서?</li>
<li><strong>반환 값 위치</strong>: 어느 레지스터에 반환 값을 넣는가?</li>
<li><strong>레지스터 보존</strong>: 어떤 레지스터는 호출 전후에 보존되어야 하는가?</li>
<li><strong>스택 프레임</strong>: 스택을 어떻게 정리하는가?</li>
</ol>
<h3 id="c-호출-규약-x86-64-system-v-abi"><a class="header" href="#c-호출-규약-x86-64-system-v-abi">C 호출 규약 (x86-64 System V ABI)</a></h3>
<p>MLIR/LLVM은 기본적으로 <strong>C 호출 규약</strong>을 사용한다. x86-64 Linux에서는 <strong>System V ABI</strong>다.</p>
<p><strong>인자 전달 (x86-64 System V ABI):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>인자 순서</th><th>정수/포인터</th><th>부동소수점</th></tr>
</thead>
<tbody>
<tr><td>1번째</td><td>RDI</td><td>XMM0</td></tr>
<tr><td>2번째</td><td>RSI</td><td>XMM1</td></tr>
<tr><td>3번째</td><td>RDX</td><td>XMM2</td></tr>
<tr><td>4번째</td><td>RCX</td><td>XMM3</td></tr>
<tr><td>5번째</td><td>R8</td><td>XMM4</td></tr>
<tr><td>6번째</td><td>R9</td><td>XMM5</td></tr>
<tr><td>7번째 이상</td><td>스택</td><td>스택</td></tr>
</tbody>
</table>
</div>
<p><strong>예시: <code>add(10, 20)</code> 호출</strong></p>
<pre><code class="language-asm">mov edi, 10      ; 첫 번째 인자 (RDI의 하위 32비트)
mov esi, 20      ; 두 번째 인자 (RSI의 하위 32비트)
call add         ; 함수 호출
; 반환 값은 EAX (RAX의 하위 32비트)에 저장됨
</code></pre>
<p><strong>반환 값:</strong></p>
<ul>
<li>정수/포인터: RAX (32비트 정수는 EAX)</li>
<li>부동소수점: XMM0</li>
</ul>
<p><strong>예시: <code>add</code> 함수 반환</strong></p>
<pre><code class="language-asm">add:
    mov eax, edi
    add eax, esi   ; eax = edi + esi
    ret            ; eax에 반환 값
</code></pre>
<h3 id="llvm이-호출-규약을-처리한다"><a class="header" href="#llvm이-호출-규약을-처리한다">LLVM이 호출 규약을 처리한다</a></h3>
<p><strong>핵심 통찰력:</strong> 우리는 호출 규약을 직접 구현하지 않는다. LLVM이 자동으로 처리한다!</p>
<p><strong>MLIR func 다이얼렉트 코드:</strong></p>
<pre><code class="language-mlir">func.func @add(%arg0: i32, %arg1: i32) -&gt; i32 {
  %0 = arith.addi %arg0, %arg1 : i32
  func.return %0 : i32
}
</code></pre>
<p><strong>LLVM이 생성하는 네이티브 코드 (x86-64):</strong></p>
<pre><code class="language-asm">add:
    ; 프롤로그 (스택 프레임 설정) - 단순 함수는 생략 가능
    lea eax, [rdi + rsi]  ; eax = edi + esi (최적화됨)
    ret
</code></pre>
<p>LLVM이 자동으로:</p>
<ol>
<li>파라미터를 적절한 레지스터에 배치 (EDI, ESI)</li>
<li>반환 값을 EAX에 배치</li>
<li>최적화 적용 (lea 사용)</li>
<li>에필로그 생략 (단순 함수)</li>
</ol>
<h3 id="플랫폼별-차이"><a class="header" href="#플랫폼별-차이">플랫폼별 차이</a></h3>
<p>호출 규약은 플랫폼마다 다르다:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>플랫폼</th><th>호출 규약</th><th>인자 전달</th></tr>
</thead>
<tbody>
<tr><td>Linux x86-64</td><td>System V ABI</td><td>RDI, RSI, RDX, RCX, R8, R9, 스택</td></tr>
<tr><td>Windows x86-64</td><td>Microsoft x64</td><td>RCX, RDX, R8, R9, 스택</td></tr>
<tr><td>ARM64</td><td>AAPCS64</td><td>X0-X7, 스택</td></tr>
<tr><td>x86-32</td><td>cdecl</td><td>스택 (오른쪽부터)</td></tr>
</tbody>
</table>
</div>
<p><strong>LLVM의 역할:</strong> 동일한 LLVM IR을 각 플랫폼에 맞게 변환한다. 우리는 신경 쓸 필요 없다!</p>
<h3 id="왜-c-호출-규약을-사용하는가"><a class="header" href="#왜-c-호출-규약을-사용하는가">왜 C 호출 규약을 사용하는가?</a></h3>
<p><strong>장점:</strong></p>
<ol>
<li><strong>C 라이브러리와 상호 운용</strong>: printf, malloc 같은 C 함수를 호출할 수 있다.</li>
<li><strong>시스템 콜 호환성</strong>: OS 시스템 콜이 C 규약을 따른다.</li>
<li><strong>디버거 지원</strong>: GDB 같은 디버거가 C 호출 규약을 이해한다.</li>
<li><strong>ABI 안정성</strong>: 표준 ABI로 다른 언어와 링크 가능.</li>
</ol>
<p><strong>단점 (Phase 3에서는 해당 없음):</strong></p>
<ul>
<li>Tail call optimization이 보장되지 않음 (Chapter 11에서 다룸)</li>
<li>클로저 전달이 비효율적일 수 있음 (Phase 4에서 다룸)</li>
</ul>
<p>Phase 3에서는 C 호출 규약이 완벽하게 작동한다. 단순한 값 전달과 반환만 있기 때문이다.</p>
<h3 id="스택-프레임-관리"><a class="header" href="#스택-프레임-관리">스택 프레임 관리</a></h3>
<p>함수 호출 시 **스택 프레임(stack frame)**이 생성된다.</p>
<p><strong>스택 프레임 구조 (x86-64):</strong></p>
<pre><code>High address
┌─────────────────┐
│ 인자 7, 8, ...  │  (레지스터에 들어가지 않는 인자들)
├─────────────────┤
│ 반환 주소       │  (call 명령어가 push)
├─────────────────┤
│ 이전 RBP        │  (함수 프롤로그가 push)
├─────────────────┤  ← RBP (base pointer)
│ 지역 변수       │
├─────────────────┤
│ 임시 값         │
└─────────────────┘  ← RSP (stack pointer)
Low address
</code></pre>
<p><strong>함수 프롤로그 (진입 시):</strong></p>
<pre><code class="language-asm">push rbp           ; 이전 프레임 포인터 저장
mov rbp, rsp       ; 새 프레임 포인터 설정
sub rsp, 32        ; 지역 변수를 위한 공간 할당
</code></pre>
<p><strong>함수 에필로그 (종료 시):</strong></p>
<pre><code class="language-asm">mov rsp, rbp       ; 스택 포인터 복원
pop rbp            ; 이전 프레임 포인터 복원
ret                ; 반환
</code></pre>
<p><strong>LLVM의 역할:</strong> 이 모든 것을 자동으로 생성한다. 우리는 <code>func.func</code>와 <code>func.return</code>만 작성하면 된다!</p>
<h3 id="tail-call-optimization-미리보기"><a class="header" href="#tail-call-optimization-미리보기">Tail Call Optimization (미리보기)</a></h3>
<p><strong>Tail call</strong>은 함수의 마지막 연산이 다른 함수 호출인 경우다:</p>
<pre><code class="language-fsharp">let factorial_tail n acc =
    if n &lt;= 1 then acc
    else factorial_tail (n - 1) (n * acc)  // Tail call!
</code></pre>
<p>일반 호출과 tail call의 차이:</p>
<p><strong>일반 호출 (스택 프레임 누적):</strong></p>
<pre><code>factorial_tail(5, 1)
  → factorial_tail(4, 5)
    → factorial_tail(3, 20)
      → factorial_tail(2, 60)
        → factorial_tail(1, 120)
          → 120
</code></pre>
<p>5개의 스택 프레임이 누적된다.</p>
<p><strong>Tail call optimization (스택 프레임 재사용):</strong></p>
<pre><code>factorial_tail(5, 1)
→ factorial_tail(4, 5)  (같은 프레임 재사용)
→ factorial_tail(3, 20)
→ factorial_tail(2, 60)
→ factorial_tail(1, 120)
→ 120
</code></pre>
<p>1개의 스택 프레임만 사용한다!</p>
<p><strong>Chapter 11에서 자세히 다룬다.</strong> Tail call optimization은 재귀 함수를 효율적으로 만드는 핵심 기술이다.</p>
<h2 id="일반적인-오류"><a class="header" href="#일반적인-오류">일반적인 오류</a></h2>
<p>함수를 처음 구현할 때 흔히 겪는 오류들을 살펴본다.</p>
<h3 id="오류-1-함수를-찾을-수-없음"><a class="header" href="#오류-1-함수를-찾을-수-없음">오류 1: 함수를 찾을 수 없음</a></h3>
<p><strong>증상:</strong></p>
<pre><code>error: 'func.call' op symbol reference '@foo' not found in symbol table
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>함수 이름 오타</li>
<li>함수가 정의되지 않음</li>
<li>함수를 모듈에 추가하지 않음</li>
</ul>
<p><strong>예시 (잘못된 코드):</strong></p>
<pre><code class="language-fsharp">// 'add' 함수를 정의했지만 'addd'로 호출
let program = {
    functions = [ { name = "add"; parameters = ["x"; "y"]; body = ... } ]
    main = App("addd", [Int 10; Int 20])  // 오타!
}
</code></pre>
<p><strong>해결 방법:</strong></p>
<ol>
<li><strong>함수 이름 확인</strong>: 정의와 호출 시 이름이 일치하는가?</li>
<li><strong>함수 정의 확인</strong>: <code>compileFuncDef</code>가 호출되었는가?</li>
<li><strong>모듈 추가 확인</strong>: <code>AddOperationToModule</code>이 호출되었는가?</li>
</ol>
<pre><code class="language-fsharp">// 올바른 코드
let program = {
    functions = [ { name = "add"; parameters = ["x"; "y"]; body = ... } ]
    main = App("add", [Int 10; Int 20])  // 일치!
}
</code></pre>
<h3 id="오류-2-인자-개수-불일치"><a class="header" href="#오류-2-인자-개수-불일치">오류 2: 인자 개수 불일치</a></h3>
<p><strong>증상:</strong></p>
<pre><code>error: 'func.call' op incorrect number of operands: expected 2 but got 1
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>함수 호출 시 인자 개수가 정의와 다름</li>
</ul>
<p><strong>예시 (잘못된 코드):</strong></p>
<pre><code class="language-fsharp">// add는 2개의 파라미터를 받는다
let addDef = { name = "add"; parameters = ["x"; "y"]; body = ... }

// 하지만 1개만 전달
let call = App("add", [Int 10])  // 오류!
</code></pre>
<p><strong>해결 방법:</strong></p>
<p>함수 정의의 파라미터 개수와 호출 시 인자 개수를 일치시킨다.</p>
<pre><code class="language-fsharp">// 올바른 코드
let call = App("add", [Int 10; Int 20])  // 2개 인자
</code></pre>
<p><strong>디버깅 팁:</strong></p>
<p>함수 시그니처를 확인하는 유틸리티를 추가한다:</p>
<pre><code class="language-fsharp">let checkFunctionArity (funcDef: FunDef) (argCount: int) =
    if argCount &lt;&gt; funcDef.parameters.Length then
        failwithf "Function %s expects %d arguments but got %d"
            funcDef.name
            funcDef.parameters.Length
            argCount
</code></pre>
<h3 id="오류-3-타입-불일치"><a class="header" href="#오류-3-타입-불일치">오류 3: 타입 불일치</a></h3>
<p><strong>증상:</strong></p>
<pre><code>error: 'func.call' op operand type mismatch: expected 'i32' but got 'i1'
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>함수 파라미터 타입과 인자 타입이 다름</li>
<li>Phase 3에서는 모든 값이 i32이므로 비교 결과(i1)를 함수에 전달할 때 발생</li>
</ul>
<p><strong>예시 (잘못된 코드):</strong></p>
<pre><code class="language-fsharp">// compute는 i32를 받는다
let computeDef = { name = "compute"; parameters = ["x"]; body = ... }

// 하지만 i1 (비교 결과)를 전달
let cond = Compare(Int 10, Gt, Int 5)  // i1 타입
let call = App("compute", [cond])      // 타입 불일치!
</code></pre>
<p><strong>해결 방법:</strong></p>
<p>Phase 3에서는 모든 함수 파라미터가 i32다. 비교 결과를 전달하려면 i1을 i32로 확장한다:</p>
<pre><code class="language-fsharp">// 비교 결과를 i32로 확장
let cond = Compare(Int 10, Gt, Int 5)  // i1
let condExtended = If(cond, Int 1, Int 0)  // i32
let call = App("compute", [condExtended])
</code></pre>
<p>또는 컴파일러가 자동으로 확장하도록 구현:</p>
<pre><code class="language-fsharp">let rec compileExpr builder env expr =
    match expr with
    | App(name, args) -&gt;
        let argValues =
            args
            |&gt; List.map (fun argExpr -&gt;
                let value = compileExpr builder env argExpr
                // i1 타입이면 i32로 확장
                if mlirTypeEqual (mlirValueGetType value) (builder.I1Type()) then
                    builder.CreateArithExtension(value, builder.I32Type())
                else
                    value
            )
            |&gt; List.toArray
        builder.CreateFuncCall(name, argValues, builder.I32Type())
</code></pre>
<h3 id="오류-4-funcreturn-누락"><a class="header" href="#오류-4-funcreturn-누락">오류 4: func.return 누락</a></h3>
<p><strong>증상:</strong></p>
<pre><code>error: 'func.func' op block must be terminated with a func.return operation
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>함수 본체가 종결자(terminator) 없이 끝남</li>
<li><code>func.return</code>을 추가하지 않음</li>
</ul>
<p><strong>예시 (잘못된 코드):</strong></p>
<pre><code class="language-fsharp">let compileFuncDef builder funcDef =
    let funcOp = builder.CreateFuncOp(...)
    let entryBlock = builder.GetFunctionEntryBlock(funcOp)
    builder.SetInsertionPointToEnd(entryBlock)

    // 본체 컴파일
    let bodyValue = compileExpr builder env funcDef.body

    // func.return 누락!
    builder.AddOperationToModule(funcOp)
</code></pre>
<p><strong>해결 방법:</strong></p>
<p>항상 <code>func.return</code>을 추가한다:</p>
<pre><code class="language-fsharp">let compileFuncDef builder funcDef =
    // ...
    let bodyValue = compileExpr builder env funcDef.body
    builder.CreateFuncReturn(bodyValue)  // 추가!
    builder.AddOperationToModule(funcOp)
</code></pre>
<h3 id="오류-5-파라미터와-let-바인딩-혼동"><a class="header" href="#오류-5-파라미터와-let-바인딩-혼동">오류 5: 파라미터와 let 바인딩 혼동</a></h3>
<p><strong>증상:</strong></p>
<pre><code>error: use of value '%arg0' requires an operation that dominates it
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>파라미터를 일반 변수처럼 처리함</li>
<li>환경에 파라미터를 추가하지 않음</li>
</ul>
<p><strong>예시 (잘못된 코드):</strong></p>
<pre><code class="language-fsharp">let compileFuncDef builder funcDef =
    // ...
    let entryBlock = builder.GetFunctionEntryBlock(funcOp)
    builder.SetInsertionPointToEnd(entryBlock)

    // 파라미터를 환경에 추가하지 않음!
    let env = Map.empty
    let bodyValue = compileExpr builder env funcDef.body  // Var "x"를 찾지 못함
</code></pre>
<p><strong>해결 방법:</strong></p>
<p>파라미터를 환경에 추가한다:</p>
<pre><code class="language-fsharp">let compileFuncDef builder funcDef =
    // ...
    let entryBlock = builder.GetFunctionEntryBlock(funcOp)

    // 파라미터를 환경에 추가
    let initialEnv =
        funcDef.parameters
        |&gt; List.mapi (fun i name -&gt;
            let arg = builder.GetFunctionBlockArg(entryBlock, i)
            (name, arg)
        )
        |&gt; Map.ofList

    builder.SetInsertionPointToEnd(entryBlock)
    let bodyValue = compileExpr builder initialEnv funcDef.body
    builder.CreateFuncReturn(bodyValue)
</code></pre>
<p><strong>핵심 원칙:</strong> 파라미터는 block arguments다. 환경에 추가하여 이름으로 참조할 수 있게 한다.</p>
<h2 id="장-요약-4"><a class="header" href="#장-요약-4">장 요약</a></h2>
<p>이 장에서 FunLang에 <strong>함수</strong>를 추가했다.</p>
<p><strong>배운 내용:</strong></p>
<ol>
<li>
<p><strong>MLIR func 다이얼렉트</strong></p>
<ul>
<li><code>func.func</code>: 함수 정의</li>
<li><code>func.call</code>: 함수 호출</li>
<li><code>func.return</code>: 함수 반환</li>
<li>모듈 레벨 심볼 테이블</li>
</ul>
</li>
<li>
<p><strong>AST 확장</strong></p>
<ul>
<li><code>FunDef</code>: 함수 정의 (이름, 파라미터, 본체)</li>
<li><code>App</code>: 함수 호출 (함수 이름, 인자 리스트)</li>
<li><code>Program</code>: 함수 정의 리스트 + main 표현식</li>
</ul>
</li>
<li>
<p><strong>P/Invoke 바인딩</strong></p>
<ul>
<li>Function type API (<code>mlirFunctionTypeGet</code>)</li>
<li>Symbol reference (<code>mlirFlatSymbolRefAttrGet</code>)</li>
<li>Block arguments (<code>mlirBlockGetArgument</code>)</li>
</ul>
</li>
<li>
<p><strong>OpBuilder 확장</strong></p>
<ul>
<li><code>CreateFuncOp</code>: 함수 생성</li>
<li><code>GetFunctionEntryBlock</code>: entry block 가져오기</li>
<li><code>GetFunctionBlockArg</code>: 파라미터 가져오기</li>
<li><code>CreateFuncCall</code>: 함수 호출</li>
<li><code>CreateFuncReturn</code>: 함수 반환</li>
</ul>
</li>
<li>
<p><strong>함수 파라미터와 Block Arguments</strong></p>
<ul>
<li>파라미터는 block arguments로 표현</li>
<li>Entry block의 arguments로 자동 생성</li>
<li>환경에 추가하여 이름으로 참조</li>
</ul>
</li>
<li>
<p><strong>코드 생성</strong></p>
<ul>
<li><code>compileFuncDef</code>: 함수 정의 컴파일</li>
<li><code>compileExpr</code>의 <code>App</code> case: 함수 호출 컴파일</li>
<li><code>compileProgram</code>: 전체 프로그램 컴파일</li>
</ul>
</li>
<li>
<p><strong>호출 규약 (Calling Convention)</strong></p>
<ul>
<li>C 호출 규약 (System V ABI)</li>
<li>인자 전달: 레지스터 → 스택</li>
<li>반환 값: RAX 레지스터</li>
<li>LLVM이 자동 처리</li>
</ul>
</li>
</ol>
<p><strong>독자가 할 수 있는 것:</strong></p>
<ul>
<li>다중 함수 정의를 포함한 FunLang 프로그램 작성</li>
<li>함수 호출과 중첩 호출 컴파일</li>
<li>생성된 MLIR IR 확인</li>
<li>네이티브 바이너리로 컴파일 및 실행</li>
</ul>
<p><strong>다음 단계 (Chapter 11):</strong></p>
<ul>
<li><strong>재귀(Recursion)</strong>: 함수가 자기 자신을 호출</li>
<li><strong>상호 재귀(Mutual Recursion)</strong>: 두 함수가 서로를 호출</li>
<li><strong>Tail Call Optimization</strong>: 재귀를 효율적으로 만들기</li>
</ul>
<p>함수는 코드 재사용과 모듈화의 핵심이다. Phase 3은 함수의 기초를 확립했다. 다음 장에서는 재귀로 함수의 표현력을 극대화한다!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-11-재귀-recursion"><a class="header" href="#chapter-11-재귀-recursion">Chapter 11: 재귀 (Recursion)</a></h1>
<h2 id="소개-11"><a class="header" href="#소개-11">소개</a></h2>
<p>함수형 프로그래밍에서 **재귀(recursion)**는 단순한 기법이 아니라 <strong>필수 도구</strong>다. 명령형 언어가 loop을 쓰는 곳에 함수형 언어는 재귀를 쓴다.</p>
<pre><code class="language-fsharp">// 명령형 스타일 (loop)
let sum_to n =
    let mutable result = 0
    for i in 1 to n do
        result &lt;- result + i
    result

// 함수형 스타일 (recursion)
let rec sum_to n =
    if n &lt;= 0 then 0
    else n + sum_to (n - 1)
</code></pre>
<p><strong>왜 재귀인가?</strong></p>
<p>순수 함수형 언어에는 mutable 변수가 없다. 값은 불변이고, 상태는 함수 파라미터를 통해 전달된다. Loop은 카운터 변수를 변경하는데, 이것은 mutation이다. 재귀는 mutation 없이 반복을 표현할 수 있다.</p>
<p>FunLang은 순수 함수형 언어다. Loop 구문이 없다. 모든 반복은 재귀로 표현된다.</p>
<p><strong>재귀의 본질: 자기 참조(Self-reference)</strong></p>
<p>재귀 함수는 <strong>자기 자신을 호출</strong>한다:</p>
<pre><code class="language-fsharp">let rec factorial n =
    if n &lt;= 1 then 1
    else n * factorial (n - 1)
           // ↑ 자기 자신을 호출!
</code></pre>
<p><code>factorial</code> 함수가 본체 내부에서 <code>factorial</code>을 호출한다. 이것이 가능하려면:</p>
<ul>
<li>함수 이름이 본체에서 보여야 한다 (scope 문제)</li>
<li>무한 재귀를 방지할 기저 사례(base case)가 필요하다</li>
</ul>
<p><strong>Chapter 11의 범위:</strong></p>
<p>이 장에서 다루는 것:</p>
<ol>
<li><strong>재귀 함수 (Recursive functions)</strong>: 자기 자신을 호출하는 함수 (factorial, fibonacci)</li>
<li><strong>상호 재귀 (Mutual recursion)</strong>: 두 함수가 서로를 호출 (is_even, is_odd)</li>
<li><strong>스택 프레임 (Stack frames)</strong>: 재귀 호출이 스택 메모리를 어떻게 사용하는가</li>
<li><strong>꼬리 호출 최적화 (Tail call optimization)</strong>: 스택 오버플로우를 방지하는 기법</li>
</ol>
<p>이 장을 마치면:</p>
<ul>
<li>factorial, fibonacci 같은 재귀 함수를 컴파일할 수 있다</li>
<li>상호 재귀가 모듈 레벨 심볼 테이블을 통해 작동하는 원리를 안다</li>
<li>스택 프레임이 어떻게 생성되고 소멸되는지 이해한다</li>
<li>꼬리 호출 최적화가 무엇이고 왜 중요한지 안다</li>
</ul>
<blockquote>
<p><strong>Preview:</strong> Phase 3 (Chapter 10-11)은 최상위 명명된 함수를 다룬다. Phase 4에서 클로저와 고차 함수를 추가할 것이다.</p>
</blockquote>
<h2 id="재귀가-mlir에서-작동하는-원리"><a class="header" href="#재귀가-mlir에서-작동하는-원리">재귀가 MLIR에서 작동하는 원리</a></h2>
<h3 id="모듈-레벨-심볼-테이블"><a class="header" href="#모듈-레벨-심볼-테이블">모듈 레벨 심볼 테이블</a></h3>
<p>Chapter 10에서 배운 것: MLIR 모듈은 <strong>flat symbol table</strong>을 가진다. 모든 <code>func.func</code> 연산이 모듈 레벨 심볼로 등록된다.</p>
<pre><code class="language-mlir">module {
  func.func @factorial(%n: i32) -&gt; i32 {
    // ...
  }

  func.func @fibonacci(%n: i32) -&gt; i32 {
    // ...
  }

  func.func @main() -&gt; i32 {
    // ...
  }
}
</code></pre>
<p><strong>핵심:</strong> 모든 함수가 서로에게 보인다. 정의 순서는 중요하지 않다.</p>
<ul>
<li><code>@factorial</code>은 <code>@fibonacci</code>를 호출할 수 있다</li>
<li><code>@fibonacci</code>는 <code>@factorial</code>을 호출할 수 있다</li>
<li><code>@factorial</code>은 <strong>자기 자신</strong>을 호출할 수 있다!</li>
</ul>
<p><strong>자기 참조 (Self-reference):</strong></p>
<pre><code class="language-mlir">func.func @factorial(%n: i32) -&gt; i32 {
  // ...
  %rec = func.call @factorial(%n_minus_1) : (i32) -&gt; i32
  //                 ↑ 자기 자신을 호출!
  // ...
}
</code></pre>
<p><code>@factorial</code> 함수가 내부에서 <code>func.call @factorial</code>을 실행한다. 이것은 **심볼 참조(symbol reference)**다:</p>
<ul>
<li><code>@factorial</code>이라는 심볼이 모듈에 존재하는가? <strong>예</strong> (자기 자신)</li>
<li>타입이 <code>(i32) -&gt; i32</code>가 맞는가? <strong>예</strong></li>
<li>호출 가능한가? <strong>예</strong></li>
</ul>
<p>MLIR verifier는 심볼 존재를 확인하지만, “자기 자신 호출“을 금지하지 않는다. 재귀가 자연스럽게 작동한다.</p>
<h3 id="interpreter-vs-compiler의-차이"><a class="header" href="#interpreter-vs-compiler의-차이">Interpreter vs Compiler의 차이</a></h3>
<p><strong>Interpreter에서 재귀 (LangTutorial FunLang):</strong></p>
<pre><code class="language-fsharp">// AST
LetRec("factorial",
       Lambda(["n"],
              If(BinOp(Var "n", Le, Num 1),
                 Num 1,
                 BinOp(Var "n",
                       Mul,
                       App(Var "factorial", [BinOp(Var "n", Sub, Num 1)])))))

// Interpreter evaluation
let rec eval env ast =
    match ast with
    | LetRec(name, Lambda(params, body), rest) -&gt;
        // 1. 재귀 환경 생성: env에 함수 자신을 추가
        let rec_env = env.Add(name, RecursiveClosure(params, body, rec_env))
        // 2. 본체 평가
        eval rec_env body
</code></pre>
<p>Interpreter는 **환경(environment)**에 함수를 바인딩한다. <code>LetRec</code>은 “재귀 바인딩“을 만든다 - 함수 본체가 평가되기 전에 환경에 자기 자신이 포함된다.</p>
<p><strong>Compiler에서 재귀 (FunLang MLIR):</strong></p>
<pre><code class="language-fsharp">// 컴파일
let compileFuncDef builder moduleDef (FunDef(name, params, body)) =
    // 1. 함수 생성 (func.func @name)
    let funcOp = builder.CreateFuncOp(name, paramTypes, returnType)

    // 2. 본체 컴파일
    let bodyValue = compileExpr builder env body

    // 3. 반환
    builder.CreateFuncReturn(bodyValue)

    // 4. 모듈에 추가
    moduleDef.AddFunction(funcOp)
</code></pre>
<p>Compiler는 <strong>심볼 테이블</strong>을 사용한다:</p>
<ul>
<li>함수가 <code>func.func</code> 연산으로 모듈에 추가되면, 심볼 <code>@name</code>이 등록된다</li>
<li>본체를 컴파일할 때 <code>func.call @name</code>을 만나면, 심볼 테이블에서 <code>@name</code>을 찾는다</li>
<li>심볼이 존재하므로 (자기 자신) 호출이 성공한다</li>
</ul>
<p><strong>차이점:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>측면</th><th>Interpreter</th><th>Compiler</th></tr>
</thead>
<tbody>
<tr><td>함수 저장</td><td>환경 (Map&lt;string, Value&gt;)</td><td>모듈 심볼 테이블</td></tr>
<tr><td>재귀 메커니즘</td><td>재귀 클로저 (self-reference in closure)</td><td>심볼 참조 (symbol reference)</td></tr>
<tr><td>평가 시점</td><td>런타임 (함수 호출할 때마다 환경 검색)</td><td>컴파일 타임 (심볼 확인) + 런타임 (call instruction)</td></tr>
<tr><td>Forward declaration</td><td>불필요 (LetRec이 재귀 환경 생성)</td><td>불필요 (모듈 레벨 심볼은 정의 순서 무관)</td></tr>
</tbody>
</table>
</div>
<p><strong>핵심:</strong> Interpreter는 환경을 사용하고, Compiler는 심볼을 사용한다. 둘 다 재귀를 지원하지만, 메커니즘이 다르다.</p>
<h3 id="컴파일-타임-심볼-확인"><a class="header" href="#컴파일-타임-심볼-확인">컴파일 타임 심볼 확인</a></h3>
<p>MLIR은 <strong>static symbol resolution</strong>을 수행한다:</p>
<pre><code class="language-mlir">// 잘못된 IR - verifier가 거부
func.func @foo(%n: i32) -&gt; i32 {
  %result = func.call @bar(%n) : (i32) -&gt; i32
  //                     ↑ @bar가 모듈에 없음!
  func.return %result : i32
}
</code></pre>
<p>MLIR verifier (<code>mlirOperationVerify</code>)는 심볼 참조를 검증한다:</p>
<ul>
<li><code>@bar</code> 심볼이 모듈에 존재하는가?</li>
<li>타입이 <code>(i32) -&gt; i32</code>와 호환되는가?</li>
</ul>
<p>검증 실패 시 에러:</p>
<pre><code>error: 'func.call' op 'bar' does not reference a valid function
</code></pre>
<p><strong>재귀 함수는 자연스럽게 통과:</strong></p>
<pre><code class="language-mlir">func.func @factorial(%n: i32) -&gt; i32 {
  // ...
  %rec = func.call @factorial(%n_minus_1) : (i32) -&gt; i32
  // ✓ @factorial은 모듈에 존재 (자기 자신)
  // ✓ 타입 (i32) -&gt; i32 일치
  // ...
}
</code></pre>
<p>Verifier는 심볼 존재만 확인한다. “자기 자신 호출“을 특별히 처리하지 않는다.</p>
<h3 id="mlir-ir-예시-factorial-자기-참조"><a class="header" href="#mlir-ir-예시-factorial-자기-참조">MLIR IR 예시: Factorial 자기 참조</a></h3>
<pre><code class="language-mlir">module {
  func.func @factorial(%arg0: i32) -&gt; i32 {
    %c1 = arith.constant 1 : i32
    %cmp = arith.cmpi sle, %arg0, %c1 : i32
    %result = scf.if %cmp -&gt; (i32) {
      scf.yield %c1 : i32
    } else {
      %n_minus_1 = arith.subi %arg0, %c1 : i32
      %rec = func.call @factorial(%n_minus_1) : (i32) -&gt; i32
      //                ↑ 자기 자신 호출
      %product = arith.muli %arg0, %rec : i32
      scf.yield %product : i32
    }
    func.return %result : i32
  }
}
</code></pre>
<p><strong>실행 시퀀스 (factorial 5):</strong></p>
<ol>
<li><code>@factorial</code>이 5로 호출됨</li>
<li>조건 확인: <code>5 &lt;= 1</code>? → false</li>
<li>else 블록 실행:
<ul>
<li><code>n_minus_1 = 5 - 1 = 4</code></li>
<li><code>rec = func.call @factorial(4)</code> ← <strong>재귀 호출</strong></li>
</ul>
</li>
<li>이제 <strong>새로운 스택 프레임</strong>에서 <code>@factorial(4)</code> 실행</li>
<li>조건 확인: <code>4 &lt;= 1</code>? → false</li>
<li>else 블록 실행:
<ul>
<li><code>n_minus_1 = 4 - 1 = 3</code></li>
<li><code>rec = func.call @factorial(3)</code> ← <strong>재귀 호출</strong></li>
</ul>
</li>
<li>… (계속)</li>
</ol>
<p>재귀 호출마다 새로운 스택 프레임이 생성된다. 각 프레임은 독립적인 <code>%arg0</code>, <code>%n_minus_1</code>, <code>%rec</code> 값을 가진다.</p>
<p><strong>핵심:</strong> 심볼 참조 <code>@factorial</code>은 컴파일 타임에 확인되고, 런타임에 <code>call</code> instruction으로 실행된다. LLVM이 스택 프레임 관리를 처리한다.</p>
<h2 id="재귀-함수-factorial"><a class="header" href="#재귀-함수-factorial">재귀 함수: Factorial</a></h2>
<h3 id="factorial-정의"><a class="header" href="#factorial-정의">Factorial 정의</a></h3>
<p><strong>수학적 정의:</strong></p>
<pre><code>factorial(n) = n! = n × (n-1) × (n-2) × ... × 2 × 1

예시:
  5! = 5 × 4 × 3 × 2 × 1 = 120
  3! = 3 × 2 × 1 = 6
  1! = 1
  0! = 1 (정의에 의해)
</code></pre>
<p><strong>재귀적 정의:</strong></p>
<pre><code>factorial(n) = {
  1                        if n &lt;= 1  (base case)
  n × factorial(n - 1)     if n &gt; 1   (recursive case)
}
</code></pre>
<p>기저 사례(base case): <code>n &lt;= 1</code>일 때 <code>1</code> 반환. 재귀 종료 조건.
재귀 사례(recursive case): <code>n × factorial(n - 1)</code>. 자기 자신을 더 작은 입력으로 호출.</p>
<p><strong>FunLang 소스:</strong></p>
<pre><code class="language-fsharp">let rec factorial n =
    if n &lt;= 1 then 1
    else n * factorial (n - 1)
</code></pre>
<h3 id="ast-표현-1"><a class="header" href="#ast-표현-1">AST 표현</a></h3>
<p>Chapter 10에서 정의한 AST:</p>
<pre><code class="language-fsharp">type Expr =
    | Num of int
    | Var of string
    | BinOp of Expr * Operator * Expr
    | If of Expr * Expr * Expr
    | Let of string * Expr * Expr
    | App of string * Expr list    // 함수 호출

type FunDef =
    | FunDef of string * string list * Expr

type Program =
    | Program of FunDef list * Expr
</code></pre>
<p><strong>factorial의 AST:</strong></p>
<pre><code class="language-fsharp">FunDef("factorial",
       ["n"],
       If(BinOp(Var "n", Le, Num 1),
          Num 1,
          BinOp(Var "n",
                Mul,
                App("factorial", [BinOp(Var "n", Sub, Num 1)]))))
</code></pre>
<p><strong>주목할 점:</strong></p>
<ul>
<li><code>App("factorial", ...)</code>: 함수 호출. 자기 자신을 호출한다.</li>
<li>기존 AST로 충분하다. <code>LetRec</code> 같은 새로운 AST 노드가 필요 없다.</li>
<li><code>FunDef</code>는 이미 모듈 레벨 함수를 표현한다. 이름으로 자기 참조가 가능하다.</li>
</ul>
<h3 id="컴파일-전략"><a class="header" href="#컴파일-전략">컴파일 전략</a></h3>
<p><strong>Chapter 10의 compileFuncDef 재사용:</strong></p>
<pre><code class="language-fsharp">let compileFuncDef (builder: OpBuilder) (moduleDef: ModuleOp) (FunDef(name, params, body)) =
    // 1. 함수 타입 생성
    let paramTypes = List.replicate params.Length builder.GetI32Type()
    let returnType = builder.GetI32Type()
    let funcType = builder.GetFunctionType(paramTypes, returnType)

    // 2. func.func 생성
    let funcOp = builder.CreateFuncOp(name, funcType)

    // 3. Entry block 생성 및 파라미터 가져오기
    let entryBlock = funcOp.GetEntryBlock()
    builder.SetInsertionPointToEnd(entryBlock)

    // 4. 환경 구축: 파라미터를 환경에 추가
    let env =
        params
        |&gt; List.mapi (fun i paramName -&gt;
            let argValue = entryBlock.GetArgument(i)
            (paramName, argValue))
        |&gt; Map.ofList

    // 5. 본체 컴파일
    let bodyValue = compileExpr builder env body

    // 6. 반환
    builder.CreateFuncReturn(bodyValue)

    // 7. 모듈에 추가
    moduleDef.AddFunction(funcOp)
</code></pre>
<p><strong>재귀 호출 처리 (compileExpr의 App case):</strong></p>
<pre><code class="language-fsharp">let rec compileExpr (builder: OpBuilder) (env: Map&lt;string, MlirValue&gt;) (expr: Expr) =
    match expr with
    | App(funcName, args) -&gt;
        // 1. 인자 컴파일
        let argValues = args |&gt; List.map (compileExpr builder env)

        // 2. 함수 호출
        builder.CreateFuncCall(funcName, argValues)
    // ... other cases
</code></pre>
<p><strong>핵심:</strong></p>
<ul>
<li><code>App("factorial", [arg])</code>를 만나면 <code>CreateFuncCall("factorial", [argValue])</code></li>
<li><code>CreateFuncCall</code>은 <code>func.call @factorial(%arg) : (i32) -&gt; i32</code> 생성</li>
<li>심볼 <code>@factorial</code>이 모듈에 존재 (자기 자신)</li>
<li>재귀 호출 완료!</li>
</ul>
<p><strong>재귀 함수 컴파일에 특별한 처리가 필요 없다.</strong> 일반 함수 호출과 동일하게 처리된다.</p>
<h3 id="완전한-mlir-ir-출력"><a class="header" href="#완전한-mlir-ir-출력">완전한 MLIR IR 출력</a></h3>
<pre><code class="language-mlir">module {
  func.func @factorial(%arg0: i32) -&gt; i32 {
    // if n &lt;= 1
    %c1 = arith.constant 1 : i32
    %cmp = arith.cmpi sle, %arg0, %c1 : i32

    // scf.if with two branches
    %result = scf.if %cmp -&gt; (i32) {
      // then: return 1
      scf.yield %c1 : i32
    } else {
      // else: return n * factorial(n - 1)

      // n - 1
      %n_minus_1 = arith.subi %arg0, %c1 : i32

      // factorial(n - 1) - 재귀 호출!
      %rec = func.call @factorial(%n_minus_1) : (i32) -&gt; i32

      // n * factorial(n - 1)
      %product = arith.muli %arg0, %rec : i32

      scf.yield %product : i32
    }

    func.return %result : i32
  }
}
</code></pre>
<p><strong>구조:</strong></p>
<ol>
<li><strong>조건 평가:</strong> <code>%cmp = arith.cmpi sle, %arg0, %c1</code> (n &lt;= 1?)</li>
<li><strong>scf.if 분기:</strong>
<ul>
<li><strong>then 블록:</strong> <code>scf.yield %c1</code> (기저 사례: 1 반환)</li>
<li><strong>else 블록:</strong>
<ul>
<li><code>%n_minus_1 = arith.subi %arg0, %c1</code> (n - 1 계산)</li>
<li><code>%rec = func.call @factorial(%n_minus_1)</code> (<strong>재귀 호출</strong>)</li>
<li><code>%product = arith.muli %arg0, %rec</code> (n * 재귀 결과)</li>
<li><code>scf.yield %product</code> (재귀 사례: n * factorial(n-1))</li>
</ul>
</li>
</ul>
</li>
<li><strong>반환:</strong> <code>func.return %result</code></li>
</ol>
<h3 id="단계별-실행-추적"><a class="header" href="#단계별-실행-추적">단계별 실행 추적</a></h3>
<p><strong>factorial 5 실행 과정:</strong></p>
<pre><code>1. factorial(5) 호출
   ├─ 조건: 5 &lt;= 1? → false
   ├─ else 블록 진입
   ├─ n_minus_1 = 5 - 1 = 4
   ├─ factorial(4) 호출 ← 재귀
   │  ├─ 조건: 4 &lt;= 1? → false
   │  ├─ else 블록 진입
   │  ├─ n_minus_1 = 4 - 1 = 3
   │  ├─ factorial(3) 호출 ← 재귀
   │  │  ├─ 조건: 3 &lt;= 1? → false
   │  │  ├─ else 블록 진입
   │  │  ├─ n_minus_1 = 3 - 1 = 2
   │  │  ├─ factorial(2) 호출 ← 재귀
   │  │  │  ├─ 조건: 2 &lt;= 1? → false
   │  │  │  ├─ else 블록 진입
   │  │  │  ├─ n_minus_1 = 2 - 1 = 1
   │  │  │  ├─ factorial(1) 호출 ← 재귀
   │  │  │  │  ├─ 조건: 1 &lt;= 1? → true
   │  │  │  │  └─ then 블록: return 1 ← 기저 사례!
   │  │  │  ├─ rec = 1
   │  │  │  ├─ product = 2 * 1 = 2
   │  │  │  └─ return 2
   │  │  ├─ rec = 2
   │  │  ├─ product = 3 * 2 = 6
   │  │  └─ return 6
   │  ├─ rec = 6
   │  ├─ product = 4 * 6 = 24
   │  └─ return 24
   ├─ rec = 24
   ├─ product = 5 * 24 = 120
   └─ return 120

최종 결과: 120
</code></pre>
<p><strong>호출 깊이 (Call depth):</strong> 5</p>
<p>각 재귀 호출은 새로운 스택 프레임을 생성한다. <code>factorial(5)</code>는 5개의 스택 프레임을 사용한다.</p>
<h3 id="lowered-llvm-ir"><a class="header" href="#lowered-llvm-ir">Lowered LLVM IR</a></h3>
<p>MLIR IR을 LLVM IR로 변환하면 (<code>mlir-opt --convert-scf-to-cf --convert-func-to-llvm --convert-arith-to-llvm</code>):</p>
<pre><code class="language-llvm">define i32 @factorial(i32 %0) {
entry:
  %1 = icmp sle i32 %0, 1
  br i1 %1, label %then, label %else

then:
  br label %merge

else:
  %2 = sub i32 %0, 1
  %3 = call i32 @factorial(i32 %2)  ; 재귀 호출 (call instruction)
  %4 = mul i32 %0, %3
  br label %merge

merge:
  %5 = phi i32 [ 1, %then ], [ %4, %else ]
  ret i32 %5
}
</code></pre>
<p><strong>주목할 점:</strong></p>
<ul>
<li><code>call i32 @factorial(i32 %2)</code>: LLVM IR의 재귀 호출</li>
<li>각 호출은 스택 프레임을 생성한다 (LLVM runtime이 처리)</li>
<li>PHI 노드 (<code>phi i32 [ 1, %then ], [ %4, %else ]</code>)는 scf.if의 lowering 결과</li>
</ul>
<p><strong>Native 코드로 컴파일:</strong></p>
<pre><code class="language-bash">mlir-translate --mlir-to-llvmir factorial.mlir &gt; factorial.ll
llc -filetype=obj factorial.ll -o factorial.o
gcc -o factorial factorial.o runtime.o -lgc
./factorial
</code></pre>
<h2 id="재귀-함수-fibonacci"><a class="header" href="#재귀-함수-fibonacci">재귀 함수: Fibonacci</a></h2>
<h3 id="fibonacci-정의"><a class="header" href="#fibonacci-정의">Fibonacci 정의</a></h3>
<p><strong>수학적 정의:</strong></p>
<pre><code>fibonacci(n) = {
  n                                if n &lt;= 1  (base case)
  fibonacci(n-1) + fibonacci(n-2)  if n &gt; 1   (recursive case)
}

수열:
  fib(0) = 0
  fib(1) = 1
  fib(2) = fib(1) + fib(0) = 1 + 0 = 1
  fib(3) = fib(2) + fib(1) = 1 + 1 = 2
  fib(4) = fib(3) + fib(2) = 2 + 1 = 3
  fib(5) = fib(4) + fib(3) = 3 + 2 = 5
  fib(6) = fib(5) + fib(4) = 5 + 3 = 8
</code></pre>
<p><strong>FunLang 소스:</strong></p>
<pre><code class="language-fsharp">let rec fib n =
    if n &lt;= 1 then n
    else fib (n - 1) + fib (n - 2)
</code></pre>
<h3 id="double-recursion-패턴"><a class="header" href="#double-recursion-패턴">Double Recursion 패턴</a></h3>
<p>Factorial은 <strong>단일 재귀(single recursion)</strong>: 한 번만 자기 자신을 호출.
Fibonacci는 <strong>이중 재귀(double recursion)</strong>: 두 번 자기 자신을 호출.</p>
<pre><code class="language-fsharp">fib (n - 1) + fib (n - 2)
//  ↑             ↑
// 첫 번째 호출   두 번째 호출
</code></pre>
<p><strong>함의:</strong></p>
<ul>
<li>각 재귀 호출이 또 다른 두 개의 호출을 만든다</li>
<li>호출 트리가 <strong>지수적으로 증가</strong>한다</li>
</ul>
<p><strong>fib(5)의 호출 트리:</strong></p>
<pre><code>                    fib(5)
                   /      \
              fib(4)      fib(3)
             /     \      /     \
        fib(3)   fib(2) fib(2) fib(1)
        /   \    /   \  /   \
    fib(2) fib(1) fib(1) fib(0) fib(1) fib(0)
    /   \
fib(1) fib(0)
</code></pre>
<p><strong>호출 횟수:</strong> <code>fib(5)</code>를 계산하기 위해 15번의 함수 호출이 발생한다.</p>
<p><strong>시간 복잡도:</strong> O(2^n) - 지수 시간. <code>fib(30)</code> ≈ 20억 번 호출!</p>
<h3 id="컴파일-두-개의-funccall"><a class="header" href="#컴파일-두-개의-funccall">컴파일: 두 개의 func.call</a></h3>
<pre><code class="language-mlir">func.func @fib(%arg0: i32) -&gt; i32 {
  // if n &lt;= 1
  %c1 = arith.constant 1 : i32
  %cmp = arith.cmpi sle, %arg0, %c1 : i32

  %result = scf.if %cmp -&gt; (i32) {
    // then: return n
    scf.yield %arg0 : i32
  } else {
    // else: return fib(n-1) + fib(n-2)

    // n - 1
    %n_minus_1 = arith.subi %arg0, %c1 : i32

    // fib(n - 1) - 첫 번째 재귀 호출
    %fib_n_1 = func.call @fib(%n_minus_1) : (i32) -&gt; i32

    // n - 2
    %c2 = arith.constant 2 : i32
    %n_minus_2 = arith.subi %arg0, %c2 : i32

    // fib(n - 2) - 두 번째 재귀 호출
    %fib_n_2 = func.call @fib(%n_minus_2) : (i32) -&gt; i32

    // fib(n-1) + fib(n-2)
    %sum = arith.addi %fib_n_1, %fib_n_2 : i32

    scf.yield %sum : i32
  }

  func.return %result : i32
}
</code></pre>
<p><strong>구조:</strong></p>
<ul>
<li><strong>else 블록에서 두 번의 func.call:</strong>
<ul>
<li><code>%fib_n_1 = func.call @fib(%n_minus_1)</code></li>
<li><code>%fib_n_2 = func.call @fib(%n_minus_2)</code></li>
</ul>
</li>
<li><strong>각 호출은 독립적:</strong> <code>%fib_n_1</code>이 완료된 후 <code>%fib_n_2</code> 실행</li>
<li><strong>결과를 더함:</strong> <code>%sum = arith.addi %fib_n_1, %fib_n_2</code></li>
</ul>
<p><strong>실행 순서 (eager evaluation):</strong></p>
<ol>
<li><code>%n_minus_1</code> 계산</li>
<li><code>func.call @fib(%n_minus_1)</code> 실행 → 결과를 <code>%fib_n_1</code>에 저장</li>
<li><code>%n_minus_2</code> 계산</li>
<li><code>func.call @fib(%n_minus_2)</code> 실행 → 결과를 <code>%fib_n_2</code>에 저장</li>
<li><code>%sum = %fib_n_1 + %fib_n_2</code> 계산</li>
</ol>
<h3 id="성능-문제"><a class="header" href="#성능-문제">성능 문제</a></h3>
<p><strong>지수 시간 복잡도:</strong></p>
<pre><code>fib(10) ≈ 177 호출
fib(20) ≈ 21,891 호출
fib(30) ≈ 2,692,537 호출
fib(40) ≈ 331,160,281 호출 (3억 번!)
</code></pre>
<p><strong>왜 느린가?</strong></p>
<p>중복 계산이 많다. <code>fib(5)</code>를 계산할 때 <code>fib(3)</code>을 두 번 계산하고, <code>fib(2)</code>를 세 번 계산한다.</p>
<pre><code>fib(5)
├─ fib(4)
│  ├─ fib(3) ← 첫 번째 fib(3)
│  └─ fib(2)
└─ fib(3) ← 두 번째 fib(3) (중복!)
   ├─ fib(2) ← 중복!
   └─ fib(1)
</code></pre>
<p><strong>최적화 방법 (Phase 3 범위 밖):</strong></p>
<ul>
<li><strong>Memoization:</strong> 이미 계산한 값을 저장 (hashtable 사용)</li>
<li><strong>Dynamic Programming:</strong> Bottom-up 방식으로 계산</li>
<li><strong>Tail recursion:</strong> 꼬리 재귀로 변환 (accumulator 사용)</li>
</ul>
<p>이 장에서는 <strong>순진한 재귀 구현</strong>만 다룬다. 최적화는 나중 단계에서 배운다.</p>
<p><strong>교훈:</strong> 재귀는 우아하지만, 항상 효율적이지는 않다. 알고리즘 선택이 중요하다.</p>
<h2 id="스택-프레임-관리-1"><a class="header" href="#스택-프레임-관리-1">스택 프레임 관리</a></h2>
<h3 id="스택-프레임이란"><a class="header" href="#스택-프레임이란">스택 프레임이란?</a></h3>
<p><strong>스택 프레임(stack frame)</strong> (또는 <strong>activation record</strong>)은 함수 호출에 필요한 정보를 저장하는 메모리 영역이다.</p>
<p><strong>스택 프레임에 포함되는 것:</strong></p>
<ol>
<li><strong>반환 주소(return address)</strong>: 함수가 끝나면 돌아갈 위치</li>
<li><strong>함수 파라미터</strong>: 호출자가 전달한 인자</li>
<li><strong>지역 변수</strong>: 함수 내부에서 선언된 변수</li>
<li><strong>저장된 레지스터</strong>: 호출 전 레지스터 상태 (ABI가 요구)</li>
<li><strong>임시 값</strong>: 중간 계산 결과 (SSA values)</li>
</ol>
<p><strong>함수 호출 시 스택 프레임 생성:</strong></p>
<pre><code>main()
  |
  ├─ factorial(5) 호출
  │    ├─ 스택 프레임 생성
  │    │    - return address: main의 다음 instruction
  │    │    - arg0 = 5
  │    │    - 지역 변수 공간
  │    ├─ factorial(4) 호출
  │    │    ├─ 새로운 스택 프레임 생성
  │    │    │    - return address: factorial(5)의 다음 instruction
  │    │    │    - arg0 = 4
  │    │    ├─ factorial(3) 호출
  │    │    │    └─ 또 다른 스택 프레임...
</code></pre>
<p><strong>스택 성장 방향:</strong></p>
<p>대부분의 플랫폼에서 스택은 <strong>아래로 성장</strong>한다 (높은 주소 → 낮은 주소):</p>
<pre><code>높은 주소
   ↓
 [main의 스택 프레임]
 [factorial(5)의 스택 프레임]  ← SP (Stack Pointer) 이동
 [factorial(4)의 스택 프레임]  ← SP 이동
 [factorial(3)의 스택 프레임]  ← SP 이동
 [factorial(2)의 스택 프레임]
 [factorial(1)의 스택 프레임]  ← SP (현재 위치)
   ↓
낮은 주소
</code></pre>
<p><strong>Stack Pointer (SP)</strong>: 스택의 현재 끝을 가리키는 레지스터. 함수 호출 시 SP가 아래로 이동.</p>
<h3 id="재귀-호출과-스택-깊이"><a class="header" href="#재귀-호출과-스택-깊이">재귀 호출과 스택 깊이</a></h3>
<p><strong>재귀 호출마다 새로운 스택 프레임:</strong></p>
<pre><code class="language-fsharp">factorial(5)
  ├─ 스택 프레임 1: arg0=5, return_addr=main
  ├─ factorial(4) 호출
  │  ├─ 스택 프레임 2: arg0=4, return_addr=factorial(5)
  │  ├─ factorial(3) 호출
  │  │  ├─ 스택 프레임 3: arg0=3, return_addr=factorial(4)
  │  │  ├─ factorial(2) 호출
  │  │  │  ├─ 스택 프레임 4: arg0=2, return_addr=factorial(3)
  │  │  │  ├─ factorial(1) 호출
  │  │  │  │  └─ 스택 프레임 5: arg0=1, return_addr=factorial(2)
  │  │  │  │     ├─ 기저 사례: return 1
  │  │  │  │     └─ 스택 프레임 5 소멸
  │  │  │  ├─ 반환값 1 받음, 2*1=2 계산, return 2
  │  │  │  └─ 스택 프레임 4 소멸
  │  │  ├─ 반환값 2 받음, 3*2=6 계산, return 6
  │  │  └─ 스택 프레임 3 소멸
  │  ├─ 반환값 6 받음, 4*6=24 계산, return 24
  │  └─ 스택 프레임 2 소멸
  ├─ 반환값 24 받음, 5*24=120 계산, return 120
  └─ 스택 프레임 1 소멸
</code></pre>
<p><strong>최대 스택 깊이:</strong> <code>factorial(5)</code>는 5개의 스택 프레임이 동시에 존재한다 (기저 사례에 도달했을 때).</p>
<p><strong>일반화:</strong> <code>factorial(n)</code>의 최대 스택 깊이는 <code>n</code>.</p>
<h3 id="스택-크기-제한"><a class="header" href="#스택-크기-제한">스택 크기 제한</a></h3>
<p><strong>운영체제는 스택 크기를 제한한다:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>플랫폼</th><th>기본 스택 크기</th></tr>
</thead>
<tbody>
<tr><td>Linux (x86-64)</td><td>8 MB</td></tr>
<tr><td>macOS</td><td>8 MB</td></tr>
<tr><td>Windows</td><td>1 MB</td></tr>
</tbody>
</table>
</div>
<p><strong>왜 제한이 필요한가?</strong></p>
<ul>
<li>무한 재귀를 방지</li>
<li>메모리 보호 (스택이 다른 메모리 영역을 침범하지 않도록)</li>
</ul>
<p><strong>스택 오버플로우(Stack Overflow):</strong></p>
<p>재귀 깊이가 너무 크면 스택 크기 한계에 도달한다:</p>
<pre><code class="language-fsharp">factorial(100000)
  ├─ 100,000개의 스택 프레임 필요
  ├─ 각 프레임이 ~64 bytes라고 가정
  ├─ 총 스택 사용: 100,000 * 64 = 6.4 MB
  └─ Linux에서는 OK (8MB 한계), Windows에서는 실패 (1MB 한계)
</code></pre>
<p><strong>스택 오버플로우 에러:</strong></p>
<pre><code class="language-bash">./factorial
Segmentation fault (core dumped)
# 또는
Stack overflow error
</code></pre>
<p><strong>해결책:</strong></p>
<ol>
<li><strong>재귀 깊이 제한:</strong> 입력 크기를 제한</li>
<li><strong>꼬리 호출 최적화(Tail Call Optimization):</strong> 스택 프레임 재사용</li>
<li><strong>반복(Iteration)으로 변환:</strong> Loop 사용 (함수형 언어에서는 덜 선호)</li>
<li><strong>Trampoline 기법:</strong> 재귀를 CPS(Continuation-Passing Style)로 변환</li>
</ol>
<p>이 장 후반부에서 꼬리 호출 최적화를 다룬다.</p>
<h3 id="llvm의-스택-프레임-관리"><a class="header" href="#llvm의-스택-프레임-관리">LLVM의 스택 프레임 관리</a></h3>
<p><strong>LLVM은 스택 프레임을 자동으로 관리한다:</strong></p>
<ol>
<li>
<p><strong>함수 프롤로그(prologue):</strong></p>
<ul>
<li>스택 포인터(SP) 감소 (스택 공간 할당)</li>
<li>프레임 포인터(FP) 저장</li>
<li>필요한 레지스터 저장 (callee-saved registers)</li>
</ul>
</li>
<li>
<p><strong>함수 에필로그(epilogue):</strong></p>
<ul>
<li>저장된 레지스터 복원</li>
<li>프레임 포인터 복원</li>
<li>스택 포인터 증가 (스택 공간 해제)</li>
<li>반환 (ret instruction)</li>
</ul>
</li>
</ol>
<p><strong>예시 (x86-64 어셈블리):</strong></p>
<pre><code class="language-asm">factorial:
  ; Prologue
  push    rbp              ; 이전 프레임 포인터 저장
  mov     rbp, rsp         ; 새로운 프레임 포인터 설정
  sub     rsp, 16          ; 지역 변수를 위한 스택 공간 할당

  ; Function body
  ; ... (factorial 계산)

  ; Epilogue
  add     rsp, 16          ; 스택 공간 해제
  pop     rbp              ; 이전 프레임 포인터 복원
  ret                      ; 반환 주소로 점프
</code></pre>
<p><strong>FunLang 컴파일러는 스택 관리를 직접 하지 않는다:</strong></p>
<ul>
<li>MLIR <code>func</code> 다이얼렉트로 함수 정의</li>
<li>LLVM이 lowering 과정에서 프롤로그/에필로그 생성</li>
<li>플랫폼별 calling convention 자동 적용 (System V ABI for Linux, Microsoft x64 for Windows)</li>
</ul>
<p><strong>이점:</strong></p>
<ul>
<li>플랫폼 독립적인 코드</li>
<li>ABI 호환성 자동 보장</li>
<li>최적화 (tail call elimination, frame pointer omission)</li>
</ul>
<h3 id="visualization-factorial-5의-스택"><a class="header" href="#visualization-factorial-5의-스택">Visualization: factorial 5의 스택</a></h3>
<p><strong>시간별 스택 상태:</strong></p>
<pre><code>시간 T1: main에서 factorial(5) 호출
┌──────────────────────┐
│ factorial(5)         │ ← SP
│  - arg0 = 5          │
│  - ret_addr = main+X │
├──────────────────────┤
│ main                 │
└──────────────────────┘

시간 T2: factorial(5)에서 factorial(4) 호출
┌──────────────────────┐
│ factorial(4)         │ ← SP
│  - arg0 = 4          │
│  - ret_addr = f(5)+Y │
├──────────────────────┤
│ factorial(5)         │
│  - arg0 = 5          │
├──────────────────────┤
│ main                 │
└──────────────────────┘

시간 T3: factorial(1) 도달 (최대 깊이)
┌──────────────────────┐
│ factorial(1)         │ ← SP (최대 깊이)
│  - arg0 = 1          │
├──────────────────────┤
│ factorial(2)         │
│  - arg0 = 2          │
├──────────────────────┤
│ factorial(3)         │
│  - arg0 = 3          │
├──────────────────────┤
│ factorial(4)         │
│  - arg0 = 4          │
├──────────────────────┤
│ factorial(5)         │
│  - arg0 = 5          │
├──────────────────────┤
│ main                 │
└──────────────────────┘

시간 T4: factorial(1) 반환 후 (1 반환)
┌──────────────────────┐
│ factorial(2)         │ ← SP
│  - arg0 = 2          │
│  - rec = 1           │
├──────────────────────┤
│ factorial(3)         │
├──────────────────────┤
│ factorial(4)         │
├──────────────────────┤
│ factorial(5)         │
├──────────────────────┤
│ main                 │
└──────────────────────┘

...

시간 T_final: 모든 호출 반환 완료
┌──────────────────────┐
│ main                 │ ← SP
│  - result = 120      │
└──────────────────────┘
</code></pre>
<p><strong>핵심:</strong></p>
<ul>
<li>재귀 호출마다 스택이 <strong>성장</strong>한다</li>
<li>기저 사례에 도달하면 스택이 <strong>수축</strong>하기 시작한다</li>
<li>각 반환은 이전 스택 프레임을 복원한다</li>
</ul>
<h3 id="스택-vs-힙"><a class="header" href="#스택-vs-힙">스택 vs 힙</a></h3>
<p><strong>Phase 2에서 배운 것:</strong></p>
<ul>
<li><strong>스택(Stack):</strong> 함수 로컬 값, LIFO, 자동 해제</li>
<li><strong>힙(Heap):</strong> 탈출하는 값(closures, data structures), 수동/GC 해제</li>
</ul>
<p><strong>Phase 3에서 함수는 스택만 사용:</strong></p>
<ul>
<li>파라미터: 스택 또는 레지스터 (calling convention)</li>
<li>반환 값: 레지스터 (작은 값) 또는 스택 (큰 구조체)</li>
<li>지역 변수: SSA values (레지스터 또는 스택 스필링)</li>
</ul>
<p><strong>Phase 4에서 클로저는 힙 사용:</strong></p>
<ul>
<li>클로저 환경: 힙에 할당 (GC_malloc)</li>
<li>클로저 포인터: 스택에 저장</li>
</ul>
<p><strong>연결:</strong></p>
<ul>
<li>Chapter 9 (Boehm GC)는 Phase 4를 위한 준비였다</li>
<li>Phase 3 함수는 GC를 사용하지 않는다 (메모리 할당 없음)</li>
<li>Phase 4 클로저에서 GC가 활성화된다</li>
</ul>
<h2 id="왜-스택-오버플로우가-발생하는가"><a class="header" href="#왜-스택-오버플로우가-발생하는가">왜 스택 오버플로우가 발생하는가</a></h2>
<h3 id="깊은-재귀의-위험"><a class="header" href="#깊은-재귀의-위험">깊은 재귀의 위험</a></h3>
<p><strong>문제:</strong></p>
<pre><code class="language-fsharp">factorial(100000)
</code></pre>
<p>이 호출은 100,000개의 스택 프레임을 생성한다. 각 프레임이 64 bytes라면:</p>
<pre><code>100,000 frames × 64 bytes/frame = 6,400,000 bytes = 6.4 MB
</code></pre>
<p>Linux 기본 스택 크기가 8 MB이므로 <strong>아슬아슬하게 성공</strong>할 수 있다. Windows (1 MB)에서는 <strong>확실히 실패</strong>한다.</p>
<p><strong>실제 테스트:</strong></p>
<pre><code class="language-bash"># factorial 100000 컴파일 및 실행
./factorial 100000
Segmentation fault
</code></pre>
<p><strong>왜 Segmentation fault?</strong></p>
<p>스택 포인터(SP)가 스택 크기 한계를 넘어서 <strong>guard page</strong>에 도달한다. Guard page는 스택 오버플로우 감지를 위한 특수 메모리 페이지로, 접근 시 segfault를 발생시킨다.</p>
<h3 id="최적화-없는-재귀"><a class="header" href="#최적화-없는-재귀">최적화 없는 재귀</a></h3>
<p><strong>일반 재귀 (Non-tail recursion):</strong></p>
<pre><code class="language-fsharp">let rec factorial n =
    if n &lt;= 1 then 1
    else n * factorial (n - 1)
         // ↑ 재귀 호출 후 곱셈이 남아있음
</code></pre>
<p>재귀 호출 후에 <strong>추가 작업</strong>(곱셈)이 있으므로:</p>
<ul>
<li>재귀 호출이 반환될 때까지 <strong>현재 스택 프레임을 유지</strong>해야 한다</li>
<li>반환 값을 받아서 <code>n</code>과 곱해야 한다</li>
<li>따라서 스택 프레임을 재사용할 수 없다</li>
</ul>
<p><strong>스택 프레임 누적:</strong></p>
<pre><code>factorial(5) 스택 프레임 유지 (n=5 저장 필요)
  factorial(4) 스택 프레임 유지 (n=4 저장 필요)
    factorial(3) 스택 프레임 유지 (n=3 저장 필요)
      factorial(2) 스택 프레임 유지 (n=2 저장 필요)
        factorial(1) 스택 프레임 생성
          return 1
        return 2 (= 2 * 1)
      return 6 (= 3 * 2)
    return 24 (= 4 * 6)
  return 120 (= 5 * 24)
</code></pre>
<p>모든 프레임이 동시에 존재해야 한다.</p>
<p><strong>결론:</strong> 일반 재귀는 스택 크기에 제한받는다.</p>
<h3 id="예시-factorial-100000은-왜-실패하는가"><a class="header" href="#예시-factorial-100000은-왜-실패하는가">예시: factorial 100000은 왜 실패하는가</a></h3>
<pre><code>스택 크기: 8 MB = 8,388,608 bytes
필요한 스택: 100,000 frames × 64 bytes = 6,400,000 bytes

6,400,000 &lt; 8,388,608 → 이론적으로 가능
</code></pre>
<p>하지만 실제로는:</p>
<ul>
<li><strong>다른 함수 프레임:</strong> main, runtime initialization</li>
<li><strong>스택 정렬 (alignment):</strong> 16-byte 정렬 요구사항</li>
<li><strong>추가 오버헤드:</strong> 레지스터 저장, guard page</li>
</ul>
<p>실제 사용 가능한 스택이 줄어든다. 그래서 6.4 MB도 실패할 수 있다.</p>
<p><strong>안전한 한계:</strong></p>
<p>대부분의 시스템에서 <strong>~5,000 - 10,000 깊이</strong>가 안전하다. 그 이상은 스택 오버플로우 위험.</p>
<p><strong>교훈:</strong> 깊은 재귀는 위험하다. 꼬리 호출 최적화가 필요하다.</p>
<h2 id="상호-재귀-mutual-recursion"><a class="header" href="#상호-재귀-mutual-recursion">상호 재귀 (Mutual Recursion)</a></h2>
<h3 id="상호-재귀란"><a class="header" href="#상호-재귀란">상호 재귀란?</a></h3>
<p>**상호 재귀(mutual recursion)**는 두 개 이상의 함수가 서로를 호출하는 패턴이다.</p>
<pre><code class="language-fsharp">// 함수 A가 함수 B를 호출하고,
// 함수 B가 함수 A를 호출한다.

let rec is_even n =
    if n = 0 then true
    else is_odd (n - 1)

let rec is_odd n =
    if n = 0 then false
    else is_even (n - 1)
</code></pre>
<p><strong>차이점:</strong></p>
<ul>
<li><strong>단순 재귀:</strong> 함수가 자기 자신을 호출 (<code>factorial</code> → <code>factorial</code>)</li>
<li><strong>상호 재귀:</strong> 함수 A가 함수 B를 호출, 함수 B가 함수 A를 호출 (<code>is_even</code> ⇄ <code>is_odd</code>)</li>
</ul>
<p><strong>왜 필요한가?</strong></p>
<p>어떤 문제는 자연스럽게 상호 재귀로 표현된다:</p>
<ul>
<li>짝수/홀수 판정</li>
<li>문법 파서 (expression → term → factor → expression)</li>
<li>상태 기계 (state A → state B → state A)</li>
</ul>
<h3 id="예시-is_even과-is_odd"><a class="header" href="#예시-is_even과-is_odd">예시: is_even과 is_odd</a></h3>
<p><strong>수학적 정의:</strong></p>
<pre><code>is_even(n) = {
  true                 if n = 0
  is_odd(n - 1)        if n &gt; 0
}

is_odd(n) = {
  false                if n = 0
  is_even(n - 1)       if n &gt; 0
}
</code></pre>
<p><strong>직관:</strong></p>
<ul>
<li>0은 짝수</li>
<li>n이 짝수인지 확인하려면: n-1이 홀수인지 확인</li>
<li>n이 홀수인지 확인하려면: n-1이 짝수인지 확인</li>
</ul>
<p><strong>FunLang 소스:</strong></p>
<pre><code class="language-fsharp">let rec is_even n =
    if n = 0 then true
    else is_odd (n - 1)

let rec is_odd n =
    if n = 0 then false
    else is_even (n - 1)
</code></pre>
<p><strong>실행 예시 (is_even 4):</strong></p>
<pre><code>is_even(4)
  ├─ 4 = 0? → false
  ├─ is_odd(3) 호출
  │  ├─ 3 = 0? → false
  │  ├─ is_even(2) 호출
  │  │  ├─ 2 = 0? → false
  │  │  ├─ is_odd(1) 호출
  │  │  │  ├─ 1 = 0? → false
  │  │  │  ├─ is_even(0) 호출
  │  │  │  │  ├─ 0 = 0? → true
  │  │  │  │  └─ return true
  │  │  │  └─ return true (is_even(0) = true)
  │  │  └─ return true (is_odd(1) = true)
  │  └─ return true (is_even(2) = true)
  └─ return true (is_odd(3) = true)

최종 결과: true (4는 짝수)
</code></pre>
<p><strong>호출 시퀀스:</strong> is_even → is_odd → is_even → is_odd → is_even</p>
<h3 id="모듈-레벨-심볼-테이블의-역할"><a class="header" href="#모듈-레벨-심볼-테이블의-역할">모듈 레벨 심볼 테이블의 역할</a></h3>
<p><strong>핵심:</strong> MLIR 모듈은 flat symbol namespace를 가진다. 모든 함수가 동시에 보인다.</p>
<pre><code class="language-mlir">module {
  func.func @is_even(%n: i32) -&gt; i1 { ... }
  func.func @is_odd(%n: i32) -&gt; i1 { ... }
}
</code></pre>
<p><strong>중요한 점:</strong></p>
<ul>
<li><strong>정의 순서는 무관:</strong> <code>is_even</code>이 먼저 정의되든, <code>is_odd</code>가 먼저 정의되든 상관없다.</li>
<li><strong>Forward declaration 불필요:</strong> C에서는 forward declaration이 필요하지만, MLIR에서는 필요 없다.</li>
<li><strong>모든 함수가 서로에게 보임:</strong> <code>is_even</code> 본체에서 <code>is_odd</code>를 참조할 수 있고, <code>is_odd</code> 본체에서 <code>is_even</code>을 참조할 수 있다.</li>
</ul>
<p><strong>C와 비교:</strong></p>
<pre><code class="language-c">// C에서는 forward declaration 필요
int is_odd(int n);  // forward declaration

int is_even(int n) {
    if (n == 0) return 1;
    else return is_odd(n - 1);
}

int is_odd(int n) {
    if (n == 0) return 0;
    else return is_even(n - 1);
}
</code></pre>
<p><strong>MLIR/FunLang에서는 불필요:</strong></p>
<pre><code class="language-mlir">// 정의 순서 무관 - 둘 다 작동
module {
  func.func @is_even(%n: i32) -&gt; i1 { ... func.call @is_odd ... }
  func.func @is_odd(%n: i32) -&gt; i1 { ... func.call @is_even ... }
}
</code></pre>
<h3 id="컴파일-크로스-참조-처리"><a class="header" href="#컴파일-크로스-참조-처리">컴파일: 크로스 참조 처리</a></h3>
<p><strong>상호 재귀 함수 컴파일:</strong></p>
<pre><code class="language-fsharp">let compileProgram (builder: OpBuilder) (moduleDef: ModuleOp) (Program(funcs, mainExpr)) =
    // 1. 모든 함수 정의를 모듈에 추가
    funcs |&gt; List.iter (compileFuncDef builder moduleDef)

    // 2. Main 표현식 컴파일
    let mainValue = compileExpr builder Map.empty mainExpr
    ...
</code></pre>
<p><strong>핵심 아이디어:</strong></p>
<ol>
<li><strong>모든 함수를 먼저 컴파일:</strong> 모듈에 <code>func.func</code> 연산 추가</li>
<li><strong>심볼 등록 자동:</strong> MLIR이 각 함수를 심볼 테이블에 등록</li>
<li><strong>본체 컴파일 시 심볼 참조:</strong> <code>func.call @is_odd</code> → 심볼 테이블에서 찾기</li>
</ol>
<p><strong>두 가지 접근법:</strong></p>
<p><strong>접근법 1: 순차 컴파일 (FunLang 사용)</strong></p>
<pre><code class="language-fsharp">// 함수를 하나씩 컴파일
funcs |&gt; List.iter (fun funcDef -&gt;
    compileFuncDef builder moduleDef funcDef
)
</code></pre>
<ul>
<li><code>is_even</code> 컴파일 시 본체에서 <code>func.call @is_odd</code> 생성</li>
<li><code>@is_odd</code> 심볼이 아직 등록 안 됨 → <strong>문제 없음!</strong></li>
<li>MLIR verifier는 <strong>모든 함수가 컴파일된 후</strong> 실행됨</li>
<li>Verifier가 실행될 때는 <code>@is_odd</code>도 이미 등록되어 있음</li>
</ul>
<p><strong>접근법 2: 스텁 먼저 생성 (대안)</strong></p>
<pre><code class="language-fsharp">// 1단계: 모든 함수 헤더만 생성 (body 없음)
funcs |&gt; List.iter (fun (FunDef(name, params, _)) -&gt;
    let funcOp = builder.CreateFuncStub(name, paramTypes, returnType)
    moduleDef.AddFunction(funcOp)
)

// 2단계: 모든 함수 본체 채우기
funcs |&gt; List.iter (fun (FunDef(name, params, body)) -&gt;
    let funcOp = moduleDef.GetFunction(name)
    compileFuncBody builder funcOp params body
)
</code></pre>
<ul>
<li>더 명시적이지만 복잡함</li>
<li>FunLang은 접근법 1 사용 (더 간단)</li>
</ul>
<p><strong>왜 작동하는가?</strong></p>
<p>MLIR의 <strong>lazy verification</strong>:</p>
<ul>
<li>함수를 컴파일하는 동안 심볼 참조는 검증하지 않음</li>
<li>모듈이 완성된 후 <code>mlirOperationVerify()</code>를 호출</li>
<li>그때 모든 심볼 참조 확인</li>
</ul>
<h3 id="완전한-mlir-ir-출력-1"><a class="header" href="#완전한-mlir-ir-출력-1">완전한 MLIR IR 출력</a></h3>
<pre><code class="language-mlir">module {
  // is_even 함수
  func.func @is_even(%arg0: i32) -&gt; i1 {
    %c0 = arith.constant 0 : i32
    %is_zero = arith.cmpi eq, %arg0, %c0 : i32

    %result = scf.if %is_zero -&gt; (i1) {
      // then: return true
      %true = arith.constant 1 : i1
      scf.yield %true : i1
    } else {
      // else: return is_odd(n - 1)
      %c1 = arith.constant 1 : i32
      %n_minus_1 = arith.subi %arg0, %c1 : i32

      // is_odd 호출 (상호 재귀!)
      %odd_result = func.call @is_odd(%n_minus_1) : (i32) -&gt; i1

      scf.yield %odd_result : i1
    }

    func.return %result : i1
  }

  // is_odd 함수
  func.func @is_odd(%arg0: i32) -&gt; i1 {
    %c0 = arith.constant 0 : i32
    %is_zero = arith.cmpi eq, %arg0, %c0 : i32

    %result = scf.if %is_zero -&gt; (i1) {
      // then: return false
      %false = arith.constant 0 : i1
      scf.yield %false : i1
    } else {
      // else: return is_even(n - 1)
      %c1 = arith.constant 1 : i32
      %n_minus_1 = arith.subi %arg0, %c1 : i32

      // is_even 호출 (상호 재귀!)
      %even_result = func.call @is_even(%n_minus_1) : (i32) -&gt; i1

      scf.yield %even_result : i1
    }

    func.return %result : i1
  }

  // Main 함수
  func.func @funlang_main() -&gt; i32 {
    %c4 = arith.constant 4 : i32
    %result_i1 = func.call @is_even(%c4) : (i32) -&gt; i1

    // i1 → i32 확장 (main 반환용)
    %result_i32 = arith.extui %result_i1 : i1 to i32

    func.return %result_i32 : i32
  }
}
</code></pre>
<p><strong>주목할 점:</strong></p>
<ul>
<li><code>@is_even</code>이 <code>func.call @is_odd</code> 사용</li>
<li><code>@is_odd</code>가 <code>func.call @is_even</code> 사용</li>
<li><strong>순환 참조(cyclic call graph)</strong> 형성</li>
<li>MLIR verifier가 허용 (심볼이 모두 존재)</li>
</ul>
<h3 id="실행-추적"><a class="header" href="#실행-추적">실행 추적</a></h3>
<p><strong>is_even(4) 호출:</strong></p>
<pre><code>is_even(4)
  ├─ 4 = 0? → false
  ├─ else 블록: is_odd(4 - 1) = is_odd(3)
  │  ├─ 3 = 0? → false
  │  ├─ else 블록: is_even(3 - 1) = is_even(2)
  │  │  ├─ 2 = 0? → false
  │  │  ├─ else 블록: is_odd(2 - 1) = is_odd(1)
  │  │  │  ├─ 1 = 0? → false
  │  │  │  ├─ else 블록: is_even(1 - 1) = is_even(0)
  │  │  │  │  ├─ 0 = 0? → true
  │  │  │  │  └─ then 블록: return true
  │  │  │  ├─ odd_result = true
  │  │  │  └─ return true
  │  │  ├─ even_result = true
  │  │  └─ return true
  │  ├─ odd_result = true
  │  └─ return true
  ├─ even_result = true
  └─ return true (i1), 확장하여 1 (i32) 반환
</code></pre>
<p><strong>호출 스택 깊이:</strong> 5 (is_even → is_odd → is_even → is_odd → is_even)</p>
<p><strong>상호 재귀의 스택 프레임:</strong></p>
<pre><code>┌──────────────────────┐
│ is_even(0)           │ ← 최대 깊이 (기저 사례)
├──────────────────────┤
│ is_odd(1)            │
├──────────────────────┤
│ is_even(2)           │
├──────────────────────┤
│ is_odd(3)            │
├──────────────────────┤
│ is_even(4)           │ ← 최초 호출
├──────────────────────┤
│ funlang_main         │
└──────────────────────┘
</code></pre>
<p>스택 프레임이 번갈아가며 생성된다: is_even → is_odd → is_even → …</p>
<h3 id="verifier의-심볼-검증"><a class="header" href="#verifier의-심볼-검증">Verifier의 심볼 검증</a></h3>
<p><strong>MLIR verifier는 모듈 완성 후 실행:</strong></p>
<pre><code class="language-fsharp">// 컴파일러 코드
let compileProgram moduleDef funcs mainExpr =
    // 1. 모든 함수 컴파일
    funcs |&gt; List.iter (compileFuncDef builder moduleDef)

    // 2. Main 컴파일
    let mainFunc = compileMain builder mainExpr
    moduleDef.AddFunction(mainFunc)

    // 3. Verify (모든 함수 추가 후)
    if not (mlirOperationVerify(moduleDef.GetOperation())) then
        failwith "Module verification failed"
</code></pre>
<p><strong>Verification 과정:</strong></p>
<ol>
<li><strong>심볼 수집:</strong> 모듈의 모든 <code>func.func</code> 연산에서 심볼 추출 (<code>@is_even</code>, <code>@is_odd</code>)</li>
<li><strong>심볼 참조 확인:</strong> 각 <code>func.call</code> 연산의 callee 확인
<ul>
<li><code>func.call @is_odd</code> → <code>@is_odd</code> 심볼이 존재하는가? <strong>예</strong></li>
<li><code>func.call @is_even</code> → <code>@is_even</code> 심볼이 존재하는가? <strong>예</strong></li>
</ul>
</li>
<li><strong>타입 검증:</strong> 호출 타입과 함수 타입 일치 확인
<ul>
<li><code>@is_even: (i32) -&gt; i1</code></li>
<li><code>func.call @is_even(%n_minus_1) : (i32) -&gt; i1</code> → <strong>일치</strong></li>
</ul>
</li>
</ol>
<p><strong>실패 케이스 (존재하지 않는 함수 호출):</strong></p>
<pre><code class="language-mlir">func.func @foo(%n: i32) -&gt; i1 {
  %result = func.call @nonexistent(%n) : (i32) -&gt; i1
  //                    ↑ 모듈에 없음
  func.return %result : i1
}
</code></pre>
<p>Verifier 에러:</p>
<pre><code>error: 'func.call' op 'nonexistent' does not reference a valid function
</code></pre>
<p><strong>상호 재귀는 통과:</strong> 모든 심볼이 존재하므로 검증 성공.</p>
<h3 id="funlang-interpreter와의-차이"><a class="header" href="#funlang-interpreter와의-차이">FunLang Interpreter와의 차이</a></h3>
<p><strong>Interpreter에서 상호 재귀:</strong></p>
<pre><code class="language-fsharp">// FunLang interpreter (LangTutorial)
let rec eval env ast =
    match ast with
    | LetRec(funcs, body) -&gt;
        // 재귀 환경 생성: 모든 함수를 env에 추가
        let rec_env =
            funcs |&gt; List.fold (fun e (name, func) -&gt;
                e.Add(name, RecursiveClosure(func, rec_env))
            ) env
        eval rec_env body
</code></pre>
<p><strong>문제:</strong></p>
<ul>
<li>환경이 재귀적으로 정의됨 (<code>rec_env</code>가 자기 자신을 참조)</li>
<li>F#의 <code>let rec</code> 또는 명시적인 mutation 필요</li>
</ul>
<p><strong>Compiler는 더 간단:</strong></p>
<ul>
<li>모듈 심볼 테이블이 자연스럽게 flat namespace 제공</li>
<li>순환 참조를 허용</li>
<li>Lazy verification으로 정의 순서 무관</li>
</ul>
<h2 id="꼬리-재귀와-꼬리-호출-최적화"><a class="header" href="#꼬리-재귀와-꼬리-호출-최적화">꼬리 재귀와 꼬리 호출 최적화</a></h2>
<h3 id="꼬리-위치-tail-position"><a class="header" href="#꼬리-위치-tail-position">꼬리 위치 (Tail Position)</a></h3>
<p>**꼬리 위치(tail position)**는 함수에서 <strong>마지막으로 실행되는 표현식의 위치</strong>다.</p>
<pre><code class="language-fsharp">let rec factorial n =
    if n &lt;= 1 then
        1           // ← 꼬리 위치 (then 분기의 마지막)
    else
        n * factorial (n - 1)
        //  ↑ factorial 호출은 꼬리 위치가 아님!
        //    호출 후 곱셈이 남아있음
</code></pre>
<p><strong>꼬리 위치 판단:</strong></p>
<ul>
<li>then 분기의 <code>1</code>: <strong>꼬리 위치</strong> (분기의 마지막 값)</li>
<li><code>factorial (n - 1)</code> 호출: <strong>꼬리 위치 아님</strong> (호출 후 <code>n *</code> 곱셈이 실행됨)</li>
<li><code>n * factorial(...)</code> 전체: <strong>꼬리 위치</strong> (else 분기의 마지막 값)</li>
</ul>
<p><strong>일반 규칙:</strong></p>
<p>함수 본체에서:</p>
<ul>
<li><code>if</code> then/else 각 분기의 마지막 표현식: 꼬리 위치</li>
<li><code>let x = ... in &lt;expr&gt;</code>: <code>&lt;expr&gt;</code>이 꼬리 위치</li>
<li>함수의 최상위 표현식: 꼬리 위치</li>
</ul>
<p><strong>꼬리 호출(tail call):</strong> 꼬리 위치에 있는 함수 호출.</p>
<pre><code class="language-fsharp">let rec countdown n =
    if n &lt;= 0 then
        0           // ← 꼬리 위치, 값 (호출 아님)
    else
        countdown (n - 1)
        // ↑ 꼬리 위치에 있는 호출 → 꼬리 호출!
</code></pre>
<p><code>countdown (n - 1)</code>은 else 분기의 마지막이고, 호출 후 추가 작업이 없다. <strong>꼬리 호출</strong>이다.</p>
<h3 id="꼬리-호출-최적화-tail-call-optimization"><a class="header" href="#꼬리-호출-최적화-tail-call-optimization">꼬리 호출 최적화 (Tail Call Optimization)</a></h3>
<p>**꼬리 호출 최적화(TCO, Tail Call Optimization)**는 꼬리 호출을 **점프(jump)**로 변환하여 스택 프레임을 재사용하는 최적화다.</p>
<p><strong>일반 재귀 (TCO 없음):</strong></p>
<pre><code>factorial(5)
  ├─ 스택 프레임 1 생성
  ├─ factorial(4) 호출
  │  ├─ 스택 프레임 2 생성
  │  ├─ factorial(3) 호출
  │  │  └─ ... (스택 누적)
  │  ├─ 반환 후 n * result 계산 ← 추가 작업
  │  └─ 스택 프레임 2 해제
  ├─ 반환 후 n * result 계산
  └─ 스택 프레임 1 해제
</code></pre>
<p><strong>꼬리 재귀 (TCO 사용):</strong></p>
<pre><code>countdown(5)
  ├─ 스택 프레임 1 생성
  ├─ countdown(4) 호출 → 점프로 변환!
  │    (스택 프레임 1 재사용, n 값만 업데이트)
  ├─ countdown(3) 호출 → 점프
  ├─ countdown(2) 호출 → 점프
  ├─ countdown(1) 호출 → 점프
  ├─ countdown(0) 호출 → 점프
  └─ 기저 사례: return 0
     (스택 프레임 1 해제)
</code></pre>
<p><strong>핵심 차이:</strong></p>
<ul>
<li><strong>일반 재귀:</strong> 각 호출마다 스택 프레임 생성. 깊이 N → N개 프레임.</li>
<li><strong>꼬리 재귀 + TCO:</strong> 단일 스택 프레임 재사용. 깊이 N → 1개 프레임.</li>
</ul>
<p><strong>왜 가능한가?</strong></p>
<p>꼬리 호출은 “호출 후 돌아올 필요가 없다”:</p>
<ul>
<li>현재 함수는 호출 결과를 그대로 반환</li>
<li>현재 스택 프레임에 남은 작업이 없음</li>
<li>따라서 현재 프레임을 버리고, 새 프레임으로 점프할 수 있음</li>
</ul>
<h3 id="꼬리-재귀-변환-factorial"><a class="header" href="#꼬리-재귀-변환-factorial">꼬리 재귀 변환: Factorial</a></h3>
<p><strong>일반 재귀 factorial (non-tail):</strong></p>
<pre><code class="language-fsharp">let rec factorial n =
    if n &lt;= 1 then 1
    else n * factorial (n - 1)
         // ↑ 호출 후 곱셈 → 꼬리 호출 아님
</code></pre>
<p><strong>꼬리 재귀 factorial:</strong></p>
<pre><code class="language-fsharp">let rec factorial_tail n acc =
    if n &lt;= 1 then acc
    else factorial_tail (n - 1) (n * acc)
         // ↑ 호출이 마지막 → 꼬리 호출!
</code></pre>
<p><strong>차이점:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>측면</th><th>일반 재귀</th><th>꼬리 재귀</th></tr>
</thead>
<tbody>
<tr><td>Accumulator</td><td>없음</td><td><code>acc</code> 파라미터</td></tr>
<tr><td>곱셈 위치</td><td>호출 <strong>후</strong> (<code>n * result</code>)</td><td>호출 <strong>전</strong> (<code>n * acc</code>)</td></tr>
<tr><td>반환값</td><td>재귀 호출 결과를 변환</td><td>재귀 호출 결과 그대로</td></tr>
<tr><td>꼬리 호출</td><td>아님</td><td>맞음</td></tr>
</tbody>
</table>
</div>
<p><strong>Accumulator 패턴:</strong></p>
<p>꼬리 재귀는 <strong>accumulator</strong>를 사용하여 중간 결과를 전달한다:</p>
<pre><code>factorial_tail(5, 1)
  → factorial_tail(4, 5*1=5)
    → factorial_tail(3, 4*5=20)
      → factorial_tail(2, 3*20=60)
        → factorial_tail(1, 2*60=120)
          → return 120
</code></pre>
<p><strong>Wrapper 함수:</strong></p>
<p>사용자는 accumulator를 모르므로, wrapper 함수 제공:</p>
<pre><code class="language-fsharp">let factorial n =
    factorial_tail n 1
</code></pre>
<h3 id="mlirllvm에서-tco"><a class="header" href="#mlirllvm에서-tco">MLIR/LLVM에서 TCO</a></h3>
<p><strong>LLVM의 꼬리 호출 최적화:</strong></p>
<p>LLVM은 특정 조건에서 꼬리 호출을 최적화할 수 있다:</p>
<ol>
<li><strong>함수 속성 (function attribute):</strong> <code>"tailcc"</code> calling convention</li>
<li><strong>최적화 플래그:</strong> <code>-tailcallopt</code></li>
<li><strong>타겟 지원:</strong> 플랫폼이 TCO를 지원해야 함 (대부분의 x86-64, ARM은 지원)</li>
</ol>
<p><strong>MLIR IR에서 꼬리 호출 표시:</strong></p>
<p>MLIR <code>func</code> 다이얼렉트는 TCO를 명시적으로 표시하는 속성이 없다. 대신:</p>
<ul>
<li>LLVM dialect로 낮춘 후 <code>tail</code> 속성 추가</li>
<li>또는 LLVM 최적화 패스에 의존</li>
</ul>
<p><strong>Lowered LLVM IR (꼬리 호출 속성):</strong></p>
<pre><code class="language-llvm">define i32 @factorial_tail(i32 %n, i32 %acc) {
entry:
  %cmp = icmp sle i32 %n, 1
  br i1 %cmp, label %base, label %rec

base:
  ret i32 %acc

rec:
  %n_minus_1 = sub i32 %n, 1
  %new_acc = mul i32 %n, %acc
  ; tail 키워드 → TCO 힌트
  %result = tail call i32 @factorial_tail(i32 %n_minus_1, i32 %new_acc)
  ret i32 %result
}
</code></pre>
<p><strong><code>tail call</code>의 의미:</strong></p>
<ul>
<li>“이 호출은 꼬리 호출입니다”</li>
<li>LLVM 최적화 패스가 이를 점프로 변환 가능</li>
<li><code>-tailcallopt</code> 플래그와 함께 사용</li>
</ul>
<p><strong>FunLang Phase 3에서 TCO:</strong></p>
<p>Phase 3에서는 <strong>TCO를 보장하지 않는다</strong>:</p>
<ul>
<li>교육 목적: 재귀의 기본 개념 먼저 이해</li>
<li>LLVM이 자동으로 최적화할 <strong>수</strong> 있지만, 보장되지 않음</li>
<li>Phase 7 (최적화)에서 명시적 TCO 지원 추가 예정</li>
</ul>
<p><strong>현재 동작:</strong></p>
<pre><code class="language-fsharp">// FunLang 소스
let rec factorial_tail n acc =
    if n &lt;= 1 then acc
    else factorial_tail (n - 1) (n * acc)

// MLIR IR
func.func @factorial_tail(%arg0: i32, %arg1: i32) -&gt; i32 {
  // ... if 조건
  %result = scf.if %cmp -&gt; (i32) {
    scf.yield %arg1 : i32
  } else {
    %n_minus_1 = arith.subi %arg0, %c1 : i32
    %new_acc = arith.muli %arg0, %arg1 : i32
    %rec = func.call @factorial_tail(%n_minus_1, %new_acc) : (i32, i32) -&gt; i32
    // ↑ 일반 func.call (tail 속성 없음)
    scf.yield %rec : i32
  }
  func.return %result : i32
}
</code></pre>
<p><strong>LLVM이 최적화할 수 있음 (보장 안 됨):</strong></p>
<ul>
<li>LLVM <code>-O2</code> 또는 <code>-O3</code> 최적화 레벨</li>
<li>일부 경우 자동으로 TCO 적용</li>
<li>하지만 C calling convention에서는 보장되지 않음</li>
</ul>
<h3 id="tco-활성화-방법-preview"><a class="header" href="#tco-활성화-방법-preview">TCO 활성화 방법 (Preview)</a></h3>
<p><strong>Phase 7에서 다룰 내용 (Preview):</strong></p>
<ol>
<li><strong><code>tailcc</code> calling convention 사용:</strong></li>
</ol>
<pre><code class="language-llvm">define tailcc i32 @factorial_tail(i32 %n, i32 %acc) {
  ; tailcc = 꼬리 호출 최적화에 특화된 calling convention
  ...
  %result = tail call tailcc i32 @factorial_tail(i32 %n_minus_1, i32 %new_acc)
  ret i32 %result
}
</code></pre>
<ol start="2">
<li><strong>Compiler 플래그:</strong></li>
</ol>
<pre><code class="language-bash">llc -tailcallopt factorial.ll -o factorial.s
</code></pre>
<ol start="3">
<li><strong>함수 속성:</strong></li>
</ol>
<p>MLIR에서 LLVM dialect로 낮출 때 함수 속성 추가:</p>
<ul>
<li><code>llvm.func @factorial_tail ... attributes { tail = true }</code></li>
</ul>
<p><strong>현재 (Phase 3):</strong></p>
<ul>
<li>꼬리 재귀 패턴을 이해</li>
<li>accumulator 사용법 배우기</li>
<li>LLVM의 자동 최적화에 의존</li>
<li>Phase 7에서 명시적 제어 추가</li>
</ul>
<h2 id="코드-생성-업데이트"><a class="header" href="#코드-생성-업데이트">코드 생성 업데이트</a></h2>
<h3 id="compilefuncdef-재사용"><a class="header" href="#compilefuncdef-재사용">compileFuncDef 재사용</a></h3>
<p><strong>좋은 소식:</strong> 재귀 함수를 위한 특별한 코드 생성이 <strong>필요 없다</strong>.</p>
<p>Chapter 10의 <code>compileFuncDef</code>를 그대로 사용:</p>
<pre><code class="language-fsharp">let compileFuncDef (builder: OpBuilder) (moduleDef: ModuleOp) (FunDef(name, params, body)) =
    // 1. 함수 타입 생성
    let paramTypes = List.replicate params.Length builder.GetI32Type()
    let returnType = builder.GetI32Type()
    let funcType = builder.GetFunctionType(paramTypes, returnType)

    // 2. func.func 생성
    let funcOp = builder.CreateFuncOp(name, funcType)

    // 3. Entry block에서 파라미터 가져오기
    let entryBlock = funcOp.GetEntryBlock()
    builder.SetInsertionPointToEnd(entryBlock)

    let env =
        params
        |&gt; List.mapi (fun i paramName -&gt;
            let argValue = entryBlock.GetArgument(i)
            (paramName, argValue))
        |&gt; Map.ofList

    // 4. 본체 컴파일
    let bodyValue = compileExpr builder env body

    // 5. 반환
    builder.CreateFuncReturn(bodyValue)

    // 6. 모듈에 추가
    moduleDef.AddFunction(funcOp)
</code></pre>
<p><strong>재귀 호출은 자동으로 처리:</strong></p>
<p><code>compileExpr</code>의 <code>App</code> case:</p>
<pre><code class="language-fsharp">| App(funcName, args) -&gt;
    let argValues = args |&gt; List.map (compileExpr builder env)
    builder.CreateFuncCall(funcName, argValues)
</code></pre>
<ul>
<li><code>App("factorial", [Num 5])</code> → <code>func.call @factorial(%c5) : (i32) -&gt; i32</code></li>
<li><code>App("factorial", [BinOp(...)])</code> → <code>func.call @factorial(%n_minus_1) : (i32) -&gt; i32</code></li>
</ul>
<p><strong>자기 참조가 자연스럽게 작동:</strong></p>
<ul>
<li><code>@factorial</code> 심볼이 모듈에 이미 존재 (본체 컴파일 중이지만 함수 자체는 이미 추가됨)</li>
<li><code>CreateFuncCall</code>이 심볼 참조 생성</li>
<li>Verifier가 나중에 확인</li>
</ul>
<h3 id="상호-재귀-처리"><a class="header" href="#상호-재귀-처리">상호 재귀 처리</a></h3>
<p><strong>상호 재귀도 특별한 처리 불필요:</strong></p>
<pre><code class="language-fsharp">let compileProgram (builder: OpBuilder) (moduleDef: ModuleOp) (Program(funcs, mainExpr)) =
    // 모든 함수 컴파일
    funcs |&gt; List.iter (compileFuncDef builder moduleDef)

    // Main 표현식 컴파일
    // ...
</code></pre>
<p><strong>순서:</strong></p>
<ol>
<li>
<p><code>is_even</code> 컴파일:</p>
<ul>
<li><code>func.func @is_even</code> 생성, 모듈에 추가</li>
<li>본체에서 <code>func.call @is_odd</code> 생성 (아직 <code>@is_odd</code> 없음 - OK!)</li>
</ul>
</li>
<li>
<p><code>is_odd</code> 컴파일:</p>
<ul>
<li><code>func.func @is_odd</code> 생성, 모듈에 추가</li>
<li>본체에서 <code>func.call @is_even</code> 생성 (<code>@is_even</code> 이미 존재)</li>
</ul>
</li>
<li>
<p>Verification:</p>
<ul>
<li><code>@is_even</code>의 <code>func.call @is_odd</code> → <code>@is_odd</code> 존재 확인 ✓</li>
<li><code>@is_odd</code>의 <code>func.call @is_even</code> → <code>@is_even</code> 존재 확인 ✓</li>
</ul>
</li>
</ol>
<p><strong>핵심:</strong> MLIR의 lazy verification 덕분에 순서 무관.</p>
<h3 id="compileprogram-전체-구조"><a class="header" href="#compileprogram-전체-구조">compileProgram 전체 구조</a></h3>
<p><strong>다중 함수 + Main 표현식:</strong></p>
<pre><code class="language-fsharp">let compileProgram (builder: OpBuilder) (moduleDef: ModuleOp) (Program(funcs, mainExpr)) =
    // 1. 모든 함수 정의 컴파일
    funcs |&gt; List.iter (fun funcDef -&gt;
        compileFuncDef builder moduleDef funcDef
    )

    // 2. Main 함수 생성
    let mainFuncType = builder.GetFunctionType([], builder.GetI32Type())
    let mainFunc = builder.CreateFuncOp("funlang_main", mainFuncType)

    let mainBlock = mainFunc.GetEntryBlock()
    builder.SetInsertionPointToEnd(mainBlock)

    // 3. Main 표현식 컴파일
    let mainValue = compileExpr builder Map.empty mainExpr

    // 4. Main 반환
    builder.CreateFuncReturn(mainValue)

    moduleDef.AddFunction(mainFunc)

    // 5. Verification
    if not (mlirOperationVerify(moduleDef.GetOperation())) then
        failwith "Module verification failed"

    moduleDef
</code></pre>
<p><strong>프로그램 구조:</strong></p>
<pre><code class="language-fsharp">Program([
    FunDef("factorial", ["n"], &lt;body&gt;),
    FunDef("fibonacci", ["n"], &lt;body&gt;),
    FunDef("is_even", ["n"], &lt;body&gt;),
    FunDef("is_odd", ["n"], &lt;body&gt;)
], App("factorial", [Num 5]))
</code></pre>
<p><strong>생성된 MLIR:</strong></p>
<pre><code class="language-mlir">module {
  func.func @factorial(%arg0: i32) -&gt; i32 { ... }
  func.func @fibonacci(%arg0: i32) -&gt; i32 { ... }
  func.func @is_even(%arg0: i32) -&gt; i1 { ... }
  func.func @is_odd(%arg0: i32) -&gt; i1 { ... }

  func.func @funlang_main() -&gt; i32 {
    %c5 = arith.constant 5 : i32
    %result = func.call @factorial(%c5) : (i32) -&gt; i32
    func.return %result : i32
  }
}
</code></pre>
<h2 id="완전한-예시-여러-재귀-함수"><a class="header" href="#완전한-예시-여러-재귀-함수">완전한 예시: 여러 재귀 함수</a></h2>
<h3 id="프로그램-소스"><a class="header" href="#프로그램-소스">프로그램 소스</a></h3>
<pre><code class="language-fsharp">// 함수 정의들
let rec factorial n =
    if n &lt;= 1 then 1
    else n * factorial (n - 1)

let rec fibonacci n =
    if n &lt;= 1 then n
    else fibonacci (n - 1) + fibonacci (n - 2)

let rec is_even n =
    if n = 0 then true
    else is_odd (n - 1)

let rec is_odd n =
    if n = 0 then false
    else is_even (n - 1)

// Main 표현식
let result_fact = factorial 5 in
let result_fib = fibonacci 6 in
let result_even = is_even 4 in
result_fact + result_fib + result_even
</code></pre>
<h3 id="ast-표현-간략"><a class="header" href="#ast-표현-간략">AST 표현 (간략)</a></h3>
<pre><code class="language-fsharp">Program([
    FunDef("factorial", ["n"], &lt;factorial_body&gt;),
    FunDef("fibonacci", ["n"], &lt;fibonacci_body&gt;),
    FunDef("is_even", ["n"], &lt;is_even_body&gt;),
    FunDef("is_odd", ["n"], &lt;is_odd_body&gt;)
],
Let("result_fact", App("factorial", [Num 5]),
Let("result_fib", App("fibonacci", [Num 6]),
Let("result_even", App("is_even", [Num 4]),
BinOp(
    BinOp(Var "result_fact", Add, Var "result_fib"),
    Add,
    Var "result_even"
)))))
</code></pre>
<h3 id="생성된-mlir-ir-전체"><a class="header" href="#생성된-mlir-ir-전체">생성된 MLIR IR (전체)</a></h3>
<pre><code class="language-mlir">module {
  // factorial 함수
  func.func @factorial(%arg0: i32) -&gt; i32 {
    %c1 = arith.constant 1 : i32
    %cmp = arith.cmpi sle, %arg0, %c1 : i32
    %result = scf.if %cmp -&gt; (i32) {
      scf.yield %c1 : i32
    } else {
      %n_minus_1 = arith.subi %arg0, %c1 : i32
      %rec = func.call @factorial(%n_minus_1) : (i32) -&gt; i32
      %product = arith.muli %arg0, %rec : i32
      scf.yield %product : i32
    }
    func.return %result : i32
  }

  // fibonacci 함수
  func.func @fibonacci(%arg0: i32) -&gt; i32 {
    %c1 = arith.constant 1 : i32
    %cmp = arith.cmpi sle, %arg0, %c1 : i32
    %result = scf.if %cmp -&gt; (i32) {
      scf.yield %arg0 : i32
    } else {
      %n_minus_1 = arith.subi %arg0, %c1 : i32
      %fib_n_1 = func.call @fibonacci(%n_minus_1) : (i32) -&gt; i32
      %c2 = arith.constant 2 : i32
      %n_minus_2 = arith.subi %arg0, %c2 : i32
      %fib_n_2 = func.call @fibonacci(%n_minus_2) : (i32) -&gt; i32
      %sum = arith.addi %fib_n_1, %fib_n_2 : i32
      scf.yield %sum : i32
    }
    func.return %result : i32
  }

  // is_even 함수
  func.func @is_even(%arg0: i32) -&gt; i1 {
    %c0 = arith.constant 0 : i32
    %is_zero = arith.cmpi eq, %arg0, %c0 : i32
    %result = scf.if %is_zero -&gt; (i1) {
      %true = arith.constant 1 : i1
      scf.yield %true : i1
    } else {
      %c1 = arith.constant 1 : i32
      %n_minus_1 = arith.subi %arg0, %c1 : i32
      %odd_result = func.call @is_odd(%n_minus_1) : (i32) -&gt; i1
      scf.yield %odd_result : i1
    }
    func.return %result : i1
  }

  // is_odd 함수
  func.func @is_odd(%arg0: i32) -&gt; i1 {
    %c0 = arith.constant 0 : i32
    %is_zero = arith.cmpi eq, %arg0, %c0 : i32
    %result = scf.if %is_zero -&gt; (i1) {
      %false = arith.constant 0 : i1
      scf.yield %false : i1
    } else {
      %c1 = arith.constant 1 : i32
      %n_minus_1 = arith.subi %arg0, %c1 : i32
      %even_result = func.call @is_even(%n_minus_1) : (i32) -&gt; i1
      scf.yield %even_result : i1
    }
    func.return %result : i1
  }

  // Main 함수
  func.func @funlang_main() -&gt; i32 {
    // result_fact = factorial(5)
    %c5 = arith.constant 5 : i32
    %result_fact = func.call @factorial(%c5) : (i32) -&gt; i32

    // result_fib = fibonacci(6)
    %c6 = arith.constant 6 : i32
    %result_fib = func.call @fibonacci(%c6) : (i32) -&gt; i32

    // result_even = is_even(4)
    %c4 = arith.constant 4 : i32
    %result_even_i1 = func.call @is_even(%c4) : (i32) -&gt; i1
    %result_even = arith.extui %result_even_i1 : i1 to i32

    // result_fact + result_fib + result_even
    %sum1 = arith.addi %result_fact, %result_fib : i32
    %sum2 = arith.addi %sum1, %result_even : i32

    func.return %sum2 : i32
  }
}
</code></pre>
<h3 id="컴파일-및-실행"><a class="header" href="#컴파일-및-실행">컴파일 및 실행</a></h3>
<pre><code class="language-bash"># 1. MLIR 파일 저장
echo "&lt;위 MLIR IR&gt;" &gt; recursion_example.mlir

# 2. Lowering passes 적용
mlir-opt \
  --convert-scf-to-cf \
  --convert-func-to-llvm \
  --convert-arith-to-llvm \
  recursion_example.mlir \
  -o lowered.mlir

# 3. LLVM IR로 변환
mlir-translate --mlir-to-llvmir lowered.mlir -o recursion.ll

# 4. Object file 생성
llc -filetype=obj recursion.ll -o recursion.o

# 5. Runtime과 링크
gcc -o recursion recursion.o runtime.o -lgc

# 6. 실행
./recursion
# 출력: 129
# (factorial(5)=120, fibonacci(6)=8, is_even(4)=1, 120+8+1=129)
</code></pre>
<h3 id="실행-결과-분석"><a class="header" href="#실행-결과-분석">실행 결과 분석</a></h3>
<p><strong>계산 과정:</strong></p>
<ol>
<li><code>factorial(5)</code> = 120</li>
<li><code>fibonacci(6)</code> = 8</li>
<li><code>is_even(4)</code> = true = 1 (i32로 확장)</li>
<li>120 + 8 + 1 = 129</li>
</ol>
<p><strong>스택 사용:</strong></p>
<ul>
<li><code>factorial(5)</code>: 최대 5개 스택 프레임</li>
<li><code>fibonacci(6)</code>: 최대 6개 스택 프레임 (하지만 호출 트리가 넓음)</li>
<li><code>is_even(4)</code>: 최대 5개 스택 프레임 (is_even/is_odd 번갈아가며)</li>
</ul>
<p><strong>총 호출 횟수:</strong></p>
<ul>
<li><code>factorial(5)</code>: 5번</li>
<li><code>fibonacci(6)</code>: 25번 (지수 복잡도!)</li>
<li><code>is_even(4)</code> + <code>is_odd</code>: 5번</li>
</ul>
<h2 id="성능-고려사항"><a class="header" href="#성능-고려사항">성능 고려사항</a></h2>
<h3 id="재귀-vs-반복-성능"><a class="header" href="#재귀-vs-반복-성능">재귀 vs 반복 성능</a></h3>
<p><strong>재귀의 오버헤드:</strong></p>
<ol>
<li>
<p><strong>함수 호출 비용:</strong></p>
<ul>
<li>스택 프레임 생성/소멸</li>
<li>레지스터 저장/복원</li>
<li>점프 instruction (call/ret)</li>
</ul>
</li>
<li>
<p><strong>스택 메모리 사용:</strong></p>
<ul>
<li>깊이 N → N개 스택 프레임</li>
<li>각 프레임 ~64-128 bytes</li>
<li>캐시 미스 가능성</li>
</ul>
</li>
<li>
<p><strong>분기 예측:</strong></p>
<ul>
<li>재귀 호출은 간접 분기</li>
<li>CPU 분기 예측기가 학습하기 어려움</li>
</ul>
</li>
</ol>
<p><strong>반복(Loop)의 이점:</strong></p>
<ol>
<li>
<p><strong>함수 호출 없음:</strong></p>
<ul>
<li>단일 스택 프레임</li>
<li>레지스터 할당 효율적</li>
</ul>
</li>
<li>
<p><strong>명령어 수 감소:</strong></p>
<ul>
<li>직접 점프 (conditional branch)</li>
<li>예측 가능한 패턴</li>
</ul>
</li>
<li>
<p><strong>메모리 효율:</strong></p>
<ul>
<li>스택 사용 최소</li>
</ul>
</li>
</ol>
<p><strong>언제 재귀가 괜찮은가?</strong></p>
<ol>
<li>
<p><strong>얕은 재귀 (shallow recursion):</strong></p>
<ul>
<li>깊이 &lt; 100: 성능 차이 미미</li>
<li>예: 균형 트리 탐색 (깊이 ~log N)</li>
</ul>
</li>
<li>
<p><strong>꼬리 재귀 + TCO:</strong></p>
<ul>
<li>컴파일러가 loop으로 변환</li>
<li>성능이 반복과 동일</li>
</ul>
</li>
<li>
<p><strong>알고리즘이 본질적으로 재귀적:</strong></p>
<ul>
<li>트리 순회, 퀵소트, 병합정렬</li>
<li>재귀로 작성하는 것이 자연스럽고 명확</li>
</ul>
</li>
</ol>
<p><strong>언제 재귀를 피해야 하는가?</strong></p>
<ol>
<li>
<p><strong>깊은 재귀 (deep recursion):</strong></p>
<ul>
<li>깊이 &gt; 10,000: 스택 오버플로우 위험</li>
<li>예: naive fibonacci</li>
</ul>
</li>
<li>
<p><strong>중복 계산:</strong></p>
<ul>
<li>Fibonacci 같은 지수 복잡도</li>
<li>Memoization 또는 DP로 해결</li>
</ul>
</li>
<li>
<p><strong>성능이 중요한 경우:</strong></p>
<ul>
<li>내부 루프 (hot path)</li>
<li>반복으로 작성 또는 TCO 보장</li>
</ul>
</li>
</ol>
<h3 id="스택-프레임-오버헤드"><a class="header" href="#스택-프레임-오버헤드">스택 프레임 오버헤드</a></h3>
<p><strong>스택 프레임 구조 (x86-64):</strong></p>
<pre><code>┌──────────────────────┐
│ Return address       │ 8 bytes
├──────────────────────┤
│ Saved rbp (frame ptr)│ 8 bytes
├──────────────────────┤
│ Local variables      │ Variable
├──────────────────────┤
│ Saved registers      │ Variable (callee-saved)
├──────────────────────┤
│ Padding (alignment)  │ 0-15 bytes (16-byte align)
└──────────────────────┘
</code></pre>
<p><strong>최소 크기:</strong> ~16 bytes (return address + rbp)
<strong>일반적 크기:</strong> 64-128 bytes (지역 변수, 레지스터 저장 포함)</p>
<p><strong>호출 비용:</strong></p>
<ul>
<li><code>call</code> instruction: ~1-2 CPU cycles (분기 예측 성공 시)</li>
<li>스택 프레임 setup: ~5-10 instructions (push rbp, mov, sub)</li>
<li>스택 프레임 teardown: ~5-10 instructions (mov, pop, ret)</li>
<li><strong>총:</strong> ~20-30 instructions per call</li>
</ul>
<p><strong>비교 (factorial 1000):</strong></p>
<ul>
<li><strong>재귀:</strong> 1,000 함수 호출 × 30 instructions = 30,000 instructions</li>
<li><strong>반복:</strong> ~5 instructions per iteration × 1,000 = 5,000 instructions</li>
</ul>
<p><strong>6배 차이!</strong> 하지만 절대 시간은 여전히 작음 (~수 마이크로초).</p>
<h3 id="llvm-최적화-기회"><a class="header" href="#llvm-최적화-기회">LLVM 최적화 기회</a></h3>
<p><strong>LLVM이 재귀에 적용하는 최적화:</strong></p>
<ol>
<li>
<p><strong>Tail Call Elimination (TCO):</strong></p>
<ul>
<li>꼬리 재귀 → loop 변환</li>
<li>스택 사용 O(1)</li>
</ul>
</li>
<li>
<p><strong>Inlining:</strong></p>
<ul>
<li>작은 재귀 함수를 호출 사이트에 인라인</li>
<li>함수 호출 오버헤드 제거</li>
</ul>
</li>
<li>
<p><strong>Constant Folding:</strong></p>
<ul>
<li>컴파일 타임에 계산 가능한 재귀 (예: <code>factorial(5)</code>) → 상수 120</li>
</ul>
</li>
<li>
<p><strong>Loop Optimization:</strong></p>
<ul>
<li>재귀를 loop으로 변환 후 loop unrolling, vectorization 적용</li>
</ul>
</li>
</ol>
<p><strong>예시 (LLVM -O3):</strong></p>
<pre><code class="language-fsharp">// 소스
let rec factorial n =
    if n &lt;= 1 then 1
    else n * factorial (n - 1)

let result = factorial 5
</code></pre>
<p><strong>LLVM -O3 최적화 후:</strong></p>
<pre><code class="language-llvm">define i32 @funlang_main() {
  ret i32 120  ; 컴파일 타임에 계산됨!
}
</code></pre>
<p><strong>변수 입력 (factorial n, n이 런타임 값):</strong></p>
<p>LLVM은 재귀를 그대로 유지하지만, 레지스터 할당과 분기 예측을 최적화.</p>
<h3 id="phase-7-최적화-preview"><a class="header" href="#phase-7-최적화-preview">Phase 7 최적화 Preview</a></h3>
<p><strong>Phase 7에서 다룰 내용:</strong></p>
<ol>
<li>
<p><strong>명시적 TCO 지원:</strong></p>
<ul>
<li><code>tailcc</code> calling convention</li>
<li>꼬리 재귀 자동 감지 및 변환</li>
</ul>
</li>
<li>
<p><strong>Inlining 제어:</strong></p>
<ul>
<li>작은 함수 자동 인라인</li>
<li><code>inline</code> 힌트</li>
</ul>
</li>
<li>
<p><strong>Memoization:</strong></p>
<ul>
<li>함수 결과 캐싱 (fibonacci 최적화)</li>
</ul>
</li>
<li>
<p><strong>Loop 변환:</strong></p>
<ul>
<li>재귀 → 반복 자동 변환 (특정 패턴)</li>
</ul>
</li>
</ol>
<p><strong>현재 (Phase 3):</strong></p>
<ul>
<li>재귀의 기본 개념과 제약 이해</li>
<li>성능 트레이드오프 인지</li>
<li>LLVM의 기본 최적화에 의존</li>
</ul>
<h2 id="일반적인-오류-1"><a class="header" href="#일반적인-오류-1">일반적인 오류</a></h2>
<h3 id="error-1-무한-재귀-기저-사례-누락"><a class="header" href="#error-1-무한-재귀-기저-사례-누락">Error 1: 무한 재귀 (기저 사례 누락)</a></h3>
<p><strong>문제:</strong></p>
<pre><code class="language-fsharp">let rec infinite_loop n =
    infinite_loop (n - 1)
    // 기저 사례가 없음!
</code></pre>
<p><strong>증상:</strong></p>
<pre><code class="language-bash">./program
Segmentation fault (core dumped)
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>재귀 종료 조건이 없음</li>
<li>스택이 무한히 성장</li>
<li>스택 오버플로우</li>
</ul>
<p><strong>해결:</strong></p>
<pre><code class="language-fsharp">let rec countdown n =
    if n &lt;= 0 then 0  // ← 기저 사례 추가
    else countdown (n - 1)
</code></pre>
<p><strong>디버깅 팁:</strong></p>
<ul>
<li>모든 재귀 함수에 기저 사례가 있는지 확인</li>
<li>“언제 재귀가 멈추는가?” 질문</li>
</ul>
<h3 id="error-2-스택-오버플로우-깊은-재귀"><a class="header" href="#error-2-스택-오버플로우-깊은-재귀">Error 2: 스택 오버플로우 (깊은 재귀)</a></h3>
<p><strong>문제:</strong></p>
<pre><code class="language-fsharp">let rec sum_to n =
    if n &lt;= 0 then 0
    else n + sum_to (n - 1)

let result = sum_to 100000  // 깊이 100,000!
</code></pre>
<p><strong>증상:</strong></p>
<pre><code class="language-bash">./program
Segmentation fault (core dumped)
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>재귀 깊이 &gt; 스택 크기</li>
<li>100,000 프레임 × 64 bytes = 6.4 MB &gt; 일부 플랫폼 한계</li>
</ul>
<p><strong>해결:</strong></p>
<ol>
<li><strong>꼬리 재귀로 변환:</strong></li>
</ol>
<pre><code class="language-fsharp">let rec sum_to_tail n acc =
    if n &lt;= 0 then acc
    else sum_to_tail (n - 1) (n + acc)

let sum_to n = sum_to_tail n 0
</code></pre>
<ol start="2">
<li><strong>입력 크기 제한:</strong></li>
</ol>
<pre><code class="language-fsharp">if n &gt; 10000 then
    failwith "Input too large"
else
    sum_to n
</code></pre>
<ol start="3">
<li><strong>반복으로 변환:</strong></li>
</ol>
<pre><code class="language-fsharp">// FunLang은 loop 없지만, LLVM이 TCO로 변환 가능
</code></pre>
<h3 id="error-3-심볼을-찾을-수-없음-타이포"><a class="header" href="#error-3-심볼을-찾을-수-없음-타이포">Error 3: 심볼을 찾을 수 없음 (타이포)</a></h3>
<p><strong>문제:</strong></p>
<pre><code class="language-fsharp">let rec factorial n =
    if n &lt;= 1 then 1
    else n * factorail (n - 1)  // typo: factorail
</code></pre>
<p><strong>증상 (MLIR verification):</strong></p>
<pre><code>error: 'func.call' op 'factorail' does not reference a valid function
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>함수 이름 오타</li>
<li>심볼 <code>@factorail</code>이 모듈에 없음</li>
</ul>
<p><strong>해결:</strong></p>
<ul>
<li>함수 이름 철자 확인</li>
<li>IDE의 자동완성 사용</li>
</ul>
<h3 id="error-4-인자-순서-오류-상호-재귀"><a class="header" href="#error-4-인자-순서-오류-상호-재귀">Error 4: 인자 순서 오류 (상호 재귀)</a></h3>
<p><strong>문제:</strong></p>
<pre><code class="language-fsharp">let rec is_even n =
    if n = 0 then true
    else is_odd n  // ← (n - 1) 빠뜨림!

let rec is_odd n =
    if n = 0 then false
    else is_even n  // ← 똑같은 오류
</code></pre>
<p><strong>증상:</strong></p>
<pre><code class="language-bash">./program
Segmentation fault (core dumped)
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>무한 재귀: is_even(4) → is_odd(4) → is_even(4) → …</li>
<li>인자가 감소하지 않음</li>
</ul>
<p><strong>해결:</strong></p>
<pre><code class="language-fsharp">let rec is_even n =
    if n = 0 then true
    else is_odd (n - 1)  // ← (n - 1) 추가

let rec is_odd n =
    if n = 0 then false
    else is_even (n - 1)
</code></pre>
<h3 id="error-5-꼬리-위치가-아닌-곳에서-tco-기대"><a class="header" href="#error-5-꼬리-위치가-아닌-곳에서-tco-기대">Error 5: 꼬리 위치가 아닌 곳에서 TCO 기대</a></h3>
<p><strong>문제:</strong></p>
<pre><code class="language-fsharp">let rec factorial n =
    if n &lt;= 1 then 1
    else n * factorial (n - 1)
    //       ↑ 꼬리 위치 아님 (곱셈 후 실행)

// TCO가 적용될 것으로 기대하지만, 실제로는 안 됨
</code></pre>
<p><strong>증상:</strong></p>
<ul>
<li>깊은 재귀에서 스택 오버플로우</li>
<li>TCO가 적용되지 않음</li>
</ul>
<p><strong>원인:</strong></p>
<ul>
<li>재귀 호출 후 추가 작업 (<code>n *</code>)</li>
<li>꼬리 호출이 아님</li>
</ul>
<p><strong>해결:</strong></p>
<pre><code class="language-fsharp">// accumulator 패턴으로 변환
let rec factorial_tail n acc =
    if n &lt;= 1 then acc
    else factorial_tail (n - 1) (n * acc)
    //   ↑ 꼬리 위치! (호출이 마지막)
</code></pre>
<h3 id="디버깅-팁"><a class="header" href="#디버깅-팁">디버깅 팁</a></h3>
<ol>
<li><strong>Print 디버깅:</strong></li>
</ol>
<pre><code class="language-fsharp">let rec factorial n =
    // 디버깅: 함수 호출 출력
    print_int n;
    if n &lt;= 1 then 1
    else n * factorial (n - 1)
</code></pre>
<ol start="2">
<li><strong>기저 사례 먼저 확인:</strong></li>
</ol>
<p>재귀 함수를 작성할 때:</p>
<ul>
<li>먼저 기저 사례 작성</li>
<li>그 다음 재귀 사례 작성</li>
</ul>
<ol start="3">
<li><strong>작은 입력으로 테스트:</strong></li>
</ol>
<pre><code class="language-fsharp">// factorial 100000 전에 factorial 5 먼저 테스트
</code></pre>
<ol start="4">
<li><strong>스택 크기 늘리기 (임시 해결):</strong></li>
</ol>
<pre><code class="language-bash"># Linux에서 스택 크기 늘리기
ulimit -s 16384  # 16 MB
./program
</code></pre>
<ol start="5">
<li><strong>MLIR IR 검증:</strong></li>
</ol>
<pre><code class="language-bash">mlir-opt --verify-diagnostics program.mlir
</code></pre>
<h2 id="요약-및-phase-3-완료"><a class="header" href="#요약-및-phase-3-완료">요약 및 Phase 3 완료</a></h2>
<h3 id="chapter-11-요약"><a class="header" href="#chapter-11-요약">Chapter 11 요약</a></h3>
<p><strong>배운 내용:</strong></p>
<ol>
<li>
<p><strong>재귀의 기본:</strong></p>
<ul>
<li>자기 자신을 호출하는 함수</li>
<li>기저 사례 + 재귀 사례</li>
<li>예시: factorial, fibonacci</li>
</ul>
</li>
<li>
<p><strong>MLIR에서 재귀:</strong></p>
<ul>
<li>모듈 레벨 심볼 테이블</li>
<li>자기 참조 (<code>func.call @factorial</code> inside <code>@factorial</code>)</li>
<li>심볼 확인은 컴파일 타임, 호출은 런타임</li>
</ul>
</li>
<li>
<p><strong>상호 재귀:</strong></p>
<ul>
<li>두 함수가 서로 호출 (is_even, is_odd)</li>
<li>Forward declaration 불필요</li>
<li>Flat symbol namespace 덕분에 자연스럽게 작동</li>
</ul>
</li>
<li>
<p><strong>스택 프레임:</strong></p>
<ul>
<li>각 재귀 호출마다 스택 프레임 생성</li>
<li>깊이 N → N개 프레임</li>
<li>스택 크기 제한 (8 MB Linux, 1 MB Windows)</li>
</ul>
</li>
<li>
<p><strong>꼬리 호출 최적화:</strong></p>
<ul>
<li>꼬리 위치 = 함수의 마지막 표현식</li>
<li>꼬리 호출 = 꼬리 위치의 함수 호출</li>
<li>TCO = 꼬리 호출을 점프로 변환, 스택 재사용</li>
<li>Accumulator 패턴으로 꼬리 재귀 변환</li>
</ul>
</li>
<li>
<p><strong>성능:</strong></p>
<ul>
<li>재귀는 오버헤드 있음 (함수 호출, 스택)</li>
<li>얕은 재귀는 괜찮음</li>
<li>깊은 재귀는 TCO 필요</li>
<li>LLVM 최적화 활용</li>
</ul>
</li>
<li>
<p><strong>일반적인 오류:</strong></p>
<ul>
<li>무한 재귀 (기저 사례 누락)</li>
<li>스택 오버플로우 (깊은 재귀)</li>
<li>타이포 (심볼 참조 실패)</li>
<li>인자 오류 (상호 재귀)</li>
<li>꼬리 위치 오해</li>
</ul>
</li>
</ol>
<h3 id="phase-3-완료"><a class="header" href="#phase-3-완료">Phase 3 완료!</a></h3>
<p><strong>Phase 3 목표:</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""> 최상위 명명된 함수 (Chapter 10)</li>
<li><input disabled="" type="checkbox" checked=""> 함수 파라미터와 호출 (Chapter 10)</li>
<li><input disabled="" type="checkbox" checked=""> 재귀 함수 (Chapter 11)</li>
<li><input disabled="" type="checkbox" checked=""> 상호 재귀 (Chapter 11)</li>
<li><input disabled="" type="checkbox" checked=""> 스택 프레임 관리 (Chapter 11)</li>
<li><input disabled="" type="checkbox" checked=""> 꼬리 호출 최적화 개념 (Chapter 11)</li>
</ul>
<p><strong>Phase 3에서 구축한 것:</strong></p>
<ol>
<li>
<p><strong>func 다이얼렉트 통합:</strong></p>
<ul>
<li><code>func.func</code>, <code>func.call</code>, <code>func.return</code> 연산</li>
<li>P/Invoke 바인딩 및 OpBuilder 메서드</li>
</ul>
</li>
<li>
<p><strong>함수 컴파일 인프라:</strong></p>
<ul>
<li><code>compileFuncDef</code>: AST → func.func</li>
<li><code>compileProgram</code>: 다중 함수 + main</li>
<li>환경 관리 (파라미터를 block arguments로)</li>
</ul>
</li>
<li>
<p><strong>재귀 지원:</strong></p>
<ul>
<li>자기 참조 (심볼 테이블)</li>
<li>상호 재귀 (lazy verification)</li>
<li>스택 기반 실행 모델</li>
</ul>
</li>
<li>
<p><strong>Calling convention:</strong></p>
<ul>
<li>C calling convention (System V ABI)</li>
<li>LLVM의 자동 프롤로그/에필로그 생성</li>
</ul>
</li>
</ol>
<p><strong>Phase 3에서 제외된 것 (Phase 4로 연기):</strong></p>
<ul>
<li><strong>클로저:</strong> 환경을 캡처하는 함수</li>
<li><strong>고차 함수:</strong> 함수를 인자로 받거나 반환</li>
<li><strong>익명 함수:</strong> Lambda 표현식</li>
<li><strong>힙 할당:</strong> 클로저 환경 (GC_malloc 사용)</li>
</ul>
<h3 id="phase-4-preview"><a class="header" href="#phase-4-preview">Phase 4 Preview</a></h3>
<p><strong>Phase 4: 클로저와 고차 함수</strong></p>
<p><strong>목표:</strong></p>
<ol>
<li>
<p><strong>Lambda 표현식:</strong></p>
<pre><code class="language-fsharp">let add_n n = fun x -&gt; x + n
</code></pre>
</li>
<li>
<p><strong>환경 캡처:</strong></p>
<pre><code class="language-fsharp">let make_counter () =
    let count = ref 0 in
    fun () -&gt; (count := !count + 1; !count)
</code></pre>
</li>
<li>
<p><strong>고차 함수:</strong></p>
<pre><code class="language-fsharp">let map f list = ...
let result = map (fun x -&gt; x * 2) [1; 2; 3]
</code></pre>
</li>
<li>
<p><strong>클로저 변환:</strong></p>
<ul>
<li>자유 변수 분석</li>
<li>환경을 힙에 할당 (GC_malloc)</li>
<li>클로저 = (function pointer, environment pointer)</li>
</ul>
</li>
<li>
<p><strong>Heap 사용:</strong></p>
<ul>
<li>Chapter 9 (Boehm GC) 활성화</li>
<li>memref 다이얼렉트 (alloc, load, store)</li>
</ul>
</li>
</ol>
<p><strong>연결:</strong></p>
<ul>
<li>Phase 3: 스택 기반 함수 (파라미터만 사용)</li>
<li>Phase 4: 힙 기반 클로저 (파라미터 + 캡처된 환경)</li>
</ul>
<h3 id="다음-단계-3"><a class="header" href="#다음-단계-3">다음 단계</a></h3>
<p><strong>완성된 컴파일러 능력:</strong></p>
<p>Phase 3 완료 후 FunLang 컴파일러는 다음을 지원한다:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""> 산술 및 비교 연산 (Chapter 06)</li>
<li><input disabled="" type="checkbox" checked=""> Let 바인딩과 변수 (Chapter 07)</li>
<li><input disabled="" type="checkbox" checked=""> If/then/else 제어 흐름 (Chapter 08)</li>
<li><input disabled="" type="checkbox" checked=""> 메모리 관리 (Boehm GC 통합, Chapter 09)</li>
<li><input disabled="" type="checkbox" checked=""> 함수 정의 및 호출 (Chapter 10)</li>
<li><input disabled="" type="checkbox" checked=""> 재귀 및 상호 재귀 (Chapter 11)</li>
</ul>
<p><strong>아직 지원하지 않는 것:</strong></p>
<ul>
<li><input disabled="" type="checkbox"> 클로저 및 lambda</li>
<li><input disabled="" type="checkbox"> 고차 함수</li>
<li><input disabled="" type="checkbox"> 패턴 매칭</li>
<li><input disabled="" type="checkbox"> 대수적 데이터 타입 (ADT)</li>
<li><input disabled="" type="checkbox"> 리스트, 튜플 등 데이터 구조</li>
<li><input disabled="" type="checkbox"> 타입 시스템 (현재 모두 i32)</li>
</ul>
<p><strong>학습 경로:</strong></p>
<pre><code>Phase 1 (Foundation): MLIR 기초, P/Invoke
  ↓
Phase 2 (Core Language): 표현식, 제어 흐름, 메모리
  ↓
Phase 3 (Functions): 함수, 재귀, 스택 ← 현재 위치
  ↓
Phase 4 (Closures): 클로저, 고차 함수, 힙
  ↓
Phase 5 (Data Structures): 리스트, 튜플, ADT
  ↓
Phase 6 (Type System): 타입 추론, 다형성
  ↓
Phase 7 (Optimization): 인라인, TCO, 최적화 패스
</code></pre>
<p><strong>축하합니다!</strong> Phase 3를 완료했습니다. FunLang 컴파일러는 이제 재귀 함수를 포함한 완전한 프로그램을 네이티브 코드로 컴파일할 수 있습니다.</p>
<p><strong>다음 장 (Phase 4)에서:</strong> 클로저와 환경 캡처를 추가하여 진정한 함수형 프로그래밍 기능을 구현할 것입니다.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-12-클로저-closures"><a class="header" href="#chapter-12-클로저-closures">Chapter 12: 클로저 (Closures)</a></h1>
<h2 id="소개-12"><a class="header" href="#소개-12">소개</a></h2>
<p>**클로저(closure)**는 함수형 프로그래밍의 핵심 기능이다. 클로저는 단순한 함수가 아니라, **함수 + 환경(environment)**의 조합이다.</p>
<pre><code class="language-fsharp">// Phase 3 함수 - 외부 변수 사용 불가
let add x y = x + y

// Phase 4 클로저 - 외부 변수 캡처 가능
let make_adder n =
    fun x -&gt; x + n   // n을 캡처!
</code></pre>
<p><code>fun x -&gt; x + n</code>은 <strong>클로저</strong>다:</p>
<ul>
<li><code>x</code>는 <strong>파라미터</strong> (bound variable)</li>
<li><code>n</code>은 <strong>캡처된 변수</strong> (free variable, captured from environment)</li>
</ul>
<p>클로저가 생성될 때, <code>n</code>의 값이 **환경(environment)**에 저장된다. 나중에 클로저가 호출되면, 저장된 <code>n</code> 값을 사용한다.</p>
<p><strong>왜 클로저가 중요한가?</strong></p>
<ol>
<li><strong>고차 함수(Higher-order functions)의 기초</strong>: 함수를 반환하거나 인자로 전달하려면 클로저가 필요하다</li>
<li><strong>상태 캡처</strong>: 함수 생성 시점의 환경을 저장할 수 있다</li>
<li><strong>추상화</strong>: 공통 패턴을 클로저로 추상화할 수 있다 (map, filter, fold)</li>
</ol>
<p><strong>클로저 vs Phase 3 함수:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Phase 3 함수</th><th>Phase 4 클로저</th></tr>
</thead>
<tbody>
<tr><td>이름이 있다 (named)</td><td>익명 가능 (anonymous)</td></tr>
<tr><td>외부 변수 사용 불가</td><td>외부 변수 캡처 가능</td></tr>
<tr><td><code>func.func</code> 연산</td><td>함수 포인터 + 환경</td></tr>
<tr><td>정적 바인딩</td><td>환경 저장 필요</td></tr>
</tbody>
</table>
</div>
<p><strong>Chapter 12의 범위:</strong></p>
<p>이 장에서 다루는 것:</p>
<ol>
<li><strong>클로저 이론</strong>: 자유 변수(free variables), 바운드 변수(bound variables)</li>
<li><strong>자유 변수 분석</strong>: 어떤 변수를 캡처해야 하는지 계산</li>
<li><strong>클로저 변환(Closure conversion)</strong>: 암묵적 캡처를 명시적으로 만들기</li>
<li><strong>환경 구조체</strong>: 캡처된 변수를 저장하는 힙 객체</li>
<li><strong>클로저 생성 코드</strong>: GC_malloc으로 환경 할당하기</li>
</ol>
<p>이 장을 마치면:</p>
<ul>
<li>클로저가 무엇이고 왜 필요한지 이해한다</li>
<li>자유 변수 분석 알고리즘을 구현할 수 있다</li>
<li>클로저를 (함수 포인터, 환경 포인터) 쌍으로 표현할 수 있다</li>
<li>환경을 힙에 할당하고 변수를 저장/로드할 수 있다</li>
<li>GC_malloc을 사용해 환경을 생성할 수 있다</li>
</ul>
<blockquote>
<p><strong>Preview:</strong> Chapter 13에서는 고차 함수 (map, filter)를 추가한다. Chapter 12는 클로저의 기초를 확립한다.</p>
</blockquote>
<h2 id="클로저-이론"><a class="header" href="#클로저-이론">클로저 이론</a></h2>
<h3 id="lexical-scoping-vs-dynamic-scoping"><a class="header" href="#lexical-scoping-vs-dynamic-scoping">Lexical Scoping vs Dynamic Scoping</a></h3>
<p>클로저를 이해하려면 먼저 <strong>스코핑(scoping)</strong> 개념을 알아야 한다. 변수의 값이 어떻게 결정되는가?</p>
<p><strong>Lexical scoping (정적 스코핑):</strong></p>
<p>변수는 <strong>코드 작성 시점의 위치</strong>로 결정된다.</p>
<pre><code class="language-fsharp">let x = 10 in
let f = fun y -&gt; x + y in
let x = 20 in
f 5   // 결과: 15 (x = 10 사용)
</code></pre>
<p><code>fun y -&gt; x + y</code>에서 <code>x</code>는 <strong>정의 시점의 <code>x</code></strong> (10)을 참조한다. 나중에 <code>x</code>를 20으로 재바인딩해도 영향 없다.</p>
<p><strong>Dynamic scoping (동적 스코핑):</strong></p>
<p>변수는 <strong>호출 시점의 환경</strong>에서 찾는다.</p>
<pre><code class="language-fsharp">// 동적 스코핑 가상 예시 (FunLang은 지원 안 함)
let x = 10 in
let f = fun y -&gt; x + y in
let x = 20 in
f 5   // 결과: 25 (x = 20 사용)
</code></pre>
<p><code>f</code>를 호출할 때, <code>x</code>는 <strong>호출 시점의 환경</strong>에서 찾는다 (20).</p>
<p><strong>FunLang은 lexical scoping을 사용한다.</strong> 대부분의 현대 언어가 그렇다 (F#, JavaScript, Python, Rust, etc.). Dynamic scoping은 혼란스럽고 디버깅이 어렵다.</p>
<p><strong>Lexical scoping의 의미:</strong></p>
<ul>
<li>함수가 정의될 때, <strong>그 시점의 환경을 기억해야 한다</strong></li>
<li>함수가 호출될 때, <strong>저장된 환경을 사용해야 한다</strong></li>
<li>이것이 <strong>클로저</strong>다: function + environment</li>
</ul>
<h3 id="free-variables-vs-bound-variables"><a class="header" href="#free-variables-vs-bound-variables">Free Variables vs Bound Variables</a></h3>
<p>변수는 두 가지로 분류된다:</p>
<p><strong>Bound variable (바운드 변수):</strong></p>
<p>함수의 파라미터이거나, let 바인딩으로 정의된 변수.</p>
<pre><code class="language-fsharp">fun x -&gt; x + 1
//  ↑   ↑
//  바인딩  사용
</code></pre>
<p><code>x</code>는 <strong>bound variable</strong>이다. <code>fun x</code>가 <code>x</code>를 바인딩한다.</p>
<p><strong>Free variable (자유 변수):</strong></p>
<p>함수 내부에서 사용되지만, 그 함수에서 바인딩되지 않은 변수.</p>
<pre><code class="language-fsharp">fun x -&gt; x + y
//           ↑
//       자유 변수!
</code></pre>
<p><code>y</code>는 <strong>free variable</strong>이다. <code>fun x</code>는 <code>y</code>를 바인딩하지 않는다. <code>y</code>는 <strong>외부 환경에서 와야 한다</strong>.</p>
<p><strong>예시 1: 자유 변수 없음</strong></p>
<pre><code class="language-fsharp">fun x -&gt; x + 1
</code></pre>
<ul>
<li>Bound: {x}</li>
<li>Free: {} (empty)</li>
</ul>
<p><strong>예시 2: 자유 변수 하나</strong></p>
<pre><code class="language-fsharp">fun x -&gt; x + y
</code></pre>
<ul>
<li>Bound: {x}</li>
<li>Free: {y}</li>
</ul>
<p><strong>예시 3: 중첩된 람다</strong></p>
<pre><code class="language-fsharp">fun x -&gt; fun y -&gt; x + y + z
</code></pre>
<p>내부 람다 <code>fun y -&gt; x + y + z</code>를 보면:</p>
<ul>
<li>Bound: {y}</li>
<li>Free: {x, z}</li>
</ul>
<p>외부 람다 <code>fun x -&gt; ...</code>를 보면:</p>
<ul>
<li>Bound: {x}</li>
<li>Free: {z}</li>
</ul>
<p><strong>전체 표현식의 자유 변수: {z}</strong></p>
<p><strong>예시 4: Let 바인딩</strong></p>
<pre><code class="language-fsharp">let a = 10 in
fun x -&gt; a + x
</code></pre>
<p><code>fun x -&gt; a + x</code>:</p>
<ul>
<li>Bound: {x}</li>
<li>Free: {a}</li>
</ul>
<p>하지만 전체 표현식은 <code>let a = 10</code>이 <code>a</code>를 바인딩하므로:</p>
<ul>
<li>전체 자유 변수: {} (empty)</li>
</ul>
<h3 id="환경-캡처-environment-capture"><a class="header" href="#환경-캡처-environment-capture">환경 캡처 (Environment Capture)</a></h3>
<p>자유 변수가 있으면, 그 값을 어디선가 가져와야 한다. 클로저는 **환경(environment)**을 저장해서 해결한다.</p>
<p><strong>환경이란?</strong></p>
<p>환경은 <strong>변수 이름 → 값</strong>의 매핑이다.</p>
<pre><code class="language-fsharp">let x = 10 in
let y = 20 in
fun z -&gt; x + y + z
</code></pre>
<p><code>fun z -&gt; x + y + z</code>가 생성될 때:</p>
<ul>
<li>자유 변수: {x, y}</li>
<li>환경에서 찾기: x = 10, y = 20</li>
<li><strong>환경 캡처</strong>: {x: 10, y: 20}을 저장</li>
</ul>
<p>클로저는 <strong>(함수 포인터, 환경 포인터)</strong> 쌍이 된다:</p>
<pre><code>Closure {
    fn_ptr: @lambda_123,
    env: { x: 10, y: 20 }
}
</code></pre>
<p>나중에 클로저를 호출할 때:</p>
<ol>
<li>함수 포인터를 찾는다 (@lambda_123)</li>
<li>환경을 함수에 전달한다 ({x: 10, y: 20})</li>
<li>함수는 환경에서 x, y 값을 로드한다</li>
<li>계산: 10 + 20 + z</li>
</ol>
<p><strong>Value capture vs Reference capture:</strong></p>
<p>FunLang은 <strong>value capture</strong>를 사용한다. 변수의 <strong>현재 값</strong>을 복사해서 저장한다.</p>
<pre><code class="language-fsharp">let x = 10 in
let f = fun y -&gt; x + y in
let x = 20 in   // x 재바인딩
f 5   // 결과: 15 (캡처된 x = 10 사용)
</code></pre>
<p>클로저가 생성될 때 <code>x = 10</code>이 환경에 복사된다. 나중에 <code>x</code>가 재바인딩되어도 영향 없다.</p>
<p>(참조 캡처는 C++의 <code>[&amp;x]</code> 같은 개념인데, FunLang은 순수 함수형이므로 지원 안 함)</p>
<h3 id="클로저의-구조"><a class="header" href="#클로저의-구조">클로저의 구조</a></h3>
<p>클로저는 <strong>두 개의 포인터</strong>로 표현된다:</p>
<pre><code class="language-c">// C 스타일 표현
struct Closure {
    void* fn_ptr;      // 함수 코드 포인터
    void* env_ptr;     // 환경 데이터 포인터
};
</code></pre>
<p><strong>1. 함수 포인터 (fn_ptr):</strong></p>
<p>실행할 코드의 주소. MLIR에서는 <code>@lambda_N</code> 심볼.</p>
<p><strong>2. 환경 포인터 (env_ptr):</strong></p>
<p>캡처된 변수들을 저장한 힙 객체. 구조체의 주소.</p>
<p><strong>시각적 다이어그램:</strong></p>
<pre><code>클로저 생성:
  let x = 10 in
  let y = 20 in
  fun z -&gt; x + y + z

메모리 레이아웃:
┌─────────────────────┐
│ Closure (스택/레지스터) │
├─────────────────────┤
│ fn_ptr: @lambda_0   │───┐
│ env_ptr: 0x1a3b5c8  │───┼───────┐
└─────────────────────┘   │       │
                          │       │
                          │       v
                          │  ┌──────────────┐
                          │  │ Environment  │
                          │  │ (힙 할당)     │
                          │  ├──────────────┤
                          │  │ x: 10        │
                          │  │ y: 20        │
                          │  └──────────────┘
                          │
                          v
                    @lambda_0 코드:
                      ; env를 파라미터로 받음
                      ; env[0]에서 x 로드
                      ; env[1]에서 y 로드
                      ; x + y + z 계산
</code></pre>
<p><strong>핵심:</strong></p>
<ul>
<li>클로저는 작은 객체 (포인터 2개)</li>
<li>환경은 힙에 할당 (크기는 캡처된 변수 개수에 따라 다름)</li>
<li>함수는 환경을 첫 번째 파라미터로 받음</li>
</ul>
<h2 id="자유-변수-분석-free-variable-analysis"><a class="header" href="#자유-변수-분석-free-variable-analysis">자유 변수 분석 (Free Variable Analysis)</a></h2>
<p>클로저를 컴파일하려면, <strong>어떤 변수를 캡처해야 하는지</strong> 알아야 한다. 이것이 **자유 변수 분석(free variable analysis)**이다.</p>
<h3 id="분석-알고리즘"><a class="header" href="#분석-알고리즘">분석 알고리즘</a></h3>
<p>자유 변수를 찾는 알고리즘은 <strong>set-based traversal</strong>이다:</p>
<ol>
<li>AST를 재귀적으로 순회</li>
<li>각 표현식에서 자유 변수 set을 계산</li>
<li>바운드 변수는 자유 변수 set에서 제거</li>
</ol>
<p><strong>정의:</strong></p>
<pre><code>FV(expr) = 표현식 expr의 자유 변수 집합
BV(expr) = 표현식 expr에서 바인딩되는 변수 집합
</code></pre>
<p><strong>규칙:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Expression</th><th>Free Variables</th><th>Bound Variables</th></tr>
</thead>
<tbody>
<tr><td><code>Var(x)</code></td><td>{x}</td><td>{}</td></tr>
<tr><td><code>Num(n)</code></td><td>{}</td><td>{}</td></tr>
<tr><td><code>Add(e1, e2)</code></td><td>FV(e1) ∪ FV(e2)</td><td>{}</td></tr>
<tr><td><code>Let(x, e1, e2)</code></td><td>FV(e1) ∪ (FV(e2) - {x})</td><td>{x}</td></tr>
<tr><td><code>Lambda(x, body)</code></td><td>FV(body) - {x}</td><td>{x}</td></tr>
<tr><td><code>App(f, arg)</code></td><td>FV(f) ∪ FV(arg)</td><td>{}</td></tr>
<tr><td><code>If(cond, t, f)</code></td><td>FV(cond) ∪ FV(t) ∪ FV(f)</td><td>{}</td></tr>
</tbody>
</table>
</div>
<p><strong>핵심 규칙 설명:</strong></p>
<p><strong>1. Var(x):</strong></p>
<p>변수 사용은 자유 변수다 (아직 바인딩 확인 안 함).</p>
<pre><code>FV(x) = {x}
</code></pre>
<p><strong>2. Lambda(x, body):</strong></p>
<p>람다가 <code>x</code>를 바인딩하므로, body의 자유 변수에서 <code>x</code>를 제거.</p>
<pre><code>FV(fun x -&gt; body) = FV(body) - {x}
</code></pre>
<p><strong>3. Let(x, e1, e2):</strong></p>
<p><code>e1</code>의 자유 변수 + (<code>e2</code>의 자유 변수 - {x})</p>
<pre><code>FV(let x = e1 in e2) = FV(e1) ∪ (FV(e2) - {x})
</code></pre>
<p><strong>4. 기타 연산:</strong></p>
<p>자식 표현식들의 자유 변수를 합집합.</p>
<pre><code>FV(e1 + e2) = FV(e1) ∪ FV(e2)
</code></pre>
<h3 id="f-구현"><a class="header" href="#f-구현">F# 구현</a></h3>
<pre><code class="language-fsharp">// AST 정의 (간략화)
type Expr =
    | Var of string
    | Num of int
    | Add of Expr * Expr
    | Sub of Expr * Expr
    | Let of string * Expr * Expr
    | Lambda of string * Expr
    | App of Expr * Expr
    | If of Expr * Expr * Expr

// 자유 변수 분석
let rec freeVars (expr: Expr) : Set&lt;string&gt; =
    match expr with
    | Var(x) -&gt;
        // 변수 사용 = 자유 변수 후보
        Set.singleton x

    | Num(_) -&gt;
        // 리터럴 = 자유 변수 없음
        Set.empty

    | Add(e1, e2)
    | Sub(e1, e2) -&gt;
        // 이항 연산 = 양쪽의 자유 변수 합
        Set.union (freeVars e1) (freeVars e2)

    | Let(x, e1, e2) -&gt;
        // let x = e1 in e2
        // e1의 자유 변수 + (e2의 자유 변수 - {x})
        let fv1 = freeVars e1
        let fv2 = freeVars e2
        Set.union fv1 (Set.remove x fv2)

    | Lambda(param, body) -&gt;
        // fun param -&gt; body
        // body의 자유 변수 - {param}
        let fvBody = freeVars body
        Set.remove param fvBody

    | App(func, arg) -&gt;
        // f arg
        // f의 자유 변수 + arg의 자유 변수
        Set.union (freeVars func) (freeVars arg)

    | If(cond, thenExpr, elseExpr) -&gt;
        // if cond then thenExpr else elseExpr
        // 세 부분의 자유 변수 합
        freeVars cond
        |&gt; Set.union (freeVars thenExpr)
        |&gt; Set.union (freeVars elseExpr)
</code></pre>
<h3 id="예시-분석"><a class="header" href="#예시-분석">예시 분석</a></h3>
<p><strong>예시 1: 단순 람다</strong></p>
<pre><code class="language-fsharp">fun x -&gt; x + 1
</code></pre>
<p>분석:</p>
<pre><code>FV(fun x -&gt; x + 1)
= FV(x + 1) - {x}
= (FV(x) ∪ FV(1)) - {x}
= ({x} ∪ {}) - {x}
= {} (empty)
</code></pre>
<p><strong>결과: 자유 변수 없음</strong></p>
<p><strong>예시 2: 하나의 자유 변수</strong></p>
<pre><code class="language-fsharp">fun x -&gt; x + y
</code></pre>
<p>분석:</p>
<pre><code>FV(fun x -&gt; x + y)
= FV(x + y) - {x}
= (FV(x) ∪ FV(y)) - {x}
= ({x} ∪ {y}) - {x}
= {y}
</code></pre>
<p><strong>결과: 자유 변수 = {y}</strong></p>
<p><strong>예시 3: 중첩 람다</strong></p>
<pre><code class="language-fsharp">fun x -&gt; fun y -&gt; x + y + z
</code></pre>
<p>분석:</p>
<pre><code>내부: FV(fun y -&gt; x + y + z)
    = FV(x + y + z) - {y}
    = ({x} ∪ {y} ∪ {z}) - {y}
    = {x, z}

외부: FV(fun x -&gt; (fun y -&gt; x + y + z))
    = FV(fun y -&gt; ...) - {x}
    = {x, z} - {x}
    = {z}
</code></pre>
<p><strong>결과: 자유 변수 = {z}</strong></p>
<p><strong>예시 4: Let 바인딩</strong></p>
<pre><code class="language-fsharp">let a = 10 in
let b = a + 5 in
fun x -&gt; a + b + x
</code></pre>
<p>분석:</p>
<pre><code>1. FV(fun x -&gt; a + b + x) = {a, b}

2. FV(let b = a + 5 in (fun x -&gt; ...))
   = FV(a + 5) ∪ (FV(fun x -&gt; ...) - {b})
   = {a} ∪ ({a, b} - {b})
   = {a} ∪ {a}
   = {a}

3. FV(let a = 10 in (let b = ...))
   = FV(10) ∪ (FV(let b = ...) - {a})
   = {} ∪ ({a} - {a})
   = {} (empty)
</code></pre>
<p><strong>결과: 전체 표현식의 자유 변수 없음</strong> (모든 변수가 바인딩됨)</p>
<p>하지만 <code>fun x -&gt; a + b + x</code> 자체는 {a, b}를 캡처해야 한다.</p>
<h3 id="스코프와-섀도잉-shadowing"><a class="header" href="#스코프와-섀도잉-shadowing">스코프와 섀도잉 (Shadowing)</a></h3>
<p>섀도잉은 같은 이름의 변수를 재바인딩하는 것이다.</p>
<pre><code class="language-fsharp">let x = 10 in
let f = fun y -&gt; x + y in
let x = 20 in
f 5
</code></pre>
<p>분석:</p>
<pre><code>1. 내부 x: let x = 10 에서 바인딩
2. fun y -&gt; x + y: x는 첫 번째 x (10) 참조
3. 외부 x: let x = 20 에서 재바인딩 (다른 x)
4. f 5: f는 x = 10을 캡처한 클로저
</code></pre>
<p><strong>중요:</strong> 자유 변수 분석은 <strong>lexical scope</strong>을 따른다. 변수는 <strong>가장 가까운 바인딩 지점</strong>을 참조한다.</p>
<p>F# 구현에서 <code>Set.remove</code>가 이것을 처리한다:</p>
<ul>
<li><code>Let(x, e1, e2)</code>에서 <code>Set.remove x fv2</code></li>
<li><code>Lambda(x, body)</code>에서 <code>Set.remove x fvBody</code></li>
</ul>
<p><strong>예시: 중첩된 섀도잉</strong></p>
<pre><code class="language-fsharp">let x = 1 in
let f = fun y -&gt;
    let x = 2 in
    fun z -&gt; x + y + z
in
f 10 100
</code></pre>
<p>내부 람다 <code>fun z -&gt; x + y + z</code>:</p>
<ul>
<li>x: let x = 2 참조 (가장 가까운 바인딩)</li>
<li>y: fun y 참조</li>
<li>자유 변수: {x (inner), y}</li>
</ul>
<p>외부 람다 <code>fun y -&gt; let x = 2 in ...</code>:</p>
<ul>
<li>자유 변수: {x (outer)}</li>
</ul>
<p><strong>핵심:</strong> 각 바인딩 지점이 새로운 스코프를 생성한다.</p>
<h2 id="클로저-변환-closure-conversion"><a class="header" href="#클로저-변환-closure-conversion">클로저 변환 (Closure Conversion)</a></h2>
<p>자유 변수를 분석했으면, 이제 **클로저 변환(closure conversion)**을 적용한다. 클로저 변환은 <strong>암묵적 환경 캡처를 명시적으로 만드는 변환</strong>이다.</p>
<h3 id="변환-개념"><a class="header" href="#변환-개념">변환 개념</a></h3>
<p><strong>변환 전 (source code):</strong></p>
<pre><code class="language-fsharp">let x = 10 in
fun y -&gt; x + y
</code></pre>
<p><code>x</code>가 암묵적으로 캡처된다.</p>
<p><strong>변환 후 (closure-converted code):</strong></p>
<pre><code class="language-fsharp">// 의사 코드
let x = 10 in
let env = { x: x } in
let closure = { fn: lambda_0, env: env } in
closure

// lambda_0 정의:
fun lambda_0 (env, y) =
    let x = env.x in
    x + y
</code></pre>
<p><strong>변화:</strong></p>
<ol>
<li><strong>환경 생성</strong>: <code>env = { x: 10 }</code></li>
<li><strong>클로저 생성</strong>: <code>closure = { fn: lambda_0, env: env }</code></li>
<li><strong>함수 수정</strong>: 환경을 첫 번째 파라미터로 받음</li>
<li><strong>자유 변수 접근</strong>: 환경에서 로드 (<code>env.x</code>)</li>
</ol>
<h3 id="beforeafter-예시"><a class="header" href="#beforeafter-예시">Before/After 예시</a></h3>
<p><strong>예시 1: 단순 클로저</strong></p>
<p><strong>Before:</strong></p>
<pre><code class="language-fsharp">let make_adder n =
    fun x -&gt; x + n
</code></pre>
<p><strong>After:</strong></p>
<pre><code class="language-mlir">// make_adder 함수
func.func @make_adder(%n: i32) -&gt; !llvm.ptr {
    // 1. 환경 할당 (1개 변수)
    %env_size = arith.constant 16 : i64  // 8 (fn ptr) + 8 (n)
    %env_ptr = llvm.call @GC_malloc(%env_size) : (i64) -&gt; !llvm.ptr

    // 2. 함수 포인터 저장 (env[0])
    %fn_addr = llvm.mlir.addressof @lambda_adder : !llvm.ptr
    %fn_slot = llvm.getelementptr %env_ptr[0] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %fn_addr, %fn_slot : !llvm.ptr

    // 3. 캡처된 변수 저장 (env[1])
    %n_slot = llvm.getelementptr %env_ptr[1] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %n, %n_slot : i32, !llvm.ptr

    // 4. 환경 포인터 반환 (클로저)
    func.return %env_ptr : !llvm.ptr
}

// lambda_adder 함수 (환경 파라미터 추가)
func.func @lambda_adder(%env: !llvm.ptr, %x: i32) -&gt; i32 {
    // 1. 환경에서 n 로드
    %n_slot = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
    %n = llvm.load %n_slot : !llvm.ptr -&gt; i32

    // 2. x + n 계산
    %result = arith.addi %x, %n : i32
    func.return %result : i32
}
</code></pre>
<p><strong>핵심 변환:</strong></p>
<ul>
<li><code>fun x -&gt; x + n</code> → <code>func.func @lambda_adder(%env, %x)</code></li>
<li><code>n</code> 접근 → <code>llvm.load from env[1]</code></li>
<li>클로저 생성 → <code>GC_malloc</code> + store fn_ptr + store n</li>
</ul>
<p><strong>예시 2: 여러 변수 캡처</strong></p>
<p><strong>Before:</strong></p>
<pre><code class="language-fsharp">let x = 10 in
let y = 20 in
let z = 30 in
fun a -&gt; x + y + z + a
</code></pre>
<p><strong>After (환경 구조):</strong></p>
<pre><code class="language-c">// 환경 레이아웃
struct env {
    void* fn_ptr;   // [0] 함수 포인터
    i32 x;          // [1] 캡처된 x
    i32 y;          // [2] 캡처된 y
    i32 z;          // [3] 캡처된 z
};

// 환경 크기 = 8 + 4 + 4 + 4 = 20 바이트
</code></pre>
<pre><code class="language-mlir">func.func @lambda_xyz(%env: !llvm.ptr, %a: i32) -&gt; i32 {
    // x 로드
    %x_slot = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
    %x = llvm.load %x_slot : !llvm.ptr -&gt; i32

    // y 로드
    %y_slot = llvm.getelementptr %env[2] : (!llvm.ptr) -&gt; !llvm.ptr
    %y = llvm.load %y_slot : !llvm.ptr -&gt; i32

    // z 로드
    %z_slot = llvm.getelementptr %env[3] : (!llvm.ptr) -&gt; !llvm.ptr
    %z = llvm.load %z_slot : !llvm.ptr -&gt; i32

    // x + y + z + a
    %t1 = arith.addi %x, %y : i32
    %t2 = arith.addi %t1, %z : i32
    %result = arith.addi %t2, %a : i32
    func.return %result : i32
}
</code></pre>
<h3 id="환경-파라미터"><a class="header" href="#환경-파라미터">환경 파라미터</a></h3>
<p>클로저 변환 후, 모든 람다 함수는 <strong>환경을 첫 번째 파라미터로 받는다</strong>.</p>
<p><strong>일반 함수 (Phase 3):</strong></p>
<pre><code class="language-mlir">func.func @add(%x: i32, %y: i32) -&gt; i32 {
    %result = arith.addi %x, %y : i32
    func.return %result : i32
}
</code></pre>
<p><strong>클로저 함수 (Phase 4):</strong></p>
<pre><code class="language-mlir">func.func @lambda_closure(%env: !llvm.ptr, %x: i32, %y: i32) -&gt; i32 {
    // 환경에서 캡처된 변수 로드
    // ...
    func.return %result : i32
}
</code></pre>
<p><strong>차이:</strong></p>
<ul>
<li>일반 함수: 파라미터만</li>
<li>클로저 함수: <code>%env: !llvm.ptr</code> + 파라미터</li>
</ul>
<p><strong>환경 타입:</strong></p>
<p>환경은 <strong>opaque pointer</strong>로 표현된다: <code>!llvm.ptr</code></p>
<p>LLVM은 포인터 타입이 단순화되어, 모든 포인터가 <code>!llvm.ptr</code>이다. 내부 구조는 <code>getelementptr</code>의 인덱스로 관리한다.</p>
<h3 id="flat-environment-vs-linked-environment"><a class="header" href="#flat-environment-vs-linked-environment">Flat Environment vs Linked Environment</a></h3>
<p>환경을 표현하는 방법은 두 가지다:</p>
<p><strong>1. Flat environment (FunLang 선택):</strong></p>
<p>모든 캡처된 변수를 하나의 배열에 저장.</p>
<pre><code class="language-c">struct env {
    void* fn_ptr;
    int var1;
    int var2;
    int var3;
};
</code></pre>
<p><strong>장점:</strong></p>
<ul>
<li>O(1) 접근: <code>env[index]</code>로 직접 접근</li>
<li>메모리 효율: 하나의 할당</li>
<li>간단한 구현</li>
</ul>
<p><strong>단점:</strong></p>
<ul>
<li>중첩 클로저가 부모 환경을 통째로 복사해야 함</li>
</ul>
<p><strong>2. Linked environment (일부 컴파일러):</strong></p>
<p>환경을 체인으로 연결.</p>
<pre><code class="language-c">struct env {
    void* fn_ptr;
    struct env* parent;  // 부모 환경 포인터
    int var1;
};
</code></pre>
<p><strong>장점:</strong></p>
<ul>
<li>중첩 클로저가 부모 환경을 공유할 수 있음</li>
</ul>
<p><strong>단점:</strong></p>
<ul>
<li>O(depth) 접근: 체인을 따라 탐색</li>
<li>메모리 간접 참조 증가</li>
</ul>
<p><strong>FunLang 선택: Flat environment</strong></p>
<p>이유:</p>
<ol>
<li><strong>단순성</strong>: 구현이 간단함</li>
<li><strong>성능</strong>: O(1) 접근이 빠름</li>
<li><strong>교육 목적</strong>: 개념을 명확히 이해할 수 있음</li>
</ol>
<p>중첩 클로저는 드물고, 복사 오버헤드가 크지 않다.</p>
<h3 id="클로저-변환-요약"><a class="header" href="#클로저-변환-요약">클로저 변환 요약</a></h3>
<p>클로저 변환은 다음 단계를 수행한다:</p>
<ol>
<li><strong>자유 변수 분석</strong>: <code>freeVars(lambda)</code> → <code>{x, y, z}</code></li>
<li><strong>환경 크기 계산</strong>: <code>size = 8 (fn ptr) + 4*n (captured vars)</code></li>
<li><strong>환경 할당</strong>: <code>GC_malloc(size)</code> → heap 객체</li>
<li><strong>함수 포인터 저장</strong>: <code>env[0] = @lambda_N</code></li>
<li><strong>변수 저장</strong>: <code>env[1] = x</code>, <code>env[2] = y</code>, …</li>
<li><strong>함수 정의 수정</strong>: <code>lambda_N(env, params...)</code> 형태로 변환</li>
<li><strong>변수 접근 수정</strong>: <code>x</code> → <code>load from env[1]</code></li>
</ol>
<p>결과: 암묵적 캡처가 명시적 환경 조작으로 변환된다.</p>
<h2 id="ast-확장-lambda-표현식"><a class="header" href="#ast-확장-lambda-표현식">AST 확장: Lambda 표현식</a></h2>
<p>클로저를 컴파일하려면, AST에 <strong>Lambda</strong> 케이스를 추가해야 한다.</p>
<h3 id="expr-타입-확장-1"><a class="header" href="#expr-타입-확장-1">Expr 타입 확장</a></h3>
<pre><code class="language-fsharp">// Phase 3 AST (Chapter 10-11)
type Expr =
    | Var of string
    | Num of int
    | Add of Expr * Expr
    | Sub of Expr * Expr
    | Mul of Expr * Expr
    | Div of Expr * Expr
    | Eq of Expr * Expr
    | Lt of Expr * Expr
    | Let of string * Expr * Expr
    | If of Expr * Expr * Expr
    | App of string * Expr list  // 함수 호출: f(arg1, arg2, ...)

// Phase 4 AST (Chapter 12+)
type Expr =
    | Var of string
    | Num of int
    | Add of Expr * Expr
    | Sub of Expr * Expr
    | Mul of Expr * Expr
    | Div of Expr * Expr
    | Eq of Expr * Expr
    | Lt of Expr * Expr
    | Let of string * Expr * Expr
    | If of Expr * Expr * Expr
    | Lambda of string * Expr        // NEW: 람다 표현식
    | App of Expr * Expr             // CHANGED: 일반 함수 적용
</code></pre>
<p><strong>변경사항:</strong></p>
<ol>
<li>
<p><strong>Lambda 추가</strong>: <code>Lambda(param, body)</code></p>
<ul>
<li><code>param</code>: 파라미터 이름 (단일 파라미터, 다중 파라미터는 currying으로 표현)</li>
<li><code>body</code>: 함수 본체</li>
</ul>
</li>
<li>
<p><strong>App 변경</strong>: <code>App(Expr, Expr)</code> (함수 표현식 + 인자 표현식)</p>
<ul>
<li>Phase 3: <code>App(string, Expr list)</code> - 이름으로 함수 호출</li>
<li>Phase 4: <code>App(Expr, Expr)</code> - 표현식이 함수가 될 수 있음 (클로저 호출)</li>
</ul>
</li>
</ol>
<h3 id="lambda-예시"><a class="header" href="#lambda-예시">Lambda 예시</a></h3>
<p><strong>예시 1: 단순 람다</strong></p>
<pre><code class="language-fsharp">fun x -&gt; x + 1
</code></pre>
<p>AST:</p>
<pre><code class="language-fsharp">Lambda("x", Add(Var "x", Num 1))
</code></pre>
<p><strong>예시 2: 클로저</strong></p>
<pre><code class="language-fsharp">let y = 10 in
fun x -&gt; x + y
</code></pre>
<p>AST:</p>
<pre><code class="language-fsharp">Let("y", Num 10,
    Lambda("x", Add(Var "x", Var "y")))
</code></pre>
<p><strong>예시 3: 고차 함수</strong></p>
<pre><code class="language-fsharp">fun f -&gt; fun x -&gt; f x
</code></pre>
<p>AST:</p>
<pre><code class="language-fsharp">Lambda("f",
    Lambda("x",
        App(Var "f", Var "x")))
</code></pre>
<h3 id="currying으로-다중-파라미터-표현"><a class="header" href="#currying으로-다중-파라미터-표현">Currying으로 다중 파라미터 표현</a></h3>
<p>FunLang은 단일 파라미터 람다만 지원한다. 다중 파라미터는 <strong>currying</strong>으로 표현한다.</p>
<pre><code class="language-fsharp">// 다중 파라미터 (syntax sugar)
fun x y -&gt; x + y

// Currying (desugared)
fun x -&gt; fun y -&gt; x + y
</code></pre>
<p>AST:</p>
<pre><code class="language-fsharp">Lambda("x",
    Lambda("y",
        Add(Var "x", Var "y")))
</code></pre>
<p>이것이 표준 함수형 언어 패턴이다 (Haskell, OCaml, F#).</p>
<h3 id="parser-업데이트-개념"><a class="header" href="#parser-업데이트-개념">Parser 업데이트 (개념)</a></h3>
<p>Lambda를 파싱하려면, <code>fun</code> 키워드를 추가해야 한다.</p>
<pre><code class="language-fsharp">// LangTutorial의 parser.fsy에서
// (독자는 LangTutorial을 참고하여 자신의 parser를 업데이트)

Expr:
    | FUN ID ARROW Expr    { Lambda($2, $4) }
    | ...
</code></pre>
<p><strong>토큰:</strong></p>
<ul>
<li><code>FUN</code>: “fun” 키워드</li>
<li><code>ID</code>: 식별자</li>
<li><code>ARROW</code>: “-&gt;” 화살표</li>
<li><code>Expr</code>: 본체 표현식</li>
</ul>
<p><strong>결합 순서:</strong></p>
<ul>
<li><code>fun x -&gt; fun y -&gt; x + y</code>: 오른쪽 결합</li>
<li><code>f x y</code>: 왼쪽 결합 (App는 왼쪽 결합)</li>
</ul>
<h2 id="mlir-환경-구조체"><a class="header" href="#mlir-환경-구조체">MLIR 환경 구조체</a></h2>
<p>클로저의 핵심은 <strong>환경(environment)</strong> 구조체다. 환경은 캡처된 변수들을 저장하는 힙 객체다.</p>
<h3 id="환경-레이아웃"><a class="header" href="#환경-레이아웃">환경 레이아웃</a></h3>
<p>환경은 **헤테로지니어스 배열(heterogeneous array)**이다:</p>
<pre><code class="language-c">// C 스타일 표현
struct closure_env {
    void* fn_ptr;   // [0] 함수 포인터
    int var1;       // [1] 첫 번째 캡처된 변수
    int var2;       // [2] 두 번째 캡처된 변수
    // ...
};
</code></pre>
<p><strong>인덱스 규칙:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Index</th><th>Content</th><th>Type</th><th>Size</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>함수 포인터</td><td><code>!llvm.ptr</code></td><td>8 bytes</td></tr>
<tr><td>1</td><td>첫 번째 변수</td><td><code>i32</code></td><td>4 bytes</td></tr>
<tr><td>2</td><td>두 번째 변수</td><td><code>i32</code></td><td>4 bytes</td></tr>
<tr><td>…</td><td>…</td><td>…</td><td>…</td></tr>
</tbody>
</table>
</div>
<p><strong>상수 정의:</strong></p>
<pre><code class="language-fsharp">// F# 컴파일러에서
let ENV_FN_PTR = 0         // 함수 포인터 인덱스
let ENV_FIRST_VAR = 1      // 첫 번째 변수 인덱스
</code></pre>
<h3 id="llvm-struct-type"><a class="header" href="#llvm-struct-type">LLVM Struct Type</a></h3>
<p>MLIR에서 환경은 <code>!llvm.struct</code> 타입으로 표현할 수도 있지만, <strong>opaque pointer</strong> 방식이 더 간단하다.</p>
<p><strong>Opaque pointer 방식 (FunLang 선택):</strong></p>
<pre><code class="language-mlir">// 환경은 !llvm.ptr로 표현
// 내부 구조는 getelementptr 인덱스로 관리

%env_ptr = llvm.call @GC_malloc(%size) : (i64) -&gt; !llvm.ptr
%slot = llvm.getelementptr %env_ptr[index] : (!llvm.ptr) -&gt; !llvm.ptr
</code></pre>
<p><strong>장점:</strong></p>
<ul>
<li>타입 시스템이 간단함</li>
<li>동적 크기 환경 가능</li>
<li>getelementptr가 바이트 오프셋 자동 계산</li>
</ul>
<p><strong>Struct type 방식 (대안):</strong></p>
<pre><code class="language-mlir">// 환경 타입 정의
!env_type = !llvm.struct&lt;(ptr, i32, i32)&gt;

// 사용
%env = llvm.alloca : !llvm.ptr
%slot = llvm.getelementptr %env[0, 1] : (!llvm.ptr) -&gt; !llvm.ptr
</code></pre>
<p><strong>단점:</strong></p>
<ul>
<li>각 클로저마다 다른 타입 필요</li>
<li>타입 정의가 복잡함</li>
</ul>
<p><strong>FunLang 선택:</strong> Opaque pointer 방식</p>
<h3 id="getelementptr로-슬롯-접근"><a class="header" href="#getelementptr로-슬롯-접근">getelementptr로 슬롯 접근</a></h3>
<p><code>llvm.getelementptr</code>는 포인터 산술 연산이다. 배열 인덱스를 받아서 해당 위치의 포인터를 계산한다.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="language-mlir">%slot_ptr = llvm.getelementptr %base_ptr[index] : (!llvm.ptr) -&gt; !llvm.ptr
</code></pre>
<p><strong>예시:</strong></p>
<pre><code class="language-mlir">// 환경 포인터: %env
// 인덱스 1번 슬롯 접근 (첫 번째 변수)

%slot = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
%value = llvm.load %slot : !llvm.ptr -&gt; i32
</code></pre>
<p><strong>중요:</strong> getelementptr는 <strong>포인터만 계산</strong>한다. 실제 로드는 <code>llvm.load</code>로 수행한다.</p>
<p><strong>메모리 레이아웃 예시:</strong></p>
<pre><code>환경 메모리 (3개 변수 캡처):
Address     Content
0x1000      @lambda_N (fn ptr, 8 bytes)
0x1008      10 (var1, 4 bytes)
0x100C      20 (var2, 4 bytes)
0x1010      30 (var3, 4 bytes)

getelementptr %env[0]: 0x1000
getelementptr %env[1]: 0x1008
getelementptr %env[2]: 0x100C
getelementptr %env[3]: 0x1010
</code></pre>
<p><strong>바이트 정렬:</strong> LLVM이 자동으로 적절한 정렬을 수행한다.</p>
<h3 id="helper-함수-createclosureenv"><a class="header" href="#helper-함수-createclosureenv">Helper 함수: CreateClosureEnv</a></h3>
<p>환경 생성을 간단하게 만드는 helper 함수:</p>
<pre><code class="language-fsharp">// F# 컴파일러에서
let createClosureEnv (builder: OpBuilder) (fnAddr: MlirValue) (capturedVars: MlirValue list) : MlirValue =
    // 1. 환경 크기 계산
    let fnPtrSize = 8L  // 포인터 크기
    let varSize = 4L    // i32 크기
    let totalSize = fnPtrSize + (int64 capturedVars.Length) * varSize
    let sizeConst = builder.CreateI64Const(totalSize)

    // 2. GC_malloc 호출
    let envPtr = builder.CreateCall("GC_malloc", [sizeConst])

    // 3. 함수 포인터 저장
    let fnSlot = builder.CreateGEP(envPtr, 0)
    builder.CreateStore(fnAddr, fnSlot)

    // 4. 캡처된 변수들 저장
    capturedVars |&gt; List.iteri (fun i var -&gt;
        let slot = builder.CreateGEP(envPtr, i + 1)
        builder.CreateStore(var, slot)
    )

    // 5. 환경 포인터 반환
    envPtr
</code></pre>
<h3 id="helper-함수-getenvslot"><a class="header" href="#helper-함수-getenvslot">Helper 함수: GetEnvSlot</a></h3>
<p>환경에서 변수 로드를 간단하게:</p>
<pre><code class="language-fsharp">let getEnvSlot (builder: OpBuilder) (envPtr: MlirValue) (index: int) : MlirValue =
    // getelementptr + load
    let slot = builder.CreateGEP(envPtr, index)
    builder.CreateLoad(slot, "i32")
</code></pre>
<p>사용 예시:</p>
<pre><code class="language-fsharp">// 환경에서 첫 번째 변수 로드
let var1 = getEnvSlot builder envPtr ENV_FIRST_VAR
</code></pre>
<h2 id="클로저-생성-코드-closure-creation"><a class="header" href="#클로저-생성-코드-closure-creation">클로저 생성 코드 (Closure Creation)</a></h2>
<p>클로저 생성은 <strong>환경 할당 + 변수 저장 + 환경 포인터 반환</strong>이다.</p>
<h3 id="compilelambda-함수"><a class="header" href="#compilelambda-함수">compileLambda 함수</a></h3>
<pre><code class="language-fsharp">// Lambda 표현식 컴파일
let compileLambda (builder: OpBuilder) (env: Environment) (param: string) (body: Expr) : MlirValue =
    // 1. 자유 변수 분석
    let freeVarSet = freeVars (Lambda(param, body))
    let freeVarList = Set.toList freeVarSet

    // 2. 캡처된 변수들의 SSA 값 가져오기
    let capturedValues =
        freeVarList |&gt; List.map (fun varName -&gt;
            match env.TryFind(varName) with
            | Some(value) -&gt; value
            | None -&gt; failwithf "Undefined variable: %s" varName
        )

    // 3. 람다 함수 정의 생성
    let lambdaName = generateLambdaName()  // @lambda_0, @lambda_1, ...
    let lambdaFunc = createLambdaFunction builder lambdaName param body freeVarList env

    // 4. 함수 포인터 얻기
    let fnAddr = builder.CreateAddressOf(lambdaName)

    // 5. 환경 생성 및 변수 저장
    let envPtr = createClosureEnv builder fnAddr capturedValues

    // 6. 환경 포인터 반환 (이것이 클로저)
    envPtr
</code></pre>
<p><strong>핵심 단계:</strong></p>
<ol>
<li><strong>자유 변수 분석</strong>: <code>freeVars</code>로 캡처할 변수 찾기</li>
<li><strong>값 가져오기</strong>: 환경에서 SSA 값 로드</li>
<li><strong>람다 함수 정의</strong>: 별도 함수로 생성 (환경 파라미터 포함)</li>
<li><strong>함수 포인터</strong>: <code>llvm.mlir.addressof</code>로 주소 얻기</li>
<li><strong>환경 할당</strong>: <code>GC_malloc</code> + 변수 저장</li>
<li><strong>반환</strong>: 환경 포인터 (클로저 값)</li>
</ol>
<h3 id="createlambdafunction"><a class="header" href="#createlambdafunction">createLambdaFunction</a></h3>
<p>람다 함수를 별도 <code>func.func</code>로 정의:</p>
<pre><code class="language-fsharp">let createLambdaFunction (builder: OpBuilder) (name: string) (param: string) (body: Expr) (freeVars: string list) (outerEnv: Environment) : unit =
    // 1. 함수 시그니처: (%env: !llvm.ptr, %param: i32) -&gt; i32
    let paramTypes = [builder.GetPtrType(); builder.GetI32Type()]
    let returnType = builder.GetI32Type()

    // 2. 함수 생성
    let funcOp = builder.CreateFuncOp(name, paramTypes, returnType)
    let entryBlock = builder.GetEntryBlock(funcOp)
    builder.SetInsertionPoint(entryBlock)

    // 3. Block arguments 얻기
    let envArg = builder.GetBlockArg(entryBlock, 0)   // %env
    let paramArg = builder.GetBlockArg(entryBlock, 1)  // %param

    // 4. 환경 구축: 파라미터 + 캡처된 변수들
    let mutable lambdaEnv = Map.empty
    lambdaEnv &lt;- lambdaEnv.Add(param, paramArg)

    // 캡처된 변수들을 환경에서 로드
    freeVars |&gt; List.iteri (fun i varName -&gt;
        let value = getEnvSlot builder envArg (ENV_FIRST_VAR + i)
        lambdaEnv &lt;- lambdaEnv.Add(varName, value)
    )

    // 5. 본체 컴파일
    let bodyValue = compileExpr builder lambdaEnv body

    // 6. 반환
    builder.CreateFuncReturn(bodyValue)
</code></pre>
<p><strong>핵심:</strong></p>
<ul>
<li>환경 파라미터 <code>%env: !llvm.ptr</code>가 첫 번째</li>
<li>실제 파라미터 <code>%param: i32</code>가 두 번째</li>
<li>캡처된 변수들을 환경에서 로드하여 lambda 환경에 추가</li>
<li>본체 컴파일은 일반 표현식과 동일</li>
</ul>
<h3 id="전체-예시-make_adder-컴파일"><a class="header" href="#전체-예시-make_adder-컴파일">전체 예시: make_adder 컴파일</a></h3>
<p><strong>Source code:</strong></p>
<pre><code class="language-fsharp">let make_adder n =
    fun x -&gt; x + n
</code></pre>
<p><strong>AST:</strong></p>
<pre><code class="language-fsharp">Let("make_adder",
    Lambda("n",
        Lambda("x", Add(Var "x", Var "n"))),
    ...)
</code></pre>
<p><strong>Generated MLIR IR:</strong></p>
<pre><code class="language-mlir">// make_adder 함수
func.func @make_adder(%n: i32) -&gt; !llvm.ptr {
    // 내부 람다: fun x -&gt; x + n
    // 자유 변수: {n}

    // 1. 환경 크기 계산: 8 (fn ptr) + 4 (n) = 12 bytes
    %env_size = arith.constant 12 : i64

    // 2. GC_malloc 호출
    %env_ptr = llvm.call @GC_malloc(%env_size) : (i64) -&gt; !llvm.ptr

    // 3. 함수 포인터 저장
    %fn_addr = llvm.mlir.addressof @lambda_adder : !llvm.ptr
    %fn_slot = llvm.getelementptr %env_ptr[0] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %fn_addr, %fn_slot : !llvm.ptr, !llvm.ptr

    // 4. 캡처된 변수 n 저장
    %n_slot = llvm.getelementptr %env_ptr[1] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %n, %n_slot : i32, !llvm.ptr

    // 5. 환경 포인터 반환 (클로저)
    func.return %env_ptr : !llvm.ptr
}

// lambda_adder 함수
func.func @lambda_adder(%env: !llvm.ptr, %x: i32) -&gt; i32 {
    // 1. 환경에서 n 로드
    %n_slot = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
    %n = llvm.load %n_slot : !llvm.ptr -&gt; i32

    // 2. x + n 계산
    %result = arith.addi %x, %n : i32

    // 3. 반환
    func.return %result : i32
}
</code></pre>
<p><strong>코드 흐름:</strong></p>
<ol>
<li><code>make_adder</code> 호출: <code>make_adder(5)</code></li>
<li>환경 할당: <code>env = GC_malloc(12)</code></li>
<li>함수 포인터 저장: <code>env[0] = @lambda_adder</code></li>
<li><code>n</code> 저장: <code>env[1] = 5</code></li>
<li>클로저 반환: <code>env</code> (포인터)</li>
<li>나중에 클로저 호출: <code>closure(10)</code></li>
<li><code>lambda_adder</code> 호출: <code>@lambda_adder(env, 10)</code></li>
<li><code>n</code> 로드: <code>env[1]</code> → <code>5</code></li>
<li>계산: <code>10 + 5</code> → <code>15</code></li>
</ol>
<h2 id="클로저-본체-컴파일-closure-body"><a class="header" href="#클로저-본체-컴파일-closure-body">클로저 본체 컴파일 (Closure Body)</a></h2>
<p>클로저 본체는 <strong>lifted function</strong>으로 컴파일된다. Lifted function은 최상위 함수로 추출된 람다 함수다.</p>
<h3 id="lifting-개념"><a class="header" href="#lifting-개념">Lifting 개념</a></h3>
<p><strong>Before lifting (nested lambda):</strong></p>
<pre><code class="language-fsharp">let make_adder n =
    fun x -&gt; x + n
</code></pre>
<p><strong>After lifting (top-level functions):</strong></p>
<pre><code class="language-fsharp">// Lifted lambda
let lambda_adder (env, x) =
    let n = env[1] in
    x + n

// make_adder는 클로저 생성기
let make_adder n =
    let env = allocate_env(@lambda_adder, n) in
    env
</code></pre>
<p>모든 람다 함수가 최상위로 <strong>lift</strong>된다. 중첩된 함수가 flat structure로 변환된다.</p>
<h3 id="환경-파라미터-타입"><a class="header" href="#환경-파라미터-타입">환경 파라미터 타입</a></h3>
<p>Lifted function의 시그니처:</p>
<pre><code class="language-mlir">func.func @lambda_N(%env: !llvm.ptr, %param1: i32, %param2: i32, ...) -&gt; i32
</code></pre>
<p><strong>첫 번째 파라미터:</strong></p>
<ul>
<li>이름: <code>%env</code></li>
<li>타입: <code>!llvm.ptr</code> (opaque pointer)</li>
<li>목적: 캡처된 변수 접근</li>
</ul>
<p><strong>나머지 파라미터:</strong></p>
<ul>
<li>람다의 실제 파라미터들</li>
</ul>
<h3 id="환경에서-변수-로드"><a class="header" href="#환경에서-변수-로드">환경에서 변수 로드</a></h3>
<p>캡처된 변수를 사용하려면, 환경에서 로드해야 한다:</p>
<pre><code class="language-mlir">// 첫 번째 캡처된 변수 로드
%var1_slot = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
%var1 = llvm.load %var1_slot : !llvm.ptr -&gt; i32

// 두 번째 캡처된 변수 로드
%var2_slot = llvm.getelementptr %env[2] : (!llvm.ptr) -&gt; !llvm.ptr
%var2 = llvm.load %var2_slot : !llvm.ptr -&gt; i32
</code></pre>
<p><strong>패턴:</strong></p>
<ol>
<li><code>getelementptr</code>로 슬롯 포인터 계산</li>
<li><code>llvm.load</code>로 값 로드</li>
<li>SSA 값으로 사용</li>
</ol>
<h3 id="전체-예시-중첩-클로저"><a class="header" href="#전체-예시-중첩-클로저">전체 예시: 중첩 클로저</a></h3>
<p><strong>Source code:</strong></p>
<pre><code class="language-fsharp">let x = 10 in
let y = 20 in
fun z -&gt; x + y + z
</code></pre>
<p><strong>Lifted function:</strong></p>
<pre><code class="language-mlir">func.func @lambda_xyz(%env: !llvm.ptr, %z: i32) -&gt; i32 {
    // 1. x 로드 (env[1])
    %x_slot = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
    %x = llvm.load %x_slot : !llvm.ptr -&gt; i32

    // 2. y 로드 (env[2])
    %y_slot = llvm.getelementptr %env[2] : (!llvm.ptr) -&gt; !llvm.ptr
    %y = llvm.load %y_slot : !llvm.ptr -&gt; i32

    // 3. x + y 계산
    %t1 = arith.addi %x, %y : i32

    // 4. t1 + z 계산
    %result = arith.addi %t1, %z : i32

    // 5. 반환
    func.return %result : i32
}
</code></pre>
<p><strong>클로저 생성 부분:</strong></p>
<pre><code class="language-mlir">func.func @main() -&gt; i32 {
    // 1. x, y 정의
    %x = arith.constant 10 : i32
    %y = arith.constant 20 : i32

    // 2. 환경 크기: 8 (fn ptr) + 4 (x) + 4 (y) = 16 bytes
    %env_size = arith.constant 16 : i64

    // 3. 환경 할당
    %env = llvm.call @GC_malloc(%env_size) : (i64) -&gt; !llvm.ptr

    // 4. 함수 포인터 저장
    %fn = llvm.mlir.addressof @lambda_xyz : !llvm.ptr
    %fn_slot = llvm.getelementptr %env[0] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %fn, %fn_slot : !llvm.ptr, !llvm.ptr

    // 5. x 저장
    %x_slot = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %x, %x_slot : i32, !llvm.ptr

    // 6. y 저장
    %y_slot = llvm.getelementptr %env[2] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %y, %y_slot : i32, !llvm.ptr

    // 7. 클로저 호출 (나중에 Chapter 13에서)
    // %result = call_closure %env (%z)

    func.return %0 : i32
}
</code></pre>
<h3 id="함수-명명-규칙"><a class="header" href="#함수-명명-규칙">함수 명명 규칙</a></h3>
<p>Lifted function의 이름은 자동 생성된다:</p>
<pre><code class="language-fsharp">let mutable lambdaCounter = 0

let generateLambdaName() =
    let name = sprintf "lambda_%d" lambdaCounter
    lambdaCounter &lt;- lambdaCounter + 1
    name
</code></pre>
<p><strong>예시:</strong></p>
<ul>
<li>첫 번째 람다: <code>@lambda_0</code></li>
<li>두 번째 람다: <code>@lambda_1</code></li>
<li>…</li>
</ul>
<p><strong>중요:</strong> 이름은 unique해야 한다. 같은 이름의 함수가 여러 개 있으면 링커 오류가 발생한다.</p>
<h2 id="공통-오류-common-errors"><a class="header" href="#공통-오류-common-errors">공통 오류 (Common Errors)</a></h2>
<p>클로저 컴파일에서 자주 발생하는 오류들:</p>
<h3 id="error-1-환경-인덱스-off-by-one"><a class="header" href="#error-1-환경-인덱스-off-by-one">Error 1: 환경 인덱스 off-by-one</a></h3>
<p><strong>증상:</strong></p>
<pre><code class="language-mlir">// 잘못된 코드 - 함수 포인터를 변수로 로드
%var1_slot = llvm.getelementptr %env[0] : (!llvm.ptr) -&gt; !llvm.ptr
%var1 = llvm.load %var1_slot : !llvm.ptr -&gt; i32  // ERROR: 타입 불일치!
</code></pre>
<p><strong>원인:</strong></p>
<p>환경 레이아웃을 잊음:</p>
<ul>
<li><code>env[0]</code>: 함수 포인터 (<code>!llvm.ptr</code>)</li>
<li><code>env[1]</code>: 첫 번째 변수 (<code>i32</code>)</li>
<li><code>env[2]</code>: 두 번째 변수 (<code>i32</code>)</li>
</ul>
<p><strong>해결:</strong></p>
<pre><code class="language-mlir">// 올바른 코드 - 첫 번째 변수는 env[1]
%var1_slot = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
%var1 = llvm.load %var1_slot : !llvm.ptr -&gt; i32  // OK
</code></pre>
<p><strong>팁:</strong> <code>ENV_FN_PTR = 0</code>, <code>ENV_FIRST_VAR = 1</code> 상수 사용하기.</p>
<h3 id="error-2-환경-파라미터-누락"><a class="header" href="#error-2-환경-파라미터-누락">Error 2: 환경 파라미터 누락</a></h3>
<p><strong>증상:</strong></p>
<pre><code class="language-mlir">// 잘못된 코드 - 환경 파라미터 없음
func.func @lambda_adder(%x: i32) -&gt; i32 {
    %n = ??? // n을 어디서 가져오나?
}
</code></pre>
<p><strong>원인:</strong></p>
<p>Lifted function에 환경 파라미터를 추가하지 않음.</p>
<p><strong>해결:</strong></p>
<pre><code class="language-mlir">// 올바른 코드 - 환경 파라미터 추가
func.func @lambda_adder(%env: !llvm.ptr, %x: i32) -&gt; i32 {
    %n_slot = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
    %n = llvm.load %n_slot : !llvm.ptr -&gt; i32
    // ...
}
</code></pre>
<p><strong>팁:</strong> 모든 람다 함수는 첫 번째 파라미터로 <code>%env: !llvm.ptr</code>를 받는다.</p>
<h3 id="error-3-스택-vs-힙-할당"><a class="header" href="#error-3-스택-vs-힙-할당">Error 3: 스택 vs 힙 할당</a></h3>
<p><strong>증상:</strong></p>
<pre><code class="language-mlir">// 잘못된 코드 - 스택 할당
%env = llvm.alloca 16, i8 : (i32, i8) -&gt; !llvm.ptr
// ...
func.return %env : !llvm.ptr  // ERROR: 스택 메모리를 반환!
</code></pre>
<p><strong>원인:</strong></p>
<p>환경을 스택에 할당했는데, 함수 반환 후 사라진다.</p>
<p><strong>해결:</strong></p>
<pre><code class="language-mlir">// 올바른 코드 - 힙 할당
%env_size = arith.constant 16 : i64
%env = llvm.call @GC_malloc(%env_size) : (i64) -&gt; !llvm.ptr
func.return %env : !llvm.ptr  // OK: 힙 메모리는 살아있음
</code></pre>
<p><strong>원칙:</strong></p>
<ul>
<li><strong>스택 할당 (<code>llvm.alloca</code>)</strong>: 함수 로컬 변수 (현재 스택 프레임에서만 유효)</li>
<li><strong>힙 할당 (<code>GC_malloc</code>)</strong>: 탈출하는 값 (함수 반환 후에도 유효)</li>
</ul>
<p>클로저는 항상 <strong>힙 할당</strong>해야 한다. 클로저가 생성된 함수가 반환된 후에도 사용되기 때문이다.</p>
<h3 id="error-4-타입-불일치"><a class="header" href="#error-4-타입-불일치">Error 4: 타입 불일치</a></h3>
<p><strong>증상:</strong></p>
<pre><code class="language-mlir">// 잘못된 코드
%fn_addr = llvm.mlir.addressof @lambda_0 : !llvm.ptr
%fn_slot = llvm.getelementptr %env[0] : (!llvm.ptr) -&gt; !llvm.ptr
llvm.store %fn_addr, %fn_slot : i32, !llvm.ptr  // ERROR: 타입 불일치!
</code></pre>
<p><strong>원인:</strong></p>
<p>함수 포인터 타입을 <code>i32</code>로 잘못 지정.</p>
<p><strong>해결:</strong></p>
<pre><code class="language-mlir">// 올바른 코드
%fn_addr = llvm.mlir.addressof @lambda_0 : !llvm.ptr
%fn_slot = llvm.getelementptr %env[0] : (!llvm.ptr) -&gt; !llvm.ptr
llvm.store %fn_addr, %fn_slot : !llvm.ptr, !llvm.ptr  // OK
</code></pre>
<p><strong>타입 체크:</strong></p>
<ul>
<li>함수 포인터: <code>!llvm.ptr</code></li>
<li>i32 변수: <code>i32</code></li>
<li><code>llvm.store</code> 시그니처: <code>llvm.store %value, %ptr : value_type, !llvm.ptr</code></li>
</ul>
<h2 id="요약"><a class="header" href="#요약">요약</a></h2>
<p><strong>이 장에서 배운 것:</strong></p>
<ol>
<li>
<p><strong>클로저 이론</strong></p>
<ul>
<li>Lexical scoping: 정의 시점의 환경을 기억</li>
<li>Free variables: 람다에서 바인딩되지 않은 변수</li>
<li>Bound variables: 람다 파라미터로 바인딩된 변수</li>
<li>환경 캡처: 자유 변수의 값을 저장</li>
</ul>
</li>
<li>
<p><strong>자유 변수 분석</strong></p>
<ul>
<li>Set-based traversal 알고리즘</li>
<li><code>FV(Lambda(x, body)) = FV(body) - {x}</code></li>
<li>F# 구현: <code>freeVars</code> 재귀 함수</li>
</ul>
</li>
<li>
<p><strong>클로저 변환</strong></p>
<ul>
<li>암묵적 캡처 → 명시적 환경 조작</li>
<li>Flat environment: 모든 변수를 배열에 저장</li>
<li>Lifted functions: 람다를 최상위 함수로 추출</li>
</ul>
</li>
<li>
<p><strong>환경 구조체</strong></p>
<ul>
<li>레이아웃: <code>[fn_ptr, var1, var2, ...]</code></li>
<li><code>env[0]</code>: 함수 포인터</li>
<li><code>env[1+]</code>: 캡처된 변수들</li>
<li><code>getelementptr</code>로 슬롯 접근</li>
</ul>
</li>
<li>
<p><strong>클로저 생성 코드</strong></p>
<ul>
<li><code>GC_malloc</code>로 환경 힙 할당</li>
<li>함수 포인터 저장 (<code>llvm.mlir.addressof</code>)</li>
<li>캡처된 변수들 저장 (<code>llvm.store</code>)</li>
<li>환경 포인터 반환 (클로저 값)</li>
</ul>
</li>
<li>
<p><strong>클로저 본체 컴파일</strong></p>
<ul>
<li>Lifted function: <code>@lambda_N(%env, %params...)</code></li>
<li>환경 파라미터를 첫 번째로 받음</li>
<li><code>getelementptr</code> + <code>llvm.load</code>로 변수 접근</li>
</ul>
</li>
</ol>
<p><strong>다음 장 (Chapter 13):</strong></p>
<ul>
<li><strong>고차 함수 (Higher-order functions)</strong>: 함수를 인자로 받거나 반환</li>
<li><strong>클로저 호출</strong>: 환경 포인터에서 함수 포인터 추출 + 간접 호출</li>
<li><strong>Map/Filter/Fold</strong>: 표준 고차 함수 구현</li>
<li><strong>Function 타입</strong>: 함수를 first-class value로 취급</li>
</ul>
<p>클로저는 함수형 프로그래밍의 핵심이다. 이 장에서 확립한 환경 캡처 메커니즘이 고차 함수의 기초가 된다.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-13-고차-함수-higher-order-functions"><a class="header" href="#chapter-13-고차-함수-higher-order-functions">Chapter 13: 고차 함수 (Higher-Order Functions)</a></h1>
<h2 id="소개-13"><a class="header" href="#소개-13">소개</a></h2>
<p>**고차 함수(higher-order function, HOF)**는 함수를 **일급 값(first-class value)**으로 다루는 함수다:</p>
<ol>
<li><strong>함수를 인자로 받는 함수</strong>: <code>apply f x = f x</code></li>
<li><strong>함수를 반환하는 함수</strong>: <code>makeAdder n = fun x -&gt; x + n</code></li>
</ol>
<pre><code class="language-fsharp">// 고차 함수 예시
let apply f x = f x           // 함수를 인자로 받는다
let twice f x = f (f x)       // 함수를 두 번 적용한다
let compose f g x = f (g x)   // 함수 합성

let inc x = x + 1
let result = twice inc 10     // 결과: 12
</code></pre>
<p><strong>왜 고차 함수가 중요한가?</strong></p>
<ol>
<li><strong>추상화(Abstraction)</strong>: 공통 패턴을 재사용 가능하게 만든다 (map, filter, fold)</li>
<li><strong>합성(Composition)</strong>: 작은 함수를 조합해 복잡한 동작을 만든다</li>
<li><strong>지연 평가(Lazy evaluation)</strong>: 계산을 함수로 감싸서 나중에 실행할 수 있다</li>
<li><strong>콜백 패턴</strong>: 비동기 작업, 이벤트 처리에 필수</li>
</ol>
<p><strong>고차 함수 vs 일반 함수:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>일반 함수 (Phase 3)</th><th>고차 함수 (Phase 4)</th></tr>
</thead>
<tbody>
<tr><td>데이터를 인자로 받는다</td><td>함수를 인자로 받는다</td></tr>
<tr><td>데이터를 반환한다</td><td>함수를 반환할 수 있다</td></tr>
<tr><td>직접 호출 (<code>func.call @symbol</code>)</td><td>간접 호출 (function pointer)</td></tr>
<tr><td>타입: <code>int -&gt; int</code></td><td>타입: <code>(int -&gt; int) -&gt; int</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Chapter 13의 목표:</strong></p>
<p>이 장을 마치면 다음을 컴파일할 수 있다:</p>
<pre><code class="language-fsharp">// 함수를 인자로 받기
let apply f x = f x
let result1 = apply inc 42   // 43

// 함수를 반환하기
let makeAdder n = fun x -&gt; x + n
let add5 = makeAdder 5
let result2 = add5 10        // 15

// 함수 합성
let compose f g x = f (g x)
let inc x = x + 1
let double x = x * 2
let incThenDouble = compose double inc
let result3 = incThenDouble 5   // 12
</code></pre>
<p><strong>Chapter 13의 범위:</strong></p>
<ol>
<li><strong>함수를 일급 값으로 다루기</strong>: 클로저가 함수의 런타임 표현이다</li>
<li><strong>간접 호출(Indirect call) 패턴</strong>: <code>llvm.call</code>로 함수 포인터를 호출한다</li>
<li><strong>Apply 함수</strong>: 가장 단순한 고차 함수</li>
<li><strong>Compose 함수</strong>: 여러 함수 인자를 다루기</li>
<li><strong>함수를 반환하기</strong>: makeAdder 패턴, upward funarg problem</li>
<li><strong>커링(Currying)</strong>: 다중 인자 함수를 중첩 클로저로 표현</li>
<li><strong>메모리 관리</strong>: GC가 클로저 생명주기를 처리한다</li>
<li><strong>Complete 예시</strong>: map 함수 (개념적, Phase 6에서 완전 구현)</li>
</ol>
<p><strong>Prerequisites:</strong></p>
<ul>
<li><strong>Chapter 12 (Closures)</strong>: 클로저 표현, 환경 구조, 자유 변수 분석</li>
<li>Phase 3 함수 (이름 있는 함수, func.call)</li>
<li>Phase 2 메모리 관리 (GC_malloc, 힙 할당)</li>
</ul>
<p>이 장은 <strong>클로저 + 고차 함수 = 함수형 프로그래밍 핵심</strong>을 완성한다.</p>
<h2 id="함수를-일급-값으로-다루기"><a class="header" href="#함수를-일급-값으로-다루기">함수를 일급 값으로 다루기</a></h2>
<h3 id="first-class-functions"><a class="header" href="#first-class-functions">First-Class Functions</a></h3>
<p>**일급 값(first-class value)**이란:</p>
<ol>
<li>변수에 할당할 수 있다</li>
<li>함수 인자로 전달할 수 있다</li>
<li>함수 반환값으로 반환할 수 있다</li>
<li>데이터 구조에 저장할 수 있다</li>
</ol>
<p>FunLang에서 <strong>함수는 일급 값이다</strong>:</p>
<pre><code class="language-fsharp">// 1. 변수에 할당
let f = fun x -&gt; x + 1

// 2. 함수 인자로 전달
let apply g x = g x
let result = apply f 10   // 11

// 3. 함수 반환값으로 반환
let makeAdder n = fun x -&gt; x + n
let add5 = makeAdder 5

// 4. 데이터 구조에 저장 (Phase 6에서 리스트 구현 후)
// let funcs = [inc; double; square]
</code></pre>
<p><strong>일급 함수의 런타임 표현:</strong></p>
<p>Chapter 12에서 배운 <strong>클로저</strong>가 바로 함수의 런타임 표현이다:</p>
<pre><code>Closure = (function_pointer, environment_pointer)
</code></pre>
<ul>
<li><code>function_pointer</code>: 실행할 코드 (lifted function의 주소)</li>
<li><code>environment_pointer</code>: 캡처된 변수들 (힙에 할당된 환경)</li>
</ul>
<p><strong>모든 함수가 클로저인가?</strong></p>
<p>논리적으로는 YES. 실제로는 최적화로 구분된다:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>함수 종류</th><th>환경</th><th>표현</th><th>예시</th></tr>
</thead>
<tbody>
<tr><td><strong>Top-level named</strong></td><td>비어있음</td><td>함수 포인터만</td><td><code>let add x y = x + y</code></td></tr>
<tr><td><strong>Lambda (no capture)</strong></td><td>비어있음</td><td>함수 포인터만</td><td><code>fun x -&gt; x + 1</code></td></tr>
<tr><td><strong>Lambda (capture)</strong></td><td>변수 캡처</td><td>클로저 (ptr, env)</td><td><code>fun x -&gt; x + n</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Uniform representation:</strong></p>
<p>컴파일러 구현을 단순화하기 위해, <strong>모든 함수를 클로저로 표현</strong>할 수 있다:</p>
<ul>
<li>Top-level 함수: 환경이 null이거나 빈 환경</li>
<li>캡처 없는 람다: 환경이 빈 환경</li>
<li>캡처 있는 람다: 환경에 변수 저장</li>
</ul>
<p>이 장에서는 <strong>uniform representation</strong>을 사용한다. 모든 함수는 <code>(fn_ptr, env_ptr)</code> 쌍이다.</p>
<h3 id="named-functions-vs-anonymous-lambdas"><a class="header" href="#named-functions-vs-anonymous-lambdas">Named Functions vs Anonymous Lambdas</a></h3>
<p><strong>Named function (Phase 3 스타일):</strong></p>
<pre><code class="language-fsharp">let inc x = x + 1
</code></pre>
<p>컴파일 결과:</p>
<pre><code class="language-mlir">func.func @inc(%x: i32) -&gt; i32 {
    %c1 = arith.constant 1 : i32
    %result = arith.addi %x, %c1 : i32
    func.return %result : i32
}
</code></pre>
<ul>
<li>MLIR 심볼 <code>@inc</code>로 직접 참조 가능</li>
<li><code>func.call @inc(%arg)</code> 직접 호출</li>
</ul>
<p><strong>Anonymous lambda (Chapter 12 스타일):</strong></p>
<pre><code class="language-fsharp">fun x -&gt; x + 1
</code></pre>
<p>컴파일 결과:</p>
<pre><code class="language-mlir">// Lifted function
func.func @lambda_0(%env: !llvm.ptr, %x: i32) -&gt; i32 {
    %c1 = arith.constant 1 : i32
    %result = arith.addi %x, %c1 : i32
    func.return %result : i32
}

// Closure 생성 (호출 지점에서)
%c0 = arith.constant 0 : i64
%env_size = arith.constant 8 : i64  // 환경 없음, fn_ptr만
%env = llvm.call @GC_malloc(%env_size) : (i64) -&gt; !llvm.ptr
%fn_ptr = llvm.mlir.addressof @lambda_0 : !llvm.ptr
llvm.store %fn_ptr, %env : !llvm.ptr, !llvm.ptr
// %env가 클로저다
</code></pre>
<p><strong>Named function을 클로저로 wrapping:</strong></p>
<p>Named function도 고차 함수에 전달하려면 클로저로 감싸야 한다:</p>
<pre><code class="language-fsharp">let inc x = x + 1        // Named function
let apply f x = f x      // HOF
let result = apply inc 42   // inc를 클로저로 wrap
</code></pre>
<p>컴파일:</p>
<pre><code class="language-mlir">// Named function (그대로)
func.func @inc(%x: i32) -&gt; i32 { ... }

// inc를 클로저로 wrap
%env_size = arith.constant 8 : i64
%env = llvm.call @GC_malloc(%env_size) : (i64) -&gt; !llvm.ptr
%fn_ptr = llvm.mlir.addressof @inc : !llvm.ptr
llvm.store %fn_ptr, %env : !llvm.ptr, !llvm.ptr
%closure_inc = %env : !llvm.ptr

// apply에 전달
%result = func.call @apply(%closure_inc, %c42) : (!llvm.ptr, i32) -&gt; i32
</code></pre>
<p><strong>요약:</strong></p>
<ul>
<li><strong>Named function</strong>: MLIR 심볼로 정의, 직접 호출 가능</li>
<li><strong>Anonymous lambda</strong>: 항상 클로저로 표현</li>
<li><strong>Named function을 HOF에 전달</strong>: 클로저로 wrapping 필요</li>
<li><strong>Uniform representation</strong>: 모두 <code>!llvm.ptr</code> (클로저 포인터)로 표현</li>
</ul>
<h2 id="클로저-호출-간접-호출-패턴"><a class="header" href="#클로저-호출-간접-호출-패턴">클로저 호출: 간접 호출 패턴</a></h2>
<h3 id="direct-call-vs-indirect-call"><a class="header" href="#direct-call-vs-indirect-call">Direct Call vs Indirect Call</a></h3>
<p><strong>Direct call (Phase 3):</strong></p>
<pre><code class="language-mlir">%result = func.call @inc(%x) : (i32) -&gt; i32
</code></pre>
<ul>
<li>호출 대상이 <strong>컴파일 타임에 결정</strong>됨 (<code>@inc</code> 심볼)</li>
<li>최적화 가능 (인라이닝, 특수화)</li>
</ul>
<p><strong>Indirect call (Phase 4):</strong></p>
<pre><code class="language-mlir">%fn_ptr = /* 클로저에서 추출 */
%result = llvm.call %fn_ptr(%closure, %x) : !llvm.ptr, (i32) -&gt; i32
</code></pre>
<ul>
<li>호출 대상이 <strong>런타임에 결정</strong>됨 (함수 포인터)</li>
<li>최적화 어려움 (가상 함수처럼 동작)</li>
</ul>
<p><strong>왜 간접 호출이 필요한가?</strong></p>
<p>고차 함수는 <strong>어떤 함수가 전달될지 컴파일 타임에 모른다</strong>:</p>
<pre><code class="language-fsharp">let apply f x = f x   // f는 런타임에 결정된다

apply inc 10      // f = inc
apply double 10   // f = double
</code></pre>
<p>컴파일러는 <code>f</code>가 무엇인지 모르므로, <strong>간접 호출</strong>을 생성해야 한다.</p>
<h3 id="간접-호출-패턴-indirect-call-pattern"><a class="header" href="#간접-호출-패턴-indirect-call-pattern">간접 호출 패턴 (Indirect Call Pattern)</a></h3>
<p>클로저를 호출하는 3단계:</p>
<p><strong>1. 함수 포인터 추출:</strong></p>
<p>환경의 slot 0에서 함수 포인터를 로드한다:</p>
<pre><code class="language-mlir">// %closure: !llvm.ptr (클로저 포인터)
%c0 = arith.constant 0 : i64
%fn_ptr_addr = llvm.getelementptr %closure[0, %c0] : (!llvm.ptr, i64) -&gt; !llvm.ptr
%fn_ptr = llvm.load %fn_ptr_addr : !llvm.ptr -&gt; !llvm.ptr
</code></pre>
<p><strong>2. 인자 준비:</strong></p>
<ul>
<li><strong>첫 번째 인자</strong>: 클로저 자신 (환경 포인터)</li>
<li><strong>나머지 인자</strong>: 원래 함수 파라미터</li>
</ul>
<pre><code class="language-mlir">%env = %closure : !llvm.ptr   // 클로저 = 환경
%arg1 = %x : i32               // 실제 인자
</code></pre>
<p><strong>3. 간접 호출:</strong></p>
<p>함수 포인터를 통해 호출한다:</p>
<pre><code class="language-mlir">%result = llvm.call %fn_ptr(%env, %arg1) : !llvm.ptr, (i32) -&gt; i32
</code></pre>
<p><strong>완전한 예시:</strong></p>
<pre><code class="language-mlir">// 클로저 %closure를 호출: closure(42)
%c0 = arith.constant 0 : i64
%c42 = arith.constant 42 : i32

// Step 1: 함수 포인터 추출
%fn_ptr_addr = llvm.getelementptr %closure[0, %c0] : (!llvm.ptr, i64) -&gt; !llvm.ptr
%fn_ptr = llvm.load %fn_ptr_addr : !llvm.ptr -&gt; !llvm.ptr

// Step 2: 인자 준비
%env = %closure : !llvm.ptr

// Step 3: 간접 호출
%result = llvm.call %fn_ptr(%env, %c42) : !llvm.ptr, (i32) -&gt; i32
</code></pre>
<h3 id="f-helper-callclosure"><a class="header" href="#f-helper-callclosure">F# Helper: CallClosure</a></h3>
<p>반복되는 패턴을 헬퍼 함수로 추출한다:</p>
<pre><code class="language-fsharp">type OpBuilder with
    /// 클로저를 간접 호출한다
    /// closure: !llvm.ptr (클로저 포인터)
    /// args: 함수 인자들 (환경 제외)
    /// Returns: 함수 호출 결과
    member this.CallClosure(closure: MlirValue, args: MlirValue list, resultType: MlirType) : MlirValue =
        // 1. 함수 포인터 추출
        let c0 = this.ConstantInt(0L, 64)
        let fnPtrAddr = this.CreateGEP(closure, [c0])
        let fnPtr = this.CreateLoad(this.PtrType(), fnPtrAddr)

        // 2. 인자 리스트 구성 (환경 + 원래 인자)
        let allArgs = closure :: args

        // 3. 간접 호출
        this.CreateLLVMCall(fnPtr, allArgs, resultType)
</code></pre>
<p><strong>사용 예시:</strong></p>
<pre><code class="language-fsharp">// compileExpr에서 클로저 호출
| App(funcExpr, argExpr) -&gt;
    let funcVal = compileExpr builder env funcExpr
    let argVal = compileExpr builder env argExpr

    // funcVal은 클로저 (!llvm.ptr)
    // argVal은 인자 (i32)
    builder.CallClosure(funcVal, [argVal], builder.IntType(32))
</code></pre>
<p><strong>간접 호출의 비용:</strong></p>
<ul>
<li><strong>성능</strong>: 직접 호출보다 느리다 (포인터 로드, 인라이닝 불가)</li>
<li><strong>유연성</strong>: 런타임에 함수 선택 가능 (고차 함수의 핵심)</li>
</ul>
<p><strong>최적화 가능성:</strong></p>
<ul>
<li><strong>인라이닝</strong>: 클로저가 상수라면 특수화 가능</li>
<li><strong>Devirtualization</strong>: 타입 분석으로 호출 대상 추론</li>
<li>Phase 4는 최적화 없이 단순 구현만 한다</li>
</ul>
<h2 id="apply-함수"><a class="header" href="#apply-함수">Apply 함수</a></h2>
<h3 id="apply의-의미"><a class="header" href="#apply의-의미">Apply의 의미</a></h3>
<p><strong>Apply 함수</strong>는 가장 단순한 고차 함수다:</p>
<pre><code class="language-fsharp">let apply f x = f x
</code></pre>
<ul>
<li>타입: <code>(a -&gt; b) -&gt; a -&gt; b</code></li>
<li>의미: 함수 <code>f</code>를 인자 <code>x</code>에 적용한다</li>
</ul>
<p><strong>왜 apply가 유용한가?</strong></p>
<p>일견 쓸모없어 보인다 (<code>f x</code>와 <code>apply f x</code>는 같다). 하지만:</p>
<ol>
<li><strong>HOF 테스트</strong>: 가장 단순한 고차 함수로 컴파일러 검증</li>
<li><strong>파이프라인</strong>: <code>x |&gt; apply f</code> 스타일 (Phase 7 파이프 연산자)</li>
<li><strong>교육적</strong>: 간접 호출 패턴을 명확히 보여줌</li>
</ol>
<p><strong>Apply 예시:</strong></p>
<pre><code class="language-fsharp">let inc x = x + 1
let double x = x * 2

let result1 = apply inc 42      // 43
let result2 = apply double 10   // 20
</code></pre>
<h3 id="apply-컴파일-f-구현"><a class="header" href="#apply-컴파일-f-구현">Apply 컴파일: F# 구현</a></h3>
<p><strong>AST 표현:</strong></p>
<pre><code class="language-fsharp">// apply f x = f x
Let("apply",
    Lambda("f",
        Lambda("x",
            App(Var "f", Var "x"))),
    ...)
</code></pre>
<p><strong>컴파일 단계:</strong></p>
<ol>
<li><strong>외부 람다</strong>: <code>fun f -&gt; ...</code> (f를 캡처)</li>
<li><strong>내부 람다</strong>: <code>fun x -&gt; f x</code> (f 사용)</li>
<li><strong>App</strong>: <code>f x</code> (간접 호출)</li>
</ol>
<p><strong>F# 컴파일 함수:</strong></p>
<pre><code class="language-fsharp">let rec compileExpr (builder: OpBuilder) (env: Map&lt;string, MlirValue&gt;) (expr: Expr) : MlirValue =
    match expr with
    // ... (기존 케이스들)

    | App(funcExpr, argExpr) -&gt;
        // funcExpr를 평가 -&gt; 클로저
        let closureVal = compileExpr builder env funcExpr

        // argExpr를 평가 -&gt; 인자
        let argVal = compileExpr builder env argExpr

        // 클로저 간접 호출
        builder.CallClosure(closureVal, [argVal], builder.IntType(32))
</code></pre>
<p><strong>Apply 전체 컴파일:</strong></p>
<pre><code class="language-fsharp">// let apply f x = f x
let compileApply (builder: OpBuilder) : MlirValue =
    // Lifted inner function: fun(env, x) -&gt; env[1](x)
    //   env[0] = fn_ptr (inner)
    //   env[1] = f (captured)
    let innerFunc = builder.CreateFunction("apply_inner",
        [builder.PtrType(); builder.IntType(32)],
        builder.IntType(32))

    // Inner function body
    builder.WithInsertionPoint(innerFunc, fun () -&gt;
        let env = innerFunc.GetArgument(0)
        let x = innerFunc.GetArgument(1)

        // Load captured f from env[1]
        let c1 = builder.ConstantInt(1L, 64)
        let fAddr = builder.CreateGEP(env, [c1])
        let f = builder.CreateLoad(builder.PtrType(), fAddr)

        // Call f(x) indirectly
        let result = builder.CallClosure(f, [x], builder.IntType(32))
        builder.CreateReturn(result)
    )

    // Lifted outer function: fun(env_outer, f) -&gt; closure(inner, [f])
    let outerFunc = builder.CreateFunction("apply_outer",
        [builder.PtrType(); builder.PtrType()],
        builder.PtrType())

    // Outer function body
    builder.WithInsertionPoint(outerFunc, fun () -&gt;
        let envOuter = outerFunc.GetArgument(0)
        let f = outerFunc.GetArgument(1)

        // Allocate environment for inner closure
        let envSize = builder.ConstantInt(16L, 64)  // 2 slots
        let envInner = builder.CreateGCMalloc(envSize)

        // env[0] = fn_ptr(inner)
        let c0 = builder.ConstantInt(0L, 64)
        let fnPtrInner = builder.CreateAddressOf(innerFunc)
        let slot0 = builder.CreateGEP(envInner, [c0])
        builder.CreateStore(fnPtrInner, slot0)

        // env[1] = f (captured)
        let c1 = builder.ConstantInt(1L, 64)
        let slot1 = builder.CreateGEP(envInner, [c1])
        builder.CreateStore(f, slot1)

        // Return closure
        builder.CreateReturn(envInner)
    )

    // Return outer closure (no captures, empty env)
    let envOuter = builder.CreateEmptyClosure(outerFunc)
    envOuter
</code></pre>
<h3 id="apply-mlir-ir"><a class="header" href="#apply-mlir-ir">Apply MLIR IR</a></h3>
<p><strong>예상 MLIR 출력:</strong></p>
<pre><code class="language-mlir">// Inner lifted function
func.func @apply_inner(%env: !llvm.ptr, %x: i32) -&gt; i32 {
    // Load captured f from env[1]
    %c1 = arith.constant 1 : i64
    %f_addr = llvm.getelementptr %env[0, %c1] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    %f = llvm.load %f_addr : !llvm.ptr -&gt; !llvm.ptr

    // Extract f's function pointer
    %c0 = arith.constant 0 : i64
    %fn_ptr_addr = llvm.getelementptr %f[0, %c0] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    %fn_ptr = llvm.load %fn_ptr_addr : !llvm.ptr -&gt; !llvm.ptr

    // Call f(x) - indirect call
    %result = llvm.call %fn_ptr(%f, %x) : (!llvm.ptr, i32) -&gt; i32
    func.return %result : i32
}

// Outer lifted function
func.func @apply_outer(%env_outer: !llvm.ptr, %f: !llvm.ptr) -&gt; !llvm.ptr {
    // Allocate environment for inner closure (2 slots)
    %env_size = arith.constant 16 : i64
    %env_inner = llvm.call @GC_malloc(%env_size) : (i64) -&gt; !llvm.ptr

    // env[0] = fn_ptr(inner)
    %c0 = arith.constant 0 : i64
    %fn_ptr_inner = llvm.mlir.addressof @apply_inner : !llvm.ptr
    %slot0 = llvm.getelementptr %env_inner[0, %c0] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    llvm.store %fn_ptr_inner, %slot0 : !llvm.ptr, !llvm.ptr

    // env[1] = f (captured)
    %c1 = arith.constant 1 : i64
    %slot1 = llvm.getelementptr %env_inner[0, %c1] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    llvm.store %f, %slot1 : !llvm.ptr, !llvm.ptr

    // Return inner closure
    func.return %env_inner : !llvm.ptr
}
</code></pre>
<p><strong>사용 예시 MLIR:</strong></p>
<pre><code class="language-mlir">// let inc x = x + 1
func.func @inc(%x: i32) -&gt; i32 {
    %c1 = arith.constant 1 : i32
    %result = arith.addi %x, %c1 : i32
    func.return %result : i32
}

// let result = apply inc 42
func.func @main() -&gt; i32 {
    // Wrap inc as closure
    %c8 = arith.constant 8 : i64
    %env_inc = llvm.call @GC_malloc(%c8) : (i64) -&gt; !llvm.ptr
    %fn_ptr_inc = llvm.mlir.addressof @inc : !llvm.ptr
    %c0 = arith.constant 0 : i64
    %slot0 = llvm.getelementptr %env_inc[0, %c0] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    llvm.store %fn_ptr_inc, %slot0 : !llvm.ptr, !llvm.ptr
    %closure_inc = %env_inc : !llvm.ptr

    // Create apply closure
    %env_apply_outer = llvm.call @GC_malloc(%c8) : (i64) -&gt; !llvm.ptr
    %fn_ptr_apply = llvm.mlir.addressof @apply_outer : !llvm.ptr
    %slot0_apply = llvm.getelementptr %env_apply_outer[0, %c0] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    llvm.store %fn_ptr_apply, %slot0_apply : !llvm.ptr, !llvm.ptr
    %closure_apply = %env_apply_outer : !llvm.ptr

    // Call apply(inc)
    %fn_ptr_apply_outer = llvm.load %slot0_apply : !llvm.ptr -&gt; !llvm.ptr
    %closure_partial = llvm.call %fn_ptr_apply_outer(%closure_apply, %closure_inc)
        : (!llvm.ptr, !llvm.ptr) -&gt; !llvm.ptr

    // Call (apply inc)(42)
    %c42 = arith.constant 42 : i32
    %fn_ptr_partial = llvm.getelementptr %closure_partial[0, %c0] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    %fn_ptr = llvm.load %fn_ptr_partial : !llvm.ptr -&gt; !llvm.ptr
    %result = llvm.call %fn_ptr(%closure_partial, %c42) : (!llvm.ptr, i32) -&gt; i32

    func.return %result : i32
}
</code></pre>
<p><strong>테스트:</strong></p>
<pre><code class="language-bash">$ ./funlang apply_test.fun
43
</code></pre>
<h2 id="여러-함수-인자-받기"><a class="header" href="#여러-함수-인자-받기">여러 함수 인자 받기</a></h2>
<h3 id="compose-함수"><a class="header" href="#compose-함수">Compose 함수</a></h3>
<p><strong>Compose</strong>는 두 함수를 합성한다:</p>
<pre><code class="language-fsharp">let compose f g x = f (g x)
</code></pre>
<ul>
<li>타입: <code>(b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c</code></li>
<li>의미: <code>g</code>를 먼저 적용하고, 그 결과에 <code>f</code>를 적용한다</li>
</ul>
<p><strong>Compose 예시:</strong></p>
<pre><code class="language-fsharp">let inc x = x + 1
let double x = x * 2

let incThenDouble = compose double inc
let result = incThenDouble 5   // double(inc(5)) = double(6) = 12
</code></pre>
<p><strong>왜 compose가 유용한가?</strong></p>
<ol>
<li><strong>함수 조합</strong>: 작은 함수를 연결해 복잡한 동작 만들기</li>
<li><strong>파이프라인</strong>: <code>f &lt;&lt; g &lt;&lt; h</code> 스타일 (Phase 7)</li>
<li><strong>포인트-프리 스타일</strong>: <code>let process = compose validate transform</code></li>
</ol>
<h3 id="compose-컴파일"><a class="header" href="#compose-컴파일">Compose 컴파일</a></h3>
<p><strong>AST:</strong></p>
<pre><code class="language-fsharp">// compose f g x = f (g x)
Let("compose",
    Lambda("f",
        Lambda("g",
            Lambda("x",
                App(Var "f", App(Var "g", Var "x"))))),
    ...)
</code></pre>
<p><strong>중첩 람다:</strong></p>
<ul>
<li>외부: <code>fun f -&gt; ...</code> (f 캡처)</li>
<li>중간: <code>fun g -&gt; ...</code> (f, g 캡처)</li>
<li>내부: <code>fun x -&gt; f (g x)</code> (f, g 사용)</li>
</ul>
<p><strong>Lifted functions:</strong></p>
<ol>
<li><strong>Innermost</strong>: <code>compose_inner(env, x)</code> - env에 f, g 저장</li>
<li><strong>Middle</strong>: <code>compose_middle(env, g)</code> - env에 f 저장, g와 f로 inner closure 생성</li>
<li><strong>Outermost</strong>: <code>compose_outer(env, f)</code> - f로 middle closure 생성</li>
</ol>
<p><strong>MLIR IR (간략):</strong></p>
<pre><code class="language-mlir">// Innermost: fun x -&gt; f (g x)
func.func @compose_inner(%env: !llvm.ptr, %x: i32) -&gt; i32 {
    // Load g from env[1]
    %c1 = arith.constant 1 : i64
    %g_addr = llvm.getelementptr %env[0, %c1] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    %g = llvm.load %g_addr : !llvm.ptr -&gt; !llvm.ptr

    // Call g(x)
    %gx = /* CallClosure(g, x) */ : i32

    // Load f from env[2]
    %c2 = arith.constant 2 : i64
    %f_addr = llvm.getelementptr %env[0, %c2] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    %f = llvm.load %f_addr : !llvm.ptr -&gt; !llvm.ptr

    // Call f(g(x))
    %result = /* CallClosure(f, gx) */ : i32
    func.return %result : i32
}

// Middle: fun g -&gt; &lt;inner closure with f, g&gt;
func.func @compose_middle(%env: !llvm.ptr, %g: !llvm.ptr) -&gt; !llvm.ptr {
    // Load f from env[1]
    %c1 = arith.constant 1 : i64
    %f_addr = llvm.getelementptr %env[0, %c1] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    %f = llvm.load %f_addr : !llvm.ptr -&gt; !llvm.ptr

    // Allocate environment for inner (3 slots: fn_ptr, g, f)
    %c24 = arith.constant 24 : i64
    %env_inner = llvm.call @GC_malloc(%c24) : (i64) -&gt; !llvm.ptr

    // env[0] = fn_ptr(inner)
    %c0 = arith.constant 0 : i64
    %fn_ptr_inner = llvm.mlir.addressof @compose_inner : !llvm.ptr
    %slot0 = llvm.getelementptr %env_inner[0, %c0] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    llvm.store %fn_ptr_inner, %slot0 : !llvm.ptr, !llvm.ptr

    // env[1] = g
    %slot1 = llvm.getelementptr %env_inner[0, %c1] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    llvm.store %g, %slot1 : !llvm.ptr, !llvm.ptr

    // env[2] = f
    %c2 = arith.constant 2 : i64
    %slot2 = llvm.getelementptr %env_inner[0, %c2] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    llvm.store %f, %slot2 : !llvm.ptr, !llvm.ptr

    func.return %env_inner : !llvm.ptr
}

// Outermost: fun f -&gt; &lt;middle closure with f&gt;
func.func @compose_outer(%env: !llvm.ptr, %f: !llvm.ptr) -&gt; !llvm.ptr {
    // Allocate environment for middle (2 slots: fn_ptr, f)
    %c16 = arith.constant 16 : i64
    %env_middle = llvm.call @GC_malloc(%c16) : (i64) -&gt; !llvm.ptr

    // env[0] = fn_ptr(middle)
    %c0 = arith.constant 0 : i64
    %fn_ptr_middle = llvm.mlir.addressof @compose_middle : !llvm.ptr
    %slot0 = llvm.getelementptr %env_middle[0, %c0] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    llvm.store %fn_ptr_middle, %slot0 : !llvm.ptr, !llvm.ptr

    // env[1] = f
    %c1 = arith.constant 1 : i64
    %slot1 = llvm.getelementptr %env_middle[0, %c1] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    llvm.store %f, %slot1 : !llvm.ptr, !llvm.ptr

    func.return %env_middle : !llvm.ptr
}
</code></pre>
<h3 id="여러-클로저-호출-체이닝"><a class="header" href="#여러-클로저-호출-체이닝">여러 클로저 호출 체이닝</a></h3>
<p><strong>Compose 사용:</strong></p>
<pre><code class="language-fsharp">let inc x = x + 1
let double x = x * 2
let incThenDouble = compose double inc
let result = incThenDouble 5
</code></pre>
<p><strong>컴파일 과정:</strong></p>
<ol>
<li><code>compose double inc</code> → 중간 클로저 반환 (middle closure with f=double, g=inc)</li>
<li><code>(compose double inc) 5</code> → 내부 클로저 호출 (inner with f, g, x=5)</li>
<li>내부에서 <code>g(5)</code> → 6</li>
<li>내부에서 <code>f(6)</code> → 12</li>
</ol>
<p><strong>MLIR 호출 체인:</strong></p>
<pre><code class="language-mlir">// 1. Wrap double as closure
%closure_double = /* ... */

// 2. Wrap inc as closure
%closure_inc = /* ... */

// 3. Create compose closure
%closure_compose = /* compose_outer의 empty closure */

// 4. Call compose(double)
%closure_partial1 = llvm.call %fn_ptr_compose(%closure_compose, %closure_double)
    : (!llvm.ptr, !llvm.ptr) -&gt; !llvm.ptr

// 5. Call (compose double)(inc)
%closure_partial2 = llvm.call %fn_ptr_partial1(%closure_partial1, %closure_inc)
    : (!llvm.ptr, !llvm.ptr) -&gt; !llvm.ptr

// 6. Call (compose double inc)(5)
%c5 = arith.constant 5 : i32
%result = llvm.call %fn_ptr_partial2(%closure_partial2, %c5)
    : (!llvm.ptr, i32) -&gt; i32
</code></pre>
<p><strong>간접 호출의 연쇄:</strong></p>
<ul>
<li><code>compose</code> 호출 → 클로저 반환</li>
<li><code>(compose double)</code> 호출 → 클로저 반환</li>
<li><code>(compose double inc)</code> 호출 → 클로저 반환</li>
<li><code>(compose double inc 5)</code> 호출 → 값 반환 (12)</li>
</ul>
<p>모든 중간 단계가 <strong>간접 호출</strong>을 사용한다.</p>
<h2 id="함수를-반환하기"><a class="header" href="#함수를-반환하기">함수를 반환하기</a></h2>
<h3 id="upward-funarg-problem"><a class="header" href="#upward-funarg-problem">Upward Funarg Problem</a></h3>
<p><strong>함수를 반환하는 함수</strong>는 특별한 문제를 야기한다:</p>
<pre><code class="language-fsharp">let makeAdder n =
    fun x -&gt; x + n   // 이 클로저가 함수를 벗어나 반환된다
</code></pre>
<ul>
<li><code>makeAdder</code>가 호출되면, 내부 람다 <code>fun x -&gt; x + n</code>이 생성된다</li>
<li>이 람다는 <code>n</code>을 <strong>캡처</strong>한다</li>
<li>람다가 <strong>makeAdder를 벗어나</strong> 반환된다</li>
<li>반환된 후에도 <code>n</code>에 접근할 수 있어야 한다!</li>
</ul>
<p><strong>Upward funarg problem:</strong></p>
<blockquote>
<p>함수가 생성된 스코프를 벗어나 반환될 때, 캡처된 변수들이 어떻게 유지되는가?</p>
</blockquote>
<p><strong>잘못된 해결책: 스택 할당</strong></p>
<pre><code class="language-c">// 안 되는 C 코드
typedef int (*func_ptr)(int);

func_ptr makeAdder(int n) {
    int captured_n = n;   // 스택 변수
    return &amp;inner_func;    // inner_func이 captured_n을 참조
}   // 여기서 captured_n이 소멸! Dangling pointer!
</code></pre>
<p>함수가 반환되면 스택 프레임이 소멸되므로, <code>captured_n</code>에 접근하면 <strong>undefined behavior</strong>다.</p>
<p><strong>올바른 해결책: 힙 할당</strong></p>
<p>환경을 **힙(heap)**에 할당하면, 함수가 반환되어도 환경이 유지된다:</p>
<pre><code class="language-mlir">func.func @makeAdder(%n: i32) -&gt; !llvm.ptr {
    // Allocate environment on heap (NOT stack!)
    %env_size = arith.constant 16 : i64
    %env = llvm.call @GC_malloc(%env_size) : (i64) -&gt; !llvm.ptr

    // env[0] = fn_ptr
    %fn_ptr = llvm.mlir.addressof @makeAdder_inner : !llvm.ptr
    // ... store fn_ptr ...

    // env[1] = n (captured)
    // ... store n ...

    func.return %env : !llvm.ptr   // 환경이 함수를 벗어나 반환
}
</code></pre>
<p><strong>GC의 역할:</strong></p>
<ul>
<li>힙에 할당된 환경은 <strong>GC가 관리</strong>한다</li>
<li>클로저가 살아있는 동안 환경도 유지된다</li>
<li>클로저가 더 이상 사용되지 않으면 환경도 해제된다</li>
</ul>
<p><strong>Chapter 12 설계의 정당성:</strong></p>
<p>Chapter 12에서 <strong>모든 클로저를 힙에 할당</strong>한 이유가 바로 이것이다. 클로저가 생성 스코프를 벗어날 수 있으므로, 항상 힙에 할당해야 안전하다.</p>
<h3 id="makeadder-구현"><a class="header" href="#makeadder-구현">MakeAdder 구현</a></h3>
<p><strong>MakeAdder 함수:</strong></p>
<pre><code class="language-fsharp">let makeAdder n =
    fun x -&gt; x + n
</code></pre>
<ul>
<li>타입: <code>int -&gt; (int -&gt; int)</code></li>
<li>의미: <code>n</code>을 받아서, “n을 더하는 함수“를 반환한다</li>
</ul>
<p><strong>사용 예시:</strong></p>
<pre><code class="language-fsharp">let add5 = makeAdder 5
let result1 = add5 10   // 15

let add10 = makeAdder 10
let result2 = add10 20  // 30
</code></pre>
<p><strong>AST:</strong></p>
<pre><code class="language-fsharp">Let("makeAdder",
    Lambda("n",
        Lambda("x",
            Add(Var "x", Var "n"))),
    ...)
</code></pre>
<p><strong>Closure conversion:</strong></p>
<ol>
<li><strong>내부 람다</strong>: <code>fun x -&gt; x + n</code> (n 캡처)
<ul>
<li>Lifted: <code>makeAdder_inner(env, x) = x + env[1]</code></li>
</ul>
</li>
<li><strong>외부 람다</strong>: <code>fun n -&gt; &lt;inner closure&gt;</code>
<ul>
<li>Lifted: <code>makeAdder_outer(env, n) = create_closure(makeAdder_inner, [n])</code></li>
</ul>
</li>
</ol>
<p><strong>F# 컴파일 (간략):</strong></p>
<pre><code class="language-fsharp">let compileMakeAdder (builder: OpBuilder) : unit =
    // Inner function: fun x -&gt; x + n
    let innerFunc = builder.CreateFunction("makeAdder_inner",
        [builder.PtrType(); builder.IntType(32)],
        builder.IntType(32))

    builder.WithInsertionPoint(innerFunc, fun () -&gt;
        let env = innerFunc.GetArgument(0)
        let x = innerFunc.GetArgument(1)

        // Load n from env[1]
        let c1 = builder.ConstantInt(1L, 64)
        let nAddr = builder.CreateGEP(env, [c1])
        let n = builder.CreateLoad(builder.IntType(32), nAddr)

        // Compute x + n
        let result = builder.CreateAdd(x, n)
        builder.CreateReturn(result)
    )

    // Outer function: fun n -&gt; &lt;inner closure&gt;
    let outerFunc = builder.CreateFunction("makeAdder_outer",
        [builder.PtrType(); builder.IntType(32)],
        builder.PtrType())

    builder.WithInsertionPoint(outerFunc, fun () -&gt;
        let envOuter = outerFunc.GetArgument(0)
        let n = outerFunc.GetArgument(1)

        // Allocate environment for inner closure (2 slots)
        let envSize = builder.ConstantInt(16L, 64)
        let envInner = builder.CreateGCMalloc(envSize)

        // env[0] = fn_ptr(inner)
        let c0 = builder.ConstantInt(0L, 64)
        let fnPtrInner = builder.CreateAddressOf(innerFunc)
        let slot0 = builder.CreateGEP(envInner, [c0])
        builder.CreateStore(fnPtrInner, slot0)

        // env[1] = n (captured)
        let c1 = builder.ConstantInt(1L, 64)
        let slot1 = builder.CreateGEP(envInner, [c1])
        builder.CreateStore(n, slot1)

        // Return inner closure (escapes function!)
        builder.CreateReturn(envInner)
    )
</code></pre>
<p><strong>완전한 MLIR IR:</strong></p>
<pre><code class="language-mlir">// Inner function
func.func @makeAdder_inner(%env: !llvm.ptr, %x: i32) -&gt; i32 {
    // Load n from env[1]
    %c1 = arith.constant 1 : i64
    %n_addr = llvm.getelementptr %env[0, %c1] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    %n = llvm.load %n_addr : !llvm.ptr -&gt; i32

    // x + n
    %result = arith.addi %x, %n : i32
    func.return %result : i32
}

// Outer function
func.func @makeAdder_outer(%env_outer: !llvm.ptr, %n: i32) -&gt; !llvm.ptr {
    // Allocate environment for inner closure
    %c16 = arith.constant 16 : i64
    %env_inner = llvm.call @GC_malloc(%c16) : (i64) -&gt; !llvm.ptr

    // env[0] = fn_ptr(inner)
    %c0 = arith.constant 0 : i64
    %fn_ptr_inner = llvm.mlir.addressof @makeAdder_inner : !llvm.ptr
    %slot0 = llvm.getelementptr %env_inner[0, %c0] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    llvm.store %fn_ptr_inner, %slot0 : !llvm.ptr, !llvm.ptr

    // env[1] = n
    %c1 = arith.constant 1 : i64
    %slot1 = llvm.getelementptr %env_inner[0, %c1] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    llvm.store %n, %slot1 : !llvm.ptr, !llvm.ptr

    // Return closure (environment escapes!)
    func.return %env_inner : !llvm.ptr
}
</code></pre>
<p><strong>테스트 코드:</strong></p>
<pre><code class="language-mlir">func.func @main() -&gt; i32 {
    // Create makeAdder closure (empty env)
    %c8 = arith.constant 8 : i64
    %env_makeAdder = llvm.call @GC_malloc(%c8) : (i64) -&gt; !llvm.ptr
    %fn_ptr_makeAdder = llvm.mlir.addressof @makeAdder_outer : !llvm.ptr
    %c0 = arith.constant 0 : i64
    %slot0 = llvm.getelementptr %env_makeAdder[0, %c0] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    llvm.store %fn_ptr_makeAdder, %slot0 : !llvm.ptr, !llvm.ptr

    // Call makeAdder(5)
    %c5 = arith.constant 5 : i32
    %fn_ptr = llvm.load %slot0 : !llvm.ptr -&gt; !llvm.ptr
    %add5 = llvm.call %fn_ptr(%env_makeAdder, %c5) : (!llvm.ptr, i32) -&gt; !llvm.ptr
    // %add5 is a closure (inner function with n=5)

    // Call add5(10)
    %c10 = arith.constant 10 : i32
    %fn_ptr_inner = llvm.getelementptr %add5[0, %c0] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    %fn_ptr_loaded = llvm.load %fn_ptr_inner : !llvm.ptr -&gt; !llvm.ptr
    %result = llvm.call %fn_ptr_loaded(%add5, %c10) : (!llvm.ptr, i32) -&gt; i32
    // %result = 15

    func.return %result : i32
}
</code></pre>
<p><strong>실행:</strong></p>
<pre><code class="language-bash">$ ./funlang makeAdder_test.fun
15
</code></pre>
<h3 id="반환된-클로저의-생명주기"><a class="header" href="#반환된-클로저의-생명주기">반환된 클로저의 생명주기</a></h3>
<p><strong>환경은 언제 해제되는가?</strong></p>
<pre><code class="language-fsharp">let add5 = makeAdder 5
// add5가 살아있는 동안, makeAdder의 환경도 유지된다
let result = add5 10   // OK
// add5가 스코프를 벗어나면, 환경도 GC에 의해 해제된다
</code></pre>
<p><strong>GC의 추적:</strong></p>
<ul>
<li><code>add5</code> (클로저 포인터)가 살아있으면 → 환경 유지</li>
<li><code>add5</code>가 더 이상 참조되지 않으면 → GC가 환경 수거</li>
</ul>
<p><strong>여러 클로저가 같은 환경을 공유하지 않는다:</strong></p>
<pre><code class="language-fsharp">let add5 = makeAdder 5
let add10 = makeAdder 10
</code></pre>
<ul>
<li><code>add5</code>와 <code>add10</code>은 <strong>서로 다른 환경</strong>을 가진다</li>
<li>각 <code>makeAdder</code> 호출이 새로운 환경을 힙에 할당한다</li>
</ul>
<p><strong>메모리 누수 없음:</strong></p>
<p>GC가 자동으로 관리하므로, 프로그래머가 <code>free</code>를 호출할 필요 없다.</p>
<h2 id="커링-패턴"><a class="header" href="#커링-패턴">커링 패턴</a></h2>
<h3 id="다중-인자-함수를-클로저-체인으로-표현"><a class="header" href="#다중-인자-함수를-클로저-체인으로-표현">다중 인자 함수를 클로저 체인으로 표현</a></h3>
<p>**커링(Currying)**은 다중 인자 함수를 <strong>중첩된 단일 인자 함수로 변환</strong>하는 것이다:</p>
<pre><code class="language-fsharp">// 다중 인자 함수 (Phase 3 스타일)
let add x y = x + y

// 커리된 함수 (Phase 4 스타일)
let add = fun x -&gt; fun y -&gt; x + y
</code></pre>
<ul>
<li><code>add</code>의 타입: <code>int -&gt; (int -&gt; int)</code></li>
<li><code>add</code>는 함수를 반환하는 함수다</li>
</ul>
<p><strong>커링의 장점:</strong></p>
<ol>
<li><strong>부분 적용(Partial application)</strong>: <code>let add5 = add 5</code></li>
<li><strong>합성 용이</strong>: 커리된 함수는 파이프라인에 쉽게 통합됨</li>
<li><strong>일관된 타입 시스템</strong>: 모든 함수가 단일 인자</li>
</ol>
<p><strong>커링 예시:</strong></p>
<pre><code class="language-fsharp">let add x y = x + y     // 실제로는 fun x -&gt; fun y -&gt; x + y

let add5 = add 5        // 부분 적용
let result = add5 10    // 15
</code></pre>
<h3 id="커리된-함수의-컴파일"><a class="header" href="#커리된-함수의-컴파일">커리된 함수의 컴파일</a></h3>
<p><strong>AST:</strong></p>
<pre><code class="language-fsharp">Let("add",
    Lambda("x",
        Lambda("y",
            Add(Var "x", Var "y"))),
    ...)
</code></pre>
<p><strong>Closure conversion:</strong></p>
<ol>
<li><strong>내부 람다</strong>: <code>fun y -&gt; x + y</code> (x 캡처)
<ul>
<li>Lifted: <code>add_inner(env, y) = env[1] + y</code></li>
</ul>
</li>
<li><strong>외부 람다</strong>: <code>fun x -&gt; &lt;inner closure&gt;</code>
<ul>
<li>Lifted: <code>add_outer(env, x) = create_closure(add_inner, [x])</code></li>
</ul>
</li>
</ol>
<p><strong>MLIR IR:</strong></p>
<pre><code class="language-mlir">// Inner: fun y -&gt; x + y
func.func @add_inner(%env: !llvm.ptr, %y: i32) -&gt; i32 {
    // Load x from env[1]
    %c1 = arith.constant 1 : i64
    %x_addr = llvm.getelementptr %env[0, %c1] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    %x = llvm.load %x_addr : !llvm.ptr -&gt; i32

    // x + y
    %result = arith.addi %x, %y : i32
    func.return %result : i32
}

// Outer: fun x -&gt; &lt;inner closure&gt;
func.func @add_outer(%env_outer: !llvm.ptr, %x: i32) -&gt; !llvm.ptr {
    // Allocate environment for inner
    %c16 = arith.constant 16 : i64
    %env_inner = llvm.call @GC_malloc(%c16) : (i64) -&gt; !llvm.ptr

    // env[0] = fn_ptr
    %c0 = arith.constant 0 : i64
    %fn_ptr = llvm.mlir.addressof @add_inner : !llvm.ptr
    %slot0 = llvm.getelementptr %env_inner[0, %c0] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    llvm.store %fn_ptr, %slot0 : !llvm.ptr, !llvm.ptr

    // env[1] = x
    %c1 = arith.constant 1 : i64
    %slot1 = llvm.getelementptr %env_inner[0, %c1] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    llvm.store %x, %slot1 : !llvm.ptr, !llvm.ptr

    func.return %env_inner : !llvm.ptr
}
</code></pre>
<p><strong>부분 적용:</strong></p>
<pre><code class="language-fsharp">let add5 = add 5
</code></pre>
<pre><code class="language-mlir">// Call add(5) -&gt; returns closure with x=5
%c5 = arith.constant 5 : i32
%closure_add = /* ... */
%fn_ptr_add = /* load from closure_add[0] */
%add5 = llvm.call %fn_ptr_add(%closure_add, %c5) : (!llvm.ptr, i32) -&gt; !llvm.ptr
// %add5 is inner closure with x=5 captured
</code></pre>
<p><strong>완전 적용:</strong></p>
<pre><code class="language-fsharp">let result = add5 10
</code></pre>
<pre><code class="language-mlir">// Call add5(10)
%c10 = arith.constant 10 : i32
%fn_ptr_inner = /* load from %add5[0] */
%result = llvm.call %fn_ptr_inner(%add5, %c10) : (!llvm.ptr, i32) -&gt; i32
// %result = 15
</code></pre>
<p><strong>커링과 makeAdder의 유사성:</strong></p>
<ul>
<li><code>makeAdder</code>는 명시적 함수 반환</li>
<li>커링은 암묵적 함수 반환 (다중 인자를 중첩 람다로 변환)</li>
<li>둘 다 <strong>upward funarg problem</strong> 해결 필요 (힙 할당)</li>
</ul>
<h3 id="3개-이상의-인자"><a class="header" href="#3개-이상의-인자">3개 이상의 인자</a></h3>
<pre><code class="language-fsharp">let add3 x y z = x + y + z
// = fun x -&gt; fun y -&gt; fun z -&gt; x + y + z
</code></pre>
<p><strong>중첩 구조:</strong></p>
<ul>
<li>외부: <code>fun x -&gt; ...</code> (비어있음)</li>
<li>중간: <code>fun y -&gt; ...</code> (x 캡처)</li>
<li>내부: <code>fun z -&gt; x + y + z</code> (x, y 캡처)</li>
</ul>
<p><strong>MLIR에서 3단계 중첩:</strong></p>
<p>각 단계가 새로운 클로저를 생성하고, 이전 환경을 캡처한다. 복잡하지만 패턴은 동일하다.</p>
<h2 id="메모리-관리와-클로저"><a class="header" href="#메모리-관리와-클로저">메모리 관리와 클로저</a></h2>
<h3 id="gc가-클로저-생명주기를-관리한다"><a class="header" href="#gc가-클로저-생명주기를-관리한다">GC가 클로저 생명주기를 관리한다</a></h3>
<p><strong>핵심 원칙:</strong></p>
<ul>
<li>모든 클로저 환경은 <strong>힙에 할당</strong>된다 (<code>GC_malloc</code>)</li>
<li><strong>GC가 자동으로 추적</strong>하여, 사용되지 않으면 해제한다</li>
<li>프로그래머는 메모리 관리를 신경 쓸 필요 없다</li>
</ul>
<p><strong>생명주기 예시:</strong></p>
<pre><code class="language-fsharp">let createAdders () =
    let add5 = makeAdder 5
    let add10 = makeAdder 10
    add5    // add5만 반환, add10은 버려진다

let adder = createAdders()
let result = adder 20   // 25
</code></pre>
<p><strong>메모리 추적:</strong></p>
<ol>
<li><code>makeAdder 5</code> 호출 → 환경1 할당 (n=5)</li>
<li><code>makeAdder 10</code> 호출 → 환경2 할당 (n=10)</li>
<li><code>add5</code> 반환 → 환경1은 유지</li>
<li><code>add10</code>은 스코프 벗어남 → 환경2는 GC 수거 대상</li>
<li><code>adder</code> 사용 → 환경1 유지</li>
<li><code>adder</code> 스코프 벗어남 → 환경1도 GC 수거</li>
</ol>
<p><strong>Dangling pointer 없음:</strong></p>
<p>C/C++에서는 스택 포인터 반환이 위험하지만, GC 덕분에 FunLang은 안전하다:</p>
<pre><code class="language-fsharp">let unsafeInC () =
    let local = 42
    fun () -&gt; local   // C에서는 dangling pointer, FunLang에서는 OK
</code></pre>
<p>FunLang 컴파일러는 <code>local</code>을 환경에 캡처하고 힙에 할당하므로 안전하다.</p>
<h3 id="순환-참조와-gc"><a class="header" href="#순환-참조와-gc">순환 참조와 GC</a></h3>
<p><strong>Cyclic closures (순환 클로저):</strong></p>
<pre><code class="language-fsharp">let rec isEven n =
    if n = 0 then true
    else isOdd (n - 1)
and isOdd n =
    if n = 0 then false
    else isEven (n - 1)
</code></pre>
<ul>
<li><code>isEven</code> 클로저가 <code>isOdd</code>를 캡처</li>
<li><code>isOdd</code> 클로저가 <code>isEven</code>을 캡처</li>
<li><strong>순환 참조!</strong></li>
</ul>
<p><strong>GC의 처리:</strong></p>
<p>Boehm GC는 <strong>tracing GC</strong>이므로, 순환 참조를 정확히 감지하고 해제한다:</p>
<ul>
<li>루트(스택, 전역)에서 도달 가능한 객체만 유지</li>
<li>순환 참조가 루트에서 도달 불가능하면 → 수거</li>
</ul>
<p><strong>Reference counting과의 차이:</strong></p>
<ul>
<li><strong>Reference counting</strong>: 순환 참조를 해제하지 못함 (메모리 누수)</li>
<li><strong>Tracing GC</strong>: 순환 참조도 정확히 처리</li>
</ul>
<p>Phase 2에서 Boehm GC를 선택한 이유가 이것이다.</p>
<h3 id="클로저-생성-비용"><a class="header" href="#클로저-생성-비용">클로저 생성 비용</a></h3>
<p><strong>힙 할당 비용:</strong></p>
<ul>
<li>클로저 생성 = <code>GC_malloc</code> 호출</li>
<li>스택 할당보다 느리지만, 안전성 보장</li>
</ul>
<p><strong>최적화 가능성 (Phase 7):</strong></p>
<ul>
<li><strong>Escape analysis</strong>: 클로저가 함수를 벗어나지 않으면 스택 할당 가능</li>
<li><strong>Closure inlining</strong>: 클로저가 즉시 호출되면 인라이닝 가능</li>
<li>Phase 4는 최적화 없이 항상 힙 할당</li>
</ul>
<p><strong>GC 오버헤드:</strong></p>
<ul>
<li>주기적인 GC 실행 (pause time)</li>
<li>메모리 오버헤드 (fragmentation)</li>
<li>하지만 프로그래머 생산성은 크게 향상</li>
</ul>
<h2 id="complete-예시-map-함수"><a class="header" href="#complete-예시-map-함수">Complete 예시: Map 함수</a></h2>
<h3 id="map의-개념"><a class="header" href="#map의-개념">Map의 개념</a></h3>
<p><strong>Map 함수</strong>는 리스트의 각 원소에 함수를 적용한다:</p>
<pre><code class="language-fsharp">// 개념적 정의 (Phase 6에서 완전 구현)
let rec map f list =
    match list with
    | [] -&gt; []
    | head :: tail -&gt; (f head) :: (map f tail)
</code></pre>
<ul>
<li>타입: <code>(a -&gt; b) -&gt; list a -&gt; list b</code></li>
<li>의미: <code>f</code>를 각 원소에 적용해 새 리스트 생성</li>
</ul>
<p><strong>Map 예시:</strong></p>
<pre><code class="language-fsharp">let inc x = x + 1
let numbers = [1; 2; 3; 4]
let incremented = map inc numbers   // [2; 3; 4; 5]

let double x = x * 2
let doubled = map double numbers    // [2; 4; 6; 8]
</code></pre>
<h3 id="phase-4의-map-단순화-버전"><a class="header" href="#phase-4의-map-단순화-버전">Phase 4의 Map (단순화 버전)</a></h3>
<p>Phase 4에는 리스트가 없으므로, <strong>개념적 설명</strong>만 한다. 핵심은 <strong>HOF 패턴</strong>이다:</p>
<pre><code class="language-fsharp">// 단순화: 두 원소 "리스트"만 처리
let map2 f x y =
    let fx = f x
    let fy = f y
    (fx, fy)   // Phase 6에서는 실제 리스트 반환
</code></pre>
<p><strong>컴파일:</strong></p>
<pre><code class="language-mlir">func.func @map2(%f: !llvm.ptr, %x: i32, %y: i32) -&gt; (i32, i32) {
    // Call f(x)
    %c0 = arith.constant 0 : i64
    %fn_ptr_addr = llvm.getelementptr %f[0, %c0] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    %fn_ptr = llvm.load %fn_ptr_addr : !llvm.ptr -&gt; !llvm.ptr
    %fx = llvm.call %fn_ptr(%f, %x) : (!llvm.ptr, i32) -&gt; i32

    // Call f(y)
    %fy = llvm.call %fn_ptr(%f, %y) : (!llvm.ptr, i32) -&gt; i32

    // Return pair (fx, fy) - Phase 6에서는 리스트
    // ... (tuple 구현 생략)
}
</code></pre>
<p><strong>Map의 핵심:</strong></p>
<ul>
<li>함수 <code>f</code>를 <strong>인자로 받는다</strong> (고차 함수)</li>
<li><code>f</code>를 <strong>여러 번 호출</strong>한다 (간접 호출)</li>
<li>각 호출마다 <code>f</code>의 환경을 전달한다</li>
</ul>
<p><strong>Map + Closure:</strong></p>
<pre><code class="language-fsharp">let addN n = fun x -&gt; x + n
let add5 = addN 5
let result = map2 add5 10 20   // (15, 25)
</code></pre>
<ul>
<li><code>add5</code>는 클로저 (n=5 캡처)</li>
<li><code>map2</code>가 <code>add5</code>를 받아서 두 번 호출</li>
<li>각 호출마다 캡처된 <code>n</code> 사용</li>
</ul>
<p>이것이 <strong>클로저 + 고차 함수 = 함수형 프로그래밍 핵심</strong> 조합이다.</p>
<h2 id="자주-하는-실수-common-errors"><a class="header" href="#자주-하는-실수-common-errors">자주 하는 실수 (Common Errors)</a></h2>
<h3 id="error-1-클로저를-첫-인자로-전달하지-않음"><a class="header" href="#error-1-클로저를-첫-인자로-전달하지-않음">Error 1: 클로저를 첫 인자로 전달하지 않음</a></h3>
<p><strong>문제:</strong></p>
<pre><code class="language-mlir">// 잘못된 호출 - 환경 누락
%result = llvm.call %fn_ptr(%arg) : (i32) -&gt; i32
</code></pre>
<p>Lifted function은 <strong>첫 번째 파라미터로 환경을 받는다</strong>:</p>
<pre><code class="language-mlir">func.func @lifted(%env: !llvm.ptr, %arg: i32) -&gt; i32
</code></pre>
<p>환경 없이 호출하면 <strong>타입 미스매치</strong> 또는 <strong>segfault</strong>:</p>
<pre><code>ERROR: Call argument count mismatch (expected 2, got 1)
</code></pre>
<p><strong>해결:</strong></p>
<pre><code class="language-mlir">// 올바른 호출 - 클로저(환경)를 첫 인자로
%result = llvm.call %fn_ptr(%closure, %arg) : (!llvm.ptr, i32) -&gt; i32
</code></pre>
<p><strong>F# 헬퍼 사용:</strong></p>
<pre><code class="language-fsharp">// 자동으로 클로저를 첫 인자로 전달
builder.CallClosure(closure, [arg], resultType)
</code></pre>
<h3 id="error-2-클로저-본체를-직접-호출"><a class="header" href="#error-2-클로저-본체를-직접-호출">Error 2: 클로저 본체를 직접 호출</a></h3>
<p><strong>문제:</strong></p>
<pre><code class="language-mlir">// 잘못된 호출 - lifted function을 직접 호출
%result = func.call @lifted_func(%env, %arg) : (!llvm.ptr, i32) -&gt; i32
</code></pre>
<p>Lifted function은 <strong>내부 함수</strong>이고, 직접 호출하면 <strong>환경이 잘못 전달</strong>될 수 있다.</p>
<p><strong>올바른 방법:</strong></p>
<ol>
<li>클로저에서 함수 포인터 추출</li>
<li>간접 호출 (<code>llvm.call</code>)</li>
</ol>
<pre><code class="language-mlir">// 올바른 호출 - 클로저를 통해 간접 호출
%fn_ptr_addr = llvm.getelementptr %closure[0, 0] : (!llvm.ptr, i64) -&gt; !llvm.ptr
%fn_ptr = llvm.load %fn_ptr_addr : !llvm.ptr -&gt; !llvm.ptr
%result = llvm.call %fn_ptr(%closure, %arg) : (!llvm.ptr, i32) -&gt; i32
</code></pre>
<p><strong>예외:</strong></p>
<p>테스트 목적으로 직접 호출할 수는 있지만, 일반적인 패턴은 아니다.</p>
<h3 id="error-3-스택에-반환-클로저의-환경-할당"><a class="header" href="#error-3-스택에-반환-클로저의-환경-할당">Error 3: 스택에 반환 클로저의 환경 할당</a></h3>
<p><strong>문제:</strong></p>
<pre><code class="language-mlir">func.func @makeAdder_wrong(%n: i32) -&gt; !llvm.ptr {
    // 잘못됨 - 스택 할당!
    %c1 = arith.constant 1 : index
    %env = memref.alloca(%c1) : memref&lt;?xi64&gt;
    // ... store function pointer and n ...
    %ptr = memref.extract_aligned_pointer_as_index %env : memref&lt;?xi64&gt; -&gt; !llvm.ptr
    func.return %ptr : !llvm.ptr
}   // 함수 종료 시 %env 소멸! Dangling pointer!
</code></pre>
<p>함수가 반환되면 <strong>스택 프레임이 소멸</strong>되므로, 환경 접근 시 undefined behavior.</p>
<p><strong>해결:</strong></p>
<pre><code class="language-mlir">func.func @makeAdder_correct(%n: i32) -&gt; !llvm.ptr {
    // 올바름 - 힙 할당
    %env_size = arith.constant 16 : i64
    %env = llvm.call @GC_malloc(%env_size) : (i64) -&gt; !llvm.ptr
    // ... store function pointer and n ...
    func.return %env : !llvm.ptr
}   // %env는 힙에 있으므로 안전
</code></pre>
<p><strong>원칙:</strong></p>
<ul>
<li><strong>반환되는 클로저</strong>: 항상 <code>GC_malloc</code> 사용</li>
<li><strong>로컬 클로저</strong> (스코프 벗어나지 않음): 스택 가능 (Phase 7 최적화)</li>
</ul>
<h3 id="error-4-간접-호출-시-타입-미스매치"><a class="header" href="#error-4-간접-호출-시-타입-미스매치">Error 4: 간접 호출 시 타입 미스매치</a></h3>
<p><strong>문제:</strong></p>
<pre><code class="language-mlir">// Lifted function: (%env: !llvm.ptr, %x: i32) -&gt; i32
func.func @lifted(%env: !llvm.ptr, %x: i32) -&gt; i32

// 잘못된 호출 - 타입 불일치
%result = llvm.call %fn_ptr(%closure) : (!llvm.ptr) -&gt; i32   // 인자 누락
</code></pre>
<p>LLVM IR에서 타입 불일치는 <strong>검증 실패</strong> 또는 <strong>런타임 크래시</strong>:</p>
<pre><code>ERROR: Function signature mismatch in indirect call
</code></pre>
<p><strong>해결:</strong></p>
<p>간접 호출 시 <strong>정확한 시그니처</strong> 명시:</p>
<pre><code class="language-mlir">// 올바른 호출 - 모든 인자와 정확한 타입
%result = llvm.call %fn_ptr(%closure, %x) : (!llvm.ptr, i32) -&gt; i32
</code></pre>
<p><strong>타입 시그니처 유지:</strong></p>
<ul>
<li>Lifted function 정의와 간접 호출 타입이 <strong>정확히 일치</strong>해야 함</li>
<li>컴파일러가 자동으로 추론하도록 구현</li>
</ul>
<h3 id="error-5-클로저-동일성-혼동"><a class="header" href="#error-5-클로저-동일성-혼동">Error 5: 클로저 동일성 혼동</a></h3>
<p><strong>문제:</strong></p>
<pre><code class="language-fsharp">let f = fun x -&gt; x + 1
let g = fun x -&gt; x + 1
// f와 g는 같은가?
</code></pre>
<p><strong>답: 아니다!</strong></p>
<ul>
<li><code>f</code>와 <code>g</code>는 <strong>서로 다른 클로저</strong>다</li>
<li>각각 <strong>다른 환경 포인터</strong>를 가진다 (빈 환경이더라도)</li>
<li><strong>포인터 비교</strong>: <code>f != g</code> (주소가 다름)</li>
</ul>
<p><strong>의미적 동등성 vs 포인터 동등성:</strong></p>
<ul>
<li><strong>의미적 동등성</strong>: 같은 동작 (extensional equality)</li>
<li><strong>포인터 동등성</strong>: 같은 객체 (intensional equality)</li>
</ul>
<p>FunLang은 <strong>포인터 동등성</strong>만 지원한다 (대부분의 언어와 동일).</p>
<p><strong>예시:</strong></p>
<pre><code class="language-mlir">// 두 클로저 생성
%closure1 = /* fun x -&gt; x + 1 */
%closure2 = /* fun x -&gt; x + 1 */

// 포인터 비교
%same = llvm.icmp "eq" %closure1, %closure2 : !llvm.ptr
// %same = false (주소가 다름)
</code></pre>
<p><strong>함수 메모이제이션:</strong></p>
<p>의미적 동등성이 필요하면 <strong>명시적 비교 로직</strong> 구현 필요 (Phase 7).</p>
<h2 id="phase-4-완료-요약"><a class="header" href="#phase-4-완료-요약">Phase 4 완료 요약</a></h2>
<h3 id="무엇을-구현했는가"><a class="header" href="#무엇을-구현했는가">무엇을 구현했는가</a></h3>
<p><strong>Phase 4 - Closures &amp; Higher-Order Functions:</strong></p>
<ol>
<li>
<p><strong>Chapter 12 - Closures:</strong></p>
<ul>
<li>클로저 이론 (lexical scoping, free/bound variables)</li>
<li>자유 변수 분석 알고리즘</li>
<li>클로저 변환 (closure conversion)</li>
<li>환경 구조체 (힙 할당)</li>
<li>GC_malloc으로 클로저 생성</li>
</ul>
</li>
<li>
<p><strong>Chapter 13 - Higher-Order Functions:</strong></p>
<ul>
<li>함수를 일급 값으로 다루기</li>
<li>간접 호출 패턴 (<code>llvm.call</code> with function pointer)</li>
<li>Apply 함수 (함수를 인자로 받기)</li>
<li>Compose 함수 (여러 함수 인자)</li>
<li>함수를 반환하기 (makeAdder, upward funarg problem)</li>
<li>커링 패턴 (다중 인자 → 중첩 람다)</li>
<li>메모리 관리 (GC가 클로저 생명주기 관리)</li>
<li>자주 하는 실수 5가지</li>
</ul>
</li>
</ol>
<p><strong>핵심 구현 항목:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>항목</th><th>설명</th><th>MLIR 패턴</th></tr>
</thead>
<tbody>
<tr><td><strong>클로저 표현</strong></td><td>(fn_ptr, env) 쌍</td><td><code>!llvm.ptr</code></td></tr>
<tr><td><strong>환경 할당</strong></td><td>힙에 GC_malloc</td><td><code>llvm.call @GC_malloc</code></td></tr>
<tr><td><strong>간접 호출</strong></td><td>함수 포인터 로드 후 호출</td><td><code>llvm.call %fn_ptr(...)</code></td></tr>
<tr><td><strong>환경 접근</strong></td><td>GEP + load</td><td><code>llvm.getelementptr + llvm.load</code></td></tr>
<tr><td><strong>클로저 생성</strong></td><td>환경 할당 + 변수 저장</td><td><code>GC_malloc + store</code></td></tr>
<tr><td><strong>함수 반환</strong></td><td>클로저 반환 (escaping)</td><td><code>func.return %env</code></td></tr>
</tbody>
</table>
</div>
<p><strong>타입 시스템:</strong></p>
<ul>
<li>모든 함수/클로저: <code>!llvm.ptr</code> (opaque pointer)</li>
<li>함수 타입 (개념적): <code>a -&gt; b</code> = <code>(!llvm.ptr, a) -&gt; b</code> (lifted)</li>
</ul>
<h3 id="phase-4가-가능하게-한-것"><a class="header" href="#phase-4가-가능하게-한-것">Phase 4가 가능하게 한 것</a></h3>
<p><strong>이제 컴파일할 수 있는 것:</strong></p>
<pre><code class="language-fsharp">// 1. 클로저 생성
let makeAdder n = fun x -&gt; x + n

// 2. 고차 함수
let apply f x = f x
let compose f g x = f (g x)

// 3. 부분 적용
let add5 = makeAdder 5
let result = add5 10   // 15

// 4. 함수 합성
let inc x = x + 1
let double x = x * 2
let incThenDouble = compose double inc
let result2 = incThenDouble 5   // 12

// 5. 콜백 패턴
let processWithCallback callback data =
    let result = compute data
    callback result

// 6. 커링
let add x y = x + y   // = fun x -&gt; fun y -&gt; x + y
let add5 = add 5
</code></pre>
<p><strong>함수형 프로그래밍의 핵심:</strong></p>
<ul>
<li>✅ 클로저 (환경 캡처)</li>
<li>✅ 고차 함수 (함수 인자/반환)</li>
<li>✅ 부분 적용</li>
<li>✅ 함수 합성</li>
<li>⏸️ Map, filter, fold (Phase 6에서 리스트 추가 후)</li>
</ul>
<h3 id="다음-단계-phase-5---custom-mlir-dialect"><a class="header" href="#다음-단계-phase-5---custom-mlir-dialect">다음 단계: Phase 5 - Custom MLIR Dialect</a></h3>
<p><strong>Phase 5 목표:</strong></p>
<p>FunLang 전용 MLIR dialect 설계 및 구현:</p>
<ol>
<li>
<p><strong>FunLang Dialect 정의:</strong></p>
<ul>
<li><code>funlang.closure</code> 연산 (클로저 생성 추상화)</li>
<li><code>funlang.closure_call</code> 연산 (간접 호출 추상화)</li>
<li><code>funlang.capture</code> 연산 (환경 저장 추상화)</li>
</ul>
</li>
<li>
<p><strong>Lowering passes:</strong></p>
<ul>
<li>FunLang dialect → Func/LLVM dialect</li>
<li>고수준 의미론 → 저수준 MLIR</li>
</ul>
</li>
<li>
<p><strong>이점:</strong></p>
<ul>
<li>컴파일러 코드 단순화 (고수준 연산 사용)</li>
<li>최적화 pass 추가 용이 (dialect-specific 변환)</li>
<li>타입 안전성 향상 (dialect 타입 시스템)</li>
</ul>
</li>
</ol>
<p><strong>Phase 4 vs Phase 5:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Phase 4</th><th>Phase 5</th></tr>
</thead>
<tbody>
<tr><td>저수준 LLVM dialect 직접 생성</td><td>고수준 FunLang dialect 생성</td></tr>
<tr><td>GEP, load, store 수동 관리</td><td>추상화된 연산 사용</td></tr>
<tr><td>최적화 어려움</td><td>Dialect 최적화 pass</td></tr>
</tbody>
</table>
</div>
<p><strong>Preview:</strong></p>
<pre><code class="language-mlir">// Phase 4 (저수준)
%env = llvm.call @GC_malloc(%c16) : (i64) -&gt; !llvm.ptr
%fn_ptr = llvm.mlir.addressof @func : !llvm.ptr
%slot0 = llvm.getelementptr %env[0, 0] : (!llvm.ptr, i64) -&gt; !llvm.ptr
llvm.store %fn_ptr, %slot0 : !llvm.ptr, !llvm.ptr
// ... (환경 저장)

// Phase 5 (고수준)
%closure = funlang.closure @func, %captured_vars : (i32) -&gt; i32
</code></pre>
<p>Phase 5는 <strong>컴파일러 품질</strong>을 향상시킨다. Phase 4는 <strong>기능 완성</strong>이다.</p>
<hr>
<p><strong>Congratulations!</strong> Phase 4 완료. 이제 FunLang은 <strong>완전한 함수형 언어</strong>의 핵심 기능을 지원한다.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-14-커스텀-dialect-설계-custom-dialect-design"><a class="header" href="#chapter-14-커스텀-dialect-설계-custom-dialect-design">Chapter 14: 커스텀 Dialect 설계 (Custom Dialect Design)</a></h1>
<h2 id="소개-14"><a class="header" href="#소개-14">소개</a></h2>
<p><strong>커스텀 MLIR dialect</strong>는 도메인별 언어(DSL)를 높은 수준에서 표현하는 방법이다. FunLang 컴파일러는 Phase 4까지 빌트인 dialect만 사용했다:</p>
<ul>
<li><code>arith</code>: 산술 연산</li>
<li><code>func</code>: 함수 정의와 호출</li>
<li><code>scf</code>: 구조적 제어 흐름 (if/while)</li>
<li><code>llvm</code>: LLVM IR 타입과 operation</li>
</ul>
<p>이 dialect들은 강력하고 범용적이지만, <strong>FunLang의 고수준 의미론을 직접 표현하지 못한다</strong>. Phase 4에서 클로저를 구현할 때 복잡성이 드러났다.</p>
<h3 id="phase-4의-문제점-저수준-llvm-dialect의-복잡성"><a class="header" href="#phase-4의-문제점-저수준-llvm-dialect의-복잡성">Phase 4의 문제점: 저수준 LLVM Dialect의 복잡성</a></h3>
<p>Chapter 12에서 클로저를 구현할 때, 단순한 개념을 복잡한 저수준 코드로 표현해야 했다:</p>
<pre><code class="language-fsharp">// 개념적으로 단순한 코드
let make_adder n =
    fun x -&gt; x + n
</code></pre>
<p><strong>생성된 MLIR (Phase 4 방식):</strong></p>
<pre><code class="language-mlir">func.func @make_adder(%n: i32) -&gt; !llvm.ptr {
    // 1. 환경 크기 계산: 8 (fn ptr) + 4 (n) = 12 bytes
    %env_size = arith.constant 12 : i64

    // 2. GC_malloc 호출
    %env_ptr = llvm.call @GC_malloc(%env_size) : (i64) -&gt; !llvm.ptr

    // 3. 함수 포인터 저장 (env[0])
    %fn_addr = llvm.mlir.addressof @lambda_adder : !llvm.ptr
    %fn_slot = llvm.getelementptr %env_ptr[0] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %fn_addr, %fn_slot : !llvm.ptr, !llvm.ptr

    // 4. 캡처된 변수 n 저장 (env[1])
    %n_slot = llvm.getelementptr %env_ptr[1] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %n, %n_slot : i32, !llvm.ptr

    // 5. 환경 포인터 반환 (클로저)
    func.return %env_ptr : !llvm.ptr
}

// lambda_adder 함수 (환경 파라미터 추가)
func.func @lambda_adder(%env: !llvm.ptr, %x: i32) -&gt; i32 {
    // 1. 환경에서 n 로드
    %n_slot = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
    %n = llvm.load %n_slot : !llvm.ptr -&gt; i32

    // 2. x + n 계산
    %result = arith.addi %x, %n : i32
    func.return %result : i32
}
</code></pre>
<p><strong>문제점:</strong></p>
<ol>
<li>
<p><strong>GEP (getelementptr) 패턴의 반복</strong></p>
<ul>
<li>환경 슬롯 접근할 때마다 <code>getelementptr + load</code> 패턴 필요</li>
<li>인덱스 관리 오류 발생 가능 (env[0] vs env[1])</li>
<li>코드 가독성 저하</li>
</ul>
</li>
<li>
<p><strong>저수준 메모리 관리 노출</strong></p>
<ul>
<li><code>GC_malloc</code> 크기 계산 (8 + 4 bytes?)</li>
<li>포인터 산술 명시적 작성</li>
<li>타입 불일치 가능성 (i32 vs !llvm.ptr)</li>
</ul>
</li>
<li>
<p><strong>도메인 의미론 상실</strong></p>
<ul>
<li>“클로저“라는 개념이 안 보인다</li>
<li>“환경 포인터” = <code>!llvm.ptr</code> (opaque, 타입 안전성 없음)</li>
<li>최적화 pass 작성 어려움 (어떤 포인터가 클로저인지?)</li>
</ul>
</li>
<li>
<p><strong>컴파일러 코드 복잡성 폭발</strong></p>
<ul>
<li>F# 컴파일러 코드가 저수준 세부사항 처리</li>
<li>변수 1개 추가할 때마다 GEP 인덱스 계산</li>
<li>에러 가능성 증가</li>
</ul>
</li>
</ol>
<p><strong>실제 컴파일러 코드 (Phase 4):</strong></p>
<pre><code class="language-fsharp">// Lambda 컴파일 (Phase 4 버전)
let compileLambda (builder: OpBuilder) (param: string) (body: Expr) (capturedVars: (string * MlirValue) list) =
    // 1. 환경 크기 계산 (수동!)
    let fnPtrSize = 8L
    let varSize = 4L  // i32 가정
    let totalSize = fnPtrSize + (int64 capturedVars.Length) * varSize
    let sizeConst = builder.CreateI64Const(totalSize)

    // 2. GC_malloc 호출
    let envPtr = builder.CreateCall("GC_malloc", [sizeConst])

    // 3. 함수 포인터 저장 (getelementptr 0)
    let fnSlot = builder.CreateGEP(envPtr, 0)
    builder.CreateStore(fnAddr, fnSlot)

    // 4. 캡처된 변수들 저장 (getelementptr 1, 2, 3...)
    capturedVars |&gt; List.iteri (fun i (name, value) -&gt;
        let slot = builder.CreateGEP(envPtr, i + 1)
        builder.CreateStore(value, slot)
    )

    envPtr
</code></pre>
<p>크기 계산, GEP 인덱스 관리, 타입 추론 등 저수준 세부사항이 컴파일러 로직에 섞여있다.</p>
<h3 id="custom-dialect의-이점"><a class="header" href="#custom-dialect의-이점">Custom Dialect의 이점</a></h3>
<p><strong>커스텀 dialect</strong>를 사용하면 <strong>높은 수준에서 의미론을 표현</strong>할 수 있다. 같은 코드를 FunLang dialect로 표현한다면:</p>
<pre><code class="language-mlir">func.func @make_adder(%n: i32) -&gt; !funlang.closure {
    // 클로저 생성 - 고수준 operation
    %closure = funlang.make_closure @lambda_adder(%n) : !funlang.closure
    func.return %closure : !funlang.closure
}

func.func @lambda_adder(%x: i32, %n: i32) -&gt; i32 {
    // 캡처된 변수는 파라미터로 전달 (환경 명시적 관리 불필요)
    %result = arith.addi %x, %n : i32
    func.return %result : i32
}
</code></pre>
<p><strong>변화:</strong></p>
<ol>
<li>
<p><strong>도메인 의미론 보존</strong></p>
<ul>
<li><code>!funlang.closure</code> 타입: 클로저임을 명시</li>
<li><code>funlang.make_closure</code>: 클로저 생성의 의도가 명확</li>
<li>GEP, malloc 등 구현 세부사항 숨김</li>
</ul>
</li>
<li>
<p><strong>컴파일러 코드 단순화</strong></p>
</li>
</ol>
<pre><code class="language-fsharp">// Lambda 컴파일 (Phase 5 버전 - 커스텀 dialect 사용)
let compileLambda (builder: OpBuilder) (param: string) (body: Expr) (capturedVars: (string * MlirValue) list) =
    // 간단! dialect operation 호출
    let capturedValues = capturedVars |&gt; List.map snd
    builder.CreateFunLangClosure(lambdaFuncName, capturedValues)
</code></pre>
<p>환경 크기, GEP 인덱스, 메모리 레이아웃 등이 dialect operation 구현 안으로 캡슐화된다.</p>
<ol start="3">
<li>
<p><strong>타입 안전성 향상</strong></p>
<ul>
<li><code>!llvm.ptr</code> (모든 포인터) → <code>!funlang.closure</code> (클로저 전용)</li>
<li>타입 체커가 클로저 오용 방지 가능</li>
<li>예: 정수 포인터를 클로저로 사용하려는 시도 방지</li>
</ul>
</li>
<li>
<p><strong>최적화 기회 증가</strong></p>
<ul>
<li>Dialect-specific optimization pass 작성 가능</li>
<li>예: 환경에 변수 1개만 있을 때 inline 최적화</li>
<li>예: 탈출하지 않는 클로저는 stack 할당</li>
</ul>
</li>
<li>
<p><strong>디버깅 용이성</strong></p>
<ul>
<li>높은 수준 IR을 먼저 검증 가능</li>
<li>에러 메시지가 도메인 용어 사용 (“closure type mismatch” vs “pointer type mismatch”)</li>
</ul>
</li>
</ol>
<h3 id="progressive-lowering-왜-점진적으로-낮추는가"><a class="header" href="#progressive-lowering-왜-점진적으로-낮추는가">Progressive Lowering: 왜 점진적으로 낮추는가?</a></h3>
<p>**Progressive lowering (점진적 하강)**은 높은 수준 표현을 여러 단계로 낮추는 전략이다:</p>
<pre><code>FunLang Dialect (highest level, domain-specific)
    ↓ (FunLangToStandard lowering pass)
Func + SCF + MemRef (mid-level, general purpose)
    ↓ (StandardToLLVM lowering pass)
LLVM Dialect (low-level, machine-oriented)
    ↓ (MLIR-to-LLVM translation)
LLVM IR → Machine Code
</code></pre>
<p><strong>Before/After 비교:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Phase 4 (Direct lowering)</th><th>Phase 5 (Progressive lowering)</th></tr>
</thead>
<tbody>
<tr><td>FunLang AST → LLVM Dialect</td><td>FunLang AST → FunLang Dialect</td></tr>
<tr><td>단일 거대 변환</td><td>→ Func/SCF/MemRef Dialect</td></tr>
<tr><td>의미론 상실 즉시</td><td>→ LLVM Dialect</td></tr>
<tr><td>최적화 불가</td><td>각 단계에서 최적화 가능</td></tr>
<tr><td>디버깅 어려움</td><td>각 단계 독립 검증 가능</td></tr>
</tbody>
</table>
</div>
<h3 id="chapter-14의-목표"><a class="header" href="#chapter-14의-목표">Chapter 14의 목표</a></h3>
<p>이 장에서 다루는 것:</p>
<ol>
<li><strong>MLIR Dialect 아키텍처</strong>: Operation, Type, Attribute의 역할</li>
<li><strong>Progressive Lowering 철학</strong>: 왜 여러 단계로 낮추는가?</li>
<li><strong>TableGen ODS</strong>: MLIR operation 정의 DSL</li>
<li><strong>C API Shim 패턴</strong>: C++ dialect를 F#에 연결</li>
<li><strong>FunLang Dialect 설계</strong>: 어떤 operation을 만들 것인가?</li>
</ol>
<p>이 장을 마치면:</p>
<ul>
<li>커스텀 dialect가 왜 필요한지 이해한다</li>
<li>TableGen ODS 문법을 읽고 쓸 수 있다</li>
<li>C API shim 패턴으로 F# interop 할 수 있다</li>
<li>FunLang dialect의 operation과 type을 설계할 수 있다</li>
<li>Progressive lowering 경로를 계획할 수 있다</li>
</ul>
<blockquote>
<p><strong>Preview:</strong> Chapter 15에서는 실제로 FunLang dialect를 구현하고 lowering pass를 작성한다. Chapter 14는 이론적 기초를 확립한다.</p>
</blockquote>
<h2 id="mlir-dialect-아키텍처"><a class="header" href="#mlir-dialect-아키텍처">MLIR Dialect 아키텍처</a></h2>
<p>MLIR의 핵심 강점은 **extensibility (확장성)**다. 새 dialect를 정의해서 도메인별 개념을 표현할 수 있다.</p>
<h3 id="dialect-hierarchy-개념"><a class="header" href="#dialect-hierarchy-개념">Dialect Hierarchy 개념</a></h3>
<p>MLIR 프로그램은 <strong>여러 dialect의 operation이 섞여있다</strong>:</p>
<pre><code class="language-mlir">func.func @example(%arg: i32) -&gt; i32 {
    // arith dialect
    %c1 = arith.constant 1 : i32
    %sum = arith.addi %arg, %c1 : i32

    // scf dialect
    %result = scf.if %cond -&gt; i32 {
        scf.yield %sum : i32
    } else {
        scf.yield %arg : i32
    }

    // func dialect
    func.return %result : i32
}
</code></pre>
<p>각 operation은 <code>dialect.operation</code> 형식으로 네임스페이스를 가진다:</p>
<ul>
<li><code>arith.constant</code>: arith dialect의 constant operation</li>
<li><code>scf.if</code>: scf dialect의 if operation</li>
<li><code>func.return</code>: func dialect의 return operation</li>
</ul>
<p><strong>Dialect hierarchy (계층 구조):</strong></p>
<pre><code>┌────────────────────────────────────────┐
│  FunLang Dialect (highest level)      │
│  - funlang.closure                     │
│  - funlang.apply                       │
│  - funlang.match (Phase 6)             │
└──────────────┬─────────────────────────┘
               │ (lowering pass)
               ↓
┌────────────────────────────────────────┐
│  Standard Dialects (mid-level)         │
│  - func.func, func.call                │
│  - scf.if, scf.while                   │
│  - memref.alloc, memref.load           │
└──────────────┬─────────────────────────┘
               │ (lowering pass)
               ↓
┌────────────────────────────────────────┐
│  LLVM Dialect (low-level)              │
│  - llvm.getelementptr                  │
│  - llvm.load, llvm.store               │
│  - llvm.call                           │
└──────────────┬─────────────────────────┘
               │ (translation)
               ↓
┌────────────────────────────────────────┐
│  LLVM IR                               │
└────────────────────────────────────────┘
</code></pre>
<p><strong>높은 수준일수록:</strong></p>
<ul>
<li>도메인 개념 명확 (funlang.closure vs !llvm.ptr)</li>
<li>최적화 기회 많음 (의미론 활용 가능)</li>
<li>플랫폼 독립적</li>
</ul>
<p><strong>낮은 수준일수록:</strong></p>
<ul>
<li>기계 모델에 가까움 (레지스터, 메모리, 포인터)</li>
<li>구현 세부사항 노출</li>
<li>플랫폼 특화</li>
</ul>
<h3 id="operation-type-attribute의-역할"><a class="header" href="#operation-type-attribute의-역할">Operation, Type, Attribute의 역할</a></h3>
<p>MLIR dialect는 세 가지 확장 포인트를 제공한다:</p>
<h4 id="1-operation-연산"><a class="header" href="#1-operation-연산">1. Operation (연산)</a></h4>
<p><strong>Operation</strong>은 계산 단위다. FunLang dialect operation 예시:</p>
<pre><code class="language-mlir">// funlang.make_closure operation
%closure = funlang.make_closure @lambda_func(%n, %m) : !funlang.closure

// funlang.apply operation
%result = funlang.apply %closure(%x) : (i32) -&gt; i32
</code></pre>
<p><strong>Operation 구성 요소:</strong></p>
<ul>
<li><strong>Name</strong>: <code>funlang.make_closure</code> (dialect.operation 형식)</li>
<li><strong>Operands</strong>: <code>@lambda_func</code>, <code>%n</code>, <code>%m</code> (입력 값)</li>
<li><strong>Results</strong>: <code>%closure</code> (출력 값)</li>
<li><strong>Types</strong>: <code>!funlang.closure</code>, <code>i32</code> (타입 정보)</li>
<li><strong>Attributes</strong>: <code>@lambda_func</code> (컴파일 타임 상수)</li>
<li><strong>Regions</strong>: 중첩 코드 블록 (예: scf.if의 then/else 블록)</li>
</ul>
<p><strong>Operation의 역할:</strong></p>
<ul>
<li>도메인별 계산 표현 (클로저 생성, 패턴 매칭 등)</li>
<li>Verifier로 정적 검증 (타입 체크, 불변식)</li>
<li>Lowering 대상 (다른 dialect operation으로 변환)</li>
</ul>
<h4 id="2-type-타입"><a class="header" href="#2-type-타입">2. Type (타입)</a></h4>
<p><strong>Type</strong>은 값의 종류를 표현한다. FunLang dialect type 예시:</p>
<pre><code class="language-mlir">// funlang.closure 타입
%closure : !funlang.closure

// funlang.list 타입 (Phase 6)
%list : !funlang.list&lt;i32&gt;
</code></pre>
<p><strong>빌트인 타입 vs 커스텀 타입:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>빌트인 타입</th><th>커스텀 타입</th></tr>
</thead>
<tbody>
<tr><td><code>i32</code>, <code>i64</code>, <code>f32</code></td><td><code>!funlang.closure</code></td></tr>
<tr><td><code>!llvm.ptr</code></td><td><code>!funlang.list&lt;i32&gt;</code></td></tr>
<tr><td><code>tensor&lt;10xf32&gt;</code></td><td><code>!funlang.record&lt;{x:i32, y:i32}&gt;</code></td></tr>
<tr><td>범용적</td><td>도메인 특화</td></tr>
</tbody>
</table>
</div>
<p><strong>타입의 역할:</strong></p>
<ul>
<li>값의 의미론 표현 (closure vs raw pointer)</li>
<li>타입 체커가 오용 방지</li>
<li>최적화 hint (closure는 함수 포인터 + 환경)</li>
</ul>
<h4 id="3-attribute-속성"><a class="header" href="#3-attribute-속성">3. Attribute (속성)</a></h4>
<p><strong>Attribute</strong>는 컴파일 타임 상수 값이다:</p>
<pre><code class="language-mlir">// IntegerAttr
%c1 = arith.constant 1 : i32

// SymbolRefAttr (함수 이름)
%fn = func.call @my_function(%arg) : (i32) -&gt; i32

// StringAttr
%str = llvm.mlir.global "hello"

// ArrayAttr
#array = [1, 2, 3, 4]
</code></pre>
<p>FunLang dialect에서 attribute 사용:</p>
<pre><code class="language-mlir">// 클로저가 참조하는 함수 (SymbolRefAttr)
%closure = funlang.make_closure @lambda_func(%n) : !funlang.closure

// 패턴 매칭 케이스 (ArrayAttr)
%result = funlang.match %value {
    #funlang.pattern&lt;constructor="Nil"&gt; -&gt; { ... }
    #funlang.pattern&lt;constructor="Cons"&gt; -&gt; { ... }
}
</code></pre>
<p><strong>Attribute의 역할:</strong></p>
<ul>
<li>컴파일 타임 정보 저장 (함수 이름, 상수 등)</li>
<li>Serialization (MLIR IR을 파일에 저장)</li>
<li>Lowering 힌트</li>
</ul>
<h3 id="region과-block-phase-1-복습"><a class="header" href="#region과-block-phase-1-복습">Region과 Block (Phase 1 복습)</a></h3>
<p>Chapter 01에서 배운 개념 다시 보기:</p>
<p><strong>Region</strong>: operation 내부의 코드 영역</p>
<pre><code class="language-mlir">scf.if %cond -&gt; i32 {
    // ↑ Region 1 (then block)
    %result = arith.addi %a, %b : i32
    scf.yield %result : i32
} else {
    // ↑ Region 2 (else block)
    %result = arith.subi %a, %b : i32
    scf.yield %result : i32
}
</code></pre>
<p><strong>Block</strong>: region 내부의 명령어 시퀀스</p>
<pre><code class="language-mlir">func.func @example(%arg: i32) -&gt; i32 {
^entry:  // ↑ Block label
    %c1 = arith.constant 1 : i32
    %sum = arith.addi %arg, %c1 : i32
    func.return %sum : i32
}
</code></pre>
<p><strong>FunLang dialect에서 region 사용 가능?</strong></p>
<p>가능하다. 예를 들어 <code>funlang.match</code> operation은 패턴별 region을 가질 수 있다:</p>
<pre><code class="language-mlir">%result = funlang.match %list : !funlang.list&lt;i32&gt; -&gt; i32 {
    // Nil case
    ^nil_case:
        %zero = arith.constant 0 : i32
        funlang.yield %zero : i32

    // Cons case
    ^cons_case(%head: i32, %tail: !funlang.list&lt;i32&gt;):
        %sum = funlang.apply %f(%head) : (i32) -&gt; i32
        funlang.yield %sum : i32
}
</code></pre>
<p>각 케이스가 별도 block을 가진다. 이렇게 <strong>structured control flow</strong>를 dialect operation으로 표현할 수 있다.</p>
<h3 id="symbol-table과-함수-참조"><a class="header" href="#symbol-table과-함수-참조">Symbol Table과 함수 참조</a></h3>
<p>MLIR은 <strong>symbol table</strong>을 사용해 함수, 전역 변수 등을 참조한다.</p>
<p><strong>Symbol (심볼):</strong></p>
<pre><code class="language-mlir">// 함수 정의 - symbol
func.func @my_function(%arg: i32) -&gt; i32 {
    func.return %arg : i32
}

// 함수 참조 - SymbolRefAttr
%result = func.call @my_function(%x) : (i32) -&gt; i32
</code></pre>
<p><code>@my_function</code>은 <strong>SymbolRefAttr</strong>이다:</p>
<ul>
<li>컴파일 타임에 해석됨</li>
<li>타입 체커가 함수 시그니처 검증</li>
<li>Linker가 심볼 해석</li>
</ul>
<p><strong>FunLang dialect에서 symbol 사용:</strong></p>
<pre><code class="language-mlir">// 람다 함수 정의 (lifted)
func.func private @lambda_adder(%env: !funlang.env, %x: i32) -&gt; i32 {
    // ...
}

// 클로저 생성 - 함수 심볼 참조
%closure = funlang.make_closure @lambda_adder(%n) : !funlang.closure
</code></pre>
<p><code>@lambda_adder</code>가 심볼이다. 클로저는 이 심볼을 참조해서 함수 포인터를 얻는다.</p>
<p><strong>Symbol vs SSA Value:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Symbol</th><th>SSA Value</th></tr>
</thead>
<tbody>
<tr><td><code>@func_name</code></td><td><code>%result</code></td></tr>
<tr><td>컴파일 타임 상수</td><td>런타임 값</td></tr>
<tr><td>전역 참조 가능</td><td>로컬 스코프만</td></tr>
<tr><td>함수, 전역 변수</td><td>operation 결과</td></tr>
</tbody>
</table>
</div>
<p>Phase 4에서 사용한 <code>llvm.mlir.addressof @lambda_func</code>도 심볼을 사용한다:</p>
<pre><code class="language-mlir">// 함수 심볼 주소 얻기
%fn_addr = llvm.mlir.addressof @lambda_func : !llvm.ptr
</code></pre>
<h3 id="dialectregistry와-의존성-선언"><a class="header" href="#dialectregistry와-의존성-선언">DialectRegistry와 의존성 선언</a></h3>
<p><strong>DialectRegistry</strong>는 context에 dialect를 등록하는 메커니즘이다.</p>
<p><strong>Phase 1-4 코드 (빌트인 dialect 등록):</strong></p>
<pre><code class="language-fsharp">// MlirHelpers.fs
let createContextWithDialects() =
    let ctx = MlirContext.Create()

    // 빌트인 dialect 등록
    let arithHandle = Mlir.mlirGetDialectHandle__arith__()
    Mlir.mlirDialectHandleRegisterDialect(arithHandle, ctx.Handle)

    let funcHandle = Mlir.mlirGetDialectHandle__func__()
    Mlir.mlirDialectHandleRegisterDialect(funcHandle, ctx.Handle)

    // ... scf, llvm 등

    ctx
</code></pre>
<p><strong>Phase 5 코드 (커스텀 dialect 추가):</strong></p>
<pre><code class="language-fsharp">// FunLang dialect 등록
let ctx = createContextWithDialects()

// C API shim 호출
FunLangDialect.RegisterDialect(ctx)
</code></pre>
<p><strong>의존성 선언:</strong></p>
<p>FunLang dialect는 다른 dialect를 사용할 수 있다:</p>
<pre><code class="language-cpp">// FunLang dialect 정의 (C++)
class FunLangDialect : public Dialect {
public:
    FunLangDialect(MLIRContext *context) : ... {
        // 의존성 선언
        addDependentDialect&lt;func::FuncDialect&gt;();
        addDependentDialect&lt;arith::ArithDialect&gt;();
        addDependentDialect&lt;LLVM::LLVMDialect&gt;();
    }
};
</code></pre>
<p>이렇게 하면:</p>
<ul>
<li>FunLang operation이 func, arith operation을 사용 가능</li>
<li>Lowering pass에서 func.call, arith.addi 생성 가능</li>
<li>Context가 필요한 dialect 자동 로드</li>
</ul>
<h3 id="funlang-dialect-계층-구조-다이어그램"><a class="header" href="#funlang-dialect-계층-구조-다이어그램">FunLang Dialect 계층 구조 다이어그램</a></h3>
<pre><code>┌─────────────────────────────────────────────────────────────────┐
│                    MLIR Context                                 │
│  (모든 dialect의 컨테이너)                                        │
└────────────────────────────┬────────────────────────────────────┘
                             │
        ┌────────────────────┼────────────────────┐
        │                    │                    │
        ▼                    ▼                    ▼
┌───────────────┐   ┌───────────────┐   ┌───────────────┐
│ FunLang       │   │ BuiltIn       │   │ LLVM          │
│ Dialect       │   │ Dialect       │   │ Dialect       │
│               │   │ (func, scf,   │   │               │
│ - closure     │   │  arith)       │   │ - ptr         │
│ - apply       │   │               │   │ - call        │
│ - match       │   │ - func.func   │   │ - gep         │
└───────┬───────┘   │ - scf.if      │   │ - load/store  │
        │           │ - arith.addi  │   └───────────────┘
        │           └───────────────┘
        │
        │  (의존성)
        └──────────────────┐
                           │
                ┌──────────┴──────────┐
                │                     │
                ▼                     ▼
        ┌───────────────┐     ┌───────────────┐
        │ Types         │     │ Operations    │
        │               │     │               │
        │ - closure     │     │ - make_closure│
        │ - list&lt;T&gt;     │     │ - apply       │
        │ - record&lt;...&gt; │     │ - match       │
        └───────────────┘     └───────────────┘
</code></pre>
<p><strong>Dialect 간 관계:</strong></p>
<ol>
<li>
<p><strong>FunLang Dialect</strong>: 최상위, 도메인 특화</p>
<ul>
<li>의존: func, scf, arith, llvm dialect</li>
<li>제공: funlang.* operation/type</li>
</ul>
</li>
<li>
<p><strong>BuiltIn Dialects</strong>: 중간 수준, 범용</p>
<ul>
<li>의존: 최소 (arith는 독립적)</li>
<li>제공: func.<em>, scf.</em>, arith.* operation</li>
</ul>
</li>
<li>
<p><strong>LLVM Dialect</strong>: 최하위, 기계 지향</p>
<ul>
<li>의존: 없음 (target-independent LLVM IR)</li>
<li>제공: llvm.* operation</li>
</ul>
</li>
</ol>
<p><strong>Lowering 경로:</strong></p>
<pre><code>funlang.make_closure
    ↓ (FunLangToFunc lowering)
func.func + memref.alloc + func.call
    ↓ (FuncToLLVM lowering)
llvm.call + llvm.getelementptr + llvm.store
    ↓ (MLIR-to-LLVM translation)
LLVM IR: call, getelementptr, store
</code></pre>
<h2 id="progressive-lowering-철학"><a class="header" href="#progressive-lowering-철학">Progressive Lowering 철학</a></h2>
<h3 id="why-not-direct-funlang--llvm-lowering"><a class="header" href="#why-not-direct-funlang--llvm-lowering">Why Not Direct FunLang → LLVM Lowering?</a></h3>
<p>컴파일러를 설계할 때 유혹이 있다: “FunLang AST를 바로 LLVM dialect로 낮추면 빠르지 않을까?”</p>
<p><strong>직접 lowering의 문제점:</strong></p>
<h4 id="1-최적화-기회-상실"><a class="header" href="#1-최적화-기회-상실">1. 최적화 기회 상실</a></h4>
<p><strong>예시: 클로저 inlining</strong></p>
<pre><code class="language-fsharp">// FunLang 코드
let apply f x = f x

let result = apply (fun y -&gt; y + 1) 42
</code></pre>
<p><strong>Direct lowering (FunLang → LLVM):</strong></p>
<pre><code class="language-mlir">// 클로저 생성 (즉시 LLVM dialect)
%env = llvm.call @GC_malloc(...) : (i64) -&gt; !llvm.ptr
%fn_ptr = llvm.mlir.addressof @lambda_0 : !llvm.ptr
%fn_slot = llvm.getelementptr %env[0] : (!llvm.ptr) -&gt; !llvm.ptr
llvm.store %fn_ptr, %fn_slot : !llvm.ptr, !llvm.ptr
// ... (환경 저장)

// 클로저 호출 (간접 호출)
%fn_ptr_loaded = llvm.load %fn_slot : !llvm.ptr -&gt; !llvm.ptr
%result = llvm.call %fn_ptr_loaded(%env, %x) : (!llvm.ptr, i32) -&gt; i32
</code></pre>
<p>문제: <strong>LLVM 수준에서는 이것이 즉시 사용되는 클로저인지 알 수 없다</strong>. 최적화 pass가 malloc, store, load, call 패턴을 분석해야 하는데, 이미 의미론이 상실됨.</p>
<p><strong>Progressive lowering (FunLang → Func → LLVM):</strong></p>
<pre><code class="language-mlir">// Step 1: FunLang dialect (high-level)
%closure = funlang.make_closure @lambda_0() : !funlang.closure
%result = funlang.apply %closure(%x) : (i32) -&gt; i32

// Optimization pass: closure inlining (FunLang dialect level)
// "이 클로저는 즉시 사용되고 탈출하지 않는다" → inline!
%result = func.call @lambda_0(%x) : (i32) -&gt; i32

// Step 2: Lower to LLVM (이미 최적화됨)
%result = llvm.call @lambda_0(%x) : (i32) -&gt; i32
</code></pre>
<p><strong>높은 수준에서 최적화하면:</strong></p>
<ul>
<li>의미론이 명확 (closure + apply = inline candidate)</li>
<li>패턴 매칭 쉬움 (GEP + load 추적 불필요)</li>
<li>변환이 안전함 (타입 체커가 검증)</li>
</ul>
<h4 id="2-코드-복잡성-폭발"><a class="header" href="#2-코드-복잡성-폭발">2. 코드 복잡성 폭발</a></h4>
<p><strong>Direct lowering 컴파일러 코드:</strong></p>
<pre><code class="language-fsharp">// compileLambda: FunLang AST → LLVM dialect
let rec compileLambda (builder: OpBuilder) (lambda: Expr) =
    match lambda with
    | Lambda(param, body) -&gt;
        // 1. 자유 변수 분석
        let freeVars = analyzeFreeVars lambda

        // 2. 환경 크기 계산 (수동!)
        let envSize = 8L + (int64 freeVars.Length) * 4L
        let sizeConst = builder.CreateI64Const(envSize)

        // 3. GC_malloc 호출
        let malloc = builder.CreateCall("GC_malloc", [sizeConst])

        // 4. 함수 포인터 저장 (GEP 0)
        let fnAddr = builder.CreateAddressOf(lambdaName)
        let fnSlot = builder.CreateGEP(malloc, 0)
        builder.CreateStore(fnAddr, fnSlot)

        // 5. 변수 저장 (GEP 1, 2, 3...)
        freeVars |&gt; List.iteri (fun i var -&gt;
            let value = compileExpr builder var
            let slot = builder.CreateGEP(malloc, i + 1)
            builder.CreateStore(value, slot)
        )

        // 6. 람다 함수 정의 (별도 함수)
        let lambdaFunc = builder.CreateFunction(lambdaName)
        // ... (환경 파라미터, body 컴파일, GEP + load for captures)

        malloc
</code></pre>
<p><strong>모든 세부사항이 한 함수에 섞여있다:</strong></p>
<ul>
<li>메모리 레이아웃 계산</li>
<li>GEP 인덱스 관리</li>
<li>타입 변환</li>
<li>함수 생성</li>
</ul>
<p><strong>Progressive lowering 컴파일러 코드:</strong></p>
<pre><code class="language-fsharp">// Step 1: FunLang AST → FunLang dialect
let rec compileLambda (builder: OpBuilder) (lambda: Expr) =
    match lambda with
    | Lambda(param, body) -&gt;
        let freeVars = analyzeFreeVars lambda
        let capturedValues = freeVars |&gt; List.map (compileExpr builder)

        // 간단! dialect operation 호출
        builder.CreateFunLangClosure(lambdaName, capturedValues)

// Step 2: FunLang dialect → Func dialect (별도 lowering pass)
// 이 pass에서 malloc, GEP, store 처리
class FunLangToFuncLowering : public RewritePattern {
    LogicalResult matchAndRewrite(MakeClosureOp op, ...) {
        // 여기서 환경 할당, 함수 포인터 저장 등 처리
        // 재사용 가능한 로직, 독립적 테스트 가능
    }
};
</code></pre>
<p><strong>코드가 계층화된다:</strong></p>
<ul>
<li>AST → Dialect: 의미론 변환 (단순)</li>
<li>Dialect → Dialect: 구현 세부사항 (재사용 가능)</li>
<li>Dialect → LLVM: 기계 코드 생성 (표준 패턴)</li>
</ul>
<h4 id="3-디버깅-어려움"><a class="header" href="#3-디버깅-어려움">3. 디버깅 어려움</a></h4>
<p><strong>Direct lowering:</strong></p>
<pre><code>FunLang AST → [Giant Black Box] → LLVM Dialect
</code></pre>
<p>에러가 발생하면:</p>
<ul>
<li>LLVM IR에서 segfault 발견</li>
<li>원인 추적 어려움 (GEP 인덱스? 타입? 메모리?)</li>
<li>AST와 LLVM IR 사이 gap이 크다</li>
</ul>
<p><strong>Progressive lowering:</strong></p>
<pre><code>FunLang AST → FunLang Dialect → Func Dialect → LLVM Dialect
               ↑ verify       ↑ verify      ↑ verify
</code></pre>
<p>각 단계에서 검증 가능:</p>
<ol>
<li>FunLang Dialect: 타입 체크 (<code>!funlang.closure</code> vs <code>i32</code>)</li>
<li>Func Dialect: 함수 시그니처, region 구조</li>
<li>LLVM Dialect: 포인터 연산, 메모리 안전성</li>
</ol>
<p><strong>에러 메시지 비교:</strong></p>
<p>Direct lowering:</p>
<pre><code>error: 'llvm.load' op requires result type '!llvm.ptr' but found 'i32'
  %value = llvm.load %slot : !llvm.ptr -&gt; i32
</code></pre>
<p>“어디서 잘못됐지? GEP 인덱스? 타입 계산?”</p>
<p>Progressive lowering:</p>
<pre><code>error: 'funlang.apply' op operand type mismatch
  expected: !funlang.closure
  found: i32
  %result = funlang.apply %x(%y) : (i32) -&gt; i32
</code></pre>
<p>“아, 클로저가 아니라 정수를 apply하려고 했구나!”</p>
<h3 id="progressive-lowering-단계-설계"><a class="header" href="#progressive-lowering-단계-설계">Progressive Lowering 단계 설계</a></h3>
<p>FunLang 컴파일러의 lowering 경로:</p>
<pre><code>┌─────────────────────────────────────────┐
│  FunLang AST (F# data structures)       │
│  - Lambda(param, body)                  │
│  - Apply(fn, arg)                       │
│  - Let(name, value, body)               │
└───────────────┬─────────────────────────┘
                │ (AST → Dialect)
                ↓
┌─────────────────────────────────────────┐
│  FunLang Dialect (MLIR IR)              │
│  - funlang.make_closure                 │
│  - funlang.apply                        │
│  - funlang.match                        │
│                                         │
│  Optimization:                          │
│  - Closure inlining                     │
│  - Dead closure elimination             │
│  - Escape analysis                      │
└───────────────┬─────────────────────────┘
                │ (FunLangToFunc lowering pass)
                ↓
┌─────────────────────────────────────────┐
│  Func + SCF + MemRef (MLIR IR)          │
│  - func.func, func.call                 │
│  - scf.if, scf.while                    │
│  - memref.alloc, memref.load/store      │
│                                         │
│  Optimization:                          │
│  - Inlining                             │
│  - Dead code elimination                │
│  - Loop optimization                    │
└───────────────┬─────────────────────────┘
                │ (FuncToLLVM lowering pass)
                ↓
┌─────────────────────────────────────────┐
│  LLVM Dialect (MLIR IR)                 │
│  - llvm.call                            │
│  - llvm.getelementptr                   │
│  - llvm.load, llvm.store                │
│                                         │
│  Optimization:                          │
│  - (LLVM's own optimization passes)     │
└───────────────┬─────────────────────────┘
                │ (MLIR → LLVM IR translation)
                ↓
┌─────────────────────────────────────────┐
│  LLVM IR                                │
│  - call, getelementptr, load, store     │
└───────────────┬─────────────────────────┘
                │ (LLVM backend)
                ↓
┌─────────────────────────────────────────┐
│  Machine Code (x86, ARM, etc.)          │
└─────────────────────────────────────────┘
</code></pre>
<h3 id="각-단계의-역할"><a class="header" href="#각-단계의-역할">각 단계의 역할</a></h3>
<h4 id="stage-1-funlang-dialect"><a class="header" href="#stage-1-funlang-dialect">Stage 1: FunLang Dialect</a></h4>
<p><strong>표현:</strong> 도메인 의미론 (클로저, 패턴 매칭, 리스트)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-mlir">func.func @make_adder(%n: i32) -&gt; !funlang.closure {
    %closure = funlang.make_closure @lambda_adder(%n) : !funlang.closure
    func.return %closure : !funlang.closure
}

func.func private @lambda_adder(%x: i32, %n: i32) -&gt; i32 {
    %result = arith.addi %x, %n : i32
    func.return %result : i32
}
</code></pre>
<p><strong>특징:</strong></p>
<ul>
<li><code>!funlang.closure</code> 타입 사용</li>
<li>구현 세부사항 숨김 (malloc, GEP 없음)</li>
<li>최적화 가능 (클로저 inlining, escape analysis)</li>
</ul>
<p><strong>최적화 예시:</strong></p>
<pre><code class="language-mlir">// Before optimization
%closure = funlang.make_closure @lambda_inc() : !funlang.closure
%result = funlang.apply %closure(%x) : (i32) -&gt; i32

// After closure inlining (FunLang dialect pass)
%result = func.call @lambda_inc(%x) : (i32) -&gt; i32
</code></pre>
<h4 id="stage-2-func--scf--memref-dialect"><a class="header" href="#stage-2-func--scf--memref-dialect">Stage 2: Func + SCF + MemRef Dialect</a></h4>
<p><strong>표현:</strong> 범용 추상화 (함수, 제어 흐름, 메모리)</p>
<p><strong>Example (Stage 1 lowering 후):</strong></p>
<pre><code class="language-mlir">func.func @make_adder(%n: i32) -&gt; !llvm.ptr {
    // 환경 할당 (memref.alloc)
    %c2 = arith.constant 2 : index
    %env = memref.alloc(%c2) : memref&lt;?xi32&gt;

    // 함수 포인터 저장 (conceptual, 실제는 다름)
    // ... (이 단계에서 여전히 추상적)

    // 캡처된 변수 저장
    %c1 = arith.constant 1 : index
    memref.store %n, %env[%c1] : memref&lt;?xi32&gt;

    // 포인터 반환
    %ptr = memref.cast %env : memref&lt;?xi32&gt; to !llvm.ptr
    func.return %ptr : !llvm.ptr
}
</code></pre>
<p><strong>특징:</strong></p>
<ul>
<li>여전히 플랫폼 독립적</li>
<li>메모리 연산이 추상적 (memref vs raw pointer)</li>
<li>구조적 제어 흐름 (scf.if vs cf.br)</li>
</ul>
<p><strong>최적화 예시:</strong></p>
<pre><code class="language-mlir">// Inlining (func dialect level)
%result = func.call @small_function(%x) : (i32) -&gt; i32

// After inlining
// (함수 본체 inline됨)
%result = arith.addi %x, %c1 : i32
</code></pre>
<h4 id="stage-3-llvm-dialect"><a class="header" href="#stage-3-llvm-dialect">Stage 3: LLVM Dialect</a></h4>
<p><strong>표현:</strong> 기계 모델 (포인터, 레지스터, 메모리)</p>
<p><strong>Example (Stage 2 lowering 후):</strong></p>
<pre><code class="language-mlir">llvm.func @make_adder(%n: i32) -&gt; !llvm.ptr {
    // GC_malloc 호출
    %c12 = llvm.mlir.constant(12 : i64) : i64
    %env = llvm.call @GC_malloc(%c12) : (i64) -&gt; !llvm.ptr

    // 함수 포인터 저장
    %fn_addr = llvm.mlir.addressof @lambda_adder : !llvm.ptr
    %fn_slot = llvm.getelementptr %env[0] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %fn_addr, %fn_slot : !llvm.ptr, !llvm.ptr

    // 캡처된 변수 저장
    %n_slot = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %n, %n_slot : i32, !llvm.ptr

    llvm.return %env : !llvm.ptr
}
</code></pre>
<p><strong>특징:</strong></p>
<ul>
<li>구현 세부사항 완전 노출 (GEP, malloc, store)</li>
<li>LLVM IR과 1:1 대응</li>
<li>플랫폼 특화 최적화 가능 (LLVM backend)</li>
</ul>
<h3 id="conversiontarget과-legalillegal-dialects"><a class="header" href="#conversiontarget과-legalillegal-dialects">ConversionTarget과 Legal/Illegal Dialects</a></h3>
<p><strong>Lowering pass</strong>는 특정 dialect operation을 다른 dialect operation으로 변환한다. MLIR은 <strong>ConversionTarget</strong>으로 이를 제어한다.</p>
<p><strong>ConversionTarget 개념:</strong></p>
<p>“이 pass 이후 어떤 operation이 허용되는가?”</p>
<pre><code class="language-cpp">// FunLangToFunc lowering pass
class FunLangToFuncLowering : public Pass {
    void runOnOperation() override {
        ConversionTarget target(getContext());

        // FunLang dialect operation은 불법 (lowering 대상)
        target.addIllegalDialect&lt;FunLangDialect&gt;();

        // Func, SCF, Arith dialect operation은 합법
        target.addLegalDialect&lt;func::FuncDialect&gt;();
        target.addLegalDialect&lt;scf::SCFDialect&gt;();
        target.addLegalDialect&lt;arith::ArithDialect&gt;();

        // Lowering 수행
        if (failed(applyPartialConversion(module, target, patterns)))
            signalPassFailure();
    }
};
</code></pre>
<p><strong>Legal vs Illegal:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Legal Operations</th><th>Illegal Operations</th></tr>
</thead>
<tbody>
<tr><td>Pass 후 존재 가능</td><td>Pass 후 제거되어야 함</td></tr>
<tr><td>변환 불필요</td><td>변환 패턴 필요</td></tr>
<tr><td>예: func.call</td><td>예: funlang.make_closure</td></tr>
</tbody>
</table>
</div>
<p><strong>예시: FunLangToFunc lowering</strong></p>
<p>Before (FunLang dialect):</p>
<pre><code class="language-mlir">%closure = funlang.make_closure @lambda_func(%n) : !funlang.closure
</code></pre>
<p>After (Func + MemRef dialect):</p>
<pre><code class="language-mlir">%env = memref.alloc(...) : memref&lt;?xi32&gt;
memref.store %n, %env[%c1] : memref&lt;?xi32&gt;
%ptr = memref.cast %env : memref&lt;?xi32&gt; to !llvm.ptr
</code></pre>
<p><strong>ConversionTarget이 보장:</strong></p>
<ul>
<li><code>funlang.make_closure</code>는 pass 후 존재하지 않음</li>
<li><code>memref.alloc</code>, <code>memref.store</code>는 합법</li>
</ul>
<h3 id="rewritepatternset-개념"><a class="header" href="#rewritepatternset-개념">RewritePatternSet 개념</a></h3>
<p><strong>RewritePattern</strong>은 operation 변환 규칙이다.</p>
<p><strong>구조:</strong></p>
<pre><code class="language-cpp">struct MakeClosureOpLowering : public OpRewritePattern&lt;MakeClosureOp&gt; {
    using OpRewritePattern&lt;MakeClosureOp&gt;::OpRewritePattern;

    LogicalResult matchAndRewrite(MakeClosureOp op,
                                   PatternRewriter &amp;rewriter) const override {
        // 1. Match: 이 operation을 변환할 수 있는가?
        // (OpRewritePattern이 자동으로 매칭)

        // 2. Rewrite: 어떻게 변환하는가?

        // 환경 할당
        Value envSize = rewriter.create&lt;arith::ConstantOp&gt;(...);
        Value env = rewriter.create&lt;memref::AllocOp&gt;(...);

        // 캡처된 변수 저장
        for (auto [idx, captured] : enumerate(op.getCapturedValues())) {
            Value index = rewriter.create&lt;arith::ConstantIndexOp&gt;(idx);
            rewriter.create&lt;memref::StoreOp&gt;(captured, env, index);
        }

        // 원래 operation 교체
        rewriter.replaceOp(op, env);
        return success();
    }
};
</code></pre>
<p><strong>RewritePatternSet 사용:</strong></p>
<pre><code class="language-cpp">void FunLangToFuncPass::runOnOperation() {
    RewritePatternSet patterns(&amp;getContext());

    // 변환 패턴 등록
    patterns.add&lt;MakeClosureOpLowering&gt;(&amp;getContext());
    patterns.add&lt;ApplyOpLowering&gt;(&amp;getContext());
    patterns.add&lt;MatchOpLowering&gt;(&amp;getContext());

    // Conversion target 설정
    ConversionTarget target(getContext());
    target.addIllegalDialect&lt;FunLangDialect&gt;();
    target.addLegalDialect&lt;func::FuncDialect, memref::MemRefDialect, arith::ArithDialect&gt;();

    // 변환 적용
    if (failed(applyPartialConversion(getOperation(), target, patterns)))
        signalPassFailure();
}
</code></pre>
<p><strong>각 pattern이 처리:</strong></p>
<ul>
<li><code>MakeClosureOpLowering</code>: <code>funlang.make_closure</code> → <code>memref.alloc</code> + stores</li>
<li><code>ApplyOpLowering</code>: <code>funlang.apply</code> → <code>func.call</code> (indirect)</li>
<li><code>MatchOpLowering</code>: <code>funlang.match</code> → <code>scf.if</code> cascade</li>
</ul>
<h3 id="실제-lowering-pass-구조-미리보기"><a class="header" href="#실제-lowering-pass-구조-미리보기">실제 Lowering Pass 구조 미리보기</a></h3>
<p><strong>FunLangToFunc.cpp 구조:</strong></p>
<pre><code class="language-cpp">// 1. Pattern 정의들
namespace {

struct MakeClosureOpLowering : public OpRewritePattern&lt;MakeClosureOp&gt; {
    LogicalResult matchAndRewrite(...) const override {
        // funlang.make_closure → memref operations
    }
};

struct ApplyOpLowering : public OpRewritePattern&lt;ApplyOp&gt; {
    LogicalResult matchAndRewrite(...) const override {
        // funlang.apply → func.call (indirect)
    }
};

} // namespace

// 2. Pass 정의
struct FunLangToFuncPass : public PassWrapper&lt;FunLangToFuncPass, OperationPass&lt;ModuleOp&gt;&gt; {
    void getDependentDialects(DialectRegistry &amp;registry) const override {
        registry.insert&lt;func::FuncDialect, memref::MemRefDialect, arith::ArithDialect&gt;();
    }

    void runOnOperation() override {
        // Pattern set 구성
        RewritePatternSet patterns(&amp;getContext());
        patterns.add&lt;MakeClosureOpLowering, ApplyOpLowering&gt;(&amp;getContext());

        // Target 설정
        ConversionTarget target(getContext());
        target.addIllegalDialect&lt;FunLangDialect&gt;();
        target.addLegalDialect&lt;func::FuncDialect, memref::MemRefDialect, arith::ArithDialect&gt;();

        // 변환 실행
        if (failed(applyPartialConversion(getOperation(), target, patterns)))
            signalPassFailure();
    }
};

// 3. Pass 등록
std::unique_ptr&lt;Pass&gt; createFunLangToFuncPass() {
    return std::make_unique&lt;FunLangToFuncPass&gt;();
}
</code></pre>
<p><strong>Pass 실행 순서 (Compiler.fs):</strong></p>
<pre><code class="language-fsharp">// MLIR pass pipeline
let runLoweringPasses (module: MlirModule) =
    let pm = PassManager.Create(module.Context)

    // 1. FunLang dialect → Func/MemRef dialect
    pm.AddPass(FunLangPasses.CreateFunLangToFuncPass())

    // 2. SCF → CF (structured control flow → control flow)
    pm.AddPass(Passes.CreateSCFToCFPass())

    // 3. Func/MemRef/Arith → LLVM dialect
    pm.AddPass(Passes.CreateFuncToLLVMPass())
    pm.AddPass(Passes.CreateMemRefToLLVMPass())
    pm.AddPass(Passes.CreateArithToLLVMPass())

    pm.Run(module)
</code></pre>
<h2 id="요약-1"><a class="header" href="#요약-1">요약</a></h2>
<p><strong>Chapter 14에서 배운 것:</strong></p>
<ol>
<li>
<p><strong>Phase 4의 문제점</strong>: 저수준 LLVM dialect 직접 사용 시 GEP 패턴 반복, 도메인 의미론 상실, 컴파일러 코드 복잡도 증가</p>
</li>
<li>
<p><strong>Custom Dialect의 이점</strong>: 도메인 의미론 보존, 컴파일러 코드 단순화, 타입 안전성 향상, 최적화 기회 증가</p>
</li>
<li>
<p><strong>MLIR Dialect 아키텍처</strong>: Operation (계산), Type (값 종류), Attribute (컴파일 타임 상수), Region/Block (중첩 코드), Symbol Table (전역 참조)</p>
</li>
<li>
<p><strong>Progressive Lowering 철학</strong>:</p>
<ul>
<li>직접 lowering의 문제 (최적화 상실, 복잡도 폭발, 디버깅 어려움)</li>
<li>단계적 lowering의 이점 (각 단계 최적화, 독립 검증, 명확한 책임)</li>
<li>FunLang → Func/MemRef → LLVM 경로</li>
</ul>
</li>
<li>
<p><strong>ConversionTarget과 RewritePattern</strong>: Legal/Illegal dialect 정의, 변환 규칙 작성, pass 구조</p>
</li>
</ol>
<h2 id="tablegen-ods-operation-definition-specification-기초"><a class="header" href="#tablegen-ods-operation-definition-specification-기초">TableGen ODS (Operation Definition Specification) 기초</a></h2>
<h3 id="tablegen이란"><a class="header" href="#tablegen이란">TableGen이란?</a></h3>
<p><strong>TableGen</strong>은 LLVM 프로젝트의 **DSL (Domain-Specific Language)**이다. 코드 생성(code generation)을 위한 선언적 언어다.</p>
<p><strong>Why TableGen?</strong></p>
<p>MLIR operation을 C++로 직접 정의하면:</p>
<pre><code class="language-cpp">// C++ 직접 정의 (verbose!)
class MakeClosureOp : public Op&lt;MakeClosureOp, OpTrait::OneResult, OpTrait::ZeroRegions&gt; {
public:
    static StringRef getOperationName() { return "funlang.make_closure"; }

    static void build(OpBuilder &amp;builder, OperationState &amp;state,
                      FlatSymbolRefAttr funcName, ValueRange capturedValues) {
        // 복잡한 builder 로직...
    }

    LogicalResult verify() {
        // 복잡한 verification 로직...
    }

    // parser, printer, folders, canonicalizers...
    // 100+ lines of boilerplate!
};
</code></pre>
<p><strong>문제점:</strong></p>
<ul>
<li>Boilerplate 코드 많음 (parser, printer, builder)</li>
<li>타입 안전성 수동 관리</li>
<li>일관성 유지 어려움 (operation마다 다른 스타일)</li>
</ul>
<p><strong>TableGen 사용:</strong></p>
<pre><code class="language-tablegen">// TableGen 정의 (concise!)
def FunLang_MakeClosureOp : FunLang_Op&lt;"make_closure", [Pure]&gt; {
  let summary = "Creates a closure value";
  let description = [{
    Creates a closure by capturing values into an environment.
  }];

  let arguments = (ins FlatSymbolRefAttr:$funcName,
                       Variadic&lt;AnyType&gt;:$capturedValues);
  let results = (outs FunLang_ClosureType:$result);

  let assemblyFormat = "$funcName `(` $capturedValues `)` attr-dict `:` type($result)";
}
</code></pre>
<p><strong>장점:</strong></p>
<ul>
<li>선언적 (what, not how)</li>
<li>코드 자동 생성 (parser, printer, builder, verifier)</li>
<li>타입 안전성 자동 보장</li>
<li>일관된 스타일</li>
</ul>
<p><strong>TableGen 빌드 프로세스:</strong></p>
<pre><code>FunLangOps.td (TableGen source)
    ↓ (mlir-tblgen tool)
FunLangOps.h.inc (Generated C++ header)
FunLangOps.cpp.inc (Generated C++ implementation)
    ↓ (C++ compiler)
libMLIRFunLangDialect.so (Shared library)
</code></pre>
<h3 id="funlang-dialect-정의"><a class="header" href="#funlang-dialect-정의">FunLang Dialect 정의</a></h3>
<p><strong>FunLangDialect.td:</strong></p>
<pre><code class="language-tablegen">// FunLang dialect 정의
def FunLang_Dialect : Dialect {
  // Dialect 이름 (operation prefix)
  let name = "funlang";

  // C++ namespace
  let cppNamespace = "::mlir::funlang";

  // 의존성 선언
  let dependentDialects = [
    "func::FuncDialect",
    "arith::ArithDialect",
    "LLVM::LLVMDialect"
  ];

  // Description (documentation)
  let description = [{
    The FunLang dialect represents high-level functional programming constructs
    for the FunLang compiler. It provides operations for closures, pattern matching,
    and other domain-specific features.
  }];

  // Extra class declarations (C++ 코드 삽입)
  let extraClassDeclaration = [{
    // Custom dialect methods (optional)
    void registerTypes();
    void registerOperations();
  }];
}
</code></pre>
<p><strong>각 필드 의미:</strong></p>
<ol>
<li>
<p><strong><code>name</code></strong>: Dialect 네임스페이스</p>
<ul>
<li>Operation: <code>funlang.make_closure</code></li>
<li>Type: <code>!funlang.closure</code></li>
</ul>
</li>
<li>
<p><strong><code>cppNamespace</code></strong>: 생성되는 C++ 코드의 네임스페이스</p>
<ul>
<li><code>mlir::funlang::MakeClosureOp</code></li>
<li><code>mlir::funlang::ClosureType</code></li>
</ul>
</li>
<li>
<p><strong><code>dependentDialects</code></strong>: 이 dialect가 사용하는 다른 dialect</p>
<ul>
<li>FunLang operation이 <code>func.func</code>, <code>arith.addi</code> 등 사용 가능</li>
<li>Context에 자동 로드됨</li>
</ul>
</li>
<li>
<p><strong><code>description</code></strong>: Documentation (mlir-doc tool이 사용)</p>
</li>
<li>
<p><strong><code>extraClassDeclaration</code></strong>: 추가 C++ 메서드 선언</p>
</li>
</ol>
<h3 id="operation-정의-구조"><a class="header" href="#operation-정의-구조">Operation 정의 구조</a></h3>
<p><strong>Base class 정의:</strong></p>
<pre><code class="language-tablegen">// FunLang operation base class
class FunLang_Op&lt;string mnemonic, list&lt;Trait&gt; traits = []&gt;
    : Op&lt;FunLang_Dialect, mnemonic, traits&gt;;
</code></pre>
<p>모든 FunLang operation이 이 base class를 상속한다.</p>
<p><strong>Operation 정의 예시: make_closure</strong></p>
<pre><code class="language-tablegen">def FunLang_MakeClosureOp : FunLang_Op&lt;"make_closure", [Pure]&gt; {
  // 한 줄 요약
  let summary = "Creates a closure value";

  // 상세 설명 (multi-line string)
  let description = [{
    The `funlang.make_closure` operation creates a closure by capturing
    values into an environment. The closure can later be invoked using
    `funlang.apply`.

    Example:
    ```mlir
    %closure = funlang.make_closure @my_lambda(%x, %y) : !funlang.closure
    ```
  }];

  // 입력 인자 (arguments)
  let arguments = (ins
    FlatSymbolRefAttr:$funcName,        // 함수 심볼 (@lambda_0)
    Variadic&lt;AnyType&gt;:$capturedValues   // 캡처된 값들 (%x, %y, ...)
  );

  // 출력 결과 (results)
  let results = (outs
    FunLang_ClosureType:$result         // 클로저 값
  );

  // Assembly format (parser/printer)
  let assemblyFormat = [{
    $funcName `(` $capturedValues `)` attr-dict `:` type($result)
  }];

  // Traits (operation 특성)
  // [Pure]: no side effects, result depends only on operands
}
</code></pre>
<p><strong>Arguments (ins):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Name</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>FlatSymbolRefAttr</code></td><td><code>funcName</code></td><td>함수 이름 attribute (<code>@lambda_0</code>)</td></tr>
<tr><td><code>Variadic&lt;AnyType&gt;</code></td><td><code>capturedValues</code></td><td>가변 길이 값 목록 (captured variables)</td></tr>
</tbody>
</table>
</div>
<p><strong>Results (outs):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Name</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>FunLang_ClosureType</code></td><td><code>result</code></td><td>클로저 타입 값</td></tr>
</tbody>
</table>
</div>
<p><strong>Assembly Format:</strong></p>
<ul>
<li><code>$funcName</code>: <code>@lambda_func</code> 출력</li>
<li><code>`(`</code>: 리터럴 <code>(</code> 문자</li>
<li><code>$capturedValues</code>: 캡처된 값들 출력 (<code>%x, %y</code>)</li>
<li><code>`)`</code>: 리터럴 <code>)</code> 문자</li>
<li><code>attr-dict</code>: attribute dictionary (선택적)</li>
<li><code>`:`</code>: 리터럴 <code>:</code> 문자</li>
<li><code>type($result)</code>: 결과 타입 출력 (<code>!funlang.closure</code>)</li>
</ul>
<p>생성되는 IR:</p>
<pre><code class="language-mlir">%closure = funlang.make_closure @lambda_func(%x, %y) : !funlang.closure
</code></pre>
<h3 id="operation-traits"><a class="header" href="#operation-traits">Operation Traits</a></h3>
<p><strong>Trait</strong>는 operation의 특성을 선언한다. MLIR이 최적화/검증에 사용한다.</p>
<p><strong>Pure trait:</strong></p>
<pre><code class="language-tablegen">def FunLang_MakeClosureOp : FunLang_Op&lt;"make_closure", [Pure]&gt; {
  // ...
}
</code></pre>
<p><code>Pure</code> = <strong>순수 함수</strong> (no side effects, deterministic)</p>
<ul>
<li>같은 입력 → 같은 출력</li>
<li>메모리 쓰기 없음, I/O 없음</li>
<li>최적화 가능: 중복 제거, 재배치</li>
</ul>
<p><strong>MemoryEffects trait:</strong></p>
<pre><code class="language-tablegen">def FunLang_AllocClosureOp : FunLang_Op&lt;"alloc_closure",
    [MemoryEffects&lt;[MemAlloc]&gt;]&gt; {
  // Memory allocation operation
}
</code></pre>
<p><code>MemoryEffects&lt;[MemAlloc]&gt;</code> = 메모리 할당만 함 (읽기/쓰기 없음)</p>
<p><strong>다른 유용한 traits:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Meaning</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>NoSideEffect</code></td><td>부작용 없음 (Pure와 비슷)</td><td>산술 연산</td></tr>
<tr><td><code>Terminator</code></td><td>Basic block 종료 operation</td><td><code>func.return</code></td></tr>
<tr><td><code>IsolatedFromAbove</code></td><td>외부 값 참조 불가</td><td><code>func.func</code></td></tr>
<tr><td><code>SameOperandsAndResultType</code></td><td>입력과 출력 타입 동일</td><td><code>arith.addi</code></td></tr>
</tbody>
</table>
</div>
<h3 id="hasverifier-속성"><a class="header" href="#hasverifier-속성">hasVerifier 속성</a></h3>
<p>Custom verification 로직이 필요하면:</p>
<pre><code class="language-tablegen">def FunLang_ApplyOp : FunLang_Op&lt;"apply"&gt; {
  let arguments = (ins FunLang_ClosureType:$closure,
                       Variadic&lt;AnyType&gt;:$arguments);
  let results = (outs AnyType:$result);

  // Custom verifier 필요
  let hasVerifier = 1;
}
</code></pre>
<p>생성된 C++ 코드에 <code>verify()</code> 메서드 선언:</p>
<pre><code class="language-cpp">// FunLangOps.h.inc에 생성됨
class ApplyOp : public ... {
public:
    LogicalResult verify();  // Custom implementation 필요
};
</code></pre>
<p><strong>Verifier 구현 (FunLangOps.cpp):</strong></p>
<pre><code class="language-cpp">LogicalResult ApplyOp::verify() {
    // 클로저 타입 체크
    if (!getClosure().getType().isa&lt;ClosureType&gt;())
        return emitError("operand must be a closure type");

    // 인자 개수 체크 (optional, 런타임 체크 가능)
    // ...

    return success();
}
</code></pre>
<h3 id="type-정의-typedef"><a class="header" href="#type-정의-typedef">Type 정의 (TypeDef)</a></h3>
<p><strong>FunLang Closure 타입:</strong></p>
<pre><code class="language-tablegen">def FunLang_ClosureType : TypeDef&lt;FunLang_Dialect, "Closure"&gt; {
  let mnemonic = "closure";

  let summary = "FunLang closure type";

  let description = [{
    Represents a closure value (function pointer + captured environment).
  }];

  // Parameters (타입 파라미터)
  // Closure는 파라미터 없음 (단순 타입)
  let parameters = (ins);

  // Assembly format
  let assemblyFormat = "";
}
</code></pre>
<p><strong>생성되는 C++ 코드:</strong></p>
<pre><code class="language-cpp">// FunLangTypes.h.inc
class ClosureType : public Type::TypeBase&lt;ClosureType, Type, TypeStorage&gt; {
public:
    static constexpr StringLiteral getMnemonic() { return "closure"; }
    // ...
};
</code></pre>
<p><strong>사용 예:</strong></p>
<pre><code class="language-mlir">// MLIR IR
%closure : !funlang.closure

// F# 코드
let closureType = FunLangType.GetClosure(ctx)
</code></pre>
<h3 id="funlang-타입-설계"><a class="header" href="#funlang-타입-설계">FunLang 타입 설계</a></h3>
<h4 id="1-closuretype-클로저"><a class="header" href="#1-closuretype-클로저">1. ClosureType (클로저)</a></h4>
<pre><code class="language-tablegen">def FunLang_ClosureType : TypeDef&lt;FunLang_Dialect, "Closure"&gt; {
  let mnemonic = "closure";
  let summary = "Function closure (function pointer + environment)";
  let parameters = (ins);
  let assemblyFormat = "";
}
</code></pre>
<p><strong>용도:</strong> 클로저 값 표현</p>
<pre><code class="language-mlir">%closure = funlang.make_closure @lambda_func(%x) : !funlang.closure
</code></pre>
<h4 id="2-listtype-리스트-phase-6-preview"><a class="header" href="#2-listtype-리스트-phase-6-preview">2. ListType (리스트, Phase 6 preview)</a></h4>
<pre><code class="language-tablegen">def FunLang_ListType : TypeDef&lt;FunLang_Dialect, "List"&gt; {
  let mnemonic = "list";
  let summary = "Immutable list of elements";

  // 파라미터: element type
  let parameters = (ins "Type":$elementType);

  // Assembly format: list&lt;i32&gt;
  let assemblyFormat = "`&lt;` $elementType `&gt;`";
}
</code></pre>
<p><strong>파라미터화된 타입:</strong></p>
<ul>
<li><code>!funlang.list&lt;i32&gt;</code>: 정수 리스트</li>
<li><code>!funlang.list&lt;!funlang.closure&gt;</code>: 클로저 리스트</li>
</ul>
<p><strong>생성된 C++ 코드:</strong></p>
<pre><code class="language-cpp">class ListType : public Type::TypeBase&lt;...&gt; {
public:
    static ListType get(Type elementType);
    Type getElementType() const;
};
</code></pre>
<p><strong>사용 예:</strong></p>
<pre><code class="language-mlir">// 빈 리스트
%nil = funlang.nil : !funlang.list&lt;i32&gt;

// Cons (head::tail)
%list = funlang.cons %head, %tail : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;
</code></pre>
<h4 id="3-recordtype-레코드-phase-7-preview"><a class="header" href="#3-recordtype-레코드-phase-7-preview">3. RecordType (레코드, Phase 7 preview)</a></h4>
<pre><code class="language-tablegen">def FunLang_RecordType : TypeDef&lt;FunLang_Dialect, "Record"&gt; {
  let mnemonic = "record";
  let summary = "Record with named fields";

  // 파라미터: field names + types
  let parameters = (ins
    ArrayRefParameter&lt;"StringAttr"&gt;:$fieldNames,
    ArrayRefParameter&lt;"Type"&gt;:$fieldTypes
  );

  let assemblyFormat = "`&lt;` `{` $fieldNames `:` $fieldTypes `}` `&gt;`";
}
</code></pre>
<p><strong>사용 예:</strong></p>
<pre><code class="language-mlir">// {x: i32, y: i32}
%point : !funlang.record&lt;{x: i32, y: i32}&gt;
</code></pre>
<h3 id="funlang-operations-정의-예시"><a class="header" href="#funlang-operations-정의-예시">FunLang Operations 정의 예시</a></h3>
<h4 id="funlangmake_closure"><a class="header" href="#funlangmake_closure">funlang.make_closure</a></h4>
<p><strong>TableGen 정의:</strong></p>
<pre><code class="language-tablegen">def FunLang_MakeClosureOp : FunLang_Op&lt;"make_closure", [Pure]&gt; {
  let summary = "Creates a closure value";

  let arguments = (ins
    FlatSymbolRefAttr:$funcName,
    Variadic&lt;AnyType&gt;:$capturedValues
  );

  let results = (outs FunLang_ClosureType:$result);

  let assemblyFormat = "$funcName `(` $capturedValues `)` attr-dict `:` type($result)";

  let builders = [
    OpBuilder&lt;(ins "FlatSymbolRefAttr":$funcName,
                   "ValueRange":$capturedValues), [{
      build($_builder, $_state, ClosureType::get($_builder.getContext()),
            funcName, capturedValues);
    }]&gt;
  ];
}
</code></pre>
<p><strong>생성된 C++ API:</strong></p>
<pre><code class="language-cpp">// FunLangOps.h.inc
class MakeClosureOp : public Op&lt;...&gt; {
public:
    static MakeClosureOp create(OpBuilder &amp;builder, Location loc,
                                FlatSymbolRefAttr funcName,
                                ValueRange capturedValues);

    FlatSymbolRefAttr getFuncName();
    OperandRange getCapturedValues();
    Value getResult();
};
</code></pre>
<h4 id="funlangapply"><a class="header" href="#funlangapply">funlang.apply</a></h4>
<p><strong>TableGen 정의:</strong></p>
<pre><code class="language-tablegen">def FunLang_ApplyOp : FunLang_Op&lt;"apply"&gt; {
  let summary = "Applies a closure to arguments";

  let arguments = (ins
    FunLang_ClosureType:$closure,
    Variadic&lt;AnyType&gt;:$arguments
  );

  let results = (outs AnyType:$result);

  let assemblyFormat = [{
    $closure `(` $arguments `)` attr-dict `:` functional-type($arguments, $result)
  }];

  let hasVerifier = 1;
}
</code></pre>
<p><strong>사용 예:</strong></p>
<pre><code class="language-mlir">%result = funlang.apply %closure(%x, %y) : (i32, i32) -&gt; i32
</code></pre>
<p><strong>Verifier (FunLangOps.cpp):</strong></p>
<pre><code class="language-cpp">LogicalResult ApplyOp::verify() {
    if (!getClosure().getType().isa&lt;ClosureType&gt;())
        return emitError("first operand must be a closure");
    return success();
}
</code></pre>
<h3 id="생성되는-c-코드-설명"><a class="header" href="#생성되는-c-코드-설명">생성되는 C++ 코드 설명</a></h3>
<p><strong>mlir-tblgen 실행:</strong></p>
<pre><code class="language-bash">mlir-tblgen -gen-op-decls FunLangOps.td &gt; FunLangOps.h.inc
mlir-tblgen -gen-op-defs FunLangOps.td &gt; FunLangOps.cpp.inc
mlir-tblgen -gen-typedef-decls FunLangTypes.td &gt; FunLangTypes.h.inc
mlir-tblgen -gen-typedef-defs FunLangTypes.td &gt; FunLangTypes.cpp.inc
</code></pre>
<p><strong>FunLangOps.h.inc (생성된 헤더):</strong></p>
<pre><code class="language-cpp">class MakeClosureOp : public Op&lt;MakeClosureOp, OpTrait::ZeroRegions,
                                OpTrait::OneResult, OpTrait::Pure&gt; {
public:
    static constexpr StringLiteral getOperationName() {
        return StringLiteral("funlang.make_closure");
    }

    // Accessors
    FlatSymbolRefAttr getFuncName();
    OperandRange getCapturedValues();
    Value getResult();

    // Builder
    static void build(OpBuilder &amp;builder, OperationState &amp;state, ...);

    // Parser/Printer (assemblyFormat에서 생성)
    static ParseResult parse(OpAsmParser &amp;parser, OperationState &amp;result);
    void print(OpAsmPrinter &amp;p);

    // Verifier (기본 타입 체크)
    LogicalResult verify();
};
</code></pre>
<p><strong>사용 (C++ dialect code):</strong></p>
<pre><code class="language-cpp">// Operation 생성
auto closureOp = builder.create&lt;MakeClosureOp&gt;(
    loc,
    funcNameAttr,
    capturedValues
);

// Accessors 사용
FlatSymbolRefAttr funcName = closureOp.getFuncName();
Value result = closureOp.getResult();
</code></pre>
<p><strong>FunLangTypes.h.inc:</strong></p>
<pre><code class="language-cpp">class ClosureType : public Type::TypeBase&lt;ClosureType, Type, TypeStorage&gt; {
public:
    static constexpr StringLiteral getMnemonic() { return "closure"; }

    static ClosureType get(MLIRContext *ctx) {
        return Base::get(ctx);
    }

    // Parser/Printer
    static ParseResult parse(AsmParser &amp;parser);
    void print(AsmPrinter &amp;printer) const;
};
</code></pre>
<p><strong>사용:</strong></p>
<pre><code class="language-cpp">// 타입 생성
ClosureType closureType = ClosureType::get(ctx);

// 타입 체크
if (auto ct = value.getType().dyn_cast&lt;ClosureType&gt;()) {
    // This is a closure!
}
</code></pre>
<h2 id="c-api-shim-패턴-f-interop"><a class="header" href="#c-api-shim-패턴-f-interop">C API Shim 패턴 (F# Interop)</a></h2>
<h3 id="문제-tablegen은-c-코드-생성-f은-c-api-필요"><a class="header" href="#문제-tablegen은-c-코드-생성-f은-c-api-필요">문제: TableGen은 C++ 코드 생성, F#은 C API 필요</a></h3>
<p><strong>상황:</strong></p>
<ol>
<li>
<p><strong>TableGen → C++ 코드 생성</strong></p>
<ul>
<li><code>MakeClosureOp</code> 클래스 (C++)</li>
<li><code>ClosureType::get()</code> 메서드 (C++)</li>
</ul>
</li>
<li>
<p><strong>F#은 C API만 호출 가능</strong></p>
<ul>
<li>P/Invoke는 <code>extern "C"</code> 함수만 지원</li>
<li>C++ 클래스 직접 호출 불가</li>
</ul>
</li>
</ol>
<p><strong>문제:</strong></p>
<pre><code class="language-fsharp">// 이런 코드를 쓰고 싶지만...
let closure = MakeClosureOp.Create(builder, funcName, capturedValues)  // ERROR: C++ class!
</code></pre>
<h3 id="해결책-extern-c-wrapper-functions"><a class="header" href="#해결책-extern-c-wrapper-functions">해결책: extern “C” Wrapper Functions</a></h3>
<p><strong>아키텍처:</strong></p>
<pre><code>┌─────────────────────────────────────────┐
│ F# Code (Compiler.fs)                   │
│                                         │
│ let closure = FunLang.CreateClosure(...) │
└────────────────┬────────────────────────┘
                 │ P/Invoke
                 ▼
┌─────────────────────────────────────────┐
│ C API Shim (FunLangCAPI.h/.cpp)         │
│                                         │
│ extern "C" {                            │
│   MlirOperation mlirFunLangClosure...() │
│ }                                       │
└────────────────┬────────────────────────┘
                 │ Call C++ API
                 ▼
┌─────────────────────────────────────────┐
│ C++ Dialect (FunLangOps.h/.cpp)         │
│                                         │
│ class MakeClosureOp { ... }             │
│ (TableGen generated)                    │
└─────────────────────────────────────────┘
</code></pre>
<h3 id="funlangcapih-구조"><a class="header" href="#funlangcapih-구조">FunLangCAPI.h 구조</a></h3>
<p><strong>헤더 파일:</strong></p>
<pre><code class="language-c">// FunLangCAPI.h - C API for FunLang Dialect
#ifndef FUNLANG_C_API_H
#define FUNLANG_C_API_H

#include "mlir-c/IR.h"

#ifdef __cplusplus
extern "C" {
#endif

//===----------------------------------------------------------------------===//
// Dialect Registration
//===----------------------------------------------------------------------===//

/// Register FunLang dialect in the given context
MLIR_CAPI_EXPORTED void mlirContextRegisterFunLangDialect(MlirContext ctx);

/// Load FunLang dialect into the given context
MLIR_CAPI_EXPORTED MlirDialect mlirContextLoadFunLangDialect(MlirContext ctx);

//===----------------------------------------------------------------------===//
// Types
//===----------------------------------------------------------------------===//

/// Returns true if the given type is a FunLang closure type
MLIR_CAPI_EXPORTED bool mlirTypeIsAFunLangClosure(MlirType type);

/// Creates a FunLang closure type
MLIR_CAPI_EXPORTED MlirType mlirFunLangClosureTypeGet(MlirContext ctx);

//===----------------------------------------------------------------------===//
// Operations
//===----------------------------------------------------------------------===//

/// Creates a funlang.make_closure operation
MLIR_CAPI_EXPORTED MlirOperation mlirFunLangMakeClosureOpCreate(
    MlirContext ctx,
    MlirLocation loc,
    MlirAttribute funcName,       // FlatSymbolRefAttr
    intptr_t numCaptured,
    MlirValue *capturedValues     // Array of values
);

/// Creates a funlang.apply operation
MLIR_CAPI_EXPORTED MlirOperation mlirFunLangApplyOpCreate(
    MlirContext ctx,
    MlirLocation loc,
    MlirValue closure,
    intptr_t numArgs,
    MlirValue *arguments,
    MlirType resultType
);

#ifdef __cplusplus
}
#endif

#endif // FUNLANG_C_API_H
</code></pre>
<p><strong>핵심 패턴:</strong></p>
<ol>
<li><strong><code>extern "C"</code></strong>: C linkage (name mangling 없음)</li>
<li><strong>MLIR C API 타입 사용</strong>: <code>MlirContext</code>, <code>MlirOperation</code>, <code>MlirValue</code></li>
<li><strong>배열 전달</strong>: <code>intptr_t num</code> + <code>MlirValue *array</code> 패턴</li>
</ol>
<h3 id="funlangcapicpp-구현-패턴"><a class="header" href="#funlangcapicpp-구현-패턴">FunLangCAPI.cpp 구현 패턴</a></h3>
<p><strong>구현 파일:</strong></p>
<pre><code class="language-cpp">// FunLangCAPI.cpp
#include "FunLangCAPI.h"
#include "mlir/CAPI/IR.h"
#include "mlir/CAPI/Support.h"
#include "FunLang/IR/FunLangDialect.h"
#include "FunLang/IR/FunLangOps.h"
#include "FunLang/IR/FunLangTypes.h"

using namespace mlir;
using namespace mlir::funlang;

//===----------------------------------------------------------------------===//
// Dialect Registration
//===----------------------------------------------------------------------===//

void mlirContextRegisterFunLangDialect(MlirContext ctx) {
    // unwrap: C handle → C++ pointer
    MLIRContext *context = unwrap(ctx);

    // Register dialect
    DialectRegistry registry;
    registry.insert&lt;FunLangDialect&gt;();
    context-&gt;appendDialectRegistry(registry);
}

MlirDialect mlirContextLoadFunLangDialect(MlirContext ctx) {
    MLIRContext *context = unwrap(ctx);
    Dialect *dialect = context-&gt;loadDialect&lt;FunLangDialect&gt;();

    // wrap: C++ pointer → C handle
    return wrap(dialect);
}

//===----------------------------------------------------------------------===//
// Types
//===----------------------------------------------------------------------===//

bool mlirTypeIsAFunLangClosure(MlirType type) {
    return unwrap(type).isa&lt;ClosureType&gt;();
}

MlirType mlirFunLangClosureTypeGet(MlirContext ctx) {
    MLIRContext *context = unwrap(ctx);
    Type closureType = ClosureType::get(context);
    return wrap(closureType);
}

//===----------------------------------------------------------------------===//
// Operations
//===----------------------------------------------------------------------===//

MlirOperation mlirFunLangMakeClosureOpCreate(
    MlirContext ctx,
    MlirLocation loc,
    MlirAttribute funcName,
    intptr_t numCaptured,
    MlirValue *capturedValues)
{
    // Unwrap C handles
    MLIRContext *context = unwrap(ctx);
    Location location = unwrap(loc);
    FlatSymbolRefAttr funcNameAttr = unwrap(funcName).cast&lt;FlatSymbolRefAttr&gt;();

    // Convert array to ValueRange
    SmallVector&lt;Value, 4&gt; captured;
    for (intptr_t i = 0; i &lt; numCaptured; ++i) {
        captured.push_back(unwrap(capturedValues[i]));
    }

    // Create operation using OpBuilder
    OpBuilder builder(context);
    auto op = builder.create&lt;MakeClosureOp&gt;(location, funcNameAttr, captured);

    // Wrap and return
    return wrap(op.getOperation());
}

MlirOperation mlirFunLangApplyOpCreate(
    MlirContext ctx,
    MlirLocation loc,
    MlirValue closure,
    intptr_t numArgs,
    MlirValue *arguments,
    MlirType resultType)
{
    MLIRContext *context = unwrap(ctx);
    Location location = unwrap(loc);
    Value closureValue = unwrap(closure);
    Type resType = unwrap(resultType);

    SmallVector&lt;Value, 4&gt; args;
    for (intptr_t i = 0; i &lt; numArgs; ++i) {
        args.push_back(unwrap(arguments[i]));
    }

    OpBuilder builder(context);
    auto op = builder.create&lt;ApplyOp&gt;(location, resType, closureValue, args);

    return wrap(op.getOperation());
}
</code></pre>
<h4 id="wrapunwrap-헬퍼-사용"><a class="header" href="#wrapunwrap-헬퍼-사용">wrap/unwrap 헬퍼 사용</a></h4>
<p><strong>MLIR C API convention:</strong></p>
<ul>
<li><strong><code>unwrap()</code></strong>: C handle → C++ pointer</li>
<li><strong><code>wrap()</code></strong>: C++ pointer → C handle</li>
</ul>
<pre><code class="language-cpp">// C handle types (opaque)
typedef struct MlirContext { void *ptr; } MlirContext;
typedef struct MlirType { void *ptr; } MlirType;
typedef struct MlirValue { void *ptr; } MlirValue;

// Unwrap/Wrap (MLIR/CAPI/Support.h)
inline MLIRContext *unwrap(MlirContext ctx) {
    return static_cast&lt;MLIRContext *&gt;(ctx.ptr);
}

inline MlirContext wrap(MLIRContext *ctx) {
    return MlirContext{static_cast&lt;void *&gt;(ctx)};
}
</code></pre>
<p><strong>사용 패턴:</strong></p>
<pre><code class="language-cpp">// C API function signature (C handles)
MlirType mlirFunLangClosureTypeGet(MlirContext ctx);

// Implementation (unwrap → use C++ API → wrap)
MlirType mlirFunLangClosureTypeGet(MlirContext ctx) {
    MLIRContext *context = unwrap(ctx);           // C → C++
    Type closureType = ClosureType::get(context); // C++ API
    return wrap(closureType);                      // C++ → C
}
</code></pre>
<h4 id="opbuilder-활용"><a class="header" href="#opbuilder-활용">OpBuilder 활용</a></h4>
<p><strong>OpBuilder</strong>는 MLIR operation 생성 헬퍼다:</p>
<pre><code class="language-cpp">OpBuilder builder(context);

// Operation 생성
auto op = builder.create&lt;MakeClosureOp&gt;(
    location,       // Location (source info)
    funcNameAttr,   // Symbol reference
    capturedValues  // Operands
);

// Block에 삽입
builder.setInsertionPointToEnd(block);
auto op2 = builder.create&lt;ApplyOp&gt;(...);
</code></pre>
<p><strong>C API shim에서:</strong></p>
<pre><code class="language-cpp">MlirOperation mlirFunLangMakeClosureOpCreate(...) {
    OpBuilder builder(context);
    auto op = builder.create&lt;MakeClosureOp&gt;(...);
    return wrap(op.getOperation());  // Operation* → MlirOperation
}
</code></pre>
<h4 id="타입-생성-및-검증"><a class="header" href="#타입-생성-및-검증">타입 생성 및 검증</a></h4>
<p><strong>타입 생성:</strong></p>
<pre><code class="language-cpp">MlirType mlirFunLangClosureTypeGet(MlirContext ctx) {
    MLIRContext *context = unwrap(ctx);
    Type closureType = ClosureType::get(context);
    return wrap(closureType);
}
</code></pre>
<p><strong>타입 검증:</strong></p>
<pre><code class="language-cpp">bool mlirTypeIsAFunLangClosure(MlirType type) {
    Type t = unwrap(type);
    return t.isa&lt;ClosureType&gt;();  // C++ RTTI
}
</code></pre>
<p>F#에서 사용:</p>
<pre><code class="language-fsharp">// 타입 생성
let closureType = FunLang.GetClosureType(ctx)

// 타입 체크
if FunLang.IsClosureType(value.Type) then
    printfn "This is a closure!"
</code></pre>
<h3 id="cmakeliststxt-빌드-설정"><a class="header" href="#cmakeliststxt-빌드-설정">CMakeLists.txt 빌드 설정</a></h3>
<p><strong>FunLang dialect CMake:</strong></p>
<pre><code class="language-cmake"># CMakeLists.txt
add_mlir_dialect_library(MLIRFunLangDialect
  # TableGen sources
  FunLangDialect.cpp
  FunLangOps.cpp
  FunLangTypes.cpp

  ADDITIONAL_HEADER_DIRS
  ${PROJECT_SOURCE_DIR}/include/FunLang

  DEPENDS
  MLIRFunLangOpsIncGen        # TableGen generated files
  MLIRFunLangTypesIncGen

  LINK_LIBS PUBLIC
  MLIRIR
  MLIRFuncDialect
  MLIRLLVMDialect
)

# C API shim
add_mlir_public_c_api_library(MLIRFunLangCAPI
  FunLangCAPI.cpp

  ADDITIONAL_HEADER_DIRS
  ${PROJECT_SOURCE_DIR}/include/FunLang-c

  LINK_LIBS PUBLIC
  MLIRCAPIIR
  MLIRFunLangDialect
)
</code></pre>
<p><strong>빌드 출력:</strong></p>
<ul>
<li><code>libMLIRFunLangDialect.so</code>: C++ dialect library</li>
<li><code>libMLIRFunLangCAPI.so</code>: C API shim library</li>
</ul>
<p>F#은 <code>MLIRFunLangCAPI.so</code>를 로드한다.</p>
<h3 id="f-pinvoke-바인딩-mlirfunlang-모듈"><a class="header" href="#f-pinvoke-바인딩-mlirfunlang-모듈">F# P/Invoke 바인딩 (Mlir.FunLang 모듈)</a></h3>
<p><strong>FunLangBindings.fs:</strong></p>
<pre><code class="language-fsharp">module Mlir.FunLang

open System
open System.Runtime.InteropServices

// P/Invoke declarations
[&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
extern void mlirContextRegisterFunLangDialect(MlirContext ctx)

[&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirDialect mlirContextLoadFunLangDialect(MlirContext ctx)

[&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
extern bool mlirTypeIsAFunLangClosure(MlirType ty)

[&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirType mlirFunLangClosureTypeGet(MlirContext ctx)

[&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirOperation mlirFunLangMakeClosureOpCreate(
    MlirContext ctx,
    MlirLocation loc,
    MlirAttribute funcName,
    nativeint numCaptured,
    MlirValue[] capturedValues
)

[&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirOperation mlirFunLangApplyOpCreate(
    MlirContext ctx,
    MlirLocation loc,
    MlirValue closure,
    nativeint numArgs,
    MlirValue[] arguments,
    MlirType resultType
)

// High-level F# API
type FunLangDialect =
    static member Register(ctx: MlirContext) =
        mlirContextRegisterFunLangDialect(ctx)

    static member Load(ctx: MlirContext) : MlirDialect =
        mlirContextLoadFunLangDialect(ctx)

type FunLangType =
    static member GetClosure(ctx: MlirContext) : MlirType =
        mlirFunLangClosureTypeGet(ctx)

    static member IsClosure(ty: MlirType) : bool =
        mlirTypeIsAFunLangClosure(ty)

type FunLangOps =
    static member CreateMakeClosure(ctx: MlirContext, loc: MlirLocation,
                                     funcName: MlirAttribute,
                                     capturedValues: MlirValue[]) : MlirOperation =
        mlirFunLangMakeClosureOpCreate(ctx, loc, funcName, nativeint capturedValues.Length, capturedValues)

    static member CreateApply(ctx: MlirContext, loc: MlirLocation,
                               closure: MlirValue, arguments: MlirValue[],
                               resultType: MlirType) : MlirOperation =
        mlirFunLangApplyOpCreate(ctx, loc, closure, nativeint arguments.Length, arguments, resultType)
</code></pre>
<p><strong>사용 예 (Compiler.fs):</strong></p>
<pre><code class="language-fsharp">// Dialect 등록
let ctx = MlirContext.Create()
FunLangDialect.Register(ctx)
FunLangDialect.Load(ctx)

// 클로저 타입 얻기
let closureType = FunLangType.GetClosure(ctx)

// make_closure operation 생성
let funcNameAttr = ... // SymbolRefAttr
let capturedValues = [| %x; %y |]
let makeClosureOp = FunLangOps.CreateMakeClosure(ctx, loc, funcNameAttr, capturedValues)

// apply operation 생성
let closureValue = ... // %closure
let arguments = [| %arg1; %arg2 |]
let resultType = ... // i32
let applyOp = FunLangOps.CreateApply(ctx, loc, closureValue, arguments, resultType)
</code></pre>
<h3 id="전체-아키텍처-다이어그램"><a class="header" href="#전체-아키텍처-다이어그램">전체 아키텍처 다이어그램</a></h3>
<pre><code>┌──────────────────────────────────────────────────────────────────┐
│                        F# Compiler                               │
│                                                                  │
│  let closure = FunLangOps.CreateMakeClosure(...)                │
│  let result = FunLangOps.CreateApply(...)                       │
└─────────────────────────┬────────────────────────────────────────┘
                          │ P/Invoke
                          │ (CallingConvention.Cdecl)
                          ↓
┌──────────────────────────────────────────────────────────────────┐
│              C API Shim (FunLangCAPI.h/.cpp)                     │
│                                                                  │
│  extern "C" {                                                    │
│    MlirOperation mlirFunLangMakeClosureOpCreate(...) {          │
│      MLIRContext *ctx = unwrap(ctxHandle);                      │
│      OpBuilder builder(ctx);                                     │
│      auto op = builder.create&lt;MakeClosureOp&gt;(...);              │
│      return wrap(op.getOperation());                             │
│    }                                                             │
│  }                                                               │
└─────────────────────────┬────────────────────────────────────────┘
                          │ Call C++ API
                          ↓
┌──────────────────────────────────────────────────────────────────┐
│         C++ Dialect (FunLangOps.h/.cpp, TableGen generated)      │
│                                                                  │
│  class MakeClosureOp : public Op&lt;...&gt; {                         │
│    // Generated by TableGen                                      │
│    static void build(OpBuilder &amp;, OperationState &amp;, ...);       │
│    LogicalResult verify();                                       │
│  };                                                              │
└─────────────────────────┬────────────────────────────────────────┘
                          │ Uses MLIR Core API
                          ↓
┌──────────────────────────────────────────────────────────────────┐
│                      MLIR Core (C++)                             │
│                                                                  │
│  - Operation, Type, Attribute classes                            │
│  - OpBuilder, PatternRewriter                                    │
│  - Dialect, DialectRegistry                                      │
└──────────────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>데이터 흐름:</strong></p>
<ol>
<li>
<p><strong>F# → C API</strong>: P/Invoke로 C 함수 호출</p>
<ul>
<li><code>MlirContext</code>, <code>MlirValue</code> 등 opaque handle 전달</li>
<li>배열은 <code>nativeint len</code> + <code>array</code> 패턴</li>
</ul>
</li>
<li>
<p><strong>C API → C++</strong>: unwrap으로 handle → pointer 변환</p>
<ul>
<li><code>unwrap(MlirContext)</code> → <code>MLIRContext*</code></li>
<li><code>OpBuilder.create&lt;Op&gt;(...)</code> 호출</li>
</ul>
</li>
<li>
<p><strong>C++ → MLIR Core</strong>: TableGen 생성 코드 사용</p>
<ul>
<li><code>MakeClosureOp::build()</code> 호출</li>
<li>Operation 생성, 타입 체크</li>
</ul>
</li>
<li>
<p><strong>C++ → C API</strong>: wrap으로 pointer → handle 변환</p>
<ul>
<li><code>wrap(Operation*)</code> → <code>MlirOperation</code></li>
<li>F#에 반환</li>
</ul>
</li>
</ol>
<h2 id="funlang-dialect-operations-preview"><a class="header" href="#funlang-dialect-operations-preview">FunLang Dialect Operations Preview</a></h2>
<p>Phase 5-6에서 구현할 operations 목록:</p>
<h3 id="1-funlangmake_closure"><a class="header" href="#1-funlangmake_closure">1. funlang.make_closure</a></h3>
<p><strong>의미:</strong> 클로저 생성 (함수 포인터 + 캡처된 변수)</p>
<p><strong>시그니처:</strong></p>
<pre><code class="language-tablegen">def FunLang_MakeClosureOp : FunLang_Op&lt;"make_closure", [Pure]&gt; {
  let arguments = (ins FlatSymbolRefAttr:$funcName,
                       Variadic&lt;AnyType&gt;:$capturedValues);
  let results = (outs FunLang_ClosureType:$result);
}
</code></pre>
<p><strong>사용 예:</strong></p>
<pre><code class="language-mlir">%closure = funlang.make_closure @lambda_adder(%n, %m) : !funlang.closure
</code></pre>
<p><strong>Lowering (Phase 5):</strong></p>
<pre><code class="language-mlir">// FunLang dialect
%closure = funlang.make_closure @lambda_adder(%n, %m) : !funlang.closure

// ↓ Lower to Func + MemRef

// 환경 할당
%c3 = arith.constant 3 : index
%env = memref.alloc(%c3) : memref&lt;?xi32&gt;

// 함수 포인터 저장 (slot 0)
// ... (conceptual)

// 변수 저장 (slot 1, 2)
%c1 = arith.constant 1 : index
memref.store %n, %env[%c1] : memref&lt;?xi32&gt;
%c2 = arith.constant 2 : index
memref.store %m, %env[%c2] : memref&lt;?xi32&gt;

// 포인터 반환
%closure_ptr = memref.cast %env : memref&lt;?xi32&gt; to !llvm.ptr
</code></pre>
<h3 id="2-funlangapply"><a class="header" href="#2-funlangapply">2. funlang.apply</a></h3>
<p><strong>의미:</strong> 클로저 호출 (간접 함수 호출)</p>
<p><strong>시그니처:</strong></p>
<pre><code class="language-tablegen">def FunLang_ApplyOp : FunLang_Op&lt;"apply"&gt; {
  let arguments = (ins FunLang_ClosureType:$closure,
                       Variadic&lt;AnyType&gt;:$arguments);
  let results = (outs AnyType:$result);
}
</code></pre>
<p><strong>사용 예:</strong></p>
<pre><code class="language-mlir">%result = funlang.apply %closure(%x, %y) : (i32, i32) -&gt; i32
</code></pre>
<p><strong>Lowering:</strong></p>
<pre><code class="language-mlir">// FunLang dialect
%result = funlang.apply %closure(%x, %y) : (i32, i32) -&gt; i32

// ↓ Lower to Func + LLVM

// 환경에서 함수 포인터 로드
%fn_slot = llvm.getelementptr %closure[0] : (!llvm.ptr) -&gt; !llvm.ptr
%fn_ptr = llvm.load %fn_slot : !llvm.ptr -&gt; !llvm.ptr

// 간접 호출 (환경 + 인자들)
%result = llvm.call %fn_ptr(%closure, %x, %y) : (!llvm.ptr, i32, i32) -&gt; i32
</code></pre>
<h3 id="3-funlangmatch-phase-6"><a class="header" href="#3-funlangmatch-phase-6">3. funlang.match (Phase 6)</a></h3>
<p><strong>의미:</strong> 패턴 매칭 (리스트, ADT)</p>
<p><strong>시그니처:</strong></p>
<pre><code class="language-tablegen">def FunLang_MatchOp : FunLang_Op&lt;"match", [RecursiveSideEffect]&gt; {
  let arguments = (ins AnyType:$scrutinee);
  let results = (outs AnyType:$result);
  let regions = (region VariadicRegion&lt;AnyRegion&gt;:$cases);
}
</code></pre>
<p><strong>사용 예:</strong></p>
<pre><code class="language-mlir">%result = funlang.match %list : !funlang.list&lt;i32&gt; -&gt; i32 {
^nil_case:
    %zero = arith.constant 0 : i32
    funlang.yield %zero : i32

^cons_case(%head: i32, %tail: !funlang.list&lt;i32&gt;):
    // ... (재귀 호출)
    funlang.yield %sum : i32
}
</code></pre>
<p><strong>Lowering:</strong></p>
<pre><code class="language-mlir">// FunLang dialect
%result = funlang.match %list { ... }

// ↓ Lower to SCF (structured control flow)

// 리스트 태그 확인
%tag = llvm.load %list[0] : !llvm.ptr -&gt; i32

// if (tag == NIL)
%is_nil = arith.cmpi eq, %tag, %c0 : i32
%result = scf.if %is_nil -&gt; i32 {
    // Nil case
    %zero = arith.constant 0 : i32
    scf.yield %zero : i32
} else {
    // Cons case - head/tail 추출
    %head = llvm.load %list[1] : !llvm.ptr -&gt; i32
    %tail = llvm.load %list[2] : !llvm.ptr -&gt; !llvm.ptr
    // ... (body)
    scf.yield %sum : i32
}
</code></pre>
<h3 id="4-funlangnil--funlangcons-phase-6"><a class="header" href="#4-funlangnil--funlangcons-phase-6">4. funlang.nil / funlang.cons (Phase 6)</a></h3>
<p><strong>리스트 생성:</strong></p>
<pre><code class="language-tablegen">def FunLang_NilOp : FunLang_Op&lt;"nil", [Pure]&gt; {
  let arguments = (ins);
  let results = (outs FunLang_ListType:$result);
}

def FunLang_ConsOp : FunLang_Op&lt;"cons", [Pure]&gt; {
  let arguments = (ins AnyType:$head, FunLang_ListType:$tail);
  let results = (outs FunLang_ListType:$result);
}
</code></pre>
<p><strong>사용 예:</strong></p>
<pre><code class="language-mlir">%nil = funlang.nil : !funlang.list&lt;i32&gt;
%list1 = funlang.cons %c1, %nil : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;
%list2 = funlang.cons %c2, %list1 : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;
// list2 = [2, 1]
</code></pre>
<h3 id="chapter-15에서-구현할-내용"><a class="header" href="#chapter-15에서-구현할-내용">Chapter 15에서 구현할 내용</a></h3>
<p><strong>Phase 5 (Chapter 15-16):</strong></p>
<ol>
<li>
<p><strong>TableGen 정의</strong></p>
<ul>
<li><code>FunLangDialect.td</code></li>
<li><code>FunLangOps.td</code> (make_closure, apply)</li>
<li><code>FunLangTypes.td</code> (closure)</li>
</ul>
</li>
<li>
<p><strong>C API Shim</strong></p>
<ul>
<li><code>FunLangCAPI.h</code></li>
<li><code>FunLangCAPI.cpp</code></li>
</ul>
</li>
<li>
<p><strong>F# Bindings</strong></p>
<ul>
<li><code>FunLangBindings.fs</code></li>
</ul>
</li>
<li>
<p><strong>Lowering Pass</strong></p>
<ul>
<li><code>FunLangToFunc.cpp</code> (make_closure → memref.alloc)</li>
<li>Pattern: <code>MakeClosureOpLowering</code>, <code>ApplyOpLowering</code></li>
</ul>
</li>
<li>
<p><strong>컴파일러 통합</strong></p>
<ul>
<li><code>Compiler.fs</code> 수정: FunLang dialect operations 생성</li>
<li>Pass pipeline: <code>FunLangToFunc → FuncToLLVM</code></li>
</ul>
</li>
</ol>
<p><strong>Phase 6 (Chapter 17-18):</strong></p>
<ul>
<li><code>funlang.match</code>, <code>funlang.nil</code>, <code>funlang.cons</code></li>
<li><code>ListType</code> 구현</li>
<li>Pattern matching lowering</li>
</ul>
<h2 id="common-pitfalls-흔한-실수들"><a class="header" href="#common-pitfalls-흔한-실수들">Common Pitfalls (흔한 실수들)</a></h2>
<h3 id="pitfall-1-불완전한-타입-시스템-anytype-남용"><a class="header" href="#pitfall-1-불완전한-타입-시스템-anytype-남용">Pitfall 1: 불완전한 타입 시스템 (AnyType 남용)</a></h3>
<p><strong>문제:</strong></p>
<pre><code class="language-tablegen">// 잘못된 설계 - 모든 것이 AnyType
def FunLang_MakeClosureOp : FunLang_Op&lt;"make_closure"&gt; {
  let arguments = (ins AnyType:$func, Variadic&lt;AnyType&gt;:$captured);
  let results = (outs AnyType:$result);  // ERROR: 타입 안전성 없음!
}
</code></pre>
<p><strong>왜 문제인가?</strong></p>
<ul>
<li><code>AnyType</code>은 컴파일 타임 체크 불가</li>
<li>정수를 클로저로 사용 가능 (버그!)</li>
<li>최적화 pass가 타입 정보 활용 불가</li>
</ul>
<p><strong>해결:</strong></p>
<pre><code class="language-tablegen">// 올바른 설계 - 명확한 타입
def FunLang_MakeClosureOp : FunLang_Op&lt;"make_closure", [Pure]&gt; {
  let arguments = (ins FlatSymbolRefAttr:$funcName,  // 함수 심볼
                       Variadic&lt;AnyType&gt;:$captured);  // 캡처된 값 (다양한 타입)
  let results = (outs FunLang_ClosureType:$result);  // GOOD: 명확한 타입!
}
</code></pre>
<p><strong>원칙:</strong></p>
<ul>
<li>도메인 타입 (closure, list)은 커스텀 타입 사용</li>
<li>범용 값 (캡처된 변수)은 <code>AnyType</code> 허용</li>
</ul>
<h3 id="pitfall-2-missing-operation-traits-pure-memoryeffects"><a class="header" href="#pitfall-2-missing-operation-traits-pure-memoryeffects">Pitfall 2: Missing Operation Traits (Pure, MemoryEffects)</a></h3>
<p><strong>문제:</strong></p>
<pre><code class="language-tablegen">// Trait 없는 operation
def FunLang_MakeClosureOp : FunLang_Op&lt;"make_closure"&gt; {
  // No traits specified!
}
</code></pre>
<p><strong>왜 문제인가?</strong></p>
<ul>
<li>MLIR이 side effect 가정 (보수적 최적화)</li>
<li>CSE (Common Subexpression Elimination) 불가</li>
<li>Dead code elimination 불가</li>
</ul>
<p><strong>예시:</strong></p>
<pre><code class="language-mlir">// 중복 클로저 생성
%closure1 = funlang.make_closure @lambda(%x) : !funlang.closure
%closure2 = funlang.make_closure @lambda(%x) : !funlang.closure
// Trait 없으면: 둘 다 유지 (side effect 가능성 가정)
// Pure trait 있으면: %closure2 = %closure1 (CSE 적용)
</code></pre>
<p><strong>해결:</strong></p>
<pre><code class="language-tablegen">// 올바른 설계 - Trait 명시
def FunLang_MakeClosureOp : FunLang_Op&lt;"make_closure", [Pure]&gt; {
  // Pure = no side effects, deterministic
}

def FunLang_AllocEnvOp : FunLang_Op&lt;"alloc_env", [MemoryEffects&lt;[MemAlloc]&gt;]&gt; {
  // MemAlloc = allocates memory (but no read/write side effects)
}
</code></pre>
<p><strong>자주 사용하는 traits:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>의미</th><th>예시</th></tr>
</thead>
<tbody>
<tr><td><code>Pure</code></td><td>부작용 없음</td><td><code>arith.addi</code>, <code>funlang.make_closure</code></td></tr>
<tr><td><code>MemoryEffects&lt;[MemRead]&gt;</code></td><td>메모리 읽기만</td><td><code>memref.load</code></td></tr>
<tr><td><code>MemoryEffects&lt;[MemWrite]&gt;</code></td><td>메모리 쓰기만</td><td><code>memref.store</code></td></tr>
<tr><td><code>MemoryEffects&lt;[MemAlloc]&gt;</code></td><td>메모리 할당만</td><td><code>memref.alloc</code></td></tr>
</tbody>
</table>
</div>
<h3 id="pitfall-3-symbol-table-미사용-string-함수-참조"><a class="header" href="#pitfall-3-symbol-table-미사용-string-함수-참조">Pitfall 3: Symbol Table 미사용 (String 함수 참조)</a></h3>
<p><strong>문제:</strong></p>
<pre><code class="language-tablegen">// 잘못된 설계 - 함수 이름을 문자열로
def FunLang_MakeClosureOp : FunLang_Op&lt;"make_closure"&gt; {
  let arguments = (ins StrAttr:$funcName);  // ERROR: 타입 체크 불가!
}
</code></pre>
<p><strong>왜 문제인가?</strong></p>
<ul>
<li>함수 존재 여부 체크 불가 (컴파일 타임)</li>
<li>함수 시그니처 검증 불가</li>
<li>Linker가 심볼 해석 불가</li>
</ul>
<p><strong>예시:</strong></p>
<pre><code class="language-mlir">// 문자열 사용 - 에러 발견 안 됨!
%closure = funlang.make_closure "typo_func"  // 함수 없어도 pass!
</code></pre>
<p><strong>해결:</strong></p>
<pre><code class="language-tablegen">// 올바른 설계 - SymbolRefAttr 사용
def FunLang_MakeClosureOp : FunLang_Op&lt;"make_closure", [Pure]&gt; {
  let arguments = (ins FlatSymbolRefAttr:$funcName);  // GOOD: 심볼 참조
}
</code></pre>
<p><strong>사용:</strong></p>
<pre><code class="language-mlir">// 심볼 참조 - 컴파일 타임 체크!
%closure = funlang.make_closure @lambda_func  // 함수 없으면 에러!

// 함수 정의 필요
func.func private @lambda_func(%env: !llvm.ptr, %x: i32) -&gt; i32 {
  // ...
}
</code></pre>
<p><strong>SymbolRefAttr의 이점:</strong></p>
<ul>
<li>컴파일 타임 심볼 해석</li>
<li>함수 시그니처 체크 가능</li>
<li>IDE 지원 (jump to definition)</li>
</ul>
<h3 id="pitfall-4-c-api-메모리-관리-혼동"><a class="header" href="#pitfall-4-c-api-메모리-관리-혼동">Pitfall 4: C API 메모리 관리 혼동</a></h3>
<p><strong>문제:</strong></p>
<pre><code class="language-cpp">// 잘못된 C API - 포인터 반환
extern "C" {
    MlirValue* mlirFunLangGetCapturedValues(MlirOperation op) {
        auto makeClosureOp = cast&lt;MakeClosureOp&gt;(unwrap(op));
        auto captured = makeClosureOp.getCapturedValues();

        // ERROR: SmallVector 로컬 변수!
        SmallVector&lt;MlirValue, 4&gt; result;
        for (Value v : captured) {
            result.push_back(wrap(v));
        }

        // DANGER: 댕글링 포인터! (result는 스택)
        return result.data();
    }
}
</code></pre>
<p><strong>왜 문제인가?</strong></p>
<ul>
<li>C API는 ownership 명확히 해야 함</li>
<li>스택 메모리 반환 → use-after-free</li>
<li>F#은 언제 메모리 해제할지 모름</li>
</ul>
<p><strong>해결 1: 호출자가 버퍼 제공</strong></p>
<pre><code class="language-cpp">extern "C" {
    intptr_t mlirFunLangGetCapturedValuesInto(MlirOperation op,
                                               MlirValue *buffer,
                                               intptr_t bufferSize) {
        auto makeClosureOp = cast&lt;MakeClosureOp&gt;(unwrap(op));
        auto captured = makeClosureOp.getCapturedValues();

        intptr_t numCaptured = captured.size();
        if (numCaptured &gt; bufferSize)
            return -1;  // Buffer too small

        for (intptr_t i = 0; i &lt; numCaptured; ++i) {
            buffer[i] = wrap(captured[i]);
        }

        return numCaptured;
    }
}
</code></pre>
<p>F#에서:</p>
<pre><code class="language-fsharp">let buffer = Array.zeroCreate&lt;MlirValue&gt; 10
let count = mlirFunLangGetCapturedValuesInto(op, buffer, 10n)
let capturedValues = buffer.[0..int count - 1]
</code></pre>
<p><strong>해결 2: Iterator 패턴</strong></p>
<pre><code class="language-cpp">extern "C" {
    void mlirFunLangMakeClosureForEachCaptured(MlirOperation op,
                                                 void (*callback)(MlirValue, void*),
                                                 void *userData) {
        auto makeClosureOp = cast&lt;MakeClosureOp&gt;(unwrap(op));
        for (Value v : makeClosureOp.getCapturedValues()) {
            callback(wrap(v), userData);
        }
    }
}
</code></pre>
<p><strong>원칙:</strong></p>
<ul>
<li>C API는 ownership 명확히 (caller owns? callee owns?)</li>
<li>배열 반환: caller-provided buffer 또는 callback</li>
<li>문서화: “caller must free” vs “MLIR owns”</li>
</ul>
<h2 id="요약-1-1"><a class="header" href="#요약-1-1">요약</a></h2>
<p><strong>Chapter 14에서 배운 것:</strong></p>
<ol>
<li>
<p><strong>Progressive Lowering의 필요성</strong>: Phase 4 직접 lowering의 문제 (복잡도, 최적화 상실, 디버깅 어려움)</p>
</li>
<li>
<p><strong>MLIR Dialect 아키텍처</strong>: Operation (계산), Type (값), Attribute (상수), Region/Block (제어 흐름), Symbol Table (전역 참조)</p>
</li>
<li>
<p><strong>TableGen ODS 기초</strong>:</p>
<ul>
<li>Dialect 정의 (<code>FunLang_Dialect</code>)</li>
<li>Operation 정의 (arguments, results, traits, assemblyFormat)</li>
<li>Type 정의 (<code>ClosureType</code>, <code>ListType</code>)</li>
<li>생성된 C++ 코드 (parser, printer, builder, verifier)</li>
</ul>
</li>
<li>
<p><strong>C API Shim 패턴</strong>:</p>
<ul>
<li>문제: TableGen → C++, F# → C API</li>
<li>해결: <code>extern "C"</code> wrapper (FunLangCAPI.h/.cpp)</li>
<li>wrap/unwrap helpers (C ↔ C++ 변환)</li>
<li>OpBuilder 활용 (operation 생성)</li>
<li>F# P/Invoke bindings</li>
</ul>
</li>
<li>
<p><strong>FunLang Operations 설계</strong>:</p>
<ul>
<li><code>funlang.make_closure</code>: 클로저 생성</li>
<li><code>funlang.apply</code>: 클로저 호출</li>
<li><code>funlang.match</code>: 패턴 매칭 (Phase 6)</li>
<li>Lowering 전략 (FunLang → Func/MemRef → LLVM)</li>
</ul>
</li>
<li>
<p><strong>Common Pitfalls</strong>:</p>
<ul>
<li>AnyType 남용 → 커스텀 타입 사용</li>
<li>Trait 누락 → Pure, MemoryEffects 명시</li>
<li>문자열 함수 참조 → SymbolRefAttr 사용</li>
<li>C API 메모리 관리 → ownership 명확히</li>
</ul>
</li>
</ol>
<p><strong>다음 장 (Chapter 15) Preview:</strong></p>
<p>Chapter 15에서는:</p>
<ul>
<li>FunLang dialect 실제 구현 (C++ 코드 작성)</li>
<li>TableGen 파일 작성 (FunLangOps.td, FunLangTypes.td)</li>
<li>C API shim 구현 (FunLangCAPI.cpp)</li>
<li>F# bindings 작성 (FunLangBindings.fs)</li>
<li>Lowering pass 구현 (FunLangToFunc.cpp)</li>
<li>컴파일러 통합 (Compiler.fs 수정)</li>
<li>전체 빌드 시스템 (CMakeLists.txt)</li>
</ul>
<p>이론적 기초를 확립했으므로, 실제 구현으로 넘어갈 준비가 됐다.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-15-커스텀-operations-custom-operations"><a class="header" href="#chapter-15-커스텀-operations-custom-operations">Chapter 15: 커스텀 Operations (Custom Operations)</a></h1>
<h2 id="소개-15"><a class="header" href="#소개-15">소개</a></h2>
<p><strong>Chapter 14</strong>에서는 커스텀 MLIR dialect의 <strong>이론</strong>을 다뤘다:</p>
<ul>
<li>Progressive lowering 철학</li>
<li>TableGen ODS 문법</li>
<li>C API shim 패턴</li>
<li>FunLang dialect 설계 방향</li>
</ul>
<p><strong>Chapter 15</strong>에서는 <strong>실제 구현</strong>을 진행한다. FunLang dialect의 핵심 operations를 정의하고 F#에서 사용할 수 있게 만든다.</p>
<h3 id="chapter-15의-목표"><a class="header" href="#chapter-15의-목표">Chapter 15의 목표</a></h3>
<ol>
<li><strong>funlang.closure Operation</strong>: Chapter 12의 12줄 클로저 생성 코드를 1줄로 압축</li>
<li><strong>funlang.apply Operation</strong>: Chapter 13의 8줄 간접 호출 코드를 1줄로 압축</li>
<li><strong>funlang.match Operation (Preview)</strong>: Phase 6 패턴 매칭을 위한 준비</li>
<li><strong>FunLang Custom Types</strong>: <code>!funlang.closure</code>, <code>!funlang.list</code> 타입 정의</li>
<li><strong>Complete F# Integration</strong>: C API shim부터 F# wrapper까지 전체 스택 구축</li>
</ol>
<h3 id="before-vs-after-코드-압축의-위력"><a class="header" href="#before-vs-after-코드-압축의-위력">Before vs After: 코드 압축의 위력</a></h3>
<p><strong>Before (Phase 4 - Chapter 12):</strong></p>
<pre><code class="language-mlir">// 클로저 생성: 12줄
func.func @make_adder(%n: i32) -&gt; !llvm.ptr {
    %env_size = arith.constant 16 : i64
    %env_ptr = llvm.call @GC_malloc(%env_size) : (i64) -&gt; !llvm.ptr
    %fn_addr = llvm.mlir.addressof @lambda_adder : !llvm.ptr
    %fn_slot = llvm.getelementptr %env_ptr[0] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %fn_addr, %fn_slot : !llvm.ptr, !llvm.ptr
    %n_slot = llvm.getelementptr %env_ptr[1] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %n, %n_slot : i32, !llvm.ptr
    func.return %env_ptr : !llvm.ptr
}

// 클로저 호출: 8줄
func.func @apply(%f: !llvm.ptr, %x: i32) -&gt; i32 {
    %c0 = arith.constant 0 : i64
    %fn_ptr_addr = llvm.getelementptr %f[0, %c0] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    %fn_ptr = llvm.load %fn_ptr_addr : !llvm.ptr -&gt; !llvm.ptr
    %result = llvm.call %fn_ptr(%f, %x) : (!llvm.ptr, i32) -&gt; i32
    func.return %result : i32
}
</code></pre>
<p><strong>After (Phase 5 - Chapter 15):</strong></p>
<pre><code class="language-mlir">// 클로저 생성: 1줄!
func.func @make_adder(%n: i32) -&gt; !funlang.closure {
    %closure = funlang.closure @lambda_adder, %n : !funlang.closure
    func.return %closure : !funlang.closure
}

// 클로저 호출: 1줄!
func.func @apply(%f: !funlang.closure, %x: i32) -&gt; i32 {
    %result = funlang.apply %f(%x) : (i32) -&gt; i32
    func.return %result : i32
}
</code></pre>
<p><strong>개선 효과:</strong></p>
<ul>
<li><strong>코드 줄 수</strong>: 20줄 → 4줄 (80% 감소!)</li>
<li><strong>가독성</strong>: GEP/store 패턴 제거, 의도 명확</li>
<li><strong>타입 안전성</strong>: <code>!llvm.ptr</code> → <code>!funlang.closure</code> (타입 시스템 활용)</li>
<li><strong>최적화 가능성</strong>: 클로저 인라이닝, escape analysis 등</li>
</ul>
<h3 id="chapter-14-복습"><a class="header" href="#chapter-14-복습">Chapter 14 복습</a></h3>
<p>커스텀 dialect를 만드는 3가지 핵심 요소:</p>
<p><strong>1. TableGen ODS (Operation Definition Specification)</strong></p>
<ul>
<li>선언적으로 operation 정의 (파서/프린터/빌더 자동 생성)</li>
<li><code>.td</code> 파일로 작성</li>
</ul>
<p><strong>2. C++ Dialect 구현</strong></p>
<ul>
<li>TableGen이 생성한 클래스를 활용</li>
<li>Verifier, lowering pass 구현</li>
</ul>
<p><strong>3. C API Shim</strong></p>
<ul>
<li><code>extern "C"</code> wrapper로 F# P/Invoke 연결</li>
<li><code>wrap</code>/<code>unwrap</code> 헬퍼로 C handle ↔ C++ pointer 변환</li>
</ul>
<p><strong>이 장에서는 이 세 요소를 모두 구현한다.</strong></p>
<h3 id="구현할-operations"><a class="header" href="#구현할-operations">구현할 Operations</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Purpose</th><th>Phase</th></tr>
</thead>
<tbody>
<tr><td><code>funlang.closure</code></td><td>클로저 생성 (GC_malloc + store 추상화)</td><td>5</td></tr>
<tr><td><code>funlang.apply</code></td><td>클로저 호출 (GEP + load + llvm.call 추상화)</td><td>5</td></tr>
<tr><td><code>funlang.match</code></td><td>패턴 매칭 (region-based control flow)</td><td>6 preview</td></tr>
</tbody>
</table>
</div>
<h3 id="구현할-types"><a class="header" href="#구현할-types">구현할 Types</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Purpose</th><th>Phase</th></tr>
</thead>
<tbody>
<tr><td><code>!funlang.closure</code></td><td>클로저 값 (opaque type)</td><td>5</td></tr>
<tr><td><code>!funlang.list&lt;T&gt;</code></td><td>불변 리스트 (parameterized type)</td><td>6 preview</td></tr>
</tbody>
</table>
</div>
<h3 id="chapter-15-성공-기준"><a class="header" href="#chapter-15-성공-기준">Chapter 15 성공 기준</a></h3>
<p>이 장을 완료하면:</p>
<ul>
<li><input disabled="" type="checkbox"> <code>funlang.closure</code> operation을 TableGen으로 정의할 수 있다</li>
<li><input disabled="" type="checkbox"> C API shim 함수를 작성해 F#에서 호출할 수 있다</li>
<li><input disabled="" type="checkbox"> F# P/Invoke 바인딩을 작성할 수 있다</li>
<li><input disabled="" type="checkbox"> Chapter 12-13의 compileExpr 코드를 리팩토링할 수 있다</li>
<li><input disabled="" type="checkbox"> Phase 4 대비 코드 줄 수가 60% 이상 감소한다</li>
<li><input disabled="" type="checkbox"> Region-based operation (funlang.match)의 구조를 이해한다</li>
</ul>
<blockquote>
<p><strong>Preview:</strong> Chapter 16에서는 FunLang dialect을 LLVM dialect으로 lowering하는 pass를 구현한다.</p>
</blockquote>
<hr>
<h2 id="part-1-funlangclosure-operation"><a class="header" href="#part-1-funlangclosure-operation">Part 1: funlang.closure Operation</a></h2>
<h3 id="phase-4-패턴-분석-무엇을-추상화하는가"><a class="header" href="#phase-4-패턴-분석-무엇을-추상화하는가">Phase 4 패턴 분석: 무엇을 추상화하는가?</a></h3>
<p>Chapter 12에서 클로저를 생성할 때, 12줄의 LLVM dialect 코드가 필요했다:</p>
<pre><code class="language-mlir">func.func @make_adder(%n: i32) -&gt; !llvm.ptr {
    // Step 1: 환경 크기 계산
    // 함수 포인터 (8 bytes) + 캡처된 변수 (4 bytes * count)
    %env_size = arith.constant 16 : i64

    // Step 2: GC_malloc 호출로 환경 할당
    %env_ptr = llvm.call @GC_malloc(%env_size) : (i64) -&gt; !llvm.ptr

    // Step 3: 함수 포인터 저장 (env[0])
    %fn_addr = llvm.mlir.addressof @lambda_adder : !llvm.ptr
    %fn_slot = llvm.getelementptr %env_ptr[0] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %fn_addr, %fn_slot : !llvm.ptr, !llvm.ptr

    // Step 4: 캡처된 변수 n 저장 (env[1])
    %n_slot = llvm.getelementptr %env_ptr[1] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %n, %n_slot : i32, !llvm.ptr

    // Step 5: 환경 포인터 반환 (클로저 값)
    func.return %env_ptr : !llvm.ptr
}
</code></pre>
<p><strong>패턴 분석:</strong></p>
<ol>
<li>
<p><strong>환경 크기 계산</strong>: 8 (fn ptr) + 4 * n (captured vars)</p>
<ul>
<li>컴파일 타임에 결정 가능</li>
<li>하지만 컴파일러 코드에서 수동 계산 필요</li>
</ul>
</li>
<li>
<p><strong>GC_malloc 호출</strong>: 힙 할당</p>
<ul>
<li>모든 클로저에 공통</li>
<li>크기만 다름</li>
</ul>
</li>
<li>
<p><strong>함수 포인터 저장</strong>: <code>env[0]</code> 슬롯에 <code>@lambda_N</code> 주소</p>
<ul>
<li>모든 클로저에 공통</li>
<li>슬롯 인덱스는 항상 0</li>
</ul>
</li>
<li>
<p><strong>변수 저장</strong>: <code>env[1..n]</code> 슬롯에 캡처된 변수들</p>
<ul>
<li>변수 개수만 다름</li>
<li>GEP + store 패턴 반복</li>
</ul>
</li>
<li>
<p><strong>타입</strong>: <code>!llvm.ptr</code> (opaque)</p>
<ul>
<li>타입 안전성 없음</li>
<li>클로저인지 일반 포인터인지 구별 불가</li>
</ul>
</li>
</ol>
<p><strong>문제점:</strong></p>
<ul>
<li><strong>반복 코드</strong>: 모든 람다마다 동일한 패턴 12줄</li>
<li><strong>인덱스 오류 가능성</strong>: <code>env[0]</code> vs <code>env[1]</code> 수동 관리</li>
<li><strong>타입 안전성 부족</strong>: 모든 포인터가 <code>!llvm.ptr</code></li>
<li><strong>최적화 어려움</strong>: 클로저인지 알 수 없음</li>
<li><strong>가독성 저하</strong>: 저수준 메모리 조작 노출</li>
</ul>
<p><strong>해결책: funlang.closure Operation</strong></p>
<p>이 패턴을 단일 operation으로 추상화한다:</p>
<pre><code class="language-mlir">// Before: 12 lines
%env_size = arith.constant 16 : i64
%env_ptr = llvm.call @GC_malloc(%env_size) : (i64) -&gt; !llvm.ptr
%fn_addr = llvm.mlir.addressof @lambda_adder : !llvm.ptr
%fn_slot = llvm.getelementptr %env_ptr[0] : (!llvm.ptr) -&gt; !llvm.ptr
llvm.store %fn_addr, %fn_slot : !llvm.ptr, !llvm.ptr
%n_slot = llvm.getelementptr %env_ptr[1] : (!llvm.ptr) -&gt; !llvm.ptr
llvm.store %n, %n_slot : i32, !llvm.ptr

// After: 1 line!
%closure = funlang.closure @lambda_adder, %n : !funlang.closure
</code></pre>
<p><strong>이득:</strong></p>
<ul>
<li><strong>간결성</strong>: 12줄 → 1줄</li>
<li><strong>타입 안전성</strong>: <code>!funlang.closure</code> (dedicated type)</li>
<li><strong>의도 명확</strong>: “클로저를 만든다“라는 의미가 즉시 보임</li>
<li><strong>컴파일러 단순화</strong>: GEP 인덱스 계산 불필요</li>
<li><strong>최적화 가능</strong>: 클로저 특화 pass 작성 가능 (escape analysis, inlining)</li>
</ul>
<h3 id="tablegen-정의-funlang_closureop"><a class="header" href="#tablegen-정의-funlang_closureop">TableGen 정의: FunLang_ClosureOp</a></h3>
<p><code>FunLangOps.td</code> 파일에 다음과 같이 정의한다:</p>
<pre><code class="language-tablegen">//===- FunLangOps.td - FunLang dialect operations ---------*- tablegen -*-===//
//
// FunLang Dialect Operations
//
//===----------------------------------------------------------------------===//

#ifndef FUNLANG_OPS
#define FUNLANG_OPS

include "mlir/IR/OpBase.td"
include "mlir/Interfaces/SideEffectInterfaces.td"
include "mlir/Interfaces/CallInterfaces.td"
include "FunLangDialect.td"
include "FunLangTypes.td"

//===----------------------------------------------------------------------===//
// ClosureOp
//===----------------------------------------------------------------------===//

def FunLang_ClosureOp : FunLang_Op&lt;"closure", [Pure]&gt; {
  let summary = "Create a closure with captured environment";

  let description = [{
    Creates a closure by combining a function reference with captured values.

    Syntax:
    ```
    %closure = funlang.closure @func_name, %arg1, %arg2, ... : !funlang.closure
    ```

    This operation abstracts the low-level closure creation pattern:
    - Allocate environment (GC_malloc)
    - Store function pointer (env[0])
    - Store captured values (env[1..n])

    Example:
    ```
    // Create closure: fun x -&gt; x + n
    %closure = funlang.closure @lambda_adder, %n : !funlang.closure
    ```

    Lowering to LLVM dialect:
    - Compute environment size: 8 (fn ptr) + sizeof(captured values)
    - Call GC_malloc
    - Store function pointer at slot 0
    - Store captured values at slots 1..n
    - Return environment pointer
  }];

  let arguments = (ins
    FlatSymbolRefAttr:$callee,
    Variadic&lt;AnyType&gt;:$capturedValues
  );

  let results = (outs FunLang_ClosureType:$result);

  let assemblyFormat = [{
    $callee (`,` $capturedValues^)? attr-dict `:` type($result)
  }];

  let builders = [
    OpBuilder&lt;(ins "mlir::FlatSymbolRefAttr":$callee,
                   "mlir::ValueRange":$capturedValues), [{
      build($_builder, $_state,
            FunLangClosureType::get($_builder.getContext()),
            callee, capturedValues);
    }]&gt;
  ];
}

#endif // FUNLANG_OPS
</code></pre>
<h3 id="tablegen-상세-설명"><a class="header" href="#tablegen-상세-설명">TableGen 상세 설명</a></h3>
<h4 id="1-operation-이름과-traits"><a class="header" href="#1-operation-이름과-traits">1. Operation 이름과 Traits</a></h4>
<pre><code class="language-tablegen">def FunLang_ClosureOp : FunLang_Op&lt;"closure", [Pure]&gt; {
</code></pre>
<p><strong>구성 요소:</strong></p>
<ul>
<li><code>FunLang_ClosureOp</code>: C++ 클래스 이름 (ClosureOp 생성)</li>
<li><code>"closure"</code>: MLIR assembly에서의 operation 이름 (funlang.closure)</li>
<li><code>[Pure]</code>: Operation traits 리스트</li>
</ul>
<p><strong>Pure Trait:</strong></p>
<p><code>Pure</code> trait는 operation이 <strong>side-effect free</strong>임을 선언한다:</p>
<pre><code class="language-cpp">// Pure operation의 의미:
// 1. 같은 입력 → 항상 같은 출력
// 2. 메모리 읽기/쓰기 없음 (pure function)
// 3. 외부 상태에 영향 없음
</code></pre>
<p><strong>왜 funlang.closure가 Pure인가?</strong></p>
<p>“GC_malloc을 호출하는데 Pure라고?“라는 의문이 들 수 있다. 여기서 Pure는 <strong>FunLang dialect 수준</strong>에서의 의미다:</p>
<ul>
<li><strong>FunLang 수준</strong>: 클로저 생성은 pure (같은 인자 → 같은 클로저 값)</li>
<li><strong>Lowering 후</strong>: GC_malloc 호출 (side effect 있음)</li>
</ul>
<p>Progressive lowering의 핵심: <strong>각 dialect 수준에서 독립적인 의미론을 가진다.</strong></p>
<p>Pure trait의 이점:</p>
<pre><code class="language-mlir">// CSE (Common Subexpression Elimination) 가능
%c1 = funlang.closure @lambda_add, %n : !funlang.closure
%c2 = funlang.closure @lambda_add, %n : !funlang.closure
// CSE pass가 %c2를 %c1로 대체 가능 (Pure이므로)
</code></pre>
<h4 id="2-summary와-description"><a class="header" href="#2-summary와-description">2. Summary와 Description</a></h4>
<pre><code class="language-tablegen">let summary = "Create a closure with captured environment";
</code></pre>
<ul>
<li><strong>summary</strong>: 한 줄 설명 (IDE tooltip, 문서 생성에 사용)</li>
<li><strong>description</strong>: 상세 설명 (Markdown 포맷 지원)</li>
</ul>
<p>Description에 포함할 내용:</p>
<ol>
<li><strong>Syntax</strong>: 사용 방법</li>
<li><strong>Semantics</strong>: 의미론 (무엇을 하는가)</li>
<li><strong>Example</strong>: 구체적 예시</li>
<li><strong>Lowering</strong>: LLVM dialect으로의 변환 방법</li>
</ol>
<h4 id="3-arguments-입력"><a class="header" href="#3-arguments-입력">3. Arguments (입력)</a></h4>
<pre><code class="language-tablegen">let arguments = (ins
  FlatSymbolRefAttr:$callee,
  Variadic&lt;AnyType&gt;:$capturedValues
);
</code></pre>
<p><strong>FlatSymbolRefAttr:$callee</strong></p>
<ul>
<li><strong>타입</strong>: Symbol reference (함수 이름)</li>
<li><strong>이름</strong>: <code>callee</code> (호출할 함수)</li>
<li><strong>FlatSymbolRefAttr</strong>: 같은 모듈 내 심볼 참조</li>
</ul>
<pre><code class="language-mlir">// FlatSymbolRefAttr 예시
funlang.closure @lambda_adder, %n  // @lambda_adder가 FlatSymbolRefAttr
</code></pre>
<p><strong>왜 StrAttr이 아니라 FlatSymbolRefAttr인가?</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>StrAttr</th><th>FlatSymbolRefAttr</th></tr>
</thead>
<tbody>
<tr><td>단순 문자열</td><td>심볼 테이블 참조</td></tr>
<tr><td>검증 없음</td><td>컴파일 타임 검증 (심볼 존재 여부)</td></tr>
<tr><td>최적화 불가</td><td>최적화 가능 (인라이닝, DCE)</td></tr>
<tr><td>타입 정보 없음</td><td>타입 정보 있음 (함수 시그니처)</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-tablegen">// 잘못된 정의
let arguments = (ins StrAttr:$callee, ...);
// 문제: "@lambda_adder"가 존재하는지 검증 불가

// 올바른 정의
let arguments = (ins FlatSymbolRefAttr:$callee, ...);
// MLIR이 심볼 테이블에서 @lambda_adder 검증
</code></pre>
<p><strong>Variadic<anytype>:$capturedValues</anytype></strong></p>
<ul>
<li><strong>Variadic</strong>: 가변 길이 인자 (0개 이상)</li>
<li><strong>AnyType</strong>: 어떤 타입이든 허용</li>
<li><strong>이름</strong>: <code>capturedValues</code></li>
</ul>
<pre><code class="language-mlir">// 캡처 변수 0개
%closure0 = funlang.closure @const_fn : !funlang.closure

// 캡처 변수 1개
%closure1 = funlang.closure @add_n, %n : !funlang.closure

// 캡처 변수 3개
%closure3 = funlang.closure @lambda_xyz, %x, %y, %z : !funlang.closure
</code></pre>
<p><strong>AnyType의 Trade-off:</strong></p>
<p>장점:</p>
<ul>
<li>유연성: i32, f64, !llvm.ptr 등 모든 타입 허용</li>
<li>간단한 정의</li>
</ul>
<p>단점:</p>
<ul>
<li>타입 안전성 감소</li>
<li>Verifier에서 추가 검증 필요</li>
</ul>
<p>Alternative (더 엄격한 타입):</p>
<pre><code class="language-tablegen">// 특정 타입만 허용
let arguments = (ins
  FlatSymbolRefAttr:$callee,
  Variadic&lt;AnyTypeOf&lt;[I32, F64, LLVM_AnyPointer]&gt;&gt;:$capturedValues
);
</code></pre>
<p>Phase 5에서는 단순성을 위해 AnyType을 사용한다.</p>
<h4 id="4-results-출력"><a class="header" href="#4-results-출력">4. Results (출력)</a></h4>
<pre><code class="language-tablegen">let results = (outs FunLang_ClosureType:$result);
</code></pre>
<ul>
<li><strong>outs</strong>: 출력 값들</li>
<li><strong>FunLang_ClosureType</strong>: 커스텀 타입 (FunLangTypes.td에 정의)</li>
<li><strong>$result</strong>: 결과 값 이름</li>
</ul>
<p>단일 결과 operation이므로 <code>outs</code> 안에 하나만 선언한다.</p>
<p><strong>FunLang_ClosureType은 어디서 정의되는가?</strong></p>
<p><code>FunLangTypes.td</code> 파일에 다음과 같이 정의한다:</p>
<pre><code class="language-tablegen">//===- FunLangTypes.td - FunLang dialect types ------------*- tablegen -*-===//

#ifndef FUNLANG_TYPES
#define FUNLANG_TYPES

include "mlir/IR/AttrTypeBase.td"
include "FunLangDialect.td"

//===----------------------------------------------------------------------===//
// FunLang Type Definitions
//===----------------------------------------------------------------------===//

class FunLang_Type&lt;string name, string typeMnemonic&gt;
    : TypeDef&lt;FunLang_Dialect, name&gt; {
  let mnemonic = typeMnemonic;
}

def FunLang_ClosureType : FunLang_Type&lt;"Closure", "closure"&gt; {
  let summary = "FunLang closure type";
  let description = [{
    Represents a closure value (function + captured environment).

    Syntax: `!funlang.closure`

    Opaque type (no type parameters).
    Lowering: !funlang.closure -&gt; !llvm.ptr
  }];
}

#endif // FUNLANG_TYPES
</code></pre>
<h4 id="5-assembly-format-parserprinter"><a class="header" href="#5-assembly-format-parserprinter">5. Assembly Format (Parser/Printer)</a></h4>
<pre><code class="language-tablegen">let assemblyFormat = [{
  $callee (`,` $capturedValues^)? attr-dict `:` type($result)
}];
</code></pre>
<p><strong>구문 분석:</strong></p>
<ul>
<li><code>$callee</code>: 심볼 참조 (필수)</li>
<li><code>(</code>,<code> $capturedValues^)?</code>: 캡처 변수들 (선택, 쉼표로 구분)
<ul>
<li><code>^</code>: anchor (variadic의 첫 요소에만 <code>,</code> 붙음)</li>
<li><code>?</code>: 선택 (캡처 변수 없으면 생략)</li>
</ul>
</li>
<li><code>attr-dict</code>: 추가 속성들 (location 등)</li>
<li><code>:</code>: 타입 구분자</li>
<li><code>type($result)</code>: 결과 타입 (<code>:!funlang.closure</code>)</li>
</ul>
<p><strong>생성되는 Assembly:</strong></p>
<pre><code class="language-mlir">// 캡처 변수 없음
%c0 = funlang.closure @const_fn : !funlang.closure

// 캡처 변수 1개
%c1 = funlang.closure @add_n, %n : !funlang.closure

// 캡처 변수 3개
%c3 = funlang.closure @lambda_xyz, %x, %y, %z : !funlang.closure
</code></pre>
<p><strong>TableGen이 자동 생성:</strong></p>
<ul>
<li><strong>Parser</strong>: assembly → C++ operation</li>
<li><strong>Printer</strong>: C++ operation → assembly</li>
</ul>
<p>수동 구현과 비교:</p>
<pre><code class="language-cpp">// 수동 구현 (100+ lines)
class ClosureOp : public Op&lt;...&gt; {
  static ParseResult parse(OpAsmParser &amp;parser, OperationState &amp;result);
  void print(OpAsmPrinter &amp;p);
};

// TableGen 자동 생성 (1 line in .td)
let assemblyFormat = [{...}];
</code></pre>
<h4 id="6-builders-생성자"><a class="header" href="#6-builders-생성자">6. Builders (생성자)</a></h4>
<pre><code class="language-tablegen">let builders = [
  OpBuilder&lt;(ins "mlir::FlatSymbolRefAttr":$callee,
                 "mlir::ValueRange":$capturedValues), [{
    build($_builder, $_state,
          FunLangClosureType::get($_builder.getContext()),
          callee, capturedValues);
  }]&gt;
];
</code></pre>
<p><strong>Builder의 역할:</strong></p>
<p>C++ 코드에서 operation을 생성할 때 사용하는 헬퍼 함수:</p>
<pre><code class="language-cpp">// C++ 코드에서 사용
auto calleeAttr = mlir::FlatSymbolRefAttr::get(context, "lambda_adder");
SmallVector&lt;mlir::Value&gt; captured = {nValue};
auto closure = builder.create&lt;FunLang::ClosureOp&gt;(loc, calleeAttr, captured);
</code></pre>
<p><strong>Builder 파라미터:</strong></p>
<ul>
<li><code>$_builder</code>: OpBuilder 인스턴스</li>
<li><code>$_state</code>: OperationState (operation 생성 중간 상태)</li>
<li><code>callee</code>: 함수 심볼</li>
<li><code>capturedValues</code>: 캡처된 변수들</li>
</ul>
<p><strong>자동 타입 추론:</strong></p>
<p>Builder 내부에서 결과 타입을 자동으로 설정한다:</p>
<pre><code class="language-cpp">FunLangClosureType::get($_builder.getContext())
// 항상 !funlang.closure 타입
</code></pre>
<h3 id="생성되는-c-클래스"><a class="header" href="#생성되는-c-클래스">생성되는 C++ 클래스</a></h3>
<p>TableGen은 <code>FunLangOps.td</code>를 읽고 다음 C++ 코드를 생성한다:</p>
<p><strong>Generated: FunLangOps.h.inc</strong></p>
<pre><code class="language-cpp">namespace mlir {
namespace funlang {

class ClosureOp : public Op&lt;ClosureOp,
                             OpTrait::ZeroRegions,
                             OpTrait::OneResult,
                             OpTrait::Pure&gt; {
public:
  using Op::Op;

  static StringRef getOperationName() {
    return "funlang.closure";
  }

  // Accessors
  FlatSymbolRefAttr getCalleeAttr() { return /*...*/ ; }
  StringRef getCallee() { return getCalleeAttr().getValue(); }

  OperandRange getCapturedValues() { return /*...*/ ; }

  FunLangClosureType getType() { return /*...*/ ; }

  // Builder
  static void build(OpBuilder &amp;builder, OperationState &amp;state,
                    FlatSymbolRefAttr callee,
                    ValueRange capturedValues);

  // Parser/Printer
  static ParseResult parse(OpAsmParser &amp;parser, OperationState &amp;result);
  void print(OpAsmPrinter &amp;p);

  // Verifier (default)
  LogicalResult verify();
};

} // namespace funlang
} // namespace mlir
</code></pre>
<p><strong>자동 생성되는 기능:</strong></p>
<ol>
<li><strong>Accessors</strong>: <code>getCallee()</code>, <code>getCapturedValues()</code> (argument 접근)</li>
<li><strong>Builder</strong>: <code>create&lt;ClosureOp&gt;(...)</code> (operation 생성)</li>
<li><strong>Parser</strong>: assembly → operation (assemblyFormat 기반)</li>
<li><strong>Printer</strong>: operation → assembly (assemblyFormat 기반)</li>
<li><strong>Verifier</strong>: 기본 검증 (타입 일치, operand 개수)</li>
</ol>
<h3 id="c-api-shim-구현"><a class="header" href="#c-api-shim-구현">C API Shim 구현</a></h3>
<p>F#에서 ClosureOp를 생성하려면 C API shim이 필요하다.</p>
<p><strong>FunLangCAPI.h:</strong></p>
<pre><code class="language-c">//===- FunLangCAPI.h - C API for FunLang dialect --------------------------===//

#ifndef FUNLANG_CAPI_H
#define FUNLANG_CAPI_H

#include "mlir-c/IR.h"

#ifdef __cplusplus
extern "C" {
#endif

//===----------------------------------------------------------------------===//
// FunLang Types
//===----------------------------------------------------------------------===//

/// Create a FunLang closure type.
MLIR_CAPI_EXPORTED MlirType mlirFunLangClosureTypeGet(MlirContext ctx);

/// Check if a type is a FunLang closure type.
MLIR_CAPI_EXPORTED bool mlirTypeIsAFunLangClosureType(MlirType type);

//===----------------------------------------------------------------------===//
// FunLang Operations
//===----------------------------------------------------------------------===//

/// Create a funlang.closure operation.
///
/// Arguments:
///   ctx: MLIR context
///   loc: Source location
///   callee: Symbol reference to the function (FlatSymbolRefAttr)
///   numCaptured: Number of captured values
///   capturedValues: Array of captured SSA values
///
/// Returns: The created operation (as MlirOperation)
MLIR_CAPI_EXPORTED MlirOperation mlirFunLangClosureOpCreate(
    MlirContext ctx,
    MlirLocation loc,
    MlirAttribute callee,
    intptr_t numCaptured,
    MlirValue *capturedValues);

/// Get the callee attribute from a funlang.closure operation.
MLIR_CAPI_EXPORTED MlirAttribute mlirFunLangClosureOpGetCallee(MlirOperation op);

/// Get the number of captured values from a funlang.closure operation.
MLIR_CAPI_EXPORTED intptr_t mlirFunLangClosureOpGetNumCapturedValues(MlirOperation op);

/// Get a captured value by index from a funlang.closure operation.
MLIR_CAPI_EXPORTED MlirValue mlirFunLangClosureOpGetCapturedValue(
    MlirOperation op, intptr_t index);

#ifdef __cplusplus
}
#endif

#endif // FUNLANG_CAPI_H
</code></pre>
<p><strong>FunLangCAPI.cpp:</strong></p>
<pre><code class="language-cpp">//===- FunLangCAPI.cpp - C API for FunLang dialect ------------------------===//

#include "FunLangCAPI.h"
#include "FunLang/FunLangDialect.h"
#include "FunLang/FunLangOps.h"
#include "FunLang/FunLangTypes.h"
#include "mlir/CAPI/IR.h"
#include "mlir/CAPI/Support.h"

using namespace mlir;
using namespace mlir::funlang;

//===----------------------------------------------------------------------===//
// Type API
//===----------------------------------------------------------------------===//

MlirType mlirFunLangClosureTypeGet(MlirContext ctx) {
  return wrap(FunLangClosureType::get(unwrap(ctx)));
}

bool mlirTypeIsAFunLangClosureType(MlirType type) {
  return unwrap(type).isa&lt;FunLangClosureType&gt;();
}

//===----------------------------------------------------------------------===//
// Operation API
//===----------------------------------------------------------------------===//

MlirOperation mlirFunLangClosureOpCreate(
    MlirContext ctx,
    MlirLocation loc,
    MlirAttribute callee,
    intptr_t numCaptured,
    MlirValue *capturedValues) {

  MLIRContext *context = unwrap(ctx);
  Location location = unwrap(loc);

  // Verify callee is a FlatSymbolRefAttr
  auto calleeAttr = unwrap(callee).dyn_cast&lt;FlatSymbolRefAttr&gt;();
  assert(calleeAttr &amp;&amp; "callee must be a FlatSymbolRefAttr");

  // Build captured values range
  SmallVector&lt;Value, 4&gt; captured;
  for (intptr_t i = 0; i &lt; numCaptured; ++i) {
    captured.push_back(unwrap(capturedValues[i]));
  }

  // Create operation using OpBuilder
  OpBuilder builder(context);
  auto op = builder.create&lt;ClosureOp&gt;(location, calleeAttr, captured);

  return wrap(op.getOperation());
}

MlirAttribute mlirFunLangClosureOpGetCallee(MlirOperation op) {
  auto closureOp = llvm::cast&lt;ClosureOp&gt;(unwrap(op));
  return wrap(closureOp.getCalleeAttr());
}

intptr_t mlirFunLangClosureOpGetNumCapturedValues(MlirOperation op) {
  auto closureOp = llvm::cast&lt;ClosureOp&gt;(unwrap(op));
  return closureOp.getCapturedValues().size();
}

MlirValue mlirFunLangClosureOpGetCapturedValue(MlirOperation op, intptr_t index) {
  auto closureOp = llvm::cast&lt;ClosureOp&gt;(unwrap(op));
  return wrap(closureOp.getCapturedValues()[index]);
}
</code></pre>
<p><strong>wrap/unwrap Pattern:</strong></p>
<p>MLIR C API의 핵심 패턴:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Direction</th><th>Function</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>C → C++</td><td><code>unwrap(MlirX)</code></td><td>C handle을 C++ pointer로 변환</td></tr>
<tr><td>C++ → C</td><td><code>wrap(X*)</code></td><td>C++ pointer를 C handle로 변환</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-cpp">// unwrap: C handle -&gt; C++ pointer
MLIRContext *context = unwrap(ctx);          // MlirContext -&gt; MLIRContext*
Location location = unwrap(loc);             // MlirLocation -&gt; Location
Value value = unwrap(capturedValues[i]);     // MlirValue -&gt; Value

// wrap: C++ pointer -&gt; C handle
MlirOperation result = wrap(op.getOperation());  // Operation* -&gt; MlirOperation
MlirType resultType = wrap(closure_type);         // Type -&gt; MlirType
</code></pre>
<h3 id="f-pinvoke-바인딩-1"><a class="header" href="#f-pinvoke-바인딩-1">F# P/Invoke 바인딩</a></h3>
<p><code>FunLangBindings.fs</code>:</p>
<pre><code class="language-fsharp">namespace Mlir.FunLang

open System.Runtime.InteropServices
open Mlir.Core

/// FunLang dialect P/Invoke bindings
module FunLangBindings =

    //==========================================================================
    // Types
    //==========================================================================

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirFunLangClosureTypeGet(MlirContext ctx)

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern bool mlirTypeIsAFunLangClosureType(MlirType ty)

    //==========================================================================
    // Operations
    //==========================================================================

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirFunLangClosureOpCreate(
        MlirContext ctx,
        MlirLocation loc,
        MlirAttribute callee,
        nativeint numCaptured,
        MlirValue[] capturedValues)

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirAttribute mlirFunLangClosureOpGetCallee(MlirOperation op)

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern nativeint mlirFunLangClosureOpGetNumCapturedValues(MlirOperation op)

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirValue mlirFunLangClosureOpGetCapturedValue(
        MlirOperation op,
        nativeint index)

/// High-level F# wrappers for FunLang operations
type FunLangOps =

    /// Create !funlang.closure type
    static member ClosureType(context: MlirContext) : MlirType =
        FunLangBindings.mlirFunLangClosureTypeGet(context)

    /// Check if type is !funlang.closure
    static member IsClosureType(ty: MlirType) : bool =
        FunLangBindings.mlirTypeIsAFunLangClosureType(ty)

    /// Create funlang.closure operation
    static member CreateClosure(
        context: MlirContext,
        location: MlirLocation,
        callee: string,
        capturedValues: MlirValue list) : MlirOperation =

        // Convert function name to FlatSymbolRefAttr
        use calleeStrRef = MlirStringRef.FromString(callee)
        let calleeAttr =
            mlirFlatSymbolRefAttrGet(context, calleeStrRef)

        // Convert F# list to array
        let capturedArray = List.toArray capturedValues
        let numCaptured = nativeint capturedArray.Length

        // Call C API
        FunLangBindings.mlirFunLangClosureOpCreate(
            context, location, calleeAttr, numCaptured, capturedArray)

    /// Get callee name from funlang.closure operation
    static member GetClosureCallee(op: MlirOperation) : string =
        let attr = FunLangBindings.mlirFunLangClosureOpGetCallee(op)
        let strRef = mlirFlatSymbolRefAttrGetValue(attr)
        MlirStringRef.ToString(strRef)

    /// Get captured values from funlang.closure operation
    static member GetClosureCapturedValues(op: MlirOperation) : MlirValue list =
        let count = FunLangBindings.mlirFunLangClosureOpGetNumCapturedValues(op)
        [ for i in 0n .. (count - 1n) do
            yield FunLangBindings.mlirFunLangClosureOpGetCapturedValue(op, i) ]
</code></pre>
<p><strong>F# Wrapper 설계 패턴:</strong></p>
<ol>
<li><strong>Low-level bindings</strong>: <code>FunLangBindings</code> 모듈에 extern 선언</li>
<li><strong>High-level wrappers</strong>: <code>FunLangOps</code> 타입에 static member</li>
<li><strong>타입 변환</strong>: F# list ↔ C array, string ↔ MlirStringRef</li>
<li><strong>Resource 관리</strong>: <code>use</code> 키워드로 자동 해제</li>
</ol>
<h3 id="사용-예시-f에서-funlangclosure-생성"><a class="header" href="#사용-예시-f에서-funlangclosure-생성">사용 예시: F#에서 funlang.closure 생성</a></h3>
<p><strong>Before (Phase 4): Low-level LLVM Operations</strong></p>
<pre><code class="language-fsharp">// Phase 4: 12줄의 LLVM dialect 코드
let compileLambda (builder: OpBuilder) (param: string) (body: Expr) (freeVars: (string * MlirValue) list) =
    let context = builder.Context
    let loc = builder.Location

    // 1. 환경 크기 계산
    let fnPtrSize = 8L
    let varSize = 4L
    let totalSize = fnPtrSize + (int64 freeVars.Length) * varSize
    let sizeConst = builder.CreateI64Const(totalSize)

    // 2. GC_malloc 호출
    let envPtr = builder.CreateCall("GC_malloc", [sizeConst])

    // 3. 함수 포인터 저장
    let lambdaName = freshLambdaName()
    let fnAddr = builder.CreateAddressOf(lambdaName)
    let fnSlot = builder.CreateGEP(envPtr, 0)
    builder.CreateStore(fnAddr, fnSlot)

    // 4. 캡처된 변수들 저장
    freeVars |&gt; List.iteri (fun i (name, value) -&gt;
        let slot = builder.CreateGEP(envPtr, i + 1)
        builder.CreateStore(value, slot)
    )

    // 5. 환경 포인터 반환
    envPtr
</code></pre>
<p><strong>After (Phase 5): FunLang Dialect</strong></p>
<pre><code class="language-fsharp">// Phase 5: 1줄!
let compileLambda (builder: OpBuilder) (param: string) (body: Expr) (freeVars: (string * MlirValue) list) =
    let context = builder.Context
    let loc = builder.Location

    // 1. 람다 함수 생성 (lifted function)
    let lambdaName = freshLambdaName()
    createLiftedFunction builder lambdaName param body freeVars

    // 2. 캡처된 변수 값들 추출
    let capturedValues = freeVars |&gt; List.map snd

    // 3. funlang.closure 생성 (1 line!)
    let closureOp = FunLangOps.CreateClosure(context, loc, lambdaName, capturedValues)
    let closureValue = mlirOperationGetResult(closureOp, 0)
    closureValue
</code></pre>
<p><strong>코드 비교:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Phase 4</th><th>Phase 5</th><th>Improvement</th></tr>
</thead>
<tbody>
<tr><td>줄 수</td><td>~20 lines</td><td>~10 lines</td><td>50% 감소</td></tr>
<tr><td>GEP 패턴</td><td>수동 (인덱스 관리)</td><td>없음</td><td>오류 가능성 제거</td></tr>
<tr><td>타입</td><td><code>!llvm.ptr</code></td><td><code>!funlang.closure</code></td><td>타입 안전성 향상</td></tr>
<tr><td>가독성</td><td>저수준 메모리 조작</td><td>고수준 의미 표현</td><td>명확성 향상</td></tr>
</tbody>
</table>
</div>
<h3 id="phase-4-vs-phase-5-코드-비교-완전한-예시"><a class="header" href="#phase-4-vs-phase-5-코드-비교-완전한-예시">Phase 4 vs Phase 5 코드 비교: 완전한 예시</a></h3>
<p><strong>테스트 프로그램:</strong></p>
<pre><code class="language-fsharp">// FunLang source
let make_adder n =
    fun x -&gt; x + n

let add5 = make_adder 5
let result = add5 10
// result = 15
</code></pre>
<p><strong>Phase 4 Generated MLIR (LLVM Dialect):</strong></p>
<pre><code class="language-mlir">module {
  // GC_malloc 선언
  llvm.func @GC_malloc(i64) -&gt; !llvm.ptr

  // lambda_adder lifted function
  func.func @lambda_adder(%env: !llvm.ptr, %x: i32) -&gt; i32 {
    // n 로드 (env[1])
    %c1 = arith.constant 1 : i64
    %n_slot = llvm.getelementptr %env[%c1] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    %n = llvm.load %n_slot : !llvm.ptr -&gt; i32

    // x + n
    %result = arith.addi %x, %n : i32
    func.return %result : i32
  }

  // make_adder 함수
  func.func @make_adder(%n: i32) -&gt; !llvm.ptr {
    // 환경 크기: 8 (fn ptr) + 4 (n) = 12 bytes
    %c12 = arith.constant 12 : i64
    %env = llvm.call @GC_malloc(%c12) : (i64) -&gt; !llvm.ptr

    // 함수 포인터 저장 (env[0])
    %fn_addr = llvm.mlir.addressof @lambda_adder : !llvm.ptr
    %c0 = arith.constant 0 : i64
    %fn_slot = llvm.getelementptr %env[%c0] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    llvm.store %fn_addr, %fn_slot : !llvm.ptr, !llvm.ptr

    // n 저장 (env[1])
    %c1 = arith.constant 1 : i64
    %n_slot = llvm.getelementptr %env[%c1] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    llvm.store %n, %n_slot : i32, !llvm.ptr

    func.return %env : !llvm.ptr
  }

  // main 함수
  func.func @main() -&gt; i32 {
    // add5 = make_adder 5
    %c5 = arith.constant 5 : i32
    %add5 = func.call @make_adder(%c5) : (i32) -&gt; !llvm.ptr

    // result = add5 10 (간접 호출)
    %c10 = arith.constant 10 : i32
    %c0 = arith.constant 0 : i64
    %fn_ptr_addr = llvm.getelementptr %add5[%c0] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    %fn_ptr = llvm.load %fn_ptr_addr : !llvm.ptr -&gt; !llvm.ptr
    %result = llvm.call %fn_ptr(%add5, %c10) : (!llvm.ptr, i32) -&gt; i32

    func.return %result : i32
  }
}
</code></pre>
<p><strong>Phase 5 Generated MLIR (FunLang Dialect):</strong></p>
<pre><code class="language-mlir">module {
  // lambda_adder lifted function (동일)
  func.func @lambda_adder(%env: !llvm.ptr, %x: i32) -&gt; i32 {
    %c1 = arith.constant 1 : i64
    %n_slot = llvm.getelementptr %env[%c1] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    %n = llvm.load %n_slot : !llvm.ptr -&gt; i32
    %result = arith.addi %x, %n : i32
    func.return %result : i32
  }

  // make_adder 함수 (funlang.closure 사용!)
  func.func @make_adder(%n: i32) -&gt; !funlang.closure {
    // 클로저 생성: 1줄!
    %closure = funlang.closure @lambda_adder, %n : !funlang.closure
    func.return %closure : !funlang.closure
  }

  // main 함수 (funlang.apply는 다음 섹션에서)
  func.func @main() -&gt; i32 {
    %c5 = arith.constant 5 : i32
    %add5 = func.call @make_adder(%c5) : (i32) -&gt; !funlang.closure

    // 간접 호출 (Chapter 15 Part 2에서 funlang.apply로 대체)
    %c10 = arith.constant 10 : i32
    // ... (임시로 Phase 4 패턴 유지)

    func.return %result : i32
  }
}
</code></pre>
<p><strong>줄 수 비교 (make_adder 함수만):</strong></p>
<ul>
<li>Phase 4: 12 lines (GC_malloc + store 패턴)</li>
<li>Phase 5: 2 lines (funlang.closure)</li>
<li><strong>Reduction: 83%</strong></li>
</ul>
<hr>
<h2 id="part-2-funlangapply-operation"><a class="header" href="#part-2-funlangapply-operation">Part 2: funlang.apply Operation</a></h2>
<h3 id="phase-4-간접-호출-패턴-분석"><a class="header" href="#phase-4-간접-호출-패턴-분석">Phase 4 간접 호출 패턴 분석</a></h3>
<p>Chapter 13에서 클로저를 호출할 때, 8줄의 LLVM dialect 코드가 필요했다:</p>
<pre><code class="language-mlir">func.func @apply(%f: !llvm.ptr, %x: i32) -&gt; i32 {
    // Step 1: 함수 포인터 추출 (env[0])
    %c0 = arith.constant 0 : i64
    %fn_ptr_addr = llvm.getelementptr %f[%c0] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    %fn_ptr = llvm.load %fn_ptr_addr : !llvm.ptr -&gt; !llvm.ptr

    // Step 2: 간접 호출 (환경 + 인자)
    %result = llvm.call %fn_ptr(%f, %x) : (!llvm.ptr, i32) -&gt; i32

    // Step 3: 결과 반환
    func.return %result : i32
}
</code></pre>
<p><strong>패턴 분석:</strong></p>
<ol>
<li><strong>상수 0 생성</strong>: 함수 포인터 슬롯 인덱스</li>
<li><strong>GEP</strong>: 환경 포인터의 0번 슬롯 주소 계산</li>
<li><strong>Load</strong>: 함수 포인터 로드</li>
<li><strong>간접 호출</strong>: <code>llvm.call %fn_ptr(...)</code>
<ul>
<li>첫 인자: 환경 포인터 (클로저 자체)</li>
<li>나머지 인자: 실제 함수 인자들</li>
</ul>
</li>
<li><strong>타입 시그니처</strong>: 수동 지정 필요</li>
</ol>
<p><strong>문제점:</strong></p>
<ul>
<li><strong>반복 코드</strong>: 모든 클로저 호출마다 동일한 패턴</li>
<li><strong>인덱스 하드코딩</strong>: <code>%c0</code> (함수 포인터는 항상 슬롯 0)</li>
<li><strong>타입 안전성 부족</strong>: 간접 호출 시그니처 수동 관리</li>
<li><strong>환경 전달 실수</strong>: <code>llvm.call %fn_ptr(%x)</code> (환경 누락 버그)</li>
</ul>
<p><strong>해결책: funlang.apply Operation</strong></p>
<pre><code class="language-mlir">// Before: 8 lines
%c0 = arith.constant 0 : i64
%fn_ptr_addr = llvm.getelementptr %f[%c0] : (!llvm.ptr, i64) -&gt; !llvm.ptr
%fn_ptr = llvm.load %fn_ptr_addr : !llvm.ptr -&gt; !llvm.ptr
%result = llvm.call %fn_ptr(%f, %x) : (!llvm.ptr, i32) -&gt; i32

// After: 1 line!
%result = funlang.apply %f(%x) : (i32) -&gt; i32
</code></pre>
<h3 id="tablegen-정의-funlang_applyop"><a class="header" href="#tablegen-정의-funlang_applyop">TableGen 정의: FunLang_ApplyOp</a></h3>
<p><code>FunLangOps.td</code>에 추가:</p>
<pre><code class="language-tablegen">//===----------------------------------------------------------------------===//
// ApplyOp
//===----------------------------------------------------------------------===//

def FunLang_ApplyOp : FunLang_Op&lt;"apply", []&gt; {
  let summary = "Apply a closure to arguments";

  let description = [{
    Applies a closure (function + environment) to arguments via indirect call.

    Syntax:
    ```
    %result = funlang.apply %closure(%arg1, %arg2, ...) : (T1, T2, ...) -&gt; Tresult
    ```

    This operation abstracts the indirect call pattern:
    - Load function pointer from closure (env[0])
    - Call function pointer with environment + args

    Example:
    ```
    // Call closure: %f(10)
    %result = funlang.apply %f(%c10) : (i32) -&gt; i32
    ```

    Lowering to LLVM dialect:
    - %fn_ptr_addr = llvm.getelementptr %closure[0]
    - %fn_ptr = llvm.load %fn_ptr_addr
    - %result = llvm.call %fn_ptr(%closure, %args...)
  }];

  let arguments = (ins
    FunLang_ClosureType:$closure,
    Variadic&lt;AnyType&gt;:$args
  );

  let results = (outs AnyType:$result);

  let assemblyFormat = [{
    $closure `(` $args `)` attr-dict `:` functional-type($args, $result)
  }];

  let builders = [
    OpBuilder&lt;(ins "mlir::Value":$closure,
                   "mlir::ValueRange":$args,
                   "mlir::Type":$resultType), [{
      build($_builder, $_state, resultType, closure, args);
    }]&gt;
  ];
}
</code></pre>
<h3 id="tablegen-상세-설명-1"><a class="header" href="#tablegen-상세-설명-1">TableGen 상세 설명</a></h3>
<h4 id="1-operation-이름과-traits-1"><a class="header" href="#1-operation-이름과-traits-1">1. Operation 이름과 Traits</a></h4>
<pre><code class="language-tablegen">def FunLang_ApplyOp : FunLang_Op&lt;"apply", []&gt; {
</code></pre>
<p><strong>Traits가 비어있는 이유:</strong></p>
<p><code>funlang.apply</code>는 <strong>side-effect가 있다</strong> (간접 호출):</p>
<ul>
<li>호출되는 함수가 무엇을 할지 모름 (메모리 쓰기, I/O 등)</li>
<li>Pure trait 불가</li>
<li>최적화 제한 (CSE 불가, DCE 불가)</li>
</ul>
<p><strong>Alternative: MemoryEffects Trait</strong></p>
<p>Phase 6 이후에는 더 정밀한 trait를 추가할 수 있다:</p>
<pre><code class="language-tablegen">def FunLang_ApplyOp : FunLang_Op&lt;"apply", [
    DeclareOpInterfaceMethods&lt;MemoryEffectsOpInterface&gt;
]&gt; {
  // ...
}
</code></pre>
<p>이를 통해 “메모리 읽기만 한다” 등의 정보를 제공할 수 있다.</p>
<h4 id="2-arguments"><a class="header" href="#2-arguments">2. Arguments</a></h4>
<pre><code class="language-tablegen">let arguments = (ins
  FunLang_ClosureType:$closure,
  Variadic&lt;AnyType&gt;:$args
);
</code></pre>
<p><strong>FunLang_ClosureType:$closure</strong></p>
<ul>
<li><strong>타입</strong>: <code>!funlang.closure</code> (커스텀 타입)</li>
<li><strong>이름</strong>: <code>closure</code></li>
<li><strong>필수</strong>: 단일 값 (variadic 아님)</li>
</ul>
<p><strong>ClosureOp와의 차이:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>ClosureOp</th><th>ApplyOp</th></tr>
</thead>
<tbody>
<tr><td><code>FlatSymbolRefAttr:$callee</code></td><td><code>FunLang_ClosureType:$closure</code></td></tr>
<tr><td>심볼 (함수 이름)</td><td>SSA 값 (클로저)</td></tr>
<tr><td>컴파일 타임 해석</td><td>런타임 값</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-mlir">// ClosureOp: callee는 심볼
%c = funlang.closure @lambda_add, %n : !funlang.closure

// ApplyOp: closure는 SSA 값
%result = funlang.apply %c(%x) : (i32) -&gt; i32
</code></pre>
<p><strong>Variadic<anytype>:$args</anytype></strong></p>
<ul>
<li><strong>가변 길이 인자</strong>: 0개 이상</li>
<li><strong>AnyType</strong>: 타입 제약 없음</li>
</ul>
<pre><code class="language-mlir">// 인자 0개
%result0 = funlang.apply %const_fn() : () -&gt; i32

// 인자 1개
%result1 = funlang.apply %add_n(%x) : (i32) -&gt; i32

// 인자 2개
%result2 = funlang.apply %mul(%x, %y) : (i32, i32) -&gt; i32
</code></pre>
<h4 id="3-results"><a class="header" href="#3-results">3. Results</a></h4>
<pre><code class="language-tablegen">let results = (outs AnyType:$result);
</code></pre>
<p><strong>AnyType을 사용하는 이유:</strong></p>
<p>클로저가 반환하는 타입은 <strong>런타임에 결정</strong>된다:</p>
<pre><code class="language-mlir">// 클로저 A: i32 반환
%r1 = funlang.apply %closure_a(%x) : (i32) -&gt; i32

// 클로저 B: f64 반환
%r2 = funlang.apply %closure_b(%y) : (f64) -&gt; f64

// 클로저 C: 클로저 반환 (HOF)
%r3 = funlang.apply %closure_c(%z) : (i32) -&gt; !funlang.closure
</code></pre>
<p><strong>타입 추론:</strong></p>
<p>Verifier에서 다음을 검증해야 한다:</p>
<ul>
<li>호출 시그니처 (<code>(T1, ...) -&gt; Tresult</code>)</li>
<li>클로저의 실제 타입과 일치하는지</li>
</ul>
<p>Phase 5에서는 단순화를 위해 AnyType을 사용하고, 기본 검증만 수행한다.</p>
<h4 id="4-assembly-format"><a class="header" href="#4-assembly-format">4. Assembly Format</a></h4>
<pre><code class="language-tablegen">let assemblyFormat = [{
  $closure `(` $args `)` attr-dict `:` functional-type($args, $result)
}];
</code></pre>
<p><strong>구문 분석:</strong></p>
<ul>
<li><code>$closure</code>: 클로저 값 (필수)</li>
<li><code>(</code> <code>)</code>: 괄호 (인자 구분)</li>
<li><code>$args</code>: 인자들 (쉼표로 자동 구분, 0개 가능)</li>
<li><code>:</code>: 타입 구분자</li>
<li><code>functional-type($args, $result)</code>: 함수 타입 <code>(T1, ...) -&gt; Tresult</code></li>
</ul>
<p><strong>functional-type이란?</strong></p>
<p>함수 시그니처 표기법:</p>
<pre><code class="language-mlir">// functional-type 예시
(i32) -&gt; i32              // 1 arg, 1 result
(i32, i32) -&gt; i32         // 2 args, 1 result
() -&gt; i32                 // 0 args, 1 result
(i32) -&gt; !funlang.closure // HOF (클로저 반환)
</code></pre>
<p><strong>생성되는 Assembly:</strong></p>
<pre><code class="language-mlir">// 다양한 호출 예시
%r1 = funlang.apply %f() : () -&gt; i32
%r2 = funlang.apply %f(%x) : (i32) -&gt; i32
%r3 = funlang.apply %f(%x, %y) : (i32, i32) -&gt; i32
%r4 = funlang.apply %compose(%f, %g) : (!funlang.closure, !funlang.closure) -&gt; !funlang.closure
</code></pre>
<h4 id="5-builders"><a class="header" href="#5-builders">5. Builders</a></h4>
<pre><code class="language-tablegen">let builders = [
  OpBuilder&lt;(ins "mlir::Value":$closure,
                 "mlir::ValueRange":$args,
                 "mlir::Type":$resultType), [{
    build($_builder, $_state, resultType, closure, args);
  }]&gt;
];
</code></pre>
<p><strong>Builder 파라미터:</strong></p>
<ul>
<li><code>closure</code>: 클로저 SSA 값</li>
<li><code>args</code>: 인자들 (가변 길이)</li>
<li><code>resultType</code>: 결과 타입 (명시적 지정 필요)</li>
</ul>
<p><strong>C++ 사용 예시:</strong></p>
<pre><code class="language-cpp">// C++ code
Value closureVal = /*...*/;
SmallVector&lt;Value&gt; args = {xValue};
Type resultType = builder.getI32Type();

auto applyOp = builder.create&lt;FunLang::ApplyOp&gt;(
    loc, closureVal, args, resultType);
Value result = applyOp.getResult();
</code></pre>
<h3 id="c-api-shim-구현-1"><a class="header" href="#c-api-shim-구현-1">C API Shim 구현</a></h3>
<p><code>FunLangCAPI.h</code>에 추가:</p>
<pre><code class="language-c">//===----------------------------------------------------------------------===//
// ApplyOp
//===----------------------------------------------------------------------===//

/// Create a funlang.apply operation.
///
/// Arguments:
///   ctx: MLIR context
///   loc: Source location
///   closure: Closure value to apply
///   numArgs: Number of arguments
///   args: Array of argument SSA values
///   resultType: Type of the result
///
/// Returns: The created operation (as MlirOperation)
MLIR_CAPI_EXPORTED MlirOperation mlirFunLangApplyOpCreate(
    MlirContext ctx,
    MlirLocation loc,
    MlirValue closure,
    intptr_t numArgs,
    MlirValue *args,
    MlirType resultType);

/// Get the closure value from a funlang.apply operation.
MLIR_CAPI_EXPORTED MlirValue mlirFunLangApplyOpGetClosure(MlirOperation op);

/// Get the number of arguments from a funlang.apply operation.
MLIR_CAPI_EXPORTED intptr_t mlirFunLangApplyOpGetNumArgs(MlirOperation op);

/// Get an argument by index from a funlang.apply operation.
MLIR_CAPI_EXPORTED MlirValue mlirFunLangApplyOpGetArg(
    MlirOperation op, intptr_t index);

/// Get the result type from a funlang.apply operation.
MLIR_CAPI_EXPORTED MlirType mlirFunLangApplyOpGetResultType(MlirOperation op);
</code></pre>
<p><code>FunLangCAPI.cpp</code>에 추가:</p>
<pre><code class="language-cpp">MlirOperation mlirFunLangApplyOpCreate(
    MlirContext ctx,
    MlirLocation loc,
    MlirValue closure,
    intptr_t numArgs,
    MlirValue *args,
    MlirType resultType) {

  MLIRContext *context = unwrap(ctx);
  Location location = unwrap(loc);
  Value closureVal = unwrap(closure);
  Type resType = unwrap(resultType);

  // Build args range
  SmallVector&lt;Value, 4&gt; argVals;
  for (intptr_t i = 0; i &lt; numArgs; ++i) {
    argVals.push_back(unwrap(args[i]));
  }

  // Create operation
  OpBuilder builder(context);
  auto op = builder.create&lt;ApplyOp&gt;(location, closureVal, argVals, resType);

  return wrap(op.getOperation());
}

MlirValue mlirFunLangApplyOpGetClosure(MlirOperation op) {
  auto applyOp = llvm::cast&lt;ApplyOp&gt;(unwrap(op));
  return wrap(applyOp.getClosure());
}

intptr_t mlirFunLangApplyOpGetNumArgs(MlirOperation op) {
  auto applyOp = llvm::cast&lt;ApplyOp&gt;(unwrap(op));
  return applyOp.getArgs().size();
}

MlirValue mlirFunLangApplyOpGetArg(MlirOperation op, intptr_t index) {
  auto applyOp = llvm::cast&lt;ApplyOp&gt;(unwrap(op));
  return wrap(applyOp.getArgs()[index]);
}

MlirType mlirFunLangApplyOpGetResultType(MlirOperation op) {
  auto applyOp = llvm::cast&lt;ApplyOp&gt;(unwrap(op));
  return wrap(applyOp.getResult().getType());
}
</code></pre>
<h3 id="f-pinvoke-바인딩-1-1"><a class="header" href="#f-pinvoke-바인딩-1-1">F# P/Invoke 바인딩</a></h3>
<p><code>FunLangBindings.fs</code>에 추가:</p>
<pre><code class="language-fsharp">module FunLangBindings =
    // (이전 ClosureOp 바인딩...)

    //==========================================================================
    // ApplyOp
    //==========================================================================

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirFunLangApplyOpCreate(
        MlirContext ctx,
        MlirLocation loc,
        MlirValue closure,
        nativeint numArgs,
        MlirValue[] args,
        MlirType resultType)

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirValue mlirFunLangApplyOpGetClosure(MlirOperation op)

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern nativeint mlirFunLangApplyOpGetNumArgs(MlirOperation op)

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirValue mlirFunLangApplyOpGetArg(MlirOperation op, nativeint index)

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirFunLangApplyOpGetResultType(MlirOperation op)

type FunLangOps =
    // (이전 ClosureType, CreateClosure...)

    /// Create funlang.apply operation
    static member CreateApply(
        context: MlirContext,
        location: MlirLocation,
        closure: MlirValue,
        args: MlirValue list,
        resultType: MlirType) : MlirValue =

        // Convert F# list to array
        let argsArray = List.toArray args
        let numArgs = nativeint argsArray.Length

        // Call C API
        let op = FunLangBindings.mlirFunLangApplyOpCreate(
            context, location, closure, numArgs, argsArray, resultType)

        // Extract result SSA value
        mlirOperationGetResult(op, 0)

    /// Get closure from funlang.apply operation
    static member GetApplyClosure(op: MlirOperation) : MlirValue =
        FunLangBindings.mlirFunLangApplyOpGetClosure(op)

    /// Get arguments from funlang.apply operation
    static member GetApplyArgs(op: MlirOperation) : MlirValue list =
        let count = FunLangBindings.mlirFunLangApplyOpGetNumArgs(op)
        [ for i in 0n .. (count - 1n) do
            yield FunLangBindings.mlirFunLangApplyOpGetArg(op, i) ]
</code></pre>
<h3 id="closure--apply-조합-예시"><a class="header" href="#closure--apply-조합-예시">Closure + Apply 조합 예시</a></h3>
<p><strong>완전한 makeAdder 예시:</strong></p>
<pre><code class="language-mlir">module {
  // Lifted function
  func.func @lambda_adder(%env: !llvm.ptr, %x: i32) -&gt; i32 {
    // (환경에서 n 로드 - Phase 5에서도 여전히 저수준)
    %c1 = arith.constant 1 : i64
    %n_slot = llvm.getelementptr %env[%c1] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    %n = llvm.load %n_slot : !llvm.ptr -&gt; i32

    // x + n 계산
    %result = arith.addi %x, %n : i32
    func.return %result : i32
  }

  // make_adder: funlang.closure 사용
  func.func @make_adder(%n: i32) -&gt; !funlang.closure {
    %closure = funlang.closure @lambda_adder, %n : !funlang.closure
    func.return %closure : !funlang.closure
  }

  // apply: funlang.apply 사용
  func.func @apply(%f: !funlang.closure, %x: i32) -&gt; i32 {
    %result = funlang.apply %f(%x) : (i32) -&gt; i32
    func.return %result : i32
  }

  // main: 전체 조합
  func.func @main() -&gt; i32 {
    // add5 = make_adder 5
    %c5 = arith.constant 5 : i32
    %add5 = func.call @make_adder(%c5) : (i32) -&gt; !funlang.closure

    // result = apply add5 10
    %c10 = arith.constant 10 : i32
    %result = func.call @apply(%add5, %c10) : (!funlang.closure, i32) -&gt; i32

    func.return %result : i32
  }
}
</code></pre>
<p><strong>Phase 4 vs Phase 5 비교 (main 함수):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Phase 4</th><th>Phase 5</th></tr>
</thead>
<tbody>
<tr><td>클로저 생성</td><td><code>func.call @make_adder</code> → <code>!llvm.ptr</code></td><td><code>func.call @make_adder</code> → <code>!funlang.closure</code></td></tr>
<tr><td>클로저 호출</td><td>GEP + load + llvm.call (8 lines)</td><td><code>funlang.apply</code> (1 line)</td></tr>
<tr><td>타입</td><td><code>!llvm.ptr</code> (opaque)</td><td><code>!funlang.closure</code> (typed)</td></tr>
</tbody>
</table>
</div>
<p><strong>apply 함수 비교:</strong></p>
<pre><code class="language-mlir">// Phase 4: 8 lines
func.func @apply(%f: !llvm.ptr, %x: i32) -&gt; i32 {
    %c0 = arith.constant 0 : i64
    %fn_ptr_addr = llvm.getelementptr %f[%c0] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    %fn_ptr = llvm.load %fn_ptr_addr : !llvm.ptr -&gt; !llvm.ptr
    %result = llvm.call %fn_ptr(%f, %x) : (!llvm.ptr, i32) -&gt; i32
    func.return %result : i32
}

// Phase 5: 2 lines
func.func @apply(%f: !funlang.closure, %x: i32) -&gt; i32 {
    %result = funlang.apply %f(%x) : (i32) -&gt; i32
    func.return %result : i32
}
</code></pre>
<p><strong>Reduction: 75% (8 lines → 2 lines)</strong></p>
<hr>
<h2 id="part-3-funlangmatch-operation-phase-6-preview"><a class="header" href="#part-3-funlangmatch-operation-phase-6-preview">Part 3: funlang.match Operation (Phase 6 Preview)</a></h2>
<h3 id="패턴-매칭-개념"><a class="header" href="#패턴-매칭-개념">패턴 매칭 개념</a></h3>
<p><strong>Pattern matching</strong>은 함수형 언어의 핵심 기능이다:</p>
<pre><code class="language-fsharp">// FunLang pattern matching (Phase 6)
let rec sum_list lst =
    match lst with
    | [] -&gt; 0
    | head :: tail -&gt; head + sum_list tail
</code></pre>
<p><strong>두 가지 구성 요소:</strong></p>
<ol>
<li><strong>Scrutinee</strong>: 패턴을 검사할 값 (<code>lst</code>)</li>
<li><strong>Cases</strong>: 각 패턴과 해당 동작
<ul>
<li><code>[]</code>: nil case (빈 리스트)</li>
<li><code>head :: tail</code>: cons case (head와 tail로 분해)</li>
</ul>
</li>
</ol>
<h3 id="why-region-based-operation"><a class="header" href="#why-region-based-operation">Why Region-Based Operation?</a></h3>
<p><strong>나쁜 설계: Block-based (scf.if 스타일)</strong></p>
<pre><code class="language-mlir">// 가상의 잘못된 설계
%result = funlang.match %list
    then ^nil_block
    else ^cons_block

^nil_block:
    %zero = arith.constant 0 : i32
    br ^merge_block(%zero : i32)

^cons_block:
    // ... head/tail 분해 ...
    br ^merge_block(%sum : i32)

^merge_block(%result: i32):
    func.return %result : i32
</code></pre>
<p><strong>문제점:</strong></p>
<ul>
<li><strong>블록들이 함수 레벨</strong>: 다른 operation과 섞임</li>
<li><strong>결과 타입 검증 어려움</strong>: 각 블록이 독립적</li>
<li><strong>가독성 저하</strong>: 패턴과 동작이 분리됨</li>
</ul>
<p><strong>좋은 설계: Region-based</strong></p>
<pre><code class="language-mlir">%result = funlang.match %list : !funlang.list&lt;i32&gt; -&gt; i32 {
  ^nil:
    %zero = arith.constant 0 : i32
    funlang.yield %zero : i32
  ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
    %sum_tail = /* recursive call */
    %sum = arith.addi %head, %sum_tail : i32
    funlang.yield %sum : i32
}
</code></pre>
<p><strong>장점:</strong></p>
<ul>
<li><strong>각 case가 별도 region</strong>: operation 내부에 encapsulated</li>
<li><strong>Block arguments</strong>: 패턴 변수를 직접 표현 (head, tail)</li>
<li><strong>Unified terminator</strong>: 모든 case가 <code>funlang.yield</code>로 종료</li>
<li><strong>타입 검증 간단</strong>: 모든 yield가 같은 타입 반환해야 함</li>
</ul>
<h3 id="tablegen-정의-funlang_matchop"><a class="header" href="#tablegen-정의-funlang_matchop">TableGen 정의: FunLang_MatchOp</a></h3>
<pre><code class="language-tablegen">//===----------------------------------------------------------------------===//
// MatchOp
//===----------------------------------------------------------------------===//

def FunLang_MatchOp : FunLang_Op&lt;"match", [
    RecursiveSideEffects,
    SingleBlockImplicitTerminator&lt;"YieldOp"&gt;
]&gt; {
  let summary = "Pattern matching expression";

  let description = [{
    Pattern matches on a value (scrutinee) with multiple cases.
    Each case is a separate region with optional block arguments.

    Syntax:
    ```
    %result = funlang.match %scrutinee : Tin -&gt; Tout {
      ^case1:
        funlang.yield %val1 : Tout
      ^case2(%arg: T):
        funlang.yield %val2 : Tout
    }
    ```

    Example (list pattern matching):
    ```
    %sum = funlang.match %list : !funlang.list&lt;i32&gt; -&gt; i32 {
      ^nil:
        %zero = arith.constant 0 : i32
        funlang.yield %zero : i32
      ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
        // ... compute sum ...
        funlang.yield %sum : i32
    }
    ```

    Constraints:
    - Each region must have exactly one block
    - Each region must end with funlang.yield
    - All yields must have the same result type

    Lowering (Phase 6):
    - Scrutinee tag check
    - Branch to corresponding case
    - Extract pattern variables (block arguments)
    - Execute case body
  }];

  let arguments = (ins AnyType:$scrutinee);
  let results = (outs AnyType:$result);
  let regions = (region VariadicRegion&lt;SizedRegion&lt;1&gt;&gt;:$cases);

  let hasVerifier = 1;
  let hasCustomAssemblyFormat = 1;
}
</code></pre>
<h3 id="region-based-operation-설명"><a class="header" href="#region-based-operation-설명">Region-Based Operation 설명</a></h3>
<h4 id="1-traits"><a class="header" href="#1-traits">1. Traits</a></h4>
<pre><code class="language-tablegen">def FunLang_MatchOp : FunLang_Op&lt;"match", [
    RecursiveSideEffects,
    SingleBlockImplicitTerminator&lt;"YieldOp"&gt;
]&gt; {
</code></pre>
<p><strong>RecursiveSideEffects:</strong></p>
<ul>
<li>Match operation의 side effect는 <strong>각 case에 의존</strong>한다</li>
<li>Case body가 Pure면 match도 Pure</li>
<li>Case body가 side effect 있으면 match도 side effect 있음</li>
</ul>
<pre><code class="language-mlir">// Pure match
%result = funlang.match %x : i32 -&gt; i32 {
  ^case1:
    %c1 = arith.constant 1 : i32
    funlang.yield %c1 : i32  // Pure
  ^case2:
    %c2 = arith.constant 2 : i32
    funlang.yield %c2 : i32  // Pure
}
// 전체 match가 Pure

// Side effect match
%result = funlang.match %x : i32 -&gt; i32 {
  ^case1:
    func.call @print(%c1) : (i32) -&gt; ()  // Side effect!
    funlang.yield %c1 : i32
  ^case2:
    funlang.yield %c2 : i32
}
// 전체 match가 side effect 있음
</code></pre>
<p><strong>SingleBlockImplicitTerminator&lt;“YieldOp”&gt;:</strong></p>
<ul>
<li>각 region이 <strong>정확히 하나의 block</strong>을 가짐</li>
<li>각 block이 <strong>YieldOp로 종료</strong>됨 (implicit terminator)</li>
<li>Parser가 자동으로 검증</li>
</ul>
<pre><code class="language-mlir">// 올바른 match
%r = funlang.match %x : i32 -&gt; i32 {
  ^case1:
    %val = arith.constant 42 : i32
    funlang.yield %val : i32  // OK: YieldOp terminator
}

// 잘못된 match
%r = funlang.match %x : i32 -&gt; i32 {
  ^case1:
    %val = arith.constant 42 : i32
    func.return %val : i32  // ERROR: Wrong terminator
}
</code></pre>
<h4 id="2-regions"><a class="header" href="#2-regions">2. Regions</a></h4>
<pre><code class="language-tablegen">let regions = (region VariadicRegion&lt;SizedRegion&lt;1&gt;&gt;:$cases);
</code></pre>
<p><strong>VariadicRegion:</strong></p>
<ul>
<li>가변 개수의 region (case 개수에 따라)</li>
<li>최소 1개 이상</li>
</ul>
<p><strong>SizedRegion&lt;1&gt;:</strong></p>
<ul>
<li>각 region이 정확히 <strong>1개의 block</strong>을 가짐</li>
<li>다중 block 불가 (control flow는 block 내에서만)</li>
</ul>
<pre><code class="language-mlir">// 2개 case
%r = funlang.match %x : i32 -&gt; i32 {
  ^case1: funlang.yield %c1 : i32
  ^case2: funlang.yield %c2 : i32
}

// 3개 case
%r = funlang.match %x : i32 -&gt; i32 {
  ^case1: funlang.yield %c1 : i32
  ^case2: funlang.yield %c2 : i32
  ^case3: funlang.yield %c3 : i32
}
</code></pre>
<p><strong>Region vs Block:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concept</th><th>Definition</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td>Region</td><td>Operation의 내부 범위</td><td>scf.if의 then/else</td></tr>
<tr><td>Block</td><td>Region 내의 명령 시퀀스</td><td>기본 블록 (CFG 노드)</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-mlir">// scf.if: 2 regions, 각 region은 1+ blocks
scf.if %cond {
  // Then region
  %val = arith.constant 1 : i32
  scf.yield %val : i32
} else {
  // Else region
  %val = arith.constant 2 : i32
  scf.yield %val : i32
}

// funlang.match: N regions, 각 region은 정확히 1 block
funlang.match %x : i32 -&gt; i32 {
  // Case 1 region (1 block)
  ^case1:
    funlang.yield %c1 : i32
  // Case 2 region (1 block)
  ^case2:
    funlang.yield %c2 : i32
}
</code></pre>
<h4 id="3-각-case가-별도-region인-이유"><a class="header" href="#3-각-case가-별도-region인-이유">3. 각 Case가 별도 Region인 이유</a></h4>
<p><strong>이유 1: 독립적인 스코프</strong></p>
<p>각 case는 독립적인 변수 바인딩을 가진다:</p>
<pre><code class="language-mlir">%result = funlang.match %list : !funlang.list&lt;i32&gt; -&gt; i32 {
  ^nil:
    // 이 region에는 변수 없음
    %zero = arith.constant 0 : i32
    funlang.yield %zero : i32

  ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
    // 이 region에는 head, tail 변수 있음
    // %head, %tail은 block arguments
    funlang.yield %head : i32
}
</code></pre>
<p><strong>이유 2: 타입 안전성</strong></p>
<p>모든 case의 yield 타입을 검증할 수 있다:</p>
<pre><code class="language-mlir">// 올바른 match (모든 yield가 i32)
%r = funlang.match %x : i32 -&gt; i32 {
  ^case1: funlang.yield %c1 : i32  // OK
  ^case2: funlang.yield %c2 : i32  // OK
}

// 잘못된 match (타입 불일치)
%r = funlang.match %x : i32 -&gt; i32 {
  ^case1: funlang.yield %c1 : i32       // OK
  ^case2: funlang.yield %f : f64        // ERROR: Type mismatch
}
</code></pre>
<p><strong>이유 3: Lowering 간소화</strong></p>
<p>각 region을 독립적인 블록으로 lowering:</p>
<pre><code class="language-mlir">// Before lowering
%r = funlang.match %list : !funlang.list&lt;i32&gt; -&gt; i32 {
  ^nil: funlang.yield %zero : i32
  ^cons(%h, %t): funlang.yield %h : i32
}

// After lowering (pseudo-code)
%tag = funlang.list_tag %list : i32  // 0 = nil, 1 = cons
cf.switch %tag [
  case 0: ^nil_block
  case 1: ^cons_block
]

^nil_block:
  %zero = arith.constant 0 : i32
  cf.br ^merge(%zero : i32)

^cons_block:
  %h = funlang.list_head %list : i32
  %t = funlang.list_tail %list : !funlang.list&lt;i32&gt;
  cf.br ^merge(%h : i32)

^merge(%result: i32):
  // ...
</code></pre>
<h4 id="4-verifier-필요성"><a class="header" href="#4-verifier-필요성">4. Verifier 필요성</a></h4>
<pre><code class="language-tablegen">let hasVerifier = 1;
</code></pre>
<p>TableGen 기본 검증만으로는 부족하다. 추가 검증 필요:</p>
<p><strong>검증 사항:</strong></p>
<ol>
<li><strong>모든 yield 타입 일치</strong>: 각 case의 yield 타입 == match 결과 타입</li>
<li><strong>Case 개수 검증</strong>: 최소 1개 이상</li>
<li><strong>Block arguments 타입 검증</strong>: Pattern 변수 타입이 valid한지</li>
<li><strong>Terminator 검증</strong>: 모든 block이 YieldOp로 종료</li>
</ol>
<p><strong>C++ Verifier 구현 (Phase 6):</strong></p>
<pre><code class="language-cpp">LogicalResult MatchOp::verify() {
  auto resultType = getResult().getType();

  // Check all cases
  for (auto &amp;region : getCases()) {
    Block &amp;block = region.front();

    // Check terminator
    auto yieldOp = dyn_cast&lt;YieldOp&gt;(block.getTerminator());
    if (!yieldOp)
      return emitOpError("case must end with funlang.yield");

    // Check yield type
    auto yieldType = yieldOp.getValue().getType();
    if (yieldType != resultType)
      return emitOpError("yield type mismatch: expected ")
             &lt;&lt; resultType &lt;&lt; ", got " &lt;&lt; yieldType;
  }

  return success();
}
</code></pre>
<h3 id="c-api-shim-구현-패턴-region-생성-포함"><a class="header" href="#c-api-shim-구현-패턴-region-생성-포함">C API Shim 구현 패턴 (Region 생성 포함)</a></h3>
<p><strong>Region-based operation의 C API는 복잡하다.</strong> Phase 6에서 완전 구현하지만, 패턴을 미리 소개한다.</p>
<p><strong>FunLangCAPI.h (Preview):</strong></p>
<pre><code class="language-c">//===----------------------------------------------------------------------===//
// MatchOp (Phase 6 Preview)
//===----------------------------------------------------------------------===//

/// Create a funlang.match operation.
///
/// Arguments:
///   ctx: MLIR context
///   loc: Source location
///   scrutinee: Value to pattern match on
///   numCases: Number of cases
///   resultType: Type of the result
///
/// Returns: The created operation (caller must build case regions)
MLIR_CAPI_EXPORTED MlirOperation mlirFunLangMatchOpCreate(
    MlirContext ctx,
    MlirLocation loc,
    MlirValue scrutinee,
    intptr_t numCases,
    MlirType resultType);

/// Get a case region by index from a funlang.match operation.
MLIR_CAPI_EXPORTED MlirRegion mlirFunLangMatchOpGetCaseRegion(
    MlirOperation op, intptr_t index);

/// Create a block in a region with block arguments.
MLIR_CAPI_EXPORTED MlirBlock mlirRegionAppendBlockWithArgs(
    MlirRegion region,
    intptr_t numArgs,
    MlirType *argTypes);

/// Create a funlang.yield operation.
MLIR_CAPI_EXPORTED MlirOperation mlirFunLangYieldOpCreate(
    MlirContext ctx,
    MlirLocation loc,
    MlirValue value);
</code></pre>
<p><strong>사용 패턴 (F# pseudo-code):</strong></p>
<pre><code class="language-fsharp">// 1. MatchOp 생성 (빈 regions)
let matchOp = FunLangBindings.mlirFunLangMatchOpCreate(
    context, loc, scrutinee, 2, resultType)

// 2. 각 case region 가져오기
let nilRegion = FunLangBindings.mlirFunLangMatchOpGetCaseRegion(matchOp, 0)
let consRegion = FunLangBindings.mlirFunLangMatchOpGetCaseRegion(matchOp, 1)

// 3. Nil case 구축
let nilBlock = FunLangBindings.mlirRegionAppendBlockWithArgs(
    nilRegion, 0, [||])  // No block arguments
builder.SetInsertionPointToEnd(nilBlock)
let zero = builder.CreateI32Const(0)
FunLangBindings.mlirFunLangYieldOpCreate(context, loc, zero)

// 4. Cons case 구축
let consBlock = FunLangBindings.mlirRegionAppendBlockWithArgs(
    consRegion, 2, [| i32Type; listType |])  // head, tail
builder.SetInsertionPointToEnd(consBlock)
let head = mlirBlockGetArgument(consBlock, 0)
let tail = mlirBlockGetArgument(consBlock, 1)
// ... compute with head, tail ...
FunLangBindings.mlirFunLangYieldOpCreate(context, loc, result)
</code></pre>
<p><strong>Phase 6에서 완전 구현한다.</strong> Phase 5에서는 MatchOp 정의만 포함한다.</p>
<h3 id="phase-6에서의-사용-예시"><a class="header" href="#phase-6에서의-사용-예시">Phase 6에서의 사용 예시</a></h3>
<p><strong>FunLang source:</strong></p>
<pre><code class="language-fsharp">// Phase 6: List pattern matching
let rec length lst =
    match lst with
    | [] -&gt; 0
    | head :: tail -&gt; 1 + length tail

let test = length [1; 2; 3]
// test = 3
</code></pre>
<p><strong>Generated MLIR (Phase 6):</strong></p>
<pre><code class="language-mlir">module {
  // length 함수
  func.func @length(%lst: !funlang.list&lt;i32&gt;) -&gt; i32 {
    %result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
      // Nil case
      ^nil:
        %zero = arith.constant 0 : i32
        funlang.yield %zero : i32

      // Cons case
      ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
        // 1 + length tail
        %one = arith.constant 1 : i32
        %tail_length = func.call @length(%tail) : (!funlang.list&lt;i32&gt;) -&gt; i32
        %result = arith.addi %one, %tail_length : i32
        funlang.yield %result : i32
    }
    func.return %result : i32
  }

  // test = length [1, 2, 3]
  func.func @test() -&gt; i32 {
    // Build list [1, 2, 3]
    %nil = funlang.nil : !funlang.list&lt;i32&gt;
    %c3 = arith.constant 3 : i32
    %lst1 = funlang.cons %c3, %nil : !funlang.list&lt;i32&gt;
    %c2 = arith.constant 2 : i32
    %lst2 = funlang.cons %c2, %lst1 : !funlang.list&lt;i32&gt;
    %c1 = arith.constant 1 : i32
    %lst3 = funlang.cons %c1, %lst2 : !funlang.list&lt;i32&gt;

    // Call length
    %len = func.call @length(%lst3) : (!funlang.list&lt;i32&gt;) -&gt; i32
    func.return %len : i32
  }
}
</code></pre>
<p><strong>Chapter 15에서는 MatchOp의 정의와 구조만 다룬다. 실제 구현과 사용은 Chapter 17 (Phase 6)에서 완성한다.</strong></p>
<hr>
<h2 id="part-4-funlang-custom-types"><a class="header" href="#part-4-funlang-custom-types">Part 4: FunLang Custom Types</a></h2>
<h3 id="funlang_closuretype-상세"><a class="header" href="#funlang_closuretype-상세">FunLang_ClosureType 상세</a></h3>
<p>Chapter 15 Part 1에서 <code>!funlang.closure</code> 타입을 간단히 소개했다. 이제 상세히 다룬다.</p>
<p><strong>FunLangTypes.td:</strong></p>
<pre><code class="language-tablegen">//===- FunLangTypes.td - FunLang dialect types ------------*- tablegen -*-===//

#ifndef FUNLANG_TYPES
#define FUNLANG_TYPES

include "mlir/IR/AttrTypeBase.td"
include "FunLangDialect.td"

//===----------------------------------------------------------------------===//
// FunLang Type Definitions
//===----------------------------------------------------------------------===//

class FunLang_Type&lt;string name, string typeMnemonic&gt;
    : TypeDef&lt;FunLang_Dialect, name&gt; {
  let mnemonic = typeMnemonic;
}

//===----------------------------------------------------------------------===//
// ClosureType
//===----------------------------------------------------------------------===//

def FunLang_ClosureType : FunLang_Type&lt;"Closure", "closure"&gt; {
  let summary = "FunLang closure type";

  let description = [{
    Represents a closure value: a combination of function pointer and
    captured environment.

    Syntax: `!funlang.closure`

    This is an opaque type (no type parameters). The internal representation
    is hidden from the FunLang dialect level.

    Lowering:
    - FunLang dialect: !funlang.closure
    - LLVM dialect: !llvm.ptr

    The lowering pass converts !funlang.closure to !llvm.ptr, exposing the
    internal representation (function pointer + environment data).
  }];

  let extraClassDeclaration = [{
    // No extra methods needed for opaque type
  }];
}

#endif // FUNLANG_TYPES
</code></pre>
<h3 id="opaque-type-vs-parameterized-type"><a class="header" href="#opaque-type-vs-parameterized-type">Opaque Type vs Parameterized Type</a></h3>
<p><strong>Opaque Type (Phase 5 선택):</strong></p>
<pre><code class="language-tablegen">def FunLang_ClosureType : FunLang_Type&lt;"Closure", "closure"&gt; {
  // No parameters
}
</code></pre>
<p><strong>MLIR Assembly:</strong></p>
<pre><code class="language-mlir">%closure = funlang.closure @lambda_add, %n : !funlang.closure
// 타입 파라미터 없음
</code></pre>
<p><strong>장점:</strong></p>
<ul>
<li><strong>단순성</strong>: 정의와 사용이 간단</li>
<li><strong>구현 숨김</strong>: 내부 표현을 dialect 레벨에서 감춤</li>
<li><strong>Lowering 유연성</strong>: 표현 방식을 나중에 변경 가능</li>
</ul>
<p><strong>단점:</strong></p>
<ul>
<li><strong>타입 정보 부족</strong>: 함수 시그니처를 타입에서 알 수 없음</li>
<li><strong>검증 제한</strong>: 타입 레벨에서 인자/결과 타입 검증 불가</li>
</ul>
<p><strong>Parameterized Type (Alternative):</strong></p>
<pre><code class="language-tablegen">def FunLang_ClosureType : FunLang_Type&lt;"Closure", "closure"&gt; {
  let parameters = (ins "FunctionType":$funcType);
  let assemblyFormat = "`&lt;` $funcType `&gt;`";
}
</code></pre>
<p><strong>MLIR Assembly:</strong></p>
<pre><code class="language-mlir">// 파라미터화된 타입
%closure = funlang.closure @lambda_add, %n : !funlang.closure&lt;(i32) -&gt; i32&gt;
//                                          함수 시그니처 ^^^^^^^^^^^
</code></pre>
<p><strong>장점:</strong></p>
<ul>
<li><strong>타입 안전성 향상</strong>: 함수 시그니처가 타입에 포함됨</li>
<li><strong>검증 가능</strong>: apply operation에서 인자 타입 검증 가능</li>
<li><strong>문서화</strong>: 타입만 봐도 클로저 시그니처 알 수 있음</li>
</ul>
<p><strong>단점:</strong></p>
<ul>
<li><strong>복잡성 증가</strong>: 타입 파라미터 관리 필요</li>
<li><strong>Lowering 복잡도</strong>: 타입 변환 시 파라미터 제거 필요</li>
</ul>
<p><strong>Phase 5 설계 결정:</strong></p>
<p>Opaque type을 사용한다:</p>
<ol>
<li><strong>단순성 우선</strong>: Phase 5는 dialect 도입이 목표</li>
<li><strong>Phase 6 고려</strong>: 리스트 타입은 parameterized (필수)</li>
<li><strong>점진적 복잡도</strong>: 나중에 파라미터 추가 가능</li>
</ol>
<h3 id="funlang_listtype-phase-6-preview"><a class="header" href="#funlang_listtype-phase-6-preview">FunLang_ListType (Phase 6 Preview)</a></h3>
<p>Phase 6에서는 리스트를 위한 <strong>parameterized type</strong>이 필요하다:</p>
<pre><code class="language-tablegen">//===----------------------------------------------------------------------===//
// ListType (Phase 6)
//===----------------------------------------------------------------------===//

def FunLang_ListType : FunLang_Type&lt;"List", "list"&gt; {
  let summary = "FunLang immutable list type";

  let description = [{
    Represents an immutable linked list.

    Syntax: `!funlang.list&lt;T&gt;`

    Type parameter:
    - T: Element type (any MLIR type)

    Examples:
    - !funlang.list&lt;i32&gt;: List of integers
    - !funlang.list&lt;f64&gt;: List of floats
    - !funlang.list&lt;!funlang.closure&gt;: List of closures

    Lowering:
    - FunLang dialect: !funlang.list&lt;T&gt;
    - LLVM dialect: !llvm.ptr (cons cell pointer)

    Internal representation (after lowering):
    - Nil: nullptr
    - Cons: struct { T head; !llvm.ptr tail }
  }];

  let parameters = (ins "Type":$elementType);
  let assemblyFormat = "`&lt;` $elementType `&gt;`";

  let extraClassDeclaration = [{
    // Get element type
    Type getElementType() { return getImpl()-&gt;elementType; }
  }];
}
</code></pre>
<p><strong>Parameterized Type의 필요성:</strong></p>
<p>리스트는 <strong>다양한 원소 타입</strong>을 지원해야 한다:</p>
<pre><code class="language-mlir">// 정수 리스트
%int_list = funlang.nil : !funlang.list&lt;i32&gt;
%int_list2 = funlang.cons %x, %int_list : !funlang.list&lt;i32&gt;

// 클로저 리스트
%closure_list = funlang.nil : !funlang.list&lt;!funlang.closure&gt;
%closure_list2 = funlang.cons %f, %closure_list : !funlang.list&lt;!funlang.closure&gt;
</code></pre>
<p>타입 파라미터 없이는 <strong>타입 안전성</strong>을 보장할 수 없다:</p>
<pre><code class="language-mlir">// 잘못된 설계 (opaque list type)
%list = funlang.nil : !funlang.list  // 어떤 타입의 리스트?
%list2 = funlang.cons %x, %list : !funlang.list  // i32? f64?

// 타입 체커가 다음을 검증할 수 없음:
// - cons의 head 타입이 list의 원소 타입과 일치하는지
// - match에서 추출한 head의 타입이 무엇인지
</code></pre>
<h3 id="타입의-llvm-lowering"><a class="header" href="#타입의-llvm-lowering">타입의 LLVM Lowering</a></h3>
<p>Progressive lowering에서 타입도 변환된다:</p>
<p><strong>FunLang Dialect → LLVM Dialect:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>FunLang Type</th><th>LLVM Type</th><th>Internal Representation</th></tr>
</thead>
<tbody>
<tr><td><code>!funlang.closure</code></td><td><code>!llvm.ptr</code></td><td><code>struct { fn_ptr, var1, var2, ... }</code></td></tr>
<tr><td><code>!funlang.list&lt;T&gt;</code></td><td><code>!llvm.ptr</code></td><td><code>struct { T head; ptr tail }</code> or <code>nullptr</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Lowering Pass (Phase 6):</strong></p>
<pre><code class="language-cpp">// FunLangToLLVM type converter
class FunLangTypeConverter : public TypeConverter {
public:
  FunLangTypeConverter() {
    // !funlang.closure -&gt; !llvm.ptr
    addConversion([](FunLangClosureType type) {
      return LLVM::LLVMPointerType::get(type.getContext());
    });

    // !funlang.list&lt;T&gt; -&gt; !llvm.ptr
    addConversion([](FunLangListType type) {
      return LLVM::LLVMPointerType::get(type.getContext());
    });

    // Pass through other types (i32, f64, etc.)
    addConversion([](Type type) { return type; });
  }
};
</code></pre>
<p><strong>Lowering 예시:</strong></p>
<pre><code class="language-mlir">// Before lowering (FunLang dialect)
func.func @make_adder(%n: i32) -&gt; !funlang.closure {
  %closure = funlang.closure @lambda_add, %n : !funlang.closure
  func.return %closure : !funlang.closure
}

// After lowering (LLVM dialect)
func.func @make_adder(%n: i32) -&gt; !llvm.ptr {
  %env_size = arith.constant 16 : i64
  %env = llvm.call @GC_malloc(%env_size) : (i64) -&gt; !llvm.ptr
  %fn_addr = llvm.mlir.addressof @lambda_add : !llvm.ptr
  %fn_slot = llvm.getelementptr %env[0] : (!llvm.ptr) -&gt; !llvm.ptr
  llvm.store %fn_addr, %fn_slot : !llvm.ptr, !llvm.ptr
  %n_slot = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
  llvm.store %n, %n_slot : i32, !llvm.ptr
  func.return %env : !llvm.ptr
}
</code></pre>
<p><strong>타입 변환과 operation 변환의 관계:</strong></p>
<ul>
<li><strong>Operation 변환</strong>: <code>funlang.closure</code> → <code>GC_malloc + store</code> 패턴</li>
<li><strong>Type 변환</strong>: <code>!funlang.closure</code> → <code>!llvm.ptr</code></li>
<li><strong>동시 적용</strong>: Lowering pass가 두 변환을 함께 수행</li>
</ul>
<h3 id="c-type-클래스-generated"><a class="header" href="#c-type-클래스-generated">C++ Type 클래스 (Generated)</a></h3>
<p>TableGen이 생성하는 C++ 코드:</p>
<p><strong>Generated: FunLangTypes.h.inc</strong></p>
<pre><code class="language-cpp">namespace mlir {
namespace funlang {

class FunLangClosureType : public Type::TypeBase&lt;
    FunLangClosureType,
    Type,
    detail::FunLangClosureTypeStorage&gt; {
public:
  using Base::Base;

  static FunLangClosureType get(MLIRContext *context);

  static constexpr StringLiteral name = "funlang.closure";
};

class FunLangListType : public Type::TypeBase&lt;
    FunLangListType,
    Type,
    detail::FunLangListTypeStorage,
    TypeTrait::HasTypeParameter&gt; {
public:
  using Base::Base;

  static FunLangListType get(Type elementType);

  Type getElementType() const;

  static constexpr StringLiteral name = "funlang.list";
};

} // namespace funlang
} // namespace mlir
</code></pre>
<p><strong>사용 예시 (C++):</strong></p>
<pre><code class="language-cpp">MLIRContext *context = /*...*/;

// Create !funlang.closure type
auto closureType = FunLangClosureType::get(context);

// Create !funlang.list&lt;i32&gt; type
auto i32Type = IntegerType::get(context, 32);
auto listType = FunLangListType::get(i32Type);

// Get element type
Type elemType = listType.getElementType();
// elemType == i32Type
</code></pre>
<hr>
<h2 id="part-5-complete-f-integration-module"><a class="header" href="#part-5-complete-f-integration-module">Part 5: Complete F# Integration Module</a></h2>
<p>이제 모든 요소를 통합해 <strong>완전한 F# 래퍼</strong>를 작성한다.</p>
<h3 id="mlirfunlangfs-모듈-전체-구조"><a class="header" href="#mlirfunlangfs-모듈-전체-구조">Mlir.FunLang.fs 모듈 전체 구조</a></h3>
<pre><code class="language-fsharp">namespace Mlir.FunLang

open System
open System.Runtime.InteropServices
open Mlir.Core

//==============================================================================
// Low-level P/Invoke Bindings
//==============================================================================

module FunLangBindings =

    //==========================================================================
    // Types
    //==========================================================================

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirFunLangClosureTypeGet(MlirContext ctx)

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern bool mlirTypeIsAFunLangClosureType(MlirType ty)

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirFunLangListTypeGet(MlirContext ctx, MlirType elementType)

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern bool mlirTypeIsAFunLangListType(MlirType ty)

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirFunLangListTypeGetElementType(MlirType ty)

    //==========================================================================
    // Operations - ClosureOp
    //==========================================================================

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirFunLangClosureOpCreate(
        MlirContext ctx,
        MlirLocation loc,
        MlirAttribute callee,
        nativeint numCaptured,
        MlirValue[] capturedValues)

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirAttribute mlirFunLangClosureOpGetCallee(MlirOperation op)

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern nativeint mlirFunLangClosureOpGetNumCapturedValues(MlirOperation op)

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirValue mlirFunLangClosureOpGetCapturedValue(
        MlirOperation op,
        nativeint index)

    //==========================================================================
    // Operations - ApplyOp
    //==========================================================================

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirFunLangApplyOpCreate(
        MlirContext ctx,
        MlirLocation loc,
        MlirValue closure,
        nativeint numArgs,
        MlirValue[] args,
        MlirType resultType)

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirValue mlirFunLangApplyOpGetClosure(MlirOperation op)

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern nativeint mlirFunLangApplyOpGetNumArgs(MlirOperation op)

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirValue mlirFunLangApplyOpGetArg(MlirOperation op, nativeint index)

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirFunLangApplyOpGetResultType(MlirOperation op)

//==============================================================================
// High-level F# Wrappers
//==============================================================================

/// FunLang dialect operations wrapper
type FunLangDialect(context: MlirContext) =

    /// MLIR context
    member val Context = context

    //==========================================================================
    // Type Creation
    //==========================================================================

    /// Create !funlang.closure type
    member this.ClosureType() : MlirType =
        FunLangBindings.mlirFunLangClosureTypeGet(this.Context)

    /// Check if type is !funlang.closure
    member this.IsClosureType(ty: MlirType) : bool =
        FunLangBindings.mlirTypeIsAFunLangClosureType(ty)

    /// Create !funlang.list&lt;T&gt; type
    member this.ListType(elementType: MlirType) : MlirType =
        FunLangBindings.mlirFunLangListTypeGet(this.Context, elementType)

    /// Check if type is !funlang.list
    member this.IsListType(ty: MlirType) : bool =
        FunLangBindings.mlirTypeIsAFunLangListType(ty)

    /// Get element type from !funlang.list&lt;T&gt;
    member this.ListElementType(ty: MlirType) : MlirType =
        if not (this.IsListType(ty)) then
            invalidArg "ty" "Expected !funlang.list type"
        FunLangBindings.mlirFunLangListTypeGetElementType(ty)

    //==========================================================================
    // Operation Creation
    //==========================================================================

    /// Create funlang.closure operation
    ///
    /// Returns the operation (caller extracts result value via getResult(0))
    member this.CreateClosureOp(
        location: MlirLocation,
        callee: string,
        capturedValues: MlirValue list) : MlirOperation =

        // Convert function name to FlatSymbolRefAttr
        use calleeStrRef = MlirStringRef.FromString(callee)
        let calleeAttr = mlirFlatSymbolRefAttrGet(this.Context, calleeStrRef)

        // Convert F# list to array
        let capturedArray = List.toArray capturedValues
        let numCaptured = nativeint capturedArray.Length

        // Call C API
        FunLangBindings.mlirFunLangClosureOpCreate(
            this.Context, location, calleeAttr, numCaptured, capturedArray)

    /// Create funlang.closure operation and return result value
    member this.CreateClosure(
        location: MlirLocation,
        callee: string,
        capturedValues: MlirValue list) : MlirValue =

        let op = this.CreateClosureOp(location, callee, capturedValues)
        mlirOperationGetResult(op, 0)

    /// Create funlang.apply operation
    ///
    /// Returns the operation (caller extracts result value via getResult(0))
    member this.CreateApplyOp(
        location: MlirLocation,
        closure: MlirValue,
        args: MlirValue list,
        resultType: MlirType) : MlirOperation =

        // Convert F# list to array
        let argsArray = List.toArray args
        let numArgs = nativeint argsArray.Length

        // Call C API
        FunLangBindings.mlirFunLangApplyOpCreate(
            this.Context, location, closure, numArgs, argsArray, resultType)

    /// Create funlang.apply operation and return result value
    member this.CreateApply(
        location: MlirLocation,
        closure: MlirValue,
        args: MlirValue list,
        resultType: MlirType) : MlirValue =

        let op = this.CreateApplyOp(location, closure, args, resultType)
        mlirOperationGetResult(op, 0)

//==============================================================================
// OpBuilder Extension Methods
//==============================================================================

/// Extension methods for OpBuilder to work with FunLang dialect
[&lt;AutoOpen&gt;]
module OpBuilderExtensions =

    type OpBuilder with

        /// Create funlang.closure operation
        member this.CreateFunLangClosure(
            callee: string,
            capturedValues: MlirValue list) : MlirValue =

            let funlang = FunLangDialect(this.Context)
            funlang.CreateClosure(this.Location, callee, capturedValues)

        /// Create funlang.apply operation
        member this.CreateFunLangApply(
            closure: MlirValue,
            args: MlirValue list,
            resultType: MlirType) : MlirValue =

            let funlang = FunLangDialect(this.Context)
            funlang.CreateApply(this.Location, closure, args, resultType)

        /// Create !funlang.closure type
        member this.FunLangClosureType() : MlirType =
            let funlang = FunLangDialect(this.Context)
            funlang.ClosureType()

        /// Create !funlang.list&lt;T&gt; type
        member this.FunLangListType(elementType: MlirType) : MlirType =
            let funlang = FunLangDialect(this.Context)
            funlang.ListType(elementType)
</code></pre>
<h3 id="f-wrapper-클래스-설계"><a class="header" href="#f-wrapper-클래스-설계">F# Wrapper 클래스 설계</a></h3>
<p><strong>설계 원칙:</strong></p>
<ol>
<li>
<p><strong>Low-level과 High-level 분리</strong></p>
<ul>
<li><code>FunLangBindings</code> 모듈: extern 선언 (P/Invoke)</li>
<li><code>FunLangDialect</code> 클래스: 타입 안전 래퍼</li>
</ul>
</li>
<li>
<p><strong>Builder 패턴</strong></p>
<ul>
<li><code>CreateClosureOp</code>: MlirOperation 반환 (유연성)</li>
<li><code>CreateClosure</code>: MlirValue 반환 (편의성)</li>
</ul>
</li>
<li>
<p><strong>OpBuilder Extension</strong></p>
<ul>
<li><code>this.CreateFunLangClosure(...)</code>: 간결한 사용</li>
<li>Context와 Location 자동 전달</li>
</ul>
</li>
<li>
<p><strong>타입 안전성</strong></p>
<ul>
<li>F# 타입 시스템 활용 (list, string)</li>
<li>Runtime 검증 (<code>IsClosureType</code>, <code>IsListType</code>)</li>
</ul>
</li>
</ol>
<h3 id="builder-패턴으로-operation-생성"><a class="header" href="#builder-패턴으로-operation-생성">Builder 패턴으로 Operation 생성</a></h3>
<p><strong>패턴 1: Direct Operation Creation</strong></p>
<pre><code class="language-fsharp">// 명시적 operation 생성
let funlang = FunLangDialect(context)
let op = funlang.CreateClosureOp(location, "lambda_add", [nValue])
let closure = mlirOperationGetResult(op, 0)

// Use cases:
// - Operation에 추가 속성 설정
// - Operation을 블록에 수동 삽입
</code></pre>
<p><strong>패턴 2: Direct Value Creation</strong></p>
<pre><code class="language-fsharp">// 결과 값만 필요
let funlang = FunLangDialect(context)
let closure = funlang.CreateClosure(location, "lambda_add", [nValue])

// Use cases:
// - 대부분의 일반적인 사용
// - Operation 자체에는 관심 없음
</code></pre>
<p><strong>패턴 3: OpBuilder Extension</strong></p>
<pre><code class="language-fsharp">// OpBuilder를 통한 생성 (가장 간결)
let closure = builder.CreateFunLangClosure("lambda_add", [nValue])

// Use cases:
// - Compiler.fs에서 compileExpr 내부
// - Location과 Context 자동 전달
// - 코드 가독성 최대화
</code></pre>
<h3 id="타입-안전성-보장"><a class="header" href="#타입-안전성-보장">타입 안전성 보장</a></h3>
<p><strong>컴파일 타임 안전성:</strong></p>
<p>F# 타입 시스템이 다음을 보장:</p>
<pre><code class="language-fsharp">// 올바른 사용
let values: MlirValue list = [v1; v2; v3]
let closure = builder.CreateFunLangClosure("lambda", values)

// 컴파일 에러
let wrong: int list = [1; 2; 3]
let closure = builder.CreateFunLangClosure("lambda", wrong)
// ERROR: Expected MlirValue list, got int list
</code></pre>
<p><strong>런타임 안전성:</strong></p>
<p>추가 검증 함수 제공:</p>
<pre><code class="language-fsharp">// 타입 검증
let ty = mlirValueGetType(someValue)
if funlang.IsClosureType(ty) then
    // someValue는 !funlang.closure 타입
    let result = funlang.CreateApply(location, someValue, [arg], i32Type)
else
    failwith "Expected closure type"
</code></pre>
<h3 id="사용-예시-makeadder를-funlang-dialect로-컴파일"><a class="header" href="#사용-예시-makeadder를-funlang-dialect로-컴파일">사용 예시: makeAdder를 FunLang Dialect로 컴파일</a></h3>
<p><strong>Phase 4 Compiler.fs (Before):</strong></p>
<pre><code class="language-fsharp">let rec compileExpr (builder: OpBuilder) (env: Map&lt;string, MlirValue&gt;) (expr: Expr) : MlirValue =
    match expr with
    | Lambda(param, body) -&gt;
        // Free variables analysis
        let freeVars = Set.difference (freeVarsExpr body) (Set.singleton param)
        let freeVarList = Set.toList freeVars

        // Create lifted function
        let lambdaName = freshLambdaName()
        createLiftedFunction builder lambdaName param body freeVarList env

        // Environment size: 8 (fn ptr) + 4 * |freeVars|
        let fnPtrSize = 8L
        let varSize = 4L
        let totalSize = fnPtrSize + (int64 freeVarList.Length) * varSize
        let sizeConst = builder.CreateI64Const(totalSize)

        // GC_malloc
        let envPtr = builder.CreateCall("GC_malloc", [sizeConst])

        // Store function pointer at env[0]
        let fnAddr = builder.CreateAddressOf(lambdaName)
        let fnSlot = builder.CreateGEP(envPtr, 0L)
        builder.CreateStore(fnAddr, fnSlot)

        // Store captured values at env[1..n]
        freeVarList |&gt; List.iteri (fun i varName -&gt;
            let value = env.[varName]
            let slot = builder.CreateGEP(envPtr, int64 (i + 1))
            builder.CreateStore(value, slot)
        )

        envPtr  // Return closure (environment pointer)

    | App(funcExpr, argExpr) -&gt;
        // Compile function and argument
        let closureVal = compileExpr builder env funcExpr
        let argVal = compileExpr builder env argExpr

        // Indirect call: GEP + load + llvm.call
        let c0 = builder.CreateI64Const(0L)
        let fnPtrAddr = builder.CreateGEP(closureVal, 0L)
        let fnPtr = builder.CreateLoad(fnPtrAddr, builder.PtrType())
        let result = builder.CreateLLVMCall(fnPtr, [closureVal; argVal], builder.IntType(32))
        result

    // ... other cases ...
</code></pre>
<p><strong>Phase 5 Compiler.fs (After):</strong></p>
<pre><code class="language-fsharp">let rec compileExpr (builder: OpBuilder) (env: Map&lt;string, MlirValue&gt;) (expr: Expr) : MlirValue =
    match expr with
    | Lambda(param, body) -&gt;
        // Free variables analysis (same)
        let freeVars = Set.difference (freeVarsExpr body) (Set.singleton param)
        let freeVarList = Set.toList freeVars

        // Create lifted function (same)
        let lambdaName = freshLambdaName()
        createLiftedFunction builder lambdaName param body freeVarList env

        // Create closure with FunLang dialect (1 line!)
        let capturedValues = freeVarList |&gt; List.map (fun v -&gt; env.[v])
        builder.CreateFunLangClosure(lambdaName, capturedValues)

    | App(funcExpr, argExpr) -&gt;
        // Compile function and argument (same)
        let closureVal = compileExpr builder env funcExpr
        let argVal = compileExpr builder env argExpr

        // Apply closure with FunLang dialect (1 line!)
        let resultType = builder.IntType(32)  // Assume i32 for now
        builder.CreateFunLangApply(closureVal, [argVal], resultType)

    // ... other cases ...
</code></pre>
<p><strong>코드 비교:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Phase 4</th><th>Phase 5</th><th>Improvement</th></tr>
</thead>
<tbody>
<tr><td>Lambda body</td><td>~15 lines</td><td>~5 lines</td><td>67% 감소</td></tr>
<tr><td>GC_malloc + GEP</td><td>명시적</td><td>숨김</td><td>추상화</td></tr>
<tr><td>App body</td><td>~5 lines</td><td>~3 lines</td><td>40% 감소</td></tr>
<tr><td>타입</td><td><code>!llvm.ptr</code></td><td><code>!funlang.closure</code></td><td>타입 안전성</td></tr>
<tr><td>가독성</td><td>저수준</td><td>고수준</td><td>의도 명확</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="part-6-refactoring-chapter-12-13-with-custom-dialect"><a class="header" href="#part-6-refactoring-chapter-12-13-with-custom-dialect">Part 6: Refactoring Chapter 12-13 with Custom Dialect</a></h2>
<p>Phase 4 코드를 Phase 5 코드로 리팩토링하는 <strong>구체적인 예시</strong>를 제공한다.</p>
<h3 id="before-chapter-12-phase-4-구현"><a class="header" href="#before-chapter-12-phase-4-구현">Before: Chapter 12 Phase 4 구현</a></h3>
<p><strong>Compiler.fs (Phase 4):</strong></p>
<pre><code class="language-fsharp">module Compiler

open Mlir.Core
open AST

// Counter for fresh lambda names
let mutable lambdaCounter = 0
let freshLambdaName() =
    lambdaCounter &lt;- lambdaCounter + 1
    sprintf "lambda_%d" lambdaCounter

// Free variables analysis
let rec freeVarsExpr (expr: Expr) : Set&lt;string&gt; =
    match expr with
    | Int _ -&gt; Set.empty
    | Var x -&gt; Set.singleton x
    | Add(e1, e2) -&gt; Set.union (freeVarsExpr e1) (freeVarsExpr e2)
    | Lambda(param, body) -&gt; Set.remove param (freeVarsExpr body)
    | App(e1, e2) -&gt; Set.union (freeVarsExpr e1) (freeVarsExpr e2)

// Create lifted function
let createLiftedFunction
    (builder: OpBuilder)
    (name: string)
    (param: string)
    (body: Expr)
    (freeVars: string list)
    (outerEnv: Map&lt;string, MlirValue&gt;) : unit =

    // Function type: (!llvm.ptr, i32) -&gt; i32
    let envType = builder.PtrType()
    let paramType = builder.IntType(32)
    let resultType = builder.IntType(32)
    let funcType = builder.FunctionType([envType; paramType], [resultType])

    // Create function
    let func = builder.CreateFunction(name, funcType)

    // Build function body
    let entryBlock = builder.GetFunctionEntryBlock(func)
    builder.SetInsertionPointToEnd(entryBlock)

    let envParam = mlirBlockGetArgument(entryBlock, 0)
    let xParam = mlirBlockGetArgument(entryBlock, 1)

    // Build environment for body: {param -&gt; xParam, freeVars -&gt; loads}
    let mutable innerEnv = Map.ofList [(param, xParam)]

    freeVars |&gt; List.iteri (fun i varName -&gt;
        // Load from env[i+1]
        let idx = int64 (i + 1)
        let slot = builder.CreateGEP(envParam, idx)
        let value = builder.CreateLoad(slot, paramType)
        innerEnv &lt;- Map.add varName value innerEnv
    )

    // Compile body
    let resultVal = compileExpr builder innerEnv body
    builder.CreateReturn(resultVal)

// Compile expression
and compileExpr (builder: OpBuilder) (env: Map&lt;string, MlirValue&gt;) (expr: Expr) : MlirValue =
    match expr with
    | Int n -&gt;
        builder.CreateI32Const(n)

    | Var x -&gt;
        env.[x]

    | Add(e1, e2) -&gt;
        let v1 = compileExpr builder env e1
        let v2 = compileExpr builder env e2
        builder.CreateArithBinaryOp(ArithOp.Addi, v1, v2)

    | Lambda(param, body) -&gt;
        // Phase 4: 12+ lines of low-level code
        let freeVars = freeVarsExpr body |&gt; Set.toList

        let lambdaName = freshLambdaName()
        createLiftedFunction builder lambdaName param body freeVars env

        // Calculate environment size
        let fnPtrSize = 8L
        let varSize = 4L
        let totalSize = fnPtrSize + (int64 freeVars.Length) * varSize
        let sizeConst = builder.CreateI64Const(totalSize)

        // Allocate environment
        let envPtr = builder.CreateCall("GC_malloc", [sizeConst])

        // Store function pointer at env[0]
        let fnAddr = builder.CreateAddressOf(lambdaName)
        let fnSlot = builder.CreateGEP(envPtr, 0L)
        builder.CreateStore(fnAddr, fnSlot)

        // Store captured variables at env[1..n]
        freeVars |&gt; List.iteri (fun i varName -&gt;
            let value = env.[varName]
            let slot = builder.CreateGEP(envPtr, int64 (i + 1))
            builder.CreateStore(value, slot)
        )

        envPtr

    | App(funcExpr, argExpr) -&gt;
        // Phase 4: 8+ lines of indirect call
        let closureVal = compileExpr builder env funcExpr
        let argVal = compileExpr builder env argExpr

        // Load function pointer from closure[0]
        let c0 = builder.CreateI64Const(0L)
        let fnPtrAddr = builder.CreateGEP(closureVal, 0L)
        let fnPtr = builder.CreateLoad(fnPtrAddr, builder.PtrType())

        // Indirect call: fn_ptr(closure, arg)
        let resultType = builder.IntType(32)
        builder.CreateLLVMCall(fnPtr, [closureVal; argVal], resultType)

// Main compile function
let compile (expr: Expr) : MlirModule =
    use context = new MlirContext()
    context.LoadDialect("builtin")
    context.LoadDialect("func")
    context.LoadDialect("arith")
    context.LoadDialect("llvm")

    use mlirModule = MlirModule.Create(context, "main_module")
    use builder = new OpBuilder(context)
    builder.SetInsertionPointToEnd(mlirModule.Body)

    // Declare GC_malloc
    let i64Type = builder.IntType(64)
    let ptrType = builder.PtrType()
    let gcMallocType = builder.FunctionType([i64Type], [ptrType])
    builder.CreateFunctionDecl("GC_malloc", gcMallocType)

    // Compile main function
    let i32Type = builder.IntType(32)
    let mainType = builder.FunctionType([], [i32Type])
    let mainFunc = builder.CreateFunction("main", mainType)

    let entryBlock = builder.GetFunctionEntryBlock(mainFunc)
    builder.SetInsertionPointToEnd(entryBlock)

    let resultVal = compileExpr builder Map.empty expr
    builder.CreateReturn(resultVal)

    mlirModule
</code></pre>
<h3 id="after-chapter-15-phase-5-구현"><a class="header" href="#after-chapter-15-phase-5-구현">After: Chapter 15 Phase 5 구현</a></h3>
<p><strong>Compiler.fs (Phase 5):</strong></p>
<pre><code class="language-fsharp">module Compiler

open Mlir.Core
open Mlir.FunLang  // Add FunLang dialect
open AST

// (freshLambdaName, freeVarsExpr - same as Phase 4)

// Create lifted function (same as Phase 4)
let createLiftedFunction
    (builder: OpBuilder)
    (name: string)
    (param: string)
    (body: Expr)
    (freeVars: string list)
    (outerEnv: Map&lt;string, MlirValue&gt;) : unit =
    // ... (same implementation) ...

// Compile expression
and compileExpr (builder: OpBuilder) (env: Map&lt;string, MlirValue&gt;) (expr: Expr) : MlirValue =
    match expr with
    | Int n -&gt; builder.CreateI32Const(n)
    | Var x -&gt; env.[x]
    | Add(e1, e2) -&gt;
        let v1 = compileExpr builder env e1
        let v2 = compileExpr builder env e2
        builder.CreateArithBinaryOp(ArithOp.Addi, v1, v2)

    | Lambda(param, body) -&gt;
        // Phase 5: 5 lines with FunLang dialect!
        let freeVars = freeVarsExpr body |&gt; Set.toList

        let lambdaName = freshLambdaName()
        createLiftedFunction builder lambdaName param body freeVars env

        // Create closure (1 line!)
        let capturedValues = freeVars |&gt; List.map (fun v -&gt; env.[v])
        builder.CreateFunLangClosure(lambdaName, capturedValues)

    | App(funcExpr, argExpr) -&gt;
        // Phase 5: 3 lines with FunLang dialect!
        let closureVal = compileExpr builder env funcExpr
        let argVal = compileExpr builder env argExpr

        // Apply closure (1 line!)
        let resultType = builder.IntType(32)
        builder.CreateFunLangApply(closureVal, [argVal], resultType)

// Main compile function
let compile (expr: Expr) : MlirModule =
    use context = new MlirContext()
    context.LoadDialect("builtin")
    context.LoadDialect("func")
    context.LoadDialect("arith")
    context.LoadDialect("llvm")
    context.LoadDialect("funlang")  // Add FunLang dialect!

    use mlirModule = MlirModule.Create(context, "main_module")
    use builder = new OpBuilder(context)
    builder.SetInsertionPointToEnd(mlirModule.Body)

    // Declare GC_malloc (same)
    let i64Type = builder.IntType(64)
    let ptrType = builder.PtrType()
    let gcMallocType = builder.FunctionType([i64Type], [ptrType])
    builder.CreateFunctionDecl("GC_malloc", gcMallocType)

    // Compile main function (same)
    let i32Type = builder.IntType(32)
    let mainType = builder.FunctionType([], [i32Type])
    let mainFunc = builder.CreateFunction("main", mainType)

    let entryBlock = builder.GetFunctionEntryBlock(mainFunc)
    builder.SetInsertionPointToEnd(entryBlock)

    let resultVal = compileExpr builder Map.empty expr
    builder.CreateReturn(resultVal)

    mlirModule
</code></pre>
<h3 id="코드-줄-수-비교"><a class="header" href="#코드-줄-수-비교">코드 줄 수 비교</a></h3>
<p><strong>Lambda case:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Version</th><th>Lines</th><th>Key Operations</th></tr>
</thead>
<tbody>
<tr><td>Phase 4</td><td>~20</td><td>Size calculation, GC_malloc, GEP loop, stores</td></tr>
<tr><td>Phase 5</td><td>~5</td><td>CreateFunLangClosure</td></tr>
<tr><td><strong>Reduction</strong></td><td><strong>75%</strong></td><td><strong>15 lines eliminated</strong></td></tr>
</tbody>
</table>
</div>
<p><strong>App case:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Version</th><th>Lines</th><th>Key Operations</th></tr>
</thead>
<tbody>
<tr><td>Phase 4</td><td>~8</td><td>GEP, load, llvm.call</td></tr>
<tr><td>Phase 5</td><td>~3</td><td>CreateFunLangApply</td></tr>
<tr><td><strong>Reduction</strong></td><td><strong>63%</strong></td><td><strong>5 lines eliminated</strong></td></tr>
</tbody>
</table>
</div>
<p><strong>Overall (compileExpr function):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Version</th><th>Total Lines</th><th>Lambda Lines</th><th>App Lines</th></tr>
</thead>
<tbody>
<tr><td>Phase 4</td><td>~50</td><td>~20</td><td>~8</td></tr>
<tr><td>Phase 5</td><td>~25</td><td>~5</td><td>~3</td></tr>
<tr><td><strong>Reduction</strong></td><td><strong>50%</strong></td><td><strong>75%</strong></td><td><strong>63%</strong></td></tr>
</tbody>
</table>
</div>
<h3 id="compileexpr-함수-변경점-요약"><a class="header" href="#compileexpr-함수-변경점-요약">compileExpr 함수 변경점 요약</a></h3>
<p><strong>추가된 import:</strong></p>
<pre><code class="language-fsharp">open Mlir.FunLang  // FunLang dialect wrapper
</code></pre>
<p><strong>변경된 dialect 로딩:</strong></p>
<pre><code class="language-fsharp">context.LoadDialect("funlang")  // FunLang dialect 추가
</code></pre>
<p><strong>Lambda case 변경:</strong></p>
<pre><code class="language-fsharp">// Before: 12+ lines (GC_malloc + GEP loop)
let totalSize = ...
let envPtr = builder.CreateCall("GC_malloc", [sizeConst])
// ... GEP loop ...

// After: 1 line
let capturedValues = freeVars |&gt; List.map (fun v -&gt; env.[v])
builder.CreateFunLangClosure(lambdaName, capturedValues)
</code></pre>
<p><strong>App case 변경:</strong></p>
<pre><code class="language-fsharp">// Before: 5+ lines (GEP + load + llvm.call)
let fnPtrAddr = builder.CreateGEP(closureVal, 0L)
let fnPtr = builder.CreateLoad(fnPtrAddr, ...)
builder.CreateLLVMCall(fnPtr, [closureVal; argVal], ...)

// After: 1 line
builder.CreateFunLangApply(closureVal, [argVal], resultType)
</code></pre>
<h3 id="generated-mlir-비교"><a class="header" href="#generated-mlir-비교">Generated MLIR 비교</a></h3>
<p><strong>Test program:</strong></p>
<pre><code class="language-fsharp">// FunLang AST
let test =
    Let("make_adder",
        Lambda("n",
            Lambda("x",
                Add(Var "x", Var "n"))),
        App(App(Var "make_adder", Int 5), Int 10))
</code></pre>
<p><strong>Phase 4 Generated MLIR:</strong></p>
<pre><code class="language-mlir">module {
  llvm.func @GC_malloc(i64) -&gt; !llvm.ptr

  func.func @lambda_1(%env: !llvm.ptr, %x: i32) -&gt; i32 {
    %c1 = arith.constant 1 : i64
    %n_slot = llvm.getelementptr %env[%c1] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    %n = llvm.load %n_slot : !llvm.ptr -&gt; i32
    %result = arith.addi %x, %n : i32
    func.return %result : i32
  }

  func.func @lambda_0(%env: !llvm.ptr, %n: i32) -&gt; !llvm.ptr {
    %c12 = arith.constant 12 : i64
    %inner_env = llvm.call @GC_malloc(%c12) : (i64) -&gt; !llvm.ptr
    %fn_addr = llvm.mlir.addressof @lambda_1 : !llvm.ptr
    %c0 = arith.constant 0 : i64
    %fn_slot = llvm.getelementptr %inner_env[%c0] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    llvm.store %fn_addr, %fn_slot : !llvm.ptr, !llvm.ptr
    %c1 = arith.constant 1 : i64
    %n_slot = llvm.getelementptr %inner_env[%c1] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    llvm.store %n, %n_slot : i32, !llvm.ptr
    func.return %inner_env : !llvm.ptr
  }

  func.func @main() -&gt; i32 {
    %c12 = arith.constant 12 : i64
    %outer_env = llvm.call @GC_malloc(%c12) : (i64) -&gt; !llvm.ptr
    %fn_addr = llvm.mlir.addressof @lambda_0 : !llvm.ptr
    %c0 = arith.constant 0 : i64
    %fn_slot = llvm.getelementptr %outer_env[%c0] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    llvm.store %fn_addr, %fn_slot : !llvm.ptr, !llvm.ptr

    %c5 = arith.constant 5 : i32
    %fn_ptr_addr = llvm.getelementptr %outer_env[%c0] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    %fn_ptr = llvm.load %fn_ptr_addr : !llvm.ptr -&gt; !llvm.ptr
    %add5 = llvm.call %fn_ptr(%outer_env, %c5) : (!llvm.ptr, i32) -&gt; !llvm.ptr

    %c10 = arith.constant 10 : i32
    %fn_ptr_addr2 = llvm.getelementptr %add5[%c0] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    %fn_ptr2 = llvm.load %fn_ptr_addr2 : !llvm.ptr -&gt; !llvm.ptr
    %result = llvm.call %fn_ptr2(%add5, %c10) : (!llvm.ptr, i32) -&gt; i32

    func.return %result : i32
  }
}
</code></pre>
<p><strong>Phase 5 Generated MLIR:</strong></p>
<pre><code class="language-mlir">module {
  llvm.func @GC_malloc(i64) -&gt; !llvm.ptr

  func.func @lambda_1(%env: !llvm.ptr, %x: i32) -&gt; i32 {
    %c1 = arith.constant 1 : i64
    %n_slot = llvm.getelementptr %env[%c1] : (!llvm.ptr, i64) -&gt; !llvm.ptr
    %n = llvm.load %n_slot : !llvm.ptr -&gt; i32
    %result = arith.addi %x, %n : i32
    func.return %result : i32
  }

  func.func @lambda_0(%env: !llvm.ptr, %n: i32) -&gt; !funlang.closure {
    // Closure creation: 1 line!
    %inner_closure = funlang.closure @lambda_1, %n : !funlang.closure
    func.return %inner_closure : !funlang.closure
  }

  func.func @main() -&gt; i32 {
    // Outer closure
    %make_adder = funlang.closure @lambda_0 : !funlang.closure

    // Apply make_adder 5
    %c5 = arith.constant 5 : i32
    %add5 = funlang.apply %make_adder(%c5) : (i32) -&gt; !funlang.closure

    // Apply add5 10
    %c10 = arith.constant 10 : i32
    %result = funlang.apply %add5(%c10) : (i32) -&gt; i32

    func.return %result : i32
  }
}
</code></pre>
<p><strong>MLIR Line Count:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Phase 4</th><th>Phase 5</th><th>Reduction</th></tr>
</thead>
<tbody>
<tr><td>lambda_0</td><td>11 lines</td><td>3 lines</td><td>73%</td></tr>
<tr><td>main</td><td>14 lines</td><td>8 lines</td><td>43%</td></tr>
<tr><td><strong>Total</strong></td><td><strong>~35 lines</strong></td><td><strong>~18 lines</strong></td><td><strong>49%</strong></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="part-7-common-errors"><a class="header" href="#part-7-common-errors">Part 7: Common Errors</a></h2>
<p>FunLang dialect 사용 시 흔히 발생하는 오류들과 해결 방법을 다룬다.</p>
<h3 id="error-1-missing-dialect-registration"><a class="header" href="#error-1-missing-dialect-registration">Error 1: Missing Dialect Registration</a></h3>
<p><strong>증상:</strong></p>
<pre><code>ERROR: Dialect 'funlang' not found in context
</code></pre>
<p><strong>원인:</strong></p>
<p>FunLang dialect을 context에 로드하지 않았다.</p>
<p><strong>잘못된 코드:</strong></p>
<pre><code class="language-fsharp">use context = new MlirContext()
context.LoadDialect("builtin")
context.LoadDialect("func")
// funlang dialect 누락!

let builder = new OpBuilder(context)
let closure = builder.CreateFunLangClosure("lambda", [])
// ERROR: funlang dialect not registered
</code></pre>
<p><strong>올바른 코드:</strong></p>
<pre><code class="language-fsharp">use context = new MlirContext()
context.LoadDialect("builtin")
context.LoadDialect("func")
context.LoadDialect("funlang")  // FunLang dialect 로드!

let builder = new OpBuilder(context)
let closure = builder.CreateFunLangClosure("lambda", [])
// OK
</code></pre>
<p><strong>체크리스트:</strong></p>
<ul>
<li><input disabled="" type="checkbox"> <code>context.LoadDialect("funlang")</code> 호출했는가?</li>
<li><input disabled="" type="checkbox"> FunLang dialect 라이브러리를 링크했는가? (<code>-lMLIR-FunLang-CAPI</code>)</li>
<li><input disabled="" type="checkbox"> Dialect 초기화 함수를 호출했는가? (C++ 프로젝트에서만 필요)</li>
</ul>
<h3 id="error-2-wrong-attribute-type-for-callee"><a class="header" href="#error-2-wrong-attribute-type-for-callee">Error 2: Wrong Attribute Type for Callee</a></h3>
<p><strong>증상:</strong></p>
<pre><code>ERROR: Expected FlatSymbolRefAttr, got StringAttr
</code></pre>
<p><strong>원인:</strong></p>
<p>함수 이름을 일반 문자열 대신 SymbolRefAttr로 전달하지 않았다.</p>
<p><strong>잘못된 코드:</strong></p>
<pre><code class="language-fsharp">// F# string을 직접 전달 (wrong!)
let nameAttr = mlirStringAttrGet(context, MlirStringRef.FromString("lambda"))
let op = FunLangBindings.mlirFunLangClosureOpCreate(
    context, loc, nameAttr, 0n, [||])
// ERROR: StringAttr is not FlatSymbolRefAttr
</code></pre>
<p><strong>올바른 코드:</strong></p>
<pre><code class="language-fsharp">// FlatSymbolRefAttr로 변환
use nameStrRef = MlirStringRef.FromString("lambda")
let calleeAttr = mlirFlatSymbolRefAttrGet(context, nameStrRef)
let op = FunLangBindings.mlirFunLangClosureOpCreate(
    context, loc, calleeAttr, 0n, [||])
// OK
</code></pre>
<p><strong>또는 High-level wrapper 사용:</strong></p>
<pre><code class="language-fsharp">// FunLangDialect wrapper가 변환 처리
let funlang = FunLangDialect(context)
let closure = funlang.CreateClosure(loc, "lambda", [])
// OK: "lambda" string is converted to FlatSymbolRefAttr internally
</code></pre>
<p><strong>Why FlatSymbolRefAttr?</strong></p>
<ul>
<li><strong>Symbol table 검증</strong>: MLIR이 <code>@lambda</code> 함수 존재 여부 확인</li>
<li><strong>최적화 지원</strong>: Inlining, DCE 등에서 심볼 참조 추적</li>
<li><strong>타입 정보</strong>: 함수 시그니처 접근 가능</li>
</ul>
<h3 id="error-3-type-mismatch-in-variadic-arguments"><a class="header" href="#error-3-type-mismatch-in-variadic-arguments">Error 3: Type Mismatch in Variadic Arguments</a></h3>
<p><strong>증상:</strong></p>
<pre><code>ERROR: funlang.closure expects all captured values to be SSA values
</code></pre>
<p><strong>원인:</strong></p>
<p>캡처된 변수 배열에 잘못된 값을 전달했다 (예: null, 초기화되지 않은 값).</p>
<p><strong>잘못된 코드:</strong></p>
<pre><code class="language-fsharp">// 빈 MlirValue 배열 생성 (uninitialized)
let capturedArray : MlirValue[] = Array.zeroCreate 3
// capturedArray[0..2] are default (uninitialized)

let op = FunLangBindings.mlirFunLangClosureOpCreate(
    context, loc, calleeAttr, 3n, capturedArray)
// ERROR: Invalid MlirValue
</code></pre>
<p><strong>올바른 코드:</strong></p>
<pre><code class="language-fsharp">// F# list에서 변환
let capturedList = [v1; v2; v3]
let capturedArray = List.toArray capturedList

let op = FunLangBindings.mlirFunLangClosureOpCreate(
    context, loc, calleeAttr, nativeint capturedArray.Length, capturedArray)
// OK: All values are valid SSA values
</code></pre>
<p><strong>또는 High-level wrapper 사용:</strong></p>
<pre><code class="language-fsharp">// FunLangDialect wrapper가 변환 처리
let funlang = FunLangDialect(context)
let closure = funlang.CreateClosure(loc, "lambda", [v1; v2; v3])
// OK: F# list is safely converted to array
</code></pre>
<p><strong>디버깅 팁:</strong></p>
<p>MlirValue의 유효성을 검증:</p>
<pre><code class="language-fsharp">// MlirValue가 유효한지 확인
let isValidValue (v: MlirValue) : bool =
    v.ptr &lt;&gt; 0n  // nativeint 0은 null pointer

// 사용 전 검증
if not (isValidValue v1) then
    failwith "v1 is invalid MlirValue"
</code></pre>
<h3 id="error-4-forgetting-to-declare-dependent-dialects"><a class="header" href="#error-4-forgetting-to-declare-dependent-dialects">Error 4: Forgetting to Declare Dependent Dialects</a></h3>
<p><strong>증상:</strong></p>
<pre><code>ERROR: Operation 'func.call' not found
ERROR: Operation 'arith.addi' not found
</code></pre>
<p><strong>원인:</strong></p>
<p>FunLang dialect은 다른 dialect (func, arith, llvm)에 의존한다. 이들을 로드하지 않으면 lifted function 내부에서 오류 발생.</p>
<p><strong>잘못된 코드:</strong></p>
<pre><code class="language-fsharp">use context = new MlirContext()
context.LoadDialect("funlang")  // FunLang만 로드

let builder = new OpBuilder(context)
let closure = builder.CreateFunLangClosure("lambda", [])
// ERROR: lifted function uses arith.addi, but arith dialect not loaded
</code></pre>
<p><strong>올바른 코드:</strong></p>
<pre><code class="language-fsharp">use context = new MlirContext()
context.LoadDialect("builtin")   // Module, FuncOp
context.LoadDialect("func")      // func.func, func.call, func.return
context.LoadDialect("arith")     // arith.constant, arith.addi
context.LoadDialect("llvm")      // llvm.ptr, llvm.getelementptr
context.LoadDialect("funlang")   // funlang.closure, funlang.apply

// 이제 모든 operations 사용 가능
</code></pre>
<p><strong>Dialect 의존성 체인:</strong></p>
<pre><code>FunLang dialect
  ├── depends on Func dialect (func.func, func.return)
  ├── depends on Arith dialect (arith.constant, arith.addi)
  └── depends on LLVM dialect (!llvm.ptr, llvm.getelementptr)
</code></pre>
<p><strong>TableGen 선언 (FunLangDialect.td):</strong></p>
<pre><code class="language-tablegen">def FunLang_Dialect : Dialect {
  let name = "funlang";
  let summary = "FunLang functional language dialect";
  let description = [{...}];
  let cppNamespace = "::mlir::funlang";

  // Dependent dialects
  let dependentDialects = [
    "mlir::func::FuncDialect",
    "mlir::arith::ArithDialect",
    "mlir::LLVM::LLVMDialect"
  ];
}
</code></pre>
<h3 id="error-5-incorrect-result-type-in-funlangapply"><a class="header" href="#error-5-incorrect-result-type-in-funlangapply">Error 5: Incorrect Result Type in funlang.apply</a></h3>
<p><strong>증상:</strong></p>
<pre><code>ERROR: funlang.apply result type does not match function signature
</code></pre>
<p><strong>원인:</strong></p>
<p><code>funlang.apply</code>에 지정한 결과 타입이 실제 클로저 함수의 반환 타입과 다르다.</p>
<p><strong>잘못된 코드:</strong></p>
<pre><code class="language-fsharp">// lambda_add 함수: (i32) -&gt; i32
%closure = funlang.closure @lambda_add, %n : !funlang.closure

// 잘못된 결과 타입 (f64)
%result = funlang.apply %closure(%x) : (i32) -&gt; f64
// ERROR: lambda_add returns i32, not f64
</code></pre>
<p><strong>올바른 코드:</strong></p>
<pre><code class="language-fsharp">// lambda_add 함수: (i32) -&gt; i32
%closure = funlang.closure @lambda_add, %n : !funlang.closure

// 올바른 결과 타입 (i32)
%result = funlang.apply %closure(%x) : (i32) -&gt; i32
// OK
</code></pre>
<p><strong>F# 컴파일러에서의 해결:</strong></p>
<p>타입 추론을 통해 자동으로 올바른 타입 지정:</p>
<pre><code class="language-fsharp">// 컴파일러가 resultType를 추론
let resultType =
    match exprType funcExpr with
    | FunctionType(argTypes, retType) -&gt; retType
    | _ -&gt; failwith "Expected function type"

builder.CreateFunLangApply(closureVal, [argVal], resultType)
</code></pre>
<h3 id="error-6-using-funlangclosure-with-non-existent-function"><a class="header" href="#error-6-using-funlangclosure-with-non-existent-function">Error 6: Using funlang.closure with Non-Existent Function</a></h3>
<p><strong>증상:</strong></p>
<pre><code>ERROR: Symbol '@lambda_99' not found in module
</code></pre>
<p><strong>원인:</strong></p>
<p><code>funlang.closure @lambda_99</code>를 생성했지만, <code>@lambda_99</code> 함수를 정의하지 않았다.</p>
<p><strong>잘못된 코드:</strong></p>
<pre><code class="language-fsharp">// 클로저 생성
let closure = builder.CreateFunLangClosure("lambda_99", [])

// 하지만 lambda_99 함수는 정의되지 않음!
// ERROR: Symbol not found
</code></pre>
<p><strong>올바른 코드:</strong></p>
<pre><code class="language-fsharp">// 1. 먼저 lifted function 생성
createLiftedFunction builder "lambda_99" "x" bodyExpr [] env

// 2. 그 다음 클로저 생성
let closure = builder.CreateFunLangClosure("lambda_99", [])
// OK: lambda_99 exists
</code></pre>
<p><strong>순서 보장:</strong></p>
<pre><code class="language-fsharp">// Lambda case in compileExpr
| Lambda(param, body) -&gt;
    let lambdaName = freshLambdaName()

    // Step 1: Create lifted function FIRST
    createLiftedFunction builder lambdaName param body freeVars env

    // Step 2: Create closure AFTER function exists
    let capturedValues = freeVars |&gt; List.map (fun v -&gt; env.[v])
    builder.CreateFunLangClosure(lambdaName, capturedValues)
</code></pre>
<hr>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<h3 id="chapter-15에서-배운-것"><a class="header" href="#chapter-15에서-배운-것">Chapter 15에서 배운 것</a></h3>
<p><strong>1. funlang.closure Operation</strong></p>
<ul>
<li>Phase 4의 12줄 클로저 생성 코드를 1줄로 압축</li>
<li>TableGen ODS로 선언적 정의</li>
<li>Pure trait로 최적화 가능</li>
<li>FlatSymbolRefAttr로 타입 안전 함수 참조</li>
<li>C API shim으로 F# 통합</li>
</ul>
<p><strong>2. funlang.apply Operation</strong></p>
<ul>
<li>Phase 4의 8줄 간접 호출 코드를 1줄로 압축</li>
<li>클로저 타입을 인자로 받음 (!funlang.closure)</li>
<li>Side effect 고려 (trait 없음)</li>
<li>Functional-type syntax로 명확한 시그니처</li>
</ul>
<p><strong>3. funlang.match Operation (Phase 6 Preview)</strong></p>
<ul>
<li>Region-based operation 구조</li>
<li>VariadicRegion&lt;SizedRegion&lt;1&gt;&gt;로 각 case 독립</li>
<li>SingleBlockImplicitTerminator&lt;“YieldOp”&gt;로 통일된 종료</li>
<li>Verifier로 타입 안전성 보장</li>
<li>Block arguments로 패턴 변수 표현</li>
</ul>
<p><strong>4. FunLang Custom Types</strong></p>
<ul>
<li>!funlang.closure: Opaque type (단순성 우선)</li>
<li>!funlang.list<t>: Parameterized type (타입 안전성 필수)</t></li>
<li>Lowering: FunLang types → !llvm.ptr</li>
</ul>
<p><strong>5. Complete F# Integration</strong></p>
<ul>
<li>Low-level bindings (FunLangBindings 모듈)</li>
<li>High-level wrappers (FunLangDialect 클래스)</li>
<li>OpBuilder extensions (CreateFunLangClosure/Apply)</li>
<li>Type-safe API (F# list, string 자동 변환)</li>
</ul>
<p><strong>6. Code Reduction</strong></p>
<ul>
<li>Lambda: 20 lines → 5 lines (75% 감소)</li>
<li>App: 8 lines → 3 lines (63% 감소)</li>
<li>Overall: 50% 코드 감소</li>
<li>타입 안전성 향상 (!llvm.ptr → !funlang.closure)</li>
</ul>
<h3 id="핵심-패턴"><a class="header" href="#핵심-패턴">핵심 패턴</a></h3>
<p><strong>TableGen ODS:</strong></p>
<pre><code class="language-tablegen">def FunLang_ClosureOp : FunLang_Op&lt;"closure", [Pure]&gt; {
  let arguments = (ins FlatSymbolRefAttr:$callee,
                       Variadic&lt;AnyType&gt;:$capturedValues);
  let results = (outs FunLang_ClosureType:$result);
  let assemblyFormat = [...];
}
</code></pre>
<p><strong>C API Shim:</strong></p>
<pre><code class="language-cpp">MlirOperation mlirFunLangClosureOpCreate(...) {
  MLIRContext *ctx = unwrap(mlirCtx);
  OpBuilder builder(ctx);
  auto op = builder.create&lt;ClosureOp&gt;(...);
  return wrap(op.getOperation());
}
</code></pre>
<p><strong>F# High-level Wrapper:</strong></p>
<pre><code class="language-fsharp">type FunLangDialect(context: MlirContext) =
    member this.CreateClosure(loc, callee, captured) =
        // Handle string → FlatSymbolRefAttr conversion
        // Handle F# list → C array conversion
        // Call C API
        // Return MlirValue
</code></pre>
<h3 id="chapter-16-preview"><a class="header" href="#chapter-16-preview">Chapter 16 Preview</a></h3>
<p><strong>Chapter 16: Lowering Passes</strong></p>
<p>다음 장에서는 FunLang dialect을 LLVM dialect으로 lowering하는 pass를 구현한다:</p>
<ol>
<li>
<p><strong>FunLangToLLVM Lowering Pass</strong></p>
<ul>
<li>funlang.closure → GC_malloc + store 패턴</li>
<li>funlang.apply → GEP + load + llvm.call 패턴</li>
<li>!funlang.closure → !llvm.ptr 타입 변환</li>
</ul>
</li>
<li>
<p><strong>Pass Infrastructure</strong></p>
<ul>
<li>Pass registration (PassManager)</li>
<li>ConversionTarget 설정</li>
<li>TypeConverter 구현</li>
<li>RewritePattern 작성</li>
</ul>
</li>
<li>
<p><strong>Testing</strong></p>
<ul>
<li>FileCheck 테스트 작성</li>
<li>Before/After IR 비교</li>
<li>실행 테스트 (JIT)</li>
</ul>
</li>
<li>
<p><strong>Optimization Opportunities</strong></p>
<ul>
<li>Closure inlining</li>
<li>Escape analysis</li>
<li>Dead closure elimination</li>
</ul>
</li>
</ol>
<p><strong>Progressive Lowering 완성:</strong></p>
<pre><code>FunLang AST
  ↓ (Compiler.fs)
FunLang Dialect (funlang.closure, funlang.apply)
  ↓ (Chapter 16: FunLangToLLVM pass)
LLVM Dialect (llvm.call @GC_malloc, llvm.getelementptr)
  ↓ (MLIR built-in passes)
LLVM IR
  ↓ (LLVM backend)
Native Code
</code></pre>
<p><strong>Phase 5의 목표 달성:</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""> Custom dialect 정의 (Chapter 14 theory, Chapter 15 implementation)</li>
<li><input disabled="" type="checkbox" checked=""> Operations 구현 (closure, apply, match preview)</li>
<li><input disabled="" type="checkbox" checked=""> Types 구현 (closure, list preview)</li>
<li><input disabled="" type="checkbox" checked=""> F# 통합 (C API shim + bindings)</li>
<li><input disabled="" type="checkbox" checked=""> Compiler 리팩토링 (Phase 4 코드 50% 감소)</li>
<li><input disabled="" type="checkbox"> Lowering pass 구현 (Chapter 16)</li>
<li><input disabled="" type="checkbox"> 테스트와 검증 (Chapter 16)</li>
</ul>
<p><strong>다음: Chapter 16 - Lowering Passes로 Phase 5를 완성한다!</strong></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-16-lowering-passes-lowering-passes"><a class="header" href="#chapter-16-lowering-passes-lowering-passes">Chapter 16: Lowering Passes (Lowering Passes)</a></h1>
<h2 id="소개-16"><a class="header" href="#소개-16">소개</a></h2>
<p><strong>Phase 5의 여정이 완성된다.</strong> Chapter 14에서 커스텀 dialect의 <strong>이론</strong>을 다뤘고, Chapter 15에서 FunLang operations를 <strong>정의</strong>했다. 이제 마지막 퍼즐 조각: <strong>lowering</strong>이다.</p>
<h3 id="chapter-14-15-복습"><a class="header" href="#chapter-14-15-복습">Chapter 14-15 복습</a></h3>
<p><strong>Chapter 14: Custom Dialect Design</strong></p>
<ul>
<li>Progressive lowering 철학 (FunLang → Func/SCF → LLVM)</li>
<li>TableGen ODS로 operation 정의</li>
<li>C API shim pattern으로 F# 연결</li>
<li>FunLang dialect 설계 방향</li>
</ul>
<p><strong>Chapter 15: Custom Operations</strong></p>
<ul>
<li><code>funlang.closure</code> operation: 클로저 생성 추상화</li>
<li><code>funlang.apply</code> operation: 클로저 호출 추상화</li>
<li><code>!funlang.closure</code> custom type: 타입 안전성</li>
<li>F# integration: C API → P/Invoke → OpBuilder extensions</li>
</ul>
<p><strong>현재 상태:</strong></p>
<pre><code class="language-mlir">// Phase 5 FunLang dialect (Chapter 15)
func.func @make_adder(%n: i32) -&gt; !funlang.closure {
    %closure = funlang.closure @lambda_adder, %n : !funlang.closure
    func.return %closure : !funlang.closure
}

func.func @lambda_adder(%env: !llvm.ptr, %x: i32) -&gt; i32 {
    // 환경에서 n 로드
    %n_slot = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
    %n = llvm.load %n_slot : !llvm.ptr -&gt; i32
    %result = arith.addi %x, %n : i32
    func.return %result : i32
}
</code></pre>
<p><strong>문제:</strong> <code>funlang.closure</code>는 high-level operation이다. LLVM backend는 이걸 이해 못한다. <strong>Lowering pass</strong>가 필요하다.</p>
<h3 id="lowering-pass란"><a class="header" href="#lowering-pass란">Lowering Pass란?</a></h3>
<p><strong>Lowering pass</strong>는 high-level operation을 low-level operation으로 변환하는 MLIR transformation이다.</p>
<p><strong>FunLang의 Progressive Lowering:</strong></p>
<pre><code>1. FunLang dialect (Chapter 15)
   funlang.closure, funlang.apply
   ↓
2. Func + SCF + MemRef (중간 추상화)
   func.func, scf.if, memref.alloca
   ↓
3. LLVM dialect (Chapter 12-13 패턴)
   llvm.call, llvm.getelementptr, llvm.store
   ↓
4. LLVM IR (MLIR → LLVM translation)
   call @GC_malloc, getelementptr, store
</code></pre>
<p><strong>Chapter 16의 scope:</strong> FunLang dialect → LLVM dialect (Step 1 → 3)</p>
<p><strong>왜 직접 LLVM dialect로?</strong></p>
<p>Phase 5에서는 간단한 클로저만 다룬다. 중간 dialect(SCF, MemRef)를 거칠 필요가 없다. <strong>직접 lowering</strong>이 효율적이다.</p>
<blockquote>
<p><strong>Phase 6 preview:</strong> 패턴 매칭 (<code>funlang.match</code>)은 복잡한 제어 흐름을 포함한다. 그때는 SCF dialect를 거쳐서 lowering한다.</p>
</blockquote>
<h3 id="lowering-목표"><a class="header" href="#lowering-목표">Lowering 목표</a></h3>
<p><strong>Before lowering (FunLang dialect):</strong></p>
<pre><code class="language-mlir">%closure = funlang.closure @lambda, %n : !funlang.closure
%result = funlang.apply %closure(%x) : (i32) -&gt; i32
</code></pre>
<p><strong>After lowering (LLVM dialect):</strong></p>
<pre><code class="language-mlir">// funlang.closure → GC_malloc + getelementptr + store
%env_size = arith.constant 16 : i64
%env = llvm.call @GC_malloc(%env_size) : (i64) -&gt; !llvm.ptr
%fn_ptr = llvm.mlir.addressof @lambda : !llvm.ptr
%slot0 = llvm.getelementptr %env[0] : (!llvm.ptr) -&gt; !llvm.ptr
llvm.store %fn_ptr, %slot0 : !llvm.ptr, !llvm.ptr
%slot1 = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
llvm.store %n, %slot1 : i32, !llvm.ptr

// funlang.apply → getelementptr + load + llvm.call
%fn_ptr_addr = llvm.getelementptr %env[0] : (!llvm.ptr) -&gt; !llvm.ptr
%fn_ptr = llvm.load %fn_ptr_addr : !llvm.ptr -&gt; !llvm.ptr
%result = llvm.call %fn_ptr(%env, %x) : (!llvm.ptr, i32) -&gt; i32
</code></pre>
<p><strong>Lowering은 Chapter 12-13의 패턴을 재사용한다.</strong> 수동으로 작성하던 코드를, 이제 compiler pass가 자동으로 생성한다.</p>
<h3 id="chapter-16-목표"><a class="header" href="#chapter-16-목표">Chapter 16 목표</a></h3>
<p>이 장을 마치면:</p>
<ol>
<li>
<p><strong>DialectConversion framework 이해</strong></p>
<ul>
<li><code>ConversionTarget</code>: 어떤 dialect가 합법적인가?</li>
<li><code>RewritePatternSet</code>: 어떻게 변환하는가?</li>
<li><code>TypeConverter</code>: 타입은 어떻게 변환하는가?</li>
</ul>
</li>
<li>
<p><strong>ConversionPattern 작성 능력</strong></p>
<ul>
<li><code>ClosureOpLowering</code>: <code>funlang.closure</code> → LLVM operations</li>
<li><code>ApplyOpLowering</code>: <code>funlang.apply</code> → LLVM operations</li>
</ul>
</li>
<li>
<p><strong>DRR (Declarative Rewrite Rules) 이해</strong></p>
<ul>
<li>TableGen 기반 패턴 매칭</li>
<li>최적화 패턴 작성 (empty closure, known closure inlining)</li>
</ul>
</li>
<li>
<p><strong>Complete lowering pass 구현</strong></p>
<ul>
<li>Pass 등록 및 실행</li>
<li>C API shim 작성</li>
<li>F#에서 pass 호출</li>
</ul>
</li>
<li>
<p><strong>End-to-end 이해</strong></p>
<ul>
<li>FunLang source → LLVM IR → executable</li>
<li>전체 컴파일 파이프라인</li>
</ul>
</li>
</ol>
<p><strong>성공 기준:</strong></p>
<pre><code class="language-fsharp">// F# source
let makeAdder n = fun x -&gt; x + n
let add5 = makeAdder 5
let result = add5 10   // 15

// Compile and run
let mlir = compileFunLang source
let mlir' = lowerFunLangToLLVM mlir  // &lt;- Chapter 16!
let llvmir = translateToLLVMIR mlir'
let executable = compileAndLink llvmir
runExecutable executable  // Prints: 15
</code></pre>
<p><strong>Chapter 16 roadmap:</strong></p>
<ol>
<li><strong>DialectConversion Framework</strong> (350+ lines)</li>
<li><strong>ClosureOp Lowering Pattern</strong> (450+ lines)</li>
<li><strong>ApplyOp Lowering Pattern</strong> (350+ lines)</li>
<li><strong>TypeConverter for FunLang Types</strong> (250+ lines)</li>
<li><strong>Declarative Rewrite Rules (DRR)</strong> (300+ lines)</li>
<li><strong>Complete Lowering Pass</strong> (250+ lines)</li>
<li><strong>End-to-End Example</strong> (200+ lines)</li>
<li><strong>Common Errors</strong> (100+ lines)</li>
<li><strong>Summary</strong> (50+ lines)</li>
</ol>
<hr>
<h2 id="dialectconversion-framework"><a class="header" href="#dialectconversion-framework">DialectConversion Framework</a></h2>
<p>MLIR의 <strong>DialectConversion framework</strong>는 dialect 간 변환을 위한 인프라다. 핵심 개념 3가지:</p>
<ol>
<li><strong>ConversionTarget</strong>: 변환 후 허용되는 operations</li>
<li><strong>RewritePatternSet</strong>: 변환 규칙 집합</li>
<li><strong>TypeConverter</strong>: 타입 변환 규칙</li>
</ol>
<h3 id="conversiontarget-legal-vs-illegal-operations"><a class="header" href="#conversiontarget-legal-vs-illegal-operations">ConversionTarget: Legal vs Illegal Operations</a></h3>
<p><strong>ConversionTarget</strong>은 “변환 후 어떤 operations가 남아도 되는가?“를 정의한다.</p>
<pre><code class="language-cpp">ConversionTarget target(getContext());

// Legal: 이 dialects의 operations는 변환 후에도 OK
target.addLegalDialect&lt;LLVM::LLVMDialect&gt;();
target.addLegalDialect&lt;func::FuncDialect&gt;();
target.addLegalDialect&lt;arith::ArithDialect&gt;();

// Illegal: 이 dialects의 operations는 반드시 변환되어야 함
target.addIllegalDialect&lt;funlang::FunLangDialect&gt;();
</code></pre>
<p><strong>의미:</strong></p>
<ul>
<li><strong>Legal dialect</strong>: 최종 IR에 존재해도 된다</li>
<li><strong>Illegal dialect</strong>: 최종 IR에 존재하면 안 된다 (변환 필수)</li>
</ul>
<p><strong>예시: FunLangToLLVM pass</strong></p>
<pre><code class="language-cpp">ConversionTarget target(getContext());

// Legal: LLVM operations는 OK (최종 목표)
target.addLegalDialect&lt;LLVM::LLVMDialect&gt;();

// Legal: func operations는 OK (func.func, func.return 필요)
target.addLegalDialect&lt;func::FuncDialect&gt;();

// Legal: arith operations는 OK (상수, 산술 연산)
target.addLegalDialect&lt;arith::ArithDialect&gt;();

// Illegal: FunLang operations는 반드시 lowering되어야 함
target.addIllegalDialect&lt;funlang::FunLangDialect&gt;();
</code></pre>
<p><strong>변환 후:</strong></p>
<pre><code class="language-mlir">// OK - func.func (legal)
func.func @foo() {
    // OK - arith.constant (legal)
    %c = arith.constant 10 : i32

    // OK - llvm.call (legal)
    %ptr = llvm.call @GC_malloc(...) : (...) -&gt; !llvm.ptr

    // ERROR - funlang.closure (illegal!)
    %closure = funlang.closure @bar : !funlang.closure
}
</code></pre>
<p><code>funlang.closure</code>가 남아있으면 <strong>conversion failure</strong>다.</p>
<h3 id="addlegalop-vs-addillegalop-fine-grained-control"><a class="header" href="#addlegalop-vs-addillegalop-fine-grained-control">addLegalOp vs addIllegalOp: Fine-grained Control</a></h3>
<p>Dialect 전체가 아니라 <strong>특정 operation</strong>만 제어할 수도 있다.</p>
<pre><code class="language-cpp">// FuncDialect 전체가 아니라 특정 operations만 legal
target.addLegalOp&lt;func::FuncOp, func::ReturnOp&gt;();

// 특정 operation만 illegal
target.addIllegalOp&lt;funlang::ClosureOp, funlang::ApplyOp&gt;();
</code></pre>
<p><strong>사용 사례:</strong> Partial lowering (일부만 변환)</p>
<pre><code class="language-cpp">// SCF dialect 중 일부는 legal (scf.while은 그대로 둠)
target.addLegalDialect&lt;scf::SCFDialect&gt;();
target.addIllegalOp&lt;scf::IfOp&gt;();  // scf.if만 lowering
</code></pre>
<h3 id="adddynamicallylegalop-conditional-legality"><a class="header" href="#adddynamicallylegalop-conditional-legality">addDynamicallyLegalOp: Conditional Legality</a></h3>
<p><strong>Dynamic legality</strong>: 런타임에 판단한다.</p>
<pre><code class="language-cpp">target.addDynamicallyLegalOp&lt;func::CallOp&gt;(
    [](func::CallOp op) {
        // FunLang 타입을 사용하는 call은 illegal (변환 필요)
        return !llvm::any_of(op.getOperandTypes(), [](Type type) {
            return type.isa&lt;funlang::ClosureType&gt;();
        });
    }
);
</code></pre>
<p><strong>의미:</strong> <code>func.call</code>이 <code>!funlang.closure</code> 타입을 사용하면 illegal (lowering 필요). 그렇지 않으면 legal (그대로 둠).</p>
<p><strong>사용 사례:</strong> 타입 의존적 변환</p>
<pre><code class="language-mlir">// Legal (i32 타입만 사용)
%result = func.call @add(%x, %y) : (i32, i32) -&gt; i32

// Illegal (funlang.closure 타입 사용)
%result = func.call @apply(%closure, %x) : (!funlang.closure, i32) -&gt; i32
</code></pre>
<h3 id="rewritepatternset-변환-규칙-집합"><a class="header" href="#rewritepatternset-변환-규칙-집합">RewritePatternSet: 변환 규칙 집합</a></h3>
<p><strong>RewritePatternSet</strong>은 “어떻게 변환하는가?“를 정의한다.</p>
<pre><code class="language-cpp">RewritePatternSet patterns(&amp;getContext());

// ConversionPattern 추가
patterns.add&lt;ClosureOpLowering&gt;(&amp;getContext());
patterns.add&lt;ApplyOpLowering&gt;(&amp;getContext());

// 여러 patterns를 한 번에 추가
patterns.add&lt;ClosureOpLowering, ApplyOpLowering, MatchOpLowering&gt;(&amp;getContext());
</code></pre>
<p><strong>Pattern의 역할:</strong></p>
<ul>
<li>특정 operation을 매치한다 (<code>funlang.closure</code>)</li>
<li>새로운 operations로 교체한다 (LLVM operations)</li>
</ul>
<h3 id="applypartialconversion-vs-applyfullconversion"><a class="header" href="#applypartialconversion-vs-applyfullconversion">applyPartialConversion vs applyFullConversion</a></h3>
<p>변환을 실행하는 방법 2가지:</p>
<p><strong>1. applyPartialConversion: 부분 변환</strong></p>
<pre><code class="language-cpp">if (failed(applyPartialConversion(moduleOp, target, std::move(patterns)))) {
    signalPassFailure();
}
</code></pre>
<ul>
<li><strong>일부 illegal operations가 남아도 OK</strong> (변환 패턴이 없으면 그냥 둠)</li>
<li><strong>사용 사례:</strong> Multi-stage lowering (여러 pass로 나눔)</li>
</ul>
<p><strong>2. applyFullConversion: 완전 변환</strong></p>
<pre><code class="language-cpp">if (failed(applyFullConversion(moduleOp, target, std::move(patterns)))) {
    signalPassFailure();
}
</code></pre>
<ul>
<li><strong>모든 illegal operations를 변환해야 함</strong> (하나라도 남으면 failure)</li>
<li><strong>사용 사례:</strong> Final lowering pass (더 이상 illegal operations 없어야 함)</li>
</ul>
<p><strong>FunLangToLLVM pass: Partial conversion 사용</strong></p>
<pre><code class="language-cpp">// Partial conversion: 다른 dialect의 operations는 나중에 lowering
if (failed(applyPartialConversion(getOperation(), target, std::move(patterns)))) {
    signalPassFailure();
}
</code></pre>
<p><strong>왜 Partial?</strong></p>
<ul>
<li><code>arith</code> operations는 나중에 별도 pass로 lowering (<code>--convert-arith-to-llvm</code>)</li>
<li><code>func</code> operations도 별도 pass로 lowering (<code>--convert-func-to-llvm</code>)</li>
<li>FunLang operations만 먼저 lowering</li>
</ul>
<h3 id="typeconverter-타입-변환"><a class="header" href="#typeconverter-타입-변환">TypeConverter: 타입 변환</a></h3>
<p><strong>TypeConverter</strong>는 “타입을 어떻게 변환하는가?“를 정의한다.</p>
<pre><code class="language-cpp">TypeConverter typeConverter;

// FunLang 타입 → LLVM 타입
typeConverter.addConversion([](funlang::ClosureType type) {
    return LLVM::LLVMPointerType::get(type.getContext());
});

typeConverter.addConversion([](funlang::ListType type) {
    return LLVM::LLVMPointerType::get(type.getContext());
});

// 기본 타입은 그대로
typeConverter.addConversion([](Type type) {
    return type;  // i32, i64 etc.
});
</code></pre>
<p><strong>변환 예시:</strong></p>
<pre><code class="language-mlir">// Before
%closure : !funlang.closure

// After
%closure : !llvm.ptr
</code></pre>
<p><strong>TypeConverter의 역할:</strong></p>
<ol>
<li>
<p><strong>Operation result types 변환</strong></p>
<pre><code class="language-cpp">Type resultType = typeConverter.convertType(op.getResult().getType());
</code></pre>
</li>
<li>
<p><strong>Function signatures 변환</strong></p>
<pre><code class="language-mlir">// Before
func.func @apply(%f: !funlang.closure) -&gt; i32

// After
func.func @apply(%f: !llvm.ptr) -&gt; i32
</code></pre>
</li>
<li>
<p><strong>Block arguments 변환</strong> (region 내부 타입)</p>
</li>
</ol>
<p><strong>Conversion patterns에서 TypeConverter 사용:</strong></p>
<pre><code class="language-cpp">struct ApplyOpLowering : public OpConversionPattern&lt;funlang::ApplyOp&gt; {
  using OpConversionPattern&lt;funlang::ApplyOp&gt;::OpConversionPattern;

  LogicalResult matchAndRewrite(
      funlang::ApplyOp op, OpAdaptor adaptor,
      ConversionPatternRewriter &amp;rewriter) const override {

    // TypeConverter를 통해 result type 변환
    Type resultType = getTypeConverter()-&gt;convertType(op.getResult().getType());

    // ...
  }
};
</code></pre>
<p><strong>ConversionPattern에 TypeConverter 전달:</strong></p>
<pre><code class="language-cpp">RewritePatternSet patterns(&amp;getContext());
patterns.add&lt;ApplyOpLowering&gt;(&amp;getContext(), typeConverter);
//                                           ^^^^^^^^^^^^^^
//                                           TypeConverter 전달
</code></pre>
<h3 id="변환-실패-처리"><a class="header" href="#변환-실패-처리">변환 실패 처리</a></h3>
<p>변환이 실패하면 pass가 실패를 알려야 한다.</p>
<pre><code class="language-cpp">void runOnOperation() override {
    // ...

    if (failed(applyPartialConversion(getOperation(), target, std::move(patterns)))) {
        // 변환 실패 시그널
        signalPassFailure();
        return;
    }
}
</code></pre>
<p><strong>실패 원인:</strong></p>
<ol>
<li><strong>Illegal operation이 남음</strong>: Pattern이 없거나 매치 실패</li>
<li><strong>타입 변환 실패</strong>: TypeConverter에 규칙 없음</li>
<li><strong>Pattern이 failure 반환</strong>: <code>matchAndRewrite</code>에서 <code>failure()</code> 리턴</li>
</ol>
<p><strong>디버깅:</strong></p>
<pre><code class="language-bash"># Verbose mode로 실행
mlir-opt --funlang-to-llvm --debug input.mlir

# 에러 메시지 예시:
# error: failed to legalize operation 'funlang.closure'
# note: see current operation: %0 = "funlang.closure"() ...
</code></pre>
<h3 id="dialectconversion-전체-흐름"><a class="header" href="#dialectconversion-전체-흐름">DialectConversion 전체 흐름</a></h3>
<p><strong>1. Target 정의:</strong></p>
<pre><code class="language-cpp">ConversionTarget target(getContext());
target.addLegalDialect&lt;LLVM::LLVMDialect&gt;();
target.addIllegalDialect&lt;funlang::FunLangDialect&gt;();
</code></pre>
<p><strong>2. TypeConverter 설정:</strong></p>
<pre><code class="language-cpp">TypeConverter typeConverter;
typeConverter.addConversion([](funlang::ClosureType type) {
    return LLVM::LLVMPointerType::get(type.getContext());
});
</code></pre>
<p><strong>3. Patterns 구성:</strong></p>
<pre><code class="language-cpp">RewritePatternSet patterns(&amp;getContext());
patterns.add&lt;ClosureOpLowering, ApplyOpLowering&gt;(&amp;getContext(), typeConverter);
</code></pre>
<p><strong>4. 변환 실행:</strong></p>
<pre><code class="language-cpp">if (failed(applyPartialConversion(getOperation(), target, std::move(patterns)))) {
    signalPassFailure();
}
</code></pre>
<p><strong>5. 검증:</strong></p>
<p>변환 후 IR에 illegal operations가 없는지 확인.</p>
<pre><code class="language-mlir">// 변환 전
%closure = funlang.closure @foo : !funlang.closure

// 변환 후
%env = llvm.call @GC_malloc(...) : (...) -&gt; !llvm.ptr
// ... (LLVM operations only)
</code></pre>
<hr>
<h2 id="closureop-lowering-pattern"><a class="header" href="#closureop-lowering-pattern">ClosureOp Lowering Pattern</a></h2>
<p><strong><code>funlang.closure</code>를 LLVM dialect로 lowering한다.</strong> Chapter 12의 클로저 생성 패턴을 재사용한다.</p>
<h3 id="chapter-12-복습-클로저-생성-패턴"><a class="header" href="#chapter-12-복습-클로저-생성-패턴">Chapter 12 복습: 클로저 생성 패턴</a></h3>
<p><strong>Closure 구조 (Chapter 12):</strong></p>
<pre><code>Environment layout (heap-allocated):
+--------+----------+----------+-----+
| fn_ptr | var1     | var2     | ... |
+--------+----------+----------+-----+
  slot 0   slot 1     slot 2
  8 bytes  variable   variable
</code></pre>
<p><strong>클로저 생성 MLIR (Chapter 12):</strong></p>
<pre><code class="language-mlir">func.func @make_adder(%n: i32) -&gt; !llvm.ptr {
    // 1. 환경 크기 계산: 8 (fn_ptr) + 8 (n)
    %env_size = arith.constant 16 : i64

    // 2. GC_malloc 호출
    %env = llvm.call @GC_malloc(%env_size) : (i64) -&gt; !llvm.ptr

    // 3. 함수 포인터 저장 (slot 0)
    %fn_ptr = llvm.mlir.addressof @lambda_adder : !llvm.ptr
    %slot0 = llvm.getelementptr %env[0] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %fn_ptr, %slot0 : !llvm.ptr, !llvm.ptr

    // 4. 캡처된 변수 n 저장 (slot 1)
    %slot1 = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %n, %slot1 : i32, !llvm.ptr

    // 5. 환경 포인터 반환
    func.return %env : !llvm.ptr
}
</code></pre>
<p><strong>Lowering 목표:</strong> <code>funlang.closure</code>를 위 패턴으로 확장한다.</p>
<h3 id="funlangclosure-operation-chapter-15-복습"><a class="header" href="#funlangclosure-operation-chapter-15-복습">funlang.closure Operation (Chapter 15 복습)</a></h3>
<p><strong>ODS 정의:</strong></p>
<pre><code class="language-tablegen">def FunLang_ClosureOp : FunLang_Op&lt;"closure", [Pure]&gt; {
  let summary = "Create a closure";

  let arguments = (ins
    FlatSymbolRefAttr:$callee,
    Variadic&lt;AnyType&gt;:$captured
  );

  let results = (outs FunLang_ClosureType:$result);

  let assemblyFormat = "$callee `,` $captured attr-dict `:` type($result)";
}
</code></pre>
<p><strong>사용 예시:</strong></p>
<pre><code class="language-mlir">// 캡처 변수 없음
%closure = funlang.closure @foo : !funlang.closure

// 캡처 변수 1개
%closure = funlang.closure @bar, %n : !funlang.closure

// 캡처 변수 여러 개
%closure = funlang.closure @baz, %x, %y, %z : !funlang.closure
</code></pre>
<h3 id="closureop-lowering-전략"><a class="header" href="#closureop-lowering-전략">ClosureOp Lowering 전략</a></h3>
<p><strong>입력:</strong> <code>funlang.closure @callee, %captured... : !funlang.closure</code></p>
<p><strong>출력:</strong> LLVM dialect operations</p>
<ol>
<li><strong>환경 크기 계산</strong>: <code>8 + (captured 개수 * 8)</code> bytes</li>
<li><strong>GC_malloc 호출</strong>: 환경 힙 할당</li>
<li><strong>함수 포인터 저장</strong>: <code>env[0] = @callee</code></li>
<li><strong>캡처 변수들 저장</strong>: <code>env[1] = captured[0]</code>, <code>env[2] = captured[1]</code>, …</li>
<li><strong>환경 포인터 반환</strong>: <code>!llvm.ptr</code></li>
</ol>
<h3 id="conversionpattern-구조"><a class="header" href="#conversionpattern-구조">ConversionPattern 구조</a></h3>
<p><strong>OpConversionPattern 템플릿:</strong></p>
<pre><code class="language-cpp">struct ClosureOpLowering : public OpConversionPattern&lt;funlang::ClosureOp&gt; {
  using OpConversionPattern&lt;funlang::ClosureOp&gt;::OpConversionPattern;

  LogicalResult matchAndRewrite(
      funlang::ClosureOp op,           // 원본 operation
      OpAdaptor adaptor,                // 변환된 operands
      ConversionPatternRewriter &amp;rewriter  // IR 수정 도구
  ) const override {

    // Lowering 로직 구현

    return success();  // 또는 failure()
  }
};
</code></pre>
<p><strong>핵심 파라미터:</strong></p>
<ol>
<li>
<p><strong><code>op</code></strong>: 원본 <code>funlang.closure</code> operation</p>
<ul>
<li><code>op.getLoc()</code>: source location</li>
<li><code>op.getCalleeAttr()</code>: 함수 심볼 (<code>@callee</code>)</li>
<li><code>op.getResult()</code>: result value</li>
</ul>
</li>
<li>
<p><strong><code>adaptor</code></strong>: 변환된 operands</p>
<ul>
<li><code>adaptor.getCaptured()</code>: 캡처된 변수들 (타입 이미 변환됨)</li>
</ul>
</li>
<li>
<p><strong><code>rewriter</code></strong>: IR 빌더</p>
<ul>
<li><code>rewriter.create&lt;...&gt;()</code>: 새 operation 생성</li>
<li><code>rewriter.replaceOp()</code>: 원본 operation 교체</li>
</ul>
</li>
</ol>
<h3 id="closureoplowering-구현-complete"><a class="header" href="#closureoplowering-구현-complete">ClosureOpLowering 구현 (Complete)</a></h3>
<pre><code class="language-cpp">struct ClosureOpLowering : public OpConversionPattern&lt;funlang::ClosureOp&gt; {
  using OpConversionPattern&lt;funlang::ClosureOp&gt;::OpConversionPattern;

  LogicalResult matchAndRewrite(
      funlang::ClosureOp op, OpAdaptor adaptor,
      ConversionPatternRewriter &amp;rewriter) const override {

    auto loc = op.getLoc();
    auto ctx = rewriter.getContext();

    // ==============================
    // 1. 환경 크기 계산
    // ==============================
    size_t numCaptured = adaptor.getCaptured().size();

    // fn_ptr (8 bytes) + captured vars (8 bytes each)
    // 단순화: 모든 변수를 8 bytes로 가정 (포인터 크기)
    size_t envSize = 8 + numCaptured * 8;

    auto i64Type = rewriter.getI64Type();
    auto envSizeConst = rewriter.create&lt;arith::ConstantOp&gt;(
        loc, i64Type, rewriter.getI64IntegerAttr(envSize));

    // ==============================
    // 2. GC_malloc 호출
    // ==============================
    auto ptrType = LLVM::LLVMPointerType::get(ctx);
    auto gcMalloc = rewriter.create&lt;LLVM::CallOp&gt;(
        loc, ptrType, "GC_malloc", ValueRange{envSizeConst});
    Value envPtr = gcMalloc.getResult(0);

    // ==============================
    // 3. 함수 포인터 저장 (env[0])
    // ==============================
    auto fnPtrAddr = rewriter.create&lt;LLVM::AddressOfOp&gt;(
        loc, ptrType, op.getCalleeAttr());

    auto slot0 = rewriter.create&lt;LLVM::GEPOp&gt;(
        loc, ptrType, ptrType, envPtr,
        ArrayRef&lt;LLVM::GEPArg&gt;{0});

    rewriter.create&lt;LLVM::StoreOp&gt;(loc, fnPtrAddr, slot0);

    // ==============================
    // 4. 캡처된 변수들 저장 (env[1..])
    // ==============================
    for (auto [idx, val] : llvm::enumerate(adaptor.getCaptured())) {
      auto slot = rewriter.create&lt;LLVM::GEPOp&gt;(
          loc, ptrType, ptrType, envPtr,
          ArrayRef&lt;LLVM::GEPArg&gt;{static_cast&lt;int32_t&gt;(idx + 1)});

      rewriter.create&lt;LLVM::StoreOp&gt;(loc, val, slot);
    }

    // ==============================
    // 5. 원본 operation 교체
    // ==============================
    rewriter.replaceOp(op, envPtr);
    return success();
  }
};
</code></pre>
<h3 id="코드-상세-설명"><a class="header" href="#코드-상세-설명">코드 상세 설명</a></h3>
<h4 id="1-환경-크기-계산"><a class="header" href="#1-환경-크기-계산">1. 환경 크기 계산</a></h4>
<pre><code class="language-cpp">size_t numCaptured = adaptor.getCaptured().size();
size_t envSize = 8 + numCaptured * 8;
</code></pre>
<ul>
<li><strong><code>adaptor.getCaptured()</code></strong>: 캡처된 변수들 (<code>ValueRange</code>)</li>
<li><strong>환경 레이아웃</strong>: <code>[fn_ptr(8), var1(8), var2(8), ...]</code></li>
<li><strong>단순화</strong>: 모든 변수를 8 bytes로 가정 (실제로는 타입별 크기 계산 필요)</li>
</ul>
<p><strong>arith.constant 생성:</strong></p>
<pre><code class="language-cpp">auto envSizeConst = rewriter.create&lt;arith::ConstantOp&gt;(
    loc, i64Type, rewriter.getI64IntegerAttr(envSize));
</code></pre>
<ul>
<li><strong><code>arith.constant 16 : i64</code></strong> 생성 (캡처 변수 1개일 때)</li>
<li><code>GC_malloc</code>에 전달할 인자</li>
</ul>
<h4 id="2-gc_malloc-호출"><a class="header" href="#2-gc_malloc-호출">2. GC_malloc 호출</a></h4>
<pre><code class="language-cpp">auto ptrType = LLVM::LLVMPointerType::get(ctx);
auto gcMalloc = rewriter.create&lt;LLVM::CallOp&gt;(
    loc, ptrType, "GC_malloc", ValueRange{envSizeConst});
Value envPtr = gcMalloc.getResult(0);
</code></pre>
<ul>
<li><strong><code>LLVM::CallOp</code></strong>: <code>llvm.call</code> operation 생성</li>
<li><strong>함수 이름</strong>: <code>"GC_malloc"</code> (string, external function)</li>
<li><strong>인자</strong>: <code>ValueRange{envSizeConst}</code> (환경 크기)</li>
<li><strong>반환 타입</strong>: <code>!llvm.ptr</code></li>
</ul>
<p><strong>생성된 MLIR:</strong></p>
<pre><code class="language-mlir">%0 = llvm.call @GC_malloc(%env_size) : (i64) -&gt; !llvm.ptr
</code></pre>
<h4 id="3-함수-포인터-저장"><a class="header" href="#3-함수-포인터-저장">3. 함수 포인터 저장</a></h4>
<pre><code class="language-cpp">auto fnPtrAddr = rewriter.create&lt;LLVM::AddressOfOp&gt;(
    loc, ptrType, op.getCalleeAttr());
</code></pre>
<ul>
<li><strong><code>LLVM::AddressOfOp</code></strong>: <code>llvm.mlir.addressof</code> operation</li>
<li><strong>심볼</strong>: <code>op.getCalleeAttr()</code> (예: <code>@lambda_adder</code>)</li>
<li><strong>타입</strong>: <code>!llvm.ptr</code></li>
</ul>
<p><strong>생성된 MLIR:</strong></p>
<pre><code class="language-mlir">%fn_ptr = llvm.mlir.addressof @lambda_adder : !llvm.ptr
</code></pre>
<p><strong>GEPOp으로 slot 0 주소 계산:</strong></p>
<pre><code class="language-cpp">auto slot0 = rewriter.create&lt;LLVM::GEPOp&gt;(
    loc, ptrType, ptrType, envPtr,
    ArrayRef&lt;LLVM::GEPArg&gt;{0});
</code></pre>
<ul>
<li><strong><code>LLVM::GEPOp</code></strong>: <code>llvm.getelementptr</code> operation</li>
<li><strong>베이스 포인터</strong>: <code>envPtr</code></li>
<li><strong>인덱스</strong>: <code>{0}</code> (첫 번째 슬롯)</li>
<li><strong>타입</strong>: <code>!llvm.ptr</code> (opaque pointer, LLVM 15+)</li>
</ul>
<p><strong>생성된 MLIR:</strong></p>
<pre><code class="language-mlir">%slot0 = llvm.getelementptr %env[0] : (!llvm.ptr) -&gt; !llvm.ptr
</code></pre>
<p><strong>함수 포인터 저장:</strong></p>
<pre><code class="language-cpp">rewriter.create&lt;LLVM::StoreOp&gt;(loc, fnPtrAddr, slot0);
</code></pre>
<p><strong>생성된 MLIR:</strong></p>
<pre><code class="language-mlir">llvm.store %fn_ptr, %slot0 : !llvm.ptr, !llvm.ptr
</code></pre>
<h4 id="4-캡처된-변수들-저장"><a class="header" href="#4-캡처된-변수들-저장">4. 캡처된 변수들 저장</a></h4>
<pre><code class="language-cpp">for (auto [idx, val] : llvm::enumerate(adaptor.getCaptured())) {
  auto slot = rewriter.create&lt;LLVM::GEPOp&gt;(
      loc, ptrType, ptrType, envPtr,
      ArrayRef&lt;LLVM::GEPArg&gt;{static_cast&lt;int32_t&gt;(idx + 1)});

  rewriter.create&lt;LLVM::StoreOp&gt;(loc, val, slot);
}
</code></pre>
<ul>
<li><strong><code>llvm::enumerate</code></strong>: <code>(index, value)</code> 쌍으로 순회</li>
<li><strong>인덱스</strong>: <code>idx + 1</code> (slot 0은 함수 포인터, slot 1부터 변수)</li>
<li><strong>각 변수를 GEP + store</strong></li>
</ul>
<p><strong>캡처 변수 2개일 때 생성된 MLIR:</strong></p>
<pre><code class="language-mlir">// 첫 번째 변수 (%n)
%slot1 = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
llvm.store %n, %slot1 : i32, !llvm.ptr

// 두 번째 변수 (%m)
%slot2 = llvm.getelementptr %env[2] : (!llvm.ptr) -&gt; !llvm.ptr
llvm.store %m, %slot2 : i32, !llvm.ptr
</code></pre>
<h4 id="5-원본-operation-교체"><a class="header" href="#5-원본-operation-교체">5. 원본 operation 교체</a></h4>
<pre><code class="language-cpp">rewriter.replaceOp(op, envPtr);
return success();
</code></pre>
<ul>
<li><strong><code>rewriter.replaceOp(op, envPtr)</code></strong>: <code>funlang.closure</code>를 <code>envPtr</code>로 교체</li>
<li><strong>SSA value 대체</strong>: <code>%closure</code>를 사용하던 곳이 이제 <code>%envPtr</code> 사용</li>
<li><strong><code>return success()</code></strong>: 변환 성공</li>
</ul>
<p><strong>Before:</strong></p>
<pre><code class="language-mlir">%closure = funlang.closure @lambda, %n : !funlang.closure
%result = funlang.apply %closure(%x) : (i32) -&gt; i32
</code></pre>
<p><strong>After:</strong></p>
<pre><code class="language-mlir">%env_size = arith.constant 16 : i64
%envPtr = llvm.call @GC_malloc(%env_size) : (i64) -&gt; !llvm.ptr
%fn_ptr = llvm.mlir.addressof @lambda : !llvm.ptr
%slot0 = llvm.getelementptr %envPtr[0] : (!llvm.ptr) -&gt; !llvm.ptr
llvm.store %fn_ptr, %slot0 : !llvm.ptr, !llvm.ptr
%slot1 = llvm.getelementptr %envPtr[1] : (!llvm.ptr) -&gt; !llvm.ptr
llvm.store %n, %slot1 : i32, !llvm.ptr

// %closure가 %envPtr로 교체됨
%result = funlang.apply %envPtr(%x) : (i32) -&gt; i32
</code></pre>
<h3 id="opadaptor의-역할"><a class="header" href="#opadaptor의-역할">OpAdaptor의 역할</a></h3>
<p>**<code>OpAdaptor</code>**는 <strong>변환된 operands</strong>를 제공한다.</p>
<p><strong>왜 필요한가?</strong></p>
<p>Conversion이 여러 단계로 이뤄질 때, operands의 타입이 이미 변환됐을 수 있다.</p>
<p><strong>예시:</strong></p>
<pre><code class="language-mlir">// Before
%captured = funlang.some_op : !funlang.closure
%closure = funlang.closure @foo, %captured : !funlang.closure

// After first pattern
%captured_lowered = ... : !llvm.ptr  // 이미 lowering됨!
%closure = funlang.closure @foo, %captured_lowered : !funlang.closure
</code></pre>
<p><code>ClosureOpLowering</code>이 실행될 때:</p>
<ul>
<li><code>op.getCaptured()[0]</code>는 원본 타입 (<code>!funlang.closure</code>)</li>
<li><code>adaptor.getCaptured()[0]</code>는 변환된 타입 (<code>!llvm.ptr</code>)</li>
</ul>
<p><strong>ConversionPattern에서는 항상 <code>adaptor</code> 사용:</strong></p>
<pre><code class="language-cpp">// 잘못됨!
for (Value val : op.getCaptured()) { ... }  // 원본 타입

// 올바름
for (Value val : adaptor.getCaptured()) { ... }  // 변환된 타입
</code></pre>
<h3 id="conversionpatternrewriter의-역할"><a class="header" href="#conversionpatternrewriter의-역할">ConversionPatternRewriter의 역할</a></h3>
<p>**<code>ConversionPatternRewriter</code>**는 <strong>IR 수정 인터페이스</strong>다.</p>
<p><strong>주요 메서드:</strong></p>
<pre><code class="language-cpp">// Operation 생성
auto newOp = rewriter.create&lt;SomeOp&gt;(loc, ...);

// Operation 교체
rewriter.replaceOp(oldOp, newValue);

// Operation 삭제
rewriter.eraseOp(op);

// 타입 변환
Type newType = rewriter.getTypeConverter()-&gt;convertType(oldType);

// 상수 생성 헬퍼
auto i32Type = rewriter.getI32Type();
auto attr = rewriter.getI32IntegerAttr(42);
</code></pre>
<p><strong>왜 일반 <code>OpBuilder</code>가 아닌가?</strong></p>
<p>Conversion framework는 <strong>transactional semantics</strong>를 제공한다:</p>
<ul>
<li>변환 실패 시 모든 변경 롤백</li>
<li>Operand mapping 자동 처리</li>
<li>Type conversion tracking</li>
</ul>
<p><strong>일반 rewriter 사용 금지:</strong></p>
<pre><code class="language-cpp">// 잘못됨!
OpBuilder builder(op.getContext());
builder.setInsertionPoint(op);
builder.create&lt;...&gt;(...);

// 올바름
rewriter.setInsertionPoint(op);
rewriter.create&lt;...&gt;(...);
</code></pre>
<h3 id="closureoplowering-테스트"><a class="header" href="#closureoplowering-테스트">ClosureOpLowering 테스트</a></h3>
<p><strong>입력 MLIR:</strong></p>
<pre><code class="language-mlir">func.func @test(%n: i32) -&gt; !funlang.closure {
    %closure = funlang.closure @lambda, %n : !funlang.closure
    func.return %closure : !funlang.closure
}
</code></pre>
<p><strong>Lowering pass 실행:</strong></p>
<pre><code class="language-bash">mlir-opt --funlang-to-llvm test.mlir
</code></pre>
<p><strong>출력 MLIR:</strong></p>
<pre><code class="language-mlir">func.func @test(%n: i32) -&gt; !llvm.ptr {
    %c16 = arith.constant 16 : i64
    %0 = llvm.call @GC_malloc(%c16) : (i64) -&gt; !llvm.ptr
    %1 = llvm.mlir.addressof @lambda : !llvm.ptr
    %2 = llvm.getelementptr %0[0] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %1, %2 : !llvm.ptr, !llvm.ptr
    %3 = llvm.getelementptr %0[1] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %n, %3 : i32, !llvm.ptr
    func.return %0 : !llvm.ptr
}
</code></pre>
<p><strong>검증:</strong></p>
<ol>
<li><code>funlang.closure</code> 사라짐 ✓</li>
<li><code>GC_malloc</code> 호출 있음 ✓</li>
<li>함수 포인터 저장 있음 ✓</li>
<li>캡처 변수 저장 있음 ✓</li>
<li>반환 타입 <code>!llvm.ptr</code> ✓</li>
</ol>
<h3 id="c-api-shim-preview"><a class="header" href="#c-api-shim-preview">C API Shim (Preview)</a></h3>
<p>Lowering pass를 F#에서 사용하려면 <strong>C API shim</strong>이 필요하다.</p>
<p><strong>C++ Pass 등록:</strong></p>
<pre><code class="language-cpp">// FunLangPasses.cpp
void registerFunLangToLLVMPass() {
  PassRegistration&lt;FunLangToLLVMPass&gt;(
      "funlang-to-llvm",
      "Lower FunLang dialect to LLVM dialect");
}

// C API shim
extern "C" void mlirFunLangRegisterToLLVMPass() {
  registerFunLangToLLVMPass();
}

extern "C" void mlirFunLangRunToLLVMPass(MlirModule module) {
  ModuleOp moduleOp = unwrap(module);
  PassManager pm(moduleOp.getContext());
  pm.addPass(std::make_unique&lt;FunLangToLLVMPass&gt;());
  if (failed(pm.run(moduleOp))) {
    llvm::errs() &lt;&lt; "FunLangToLLVM pass failed\n";
  }
}
</code></pre>
<p><strong>F# P/Invoke:</strong></p>
<pre><code class="language-fsharp">[&lt;DllImport("funlang-dialect", CallingConvention = CallingConvention.Cdecl)&gt;]
extern void mlirFunLangRegisterToLLVMPass()

[&lt;DllImport("funlang-dialect", CallingConvention = CallingConvention.Cdecl)&gt;]
extern void mlirFunLangRunToLLVMPass(MlirModule module)

// 사용
let lowerToLLVM (module_: MlirModule) =
    mlirFunLangRunToLLVMPass(module_)
</code></pre>
<p><strong>전체 pass pipeline 구성:</strong></p>
<pre><code class="language-fsharp">let compileToLLVM (mlir: MlirModule) =
    // 1. FunLang → LLVM
    mlirFunLangRunToLLVMPass(mlir)

    // 2. Arith → LLVM
    mlirRunArithToLLVMPass(mlir)

    // 3. Func → LLVM
    mlirRunFuncToLLVMPass(mlir)

    // 4. LLVM dialect → LLVM IR
    mlirTranslateToLLVMIR(mlir)
</code></pre>
<p><strong>Section 2와 3 요약:</strong></p>
<ul>
<li><strong>DialectConversion framework</strong>: Target + Patterns + TypeConverter</li>
<li><strong>ClosureOpLowering</strong>: <code>funlang.closure</code> → GC_malloc + GEP + store 패턴</li>
<li><strong>OpAdaptor</strong>: 변환된 operands 제공</li>
<li><strong>ConversionPatternRewriter</strong>: IR 수정 인터페이스</li>
<li><strong>C API shim</strong>: F#에서 pass 실행</li>
</ul>
<p><strong>다음 Section:</strong> <code>funlang.apply</code> lowering pattern 구현</p>
<hr>
<h2 id="applyop-lowering-pattern"><a class="header" href="#applyop-lowering-pattern">ApplyOp Lowering Pattern</a></h2>
<p><strong><code>funlang.apply</code>를 LLVM dialect로 lowering한다.</strong> Chapter 13의 간접 호출 패턴을 재사용한다.</p>
<h3 id="chapter-13-복습-간접-호출-패턴"><a class="header" href="#chapter-13-복습-간접-호출-패턴">Chapter 13 복습: 간접 호출 패턴</a></h3>
<p><strong>Closure application (Chapter 13):</strong></p>
<pre><code class="language-mlir">func.func @apply(%f: !llvm.ptr, %x: i32) -&gt; i32 {
    // 1. 환경에서 함수 포인터 로드 (env[0])
    %fn_ptr_addr = llvm.getelementptr %f[0] : (!llvm.ptr) -&gt; !llvm.ptr
    %fn_ptr = llvm.load %fn_ptr_addr : !llvm.ptr -&gt; !llvm.ptr

    // 2. 간접 호출 (fn_ptr를 통해 호출)
    // 첫 번째 인자: 환경 포인터 (%f)
    // 나머지 인자: 실제 인자 (%x)
    %result = llvm.call %fn_ptr(%f, %x) : (!llvm.ptr, i32) -&gt; i32

    func.return %result : i32
}
</code></pre>
<p><strong>핵심 단계:</strong></p>
<ol>
<li><strong>함수 포인터 추출</strong>: <code>env[0]</code>에서 로드</li>
<li><strong>인자 구성</strong>: <code>[환경 포인터, 실제 인자들]</code></li>
<li><strong>간접 호출</strong>: <code>llvm.call %fn_ptr(...)</code></li>
</ol>
<h3 id="funlangapply-operation-chapter-15-복습"><a class="header" href="#funlangapply-operation-chapter-15-복습">funlang.apply Operation (Chapter 15 복습)</a></h3>
<p><strong>ODS 정의:</strong></p>
<pre><code class="language-tablegen">def FunLang_ApplyOp : FunLang_Op&lt;"apply"&gt; {
  let summary = "Apply a closure to arguments";

  let arguments = (ins
    FunLang_ClosureType:$closure,
    Variadic&lt;AnyType&gt;:$args
  );

  let results = (outs AnyType:$result);

  let assemblyFormat = [{
    $closure `(` $args `)` attr-dict `:` functional-type($args, $result)
  }];
}
</code></pre>
<p><strong>사용 예시:</strong></p>
<pre><code class="language-mlir">// 인자 1개
%result = funlang.apply %closure(%x) : (i32) -&gt; i32

// 인자 여러 개
%result = funlang.apply %closure(%x, %y) : (i32, i32) -&gt; i32

// 인자 없음 (thunk)
%result = funlang.apply %closure() : () -&gt; i32
</code></pre>
<h3 id="applyop-lowering-전략"><a class="header" href="#applyop-lowering-전략">ApplyOp Lowering 전략</a></h3>
<p><strong>입력:</strong> <code>%result = funlang.apply %closure(%args...) : (...) -&gt; result_type</code></p>
<p><strong>출력:</strong> LLVM dialect operations</p>
<ol>
<li><strong>함수 포인터 추출</strong>: <code>env[0]</code>에서 로드</li>
<li><strong>인자 리스트 구성</strong>: <code>[closure, args...]</code></li>
<li><strong>간접 호출</strong>: <code>llvm.call %fn_ptr(...)</code></li>
<li><strong>결과 반환</strong>: <code>result_type</code>로 변환</li>
</ol>
<h3 id="applyoplowering-구현-complete"><a class="header" href="#applyoplowering-구현-complete">ApplyOpLowering 구현 (Complete)</a></h3>
<pre><code class="language-cpp">struct ApplyOpLowering : public OpConversionPattern&lt;funlang::ApplyOp&gt; {
  using OpConversionPattern&lt;funlang::ApplyOp&gt;::OpConversionPattern;

  LogicalResult matchAndRewrite(
      funlang::ApplyOp op, OpAdaptor adaptor,
      ConversionPatternRewriter &amp;rewriter) const override {

    auto loc = op.getLoc();
    auto ctx = rewriter.getContext();
    auto ptrType = LLVM::LLVMPointerType::get(ctx);

    // ==============================
    // 1. 함수 포인터 추출 (env[0])
    // ==============================
    Value closure = adaptor.getClosure();

    auto slot0 = rewriter.create&lt;LLVM::GEPOp&gt;(
        loc, ptrType, ptrType, closure,
        ArrayRef&lt;LLVM::GEPArg&gt;{0});

    auto fnPtr = rewriter.create&lt;LLVM::LoadOp&gt;(loc, ptrType, slot0);

    // ==============================
    // 2. 인자 리스트 구성
    // ==============================
    SmallVector&lt;Value&gt; callArgs;

    // 첫 번째 인자: 환경 포인터 (클로저 자체)
    callArgs.push_back(closure);

    // 나머지 인자: 실제 인자들
    callArgs.append(adaptor.getArgs().begin(), adaptor.getArgs().end());

    // ==============================
    // 3. 결과 타입 변환
    // ==============================
    Type resultType = getTypeConverter()-&gt;convertType(op.getResult().getType());

    // ==============================
    // 4. 간접 호출
    // ==============================
    auto call = rewriter.create&lt;LLVM::CallOp&gt;(
        loc, resultType, fnPtr, callArgs);

    // ==============================
    // 5. 원본 operation 교체
    // ==============================
    rewriter.replaceOp(op, call.getResult(0));
    return success();
  }
};
</code></pre>
<h3 id="코드-상세-설명-1"><a class="header" href="#코드-상세-설명-1">코드 상세 설명</a></h3>
<h4 id="1-함수-포인터-추출"><a class="header" href="#1-함수-포인터-추출">1. 함수 포인터 추출</a></h4>
<pre><code class="language-cpp">Value closure = adaptor.getClosure();

auto slot0 = rewriter.create&lt;LLVM::GEPOp&gt;(
    loc, ptrType, ptrType, closure,
    ArrayRef&lt;LLVM::GEPArg&gt;{0});

auto fnPtr = rewriter.create&lt;LLVM::LoadOp&gt;(loc, ptrType, slot0);
</code></pre>
<ul>
<li><strong><code>adaptor.getClosure()</code></strong>: 클로저 포인터 (이미 <code>!llvm.ptr</code>로 변환됨)</li>
<li><strong>GEP</strong>: <code>closure[0]</code> 주소 계산 (함수 포인터 슬롯)</li>
<li><strong>Load</strong>: 함수 포인터 로드</li>
</ul>
<p><strong>생성된 MLIR:</strong></p>
<pre><code class="language-mlir">%slot0 = llvm.getelementptr %closure[0] : (!llvm.ptr) -&gt; !llvm.ptr
%fn_ptr = llvm.load %slot0 : !llvm.ptr -&gt; !llvm.ptr
</code></pre>
<h4 id="2-인자-리스트-구성"><a class="header" href="#2-인자-리스트-구성">2. 인자 리스트 구성</a></h4>
<pre><code class="language-cpp">SmallVector&lt;Value&gt; callArgs;
callArgs.push_back(closure);  // 환경 포인터
callArgs.append(adaptor.getArgs().begin(), adaptor.getArgs().end());
</code></pre>
<ul>
<li><strong>첫 번째 인자</strong>: 클로저 자체 (환경 포인터)</li>
<li><strong>나머지 인자</strong>: 실제 application 인자들</li>
</ul>
<p><strong>예시:</strong></p>
<pre><code class="language-mlir">// funlang.apply %closure(%x, %y)
// callArgs = [%closure, %x, %y]
</code></pre>
<p><strong>왜 closure를 첫 번째 인자로?</strong></p>
<p>Lifted function은 환경 포인터를 첫 번째 파라미터로 받는다:</p>
<pre><code class="language-mlir">func.func @lambda_adder(%env: !llvm.ptr, %x: i32) -&gt; i32 {
    // %env에서 캡처된 변수 접근
    ...
}
</code></pre>
<h4 id="3-결과-타입-변환"><a class="header" href="#3-결과-타입-변환">3. 결과 타입 변환</a></h4>
<pre><code class="language-cpp">Type resultType = getTypeConverter()-&gt;convertType(op.getResult().getType());
</code></pre>
<ul>
<li><strong><code>getTypeConverter()</code></strong>: Pattern에 연결된 TypeConverter</li>
<li><strong><code>convertType()</code></strong>: FunLang 타입 → LLVM 타입</li>
</ul>
<p><strong>변환 예시:</strong></p>
<pre><code class="language-cpp">// funlang.closure → !llvm.ptr
!funlang.closure  -&gt;  !llvm.ptr

// 기본 타입은 그대로
i32  -&gt;  i32
i64  -&gt;  i64
</code></pre>
<p><strong>왜 필요한가?</strong></p>
<p>함수가 클로저를 반환할 수 있다:</p>
<pre><code class="language-mlir">// funlang.apply의 결과가 또 다른 클로저
%closure2 = funlang.apply %closure(%x) : (i32) -&gt; !funlang.closure

// Lowering 후
%closure2 = llvm.call %fn_ptr(%closure, %x) : (!llvm.ptr, i32) -&gt; !llvm.ptr
</code></pre>
<h4 id="4-간접-호출"><a class="header" href="#4-간접-호출">4. 간접 호출</a></h4>
<pre><code class="language-cpp">auto call = rewriter.create&lt;LLVM::CallOp&gt;(
    loc, resultType, fnPtr, callArgs);
</code></pre>
<ul>
<li><strong><code>LLVM::CallOp</code></strong>: <code>llvm.call</code> operation</li>
<li><strong>Callee</strong>: <code>fnPtr</code> (함수 포인터, <code>Value</code>)</li>
<li><strong>인자</strong>: <code>callArgs</code> (환경 + 실제 인자)</li>
<li><strong>반환 타입</strong>: <code>resultType</code></li>
</ul>
<p><strong>일반 호출 vs 간접 호출:</strong></p>
<pre><code class="language-mlir">// 일반 호출 (direct call)
%result = llvm.call @foo(%x) : (i32) -&gt; i32

// 간접 호출 (indirect call)
%result = llvm.call %fn_ptr(%x) : (i32) -&gt; i32
</code></pre>
<p><strong>생성된 MLIR:</strong></p>
<pre><code class="language-mlir">%result = llvm.call %fn_ptr(%closure, %x) : (!llvm.ptr, i32) -&gt; i32
</code></pre>
<h4 id="5-원본-operation-교체-1"><a class="header" href="#5-원본-operation-교체-1">5. 원본 operation 교체</a></h4>
<pre><code class="language-cpp">rewriter.replaceOp(op, call.getResult(0));
return success();
</code></pre>
<ul>
<li><strong><code>call.getResult(0)</code></strong>: <code>llvm.call</code>의 반환 값</li>
<li><strong>교체</strong>: <code>funlang.apply</code> 결과를 <code>llvm.call</code> 결과로 대체</li>
</ul>
<h3 id="applyoplowering-테스트"><a class="header" href="#applyoplowering-테스트">ApplyOpLowering 테스트</a></h3>
<p><strong>입력 MLIR:</strong></p>
<pre><code class="language-mlir">func.func @test(%closure: !funlang.closure, %x: i32) -&gt; i32 {
    %result = funlang.apply %closure(%x) : (i32) -&gt; i32
    func.return %result : i32
}
</code></pre>
<p><strong>Lowering pass 실행:</strong></p>
<pre><code class="language-bash">mlir-opt --funlang-to-llvm test.mlir
</code></pre>
<p><strong>출력 MLIR:</strong></p>
<pre><code class="language-mlir">func.func @test(%closure: !llvm.ptr, %x: i32) -&gt; i32 {
    %0 = llvm.getelementptr %closure[0] : (!llvm.ptr) -&gt; !llvm.ptr
    %1 = llvm.load %0 : !llvm.ptr -&gt; !llvm.ptr
    %2 = llvm.call %1(%closure, %x) : (!llvm.ptr, i32) -&gt; i32
    func.return %2 : i32
}
</code></pre>
<p><strong>검증:</strong></p>
<ol>
<li><code>funlang.apply</code> 사라짐 ✓</li>
<li>GEP + load로 함수 포인터 추출 ✓</li>
<li>간접 호출 (<code>llvm.call %fn_ptr</code>) ✓</li>
<li>인자 리스트 올바름 (<code>%closure, %x</code>) ✓</li>
</ol>
<h3 id="end-to-end-예시-makeadder"><a class="header" href="#end-to-end-예시-makeadder">End-to-End 예시: makeAdder</a></h3>
<p><strong>Phase 5 FunLang dialect:</strong></p>
<pre><code class="language-mlir">func.func @make_adder(%n: i32) -&gt; !funlang.closure {
    %closure = funlang.closure @lambda_adder, %n : !funlang.closure
    func.return %closure : !funlang.closure
}

func.func @lambda_adder(%env: !llvm.ptr, %x: i32) -&gt; i32 {
    %n_slot = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
    %n = llvm.load %n_slot : !llvm.ptr -&gt; i32
    %result = arith.addi %x, %n : i32
    func.return %result : i32
}

func.func @main() -&gt; i32 {
    %c5 = arith.constant 5 : i32
    %c10 = arith.constant 10 : i32

    // makeAdder 5
    %add5 = funlang.closure @lambda_adder, %c5 : !funlang.closure

    // add5 10
    %result = funlang.apply %add5(%c10) : (i32) -&gt; i32

    func.return %result : i32
}
</code></pre>
<p><strong>After FunLangToLLVM pass:</strong></p>
<pre><code class="language-mlir">func.func @make_adder(%n: i32) -&gt; !llvm.ptr {
    // ClosureOpLowering
    %c16 = arith.constant 16 : i64
    %env = llvm.call @GC_malloc(%c16) : (i64) -&gt; !llvm.ptr
    %fn_ptr = llvm.mlir.addressof @lambda_adder : !llvm.ptr
    %slot0 = llvm.getelementptr %env[0] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %fn_ptr, %slot0 : !llvm.ptr, !llvm.ptr
    %slot1 = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %n, %slot1 : i32, !llvm.ptr
    func.return %env : !llvm.ptr
}

func.func @lambda_adder(%env: !llvm.ptr, %x: i32) -&gt; i32 {
    %n_slot = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
    %n = llvm.load %n_slot : !llvm.ptr -&gt; i32
    %result = arith.addi %x, %n : i32
    func.return %result : i32
}

func.func @main() -&gt; i32 {
    %c5 = arith.constant 5 : i32
    %c10 = arith.constant 10 : i32

    // ClosureOpLowering
    %c16 = arith.constant 16 : i64
    %add5 = llvm.call @GC_malloc(%c16) : (i64) -&gt; !llvm.ptr
    %fn_ptr = llvm.mlir.addressof @lambda_adder : !llvm.ptr
    %slot0 = llvm.getelementptr %add5[0] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %fn_ptr, %slot0 : !llvm.ptr, !llvm.ptr
    %slot1 = llvm.getelementptr %add5[1] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %c5, %slot1 : i32, !llvm.ptr

    // ApplyOpLowering
    %fn_ptr_addr = llvm.getelementptr %add5[0] : (!llvm.ptr) -&gt; !llvm.ptr
    %fn_ptr_loaded = llvm.load %fn_ptr_addr : !llvm.ptr -&gt; !llvm.ptr
    %result = llvm.call %fn_ptr_loaded(%add5, %c10) : (!llvm.ptr, i32) -&gt; i32

    func.return %result : i32
}
</code></pre>
<p><strong>실행 흐름 추적:</strong></p>
<ol>
<li><code>%c5</code>, <code>%c10</code> 상수 생성</li>
<li><strong>Closure 생성</strong> (ClosureOpLowering):
<ul>
<li><code>GC_malloc(16)</code> → <code>%add5</code> (환경 포인터)</li>
<li><code>%add5[0] = @lambda_adder</code> (함수 포인터)</li>
<li><code>%add5[1] = 5</code> (캡처된 <code>n</code>)</li>
</ul>
</li>
<li><strong>Closure 호출</strong> (ApplyOpLowering):
<ul>
<li><code>%add5[0]</code> 로드 → <code>%fn_ptr_loaded</code> (함수 포인터)</li>
<li><code>llvm.call %fn_ptr_loaded(%add5, 10)</code></li>
</ul>
</li>
<li><strong>lambda_adder 실행</strong>:
<ul>
<li><code>%env[1]</code> 로드 → <code>%n = 5</code></li>
<li><code>10 + 5 = 15</code></li>
<li>반환: <code>15</code></li>
</ul>
</li>
</ol>
<hr>
<h2 id="typeconverter-for-funlang-types"><a class="header" href="#typeconverter-for-funlang-types">TypeConverter for FunLang Types</a></h2>
<p><strong>TypeConverter</strong>는 FunLang 타입을 LLVM 타입으로 변환한다.</p>
<h3 id="funlang-custom-types-chapter-15"><a class="header" href="#funlang-custom-types-chapter-15">FunLang Custom Types (Chapter 15)</a></h3>
<p><strong>1. funlang.closure:</strong></p>
<pre><code class="language-tablegen">def FunLang_ClosureType : FunLang_Type&lt;"Closure"&gt; {
  let mnemonic = "closure";
  let description = "FunLang closure type (function pointer + environment)";
}
</code></pre>
<p><strong>MLIR 표기:</strong> <code>!funlang.closure</code></p>
<p><strong>2. funlang.list (Phase 6 preview):</strong></p>
<pre><code class="language-tablegen">def FunLang_ListType : FunLang_Type&lt;"List"&gt; {
  let mnemonic = "list";
  let parameters = (ins "Type":$elementType);
  let assemblyFormat = "`&lt;` $elementType `&gt;`";
}
</code></pre>
<p><strong>MLIR 표기:</strong> <code>!funlang.list&lt;i32&gt;</code>, <code>!funlang.list&lt;!funlang.closure&gt;</code></p>
<h3 id="typeconverter-구성"><a class="header" href="#typeconverter-구성">TypeConverter 구성</a></h3>
<pre><code class="language-cpp">TypeConverter typeConverter;

// ==============================
// 1. FunLang 타입 변환
// ==============================

// funlang.closure → !llvm.ptr
typeConverter.addConversion([&amp;](funlang::ClosureType type) {
    return LLVM::LLVMPointerType::get(type.getContext());
});

// funlang.list&lt;T&gt; → !llvm.ptr
typeConverter.addConversion([&amp;](funlang::ListType type) {
    return LLVM::LLVMPointerType::get(type.getContext());
});

// ==============================
// 2. 기본 타입은 그대로
// ==============================
typeConverter.addConversion([](Type type) {
    // i32, i64, i1 등은 변환하지 않음
    return type;
});
</code></pre>
<p><strong>변환 예시:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td><code>!funlang.closure</code></td><td><code>!llvm.ptr</code></td></tr>
<tr><td><code>!funlang.list&lt;i32&gt;</code></td><td><code>!llvm.ptr</code></td></tr>
<tr><td><code>i32</code></td><td><code>i32</code></td></tr>
<tr><td><code>i64</code></td><td><code>i64</code></td></tr>
</tbody>
</table>
</div>
<h3 id="function-signature-변환"><a class="header" href="#function-signature-변환">Function Signature 변환</a></h3>
<p><strong>TypeConverter는 자동으로 function signatures를 변환한다.</strong></p>
<p><strong>Before:</strong></p>
<pre><code class="language-mlir">func.func @apply(%f: !funlang.closure, %x: i32) -&gt; i32 {
    %result = funlang.apply %f(%x) : (i32) -&gt; i32
    func.return %result : i32
}
</code></pre>
<p><strong>After:</strong></p>
<pre><code class="language-mlir">func.func @apply(%f: !llvm.ptr, %x: i32) -&gt; i32 {
    %0 = llvm.getelementptr %f[0] : (!llvm.ptr) -&gt; !llvm.ptr
    %1 = llvm.load %0 : !llvm.ptr -&gt; !llvm.ptr
    %2 = llvm.call %1(%f, %x) : (!llvm.ptr, i32) -&gt; i32
    func.return %2 : i32
}
</code></pre>
<p><strong>변환 지점:</strong></p>
<ul>
<li><strong>파라미터 타입</strong>: <code>%f: !funlang.closure</code> → <code>%f: !llvm.ptr</code></li>
<li><strong>반환 타입</strong>: 여기서는 <code>i32</code> (변환 없음)</li>
<li><strong>Operation result 타입</strong>: <code>funlang.apply</code> 결과 타입 변환</li>
</ul>
<h3 id="materialization-타입-변환-보조"><a class="header" href="#materialization-타입-변환-보조">Materialization: 타입 변환 보조</a></h3>
<p><strong>Materialization</strong>은 타입 변환 중간에 필요한 “접착제” operations을 삽입한다.</p>
<p><strong>사용 사례:</strong> Conversion이 여러 단계로 나뉠 때, 중간 타입 불일치 해결.</p>
<h4 id="source-materialization"><a class="header" href="#source-materialization">Source Materialization</a></h4>
<pre><code class="language-cpp">typeConverter.addSourceMaterialization(
    [](OpBuilder &amp;builder, Type resultType, ValueRange inputs, Location loc) -&gt; Value {
      // 원본 타입 (FunLang) → 중간 타입 변환
      if (resultType.isa&lt;funlang::ClosureType&gt;()) {
        return builder.create&lt;UnrealizedConversionCastOp&gt;(loc, resultType, inputs).getResult(0);
      }
      return nullptr;
    });
</code></pre>
<h4 id="target-materialization"><a class="header" href="#target-materialization">Target Materialization</a></h4>
<pre><code class="language-cpp">typeConverter.addTargetMaterialization(
    [](OpBuilder &amp;builder, Type resultType, ValueRange inputs, Location loc) -&gt; Value {
      // 중간 타입 → 대상 타입 (LLVM) 변환
      if (resultType.isa&lt;LLVM::LLVMPointerType&gt;()) {
        return builder.create&lt;UnrealizedConversionCastOp&gt;(loc, resultType, inputs).getResult(0);
      }
      return nullptr;
    });
</code></pre>
<h4 id="unrealized_conversion_cast"><a class="header" href="#unrealized_conversion_cast">unrealized_conversion_cast</a></h4>
<p><strong>Materialization이 생성하는 operation:</strong></p>
<pre><code class="language-mlir">%cast = builtin.unrealized_conversion_cast %input : !funlang.closure to !llvm.ptr
</code></pre>
<p><strong>의미:</strong> “이 타입 변환은 아직 완료되지 않았다”</p>
<p><strong>최종 lowering 후:</strong></p>
<ul>
<li>모든 <code>unrealized_conversion_cast</code>는 사라져야 한다</li>
<li>남아있으면 conversion failure</li>
</ul>
<p><strong>Phase 5에서는 단순한 변환이므로 materialization 불필요:</strong></p>
<ul>
<li><code>funlang.closure</code> → <code>!llvm.ptr</code> (direct mapping)</li>
<li>중간 타입 없음</li>
</ul>
<h3 id="타입-변환-체인"><a class="header" href="#타입-변환-체인">타입 변환 체인</a></h3>
<p><strong>Multi-stage lowering에서 타입 변환 체인:</strong></p>
<pre><code>Phase 5 FunLang dialect:
  !funlang.closure

Phase 5a (optional): High-level abstractions
  !funlang.env_ptr  (환경 포인터 전용 타입)

Phase 5b (final): LLVM dialect
  !llvm.ptr
</code></pre>
<p><strong>현재 Phase 5 (단순 버전):</strong></p>
<pre><code>!funlang.closure  →  !llvm.ptr  (direct)
</code></pre>
<p><strong>TypeConverter 체인 예시 (multi-stage):</strong></p>
<pre><code class="language-cpp">// Stage 1: FunLang → HighLevel
TypeConverter highLevelConverter;
highLevelConverter.addConversion([](funlang::ClosureType type) {
    return funlang::EnvPtrType::get(type.getContext());
});

// Stage 2: HighLevel → LLVM
TypeConverter llvmConverter;
llvmConverter.addConversion([](funlang::EnvPtrType type) {
    return LLVM::LLVMPointerType::get(type.getContext());
});
</code></pre>
<hr>
<h2 id="declarative-rewrite-rules-drr"><a class="header" href="#declarative-rewrite-rules-drr">Declarative Rewrite Rules (DRR)</a></h2>
<p>**DRR (Declarative Rewrite Rules)**은 <strong>TableGen 기반 패턴 매칭 시스템</strong>이다. C++ ConversionPattern보다 간단한 변환을 선언적으로 작성할 수 있다.</p>
<h3 id="drr이란"><a class="header" href="#drr이란">DRR이란?</a></h3>
<p><strong>DRR</strong>은 MLIR의 패턴 매칭 DSL이다:</p>
<ul>
<li><strong>입력</strong>: <code>.td</code> 파일에 패턴 작성</li>
<li><strong>출력</strong>: C++ 코드 자동 생성 (mlir-tblgen)</li>
<li><strong>용도</strong>: 최적화, 정규화, 간단한 lowering</li>
</ul>
<p><strong>DRR vs C++ ConversionPattern:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>DRR</th><th>C++ ConversionPattern</th></tr>
</thead>
<tbody>
<tr><td><strong>문법</strong></td><td>선언적 (TableGen)</td><td>명령형 (C++)</td></tr>
<tr><td><strong>복잡도</strong></td><td>간단한 패턴</td><td>복잡한 로직 가능</td></tr>
<tr><td><strong>제어 흐름</strong></td><td>없음 (순수 매칭)</td><td>if/for/while 가능</td></tr>
<tr><td><strong>타입 안전성</strong></td><td>컴파일 타임</td><td>런타임 검증</td></tr>
<tr><td><strong>디버깅</strong></td><td>어려움</td><td>쉬움 (breakpoint)</td></tr>
</tbody>
</table>
</div>
<p><strong>언제 DRR을 사용하는가?</strong></p>
<ul>
<li>✓ 1:1 operation 변환 (A → B)</li>
<li>✓ 간단한 패턴 매칭 (조건 1-2개)</li>
<li>✓ 최적화 패턴 (constant folding, peephole)</li>
</ul>
<p><strong>언제 C++를 사용하는가?</strong></p>
<ul>
<li>✓ 복잡한 변환 로직 (ClosureOpLowering처럼 여러 ops 생성)</li>
<li>✓ 동적 계산 (환경 크기 계산)</li>
<li>✓ 제어 흐름 (for loop으로 캡처 변수 처리)</li>
</ul>
<h3 id="drr-문법-기초"><a class="header" href="#drr-문법-기초">DRR 문법 기초</a></h3>
<p><strong>Pat (Pattern) 정의:</strong></p>
<pre><code class="language-tablegen">def PatternName : Pat&lt;
  (SourcePattern),   // 매치할 패턴
  (TargetPattern),   // 교체할 패턴
  [(Constraint)]     // 추가 제약 (optional)
&gt;;
</code></pre>
<p><strong>예시: 상수 폴딩</strong></p>
<pre><code class="language-tablegen">def AddZero : Pat&lt;
  (Arith_AddIOp $x, (Arith_ConstantOp ConstantAttr&lt;I32Attr, "0"&gt;)),
  (replaceWithValue $x)
&gt;;
</code></pre>
<p><strong>의미:</strong> <code>x + 0</code> → <code>x</code></p>
<h3 id="drr-예시-1-empty-closure-최적화"><a class="header" href="#drr-예시-1-empty-closure-최적화">DRR 예시 1: Empty Closure 최적화</a></h3>
<p><strong>최적화 목표:</strong></p>
<p>캡처 변수가 없는 클로저는 함수 포인터만 필요하다. 환경 할당 불필요.</p>
<p><strong>Before:</strong></p>
<pre><code class="language-mlir">// 캡처 없음
%closure = funlang.closure @foo : !funlang.closure

// Lowering 후 (불필요한 GC_malloc!)
%env = llvm.call @GC_malloc(%c8) : (i64) -&gt; !llvm.ptr
%fn_ptr = llvm.mlir.addressof @foo : !llvm.ptr
llvm.store %fn_ptr, %env[0] : !llvm.ptr
</code></pre>
<p><strong>After (최적화):</strong></p>
<pre><code class="language-mlir">// 함수 포인터만 사용
%fn_ptr = llvm.mlir.addressof @foo : !llvm.ptr

// apply에서 직접 함수 포인터 사용
%result = llvm.call @foo(%null_env, %x) : (!llvm.ptr, i32) -&gt; i32
</code></pre>
<p><strong>DRR 패턴:</strong></p>
<pre><code class="language-tablegen">def SimplifyEmptyClosure : Pat&lt;
  // Match: funlang.closure with no captured variables
  (FunLang_ClosureOp:$result $callee, (variadic)),

  // Replace: function reference (Phase 6에 FuncRefOp 추가 필요)
  (FunLang_FuncRefOp $callee),

  // Constraint: captured variables must be empty
  [(Constraint&lt;CPred&lt;"$0.empty()"&gt;, "$result.getCaptured()"&gt;)]
&gt;;
</code></pre>
<p><strong>설명:</strong></p>
<ul>
<li><strong><code>(variadic)</code></strong>: 가변 인자 (0개 이상)</li>
<li><strong><code>CPred&lt;"$0.empty()"&gt;</code></strong>: C++ predicate - 첫 번째 인자가 비어있는가?</li>
<li><strong><code>FuncRefOp</code></strong>: 함수 참조만 담는 operation (Phase 6에서 추가 예정)</li>
</ul>
<h3 id="drr-예시-2-known-closure-inlining"><a class="header" href="#drr-예시-2-known-closure-inlining">DRR 예시 2: Known Closure Inlining</a></h3>
<p><strong>최적화 목표:</strong></p>
<p>클로저 생성 직후 호출하면 인라인 가능.</p>
<p><strong>Before:</strong></p>
<pre><code class="language-mlir">// 클로저 생성 후 즉시 호출
%closure = funlang.closure @lambda, %n : !funlang.closure
%result = funlang.apply %closure(%x) : (i32) -&gt; i32
</code></pre>
<p><strong>After (최적화):</strong></p>
<pre><code class="language-mlir">// 직접 호출 (환경 할당 불필요)
%result = func.call @lambda(%n, %x) : (i32, i32) -&gt; i32
</code></pre>
<p><strong>DRR 패턴:</strong></p>
<pre><code class="language-tablegen">def InlineKnownApply : Pat&lt;
  // Match: apply (closure @callee, $captures) ($args)
  (FunLang_ApplyOp
    (FunLang_ClosureOp:$closure $callee, $captures),
    $args),

  // Replace: direct call @callee (concat $captures and $args)
  (Func_CallOp $callee, (ConcatValues $captures, $args))
&gt;;
</code></pre>
<p><strong>설명:</strong></p>
<ul>
<li><strong><code>$captures</code></strong>: 캡처된 변수들 (variadic)</li>
<li><strong><code>$args</code></strong>: apply 인자들 (variadic)</li>
<li><strong><code>ConcatValues</code></strong>: 두 리스트 합치기 (DRR helper)</li>
<li><strong><code>Func_CallOp</code></strong>: 직접 호출 operation</li>
</ul>
<p><strong>제약:</strong></p>
<p>이 패턴은 <strong>클로저가 escape하지 않을 때만</strong> 안전하다:</p>
<pre><code class="language-mlir">// OK: 즉시 호출
%result = funlang.apply (funlang.closure @f, %n) (%x)

// NOT OK: 클로저가 반환됨 (인라인 불가!)
func.func @make_adder(%n: i32) -&gt; !funlang.closure {
    %closure = funlang.closure @f, %n : !funlang.closure
    func.return %closure  // Escape!
}
</code></pre>
<p><strong>DRR로 escape 검사 불가 → C++ ConversionPattern 필요</strong></p>
<h3 id="drr-예시-3-constant-propagation"><a class="header" href="#drr-예시-3-constant-propagation">DRR 예시 3: Constant Propagation</a></h3>
<p><strong>최적화 목표:</strong></p>
<p>클로저가 상수만 캡처하면 compile-time에 처리 가능.</p>
<p><strong>Before:</strong></p>
<pre><code class="language-mlir">%c5 = arith.constant 5 : i32
%closure = funlang.closure @lambda, %c5 : !funlang.closure
</code></pre>
<p><strong>After (최적화):</strong></p>
<pre><code class="language-mlir">// lambda 함수 내부에서 %c5를 직접 사용하도록 인라인
// (복잡한 변환이므로 DRR보다 C++가 적합)
</code></pre>
<p><strong>DRR 한계:</strong></p>
<ul>
<li>함수 본문 수정 필요 (DRR은 local pattern만 매칭)</li>
<li>Whole-program analysis 필요 (DRR은 single operation 매칭)</li>
</ul>
<p><strong>결론:</strong> 이런 최적화는 <strong>C++ pass</strong>로 구현해야 함.</p>
<h3 id="mlir-tblgen으로-drr-컴파일"><a class="header" href="#mlir-tblgen으로-drr-컴파일">mlir-tblgen으로 DRR 컴파일</a></h3>
<p><strong>1. DRR 패턴 작성:</strong></p>
<pre><code class="language-tablegen">// FunLangPatterns.td
include "mlir/IR/PatternBase.td"
include "FunLangOps.td"

def SimplifyEmptyClosure : Pat&lt;
  (FunLang_ClosureOp:$result $callee, (variadic)),
  (FunLang_FuncRefOp $callee),
  [(Constraint&lt;CPred&lt;"$0.empty()"&gt;, "$result.getCaptured()"&gt;)]
&gt;;
</code></pre>
<p><strong>2. mlir-tblgen 실행:</strong></p>
<pre><code class="language-bash">mlir-tblgen -gen-rewriters FunLangPatterns.td -o FunLangPatterns.cpp.inc
</code></pre>
<p><strong>3. 생성된 C++ 코드:</strong></p>
<pre><code class="language-cpp">// FunLangPatterns.cpp.inc
struct SimplifyEmptyClosure : public RewritePattern {
  SimplifyEmptyClosure(MLIRContext *context)
      : RewritePattern(ClosureOp::getOperationName(), 1, context) {}

  LogicalResult matchAndRewrite(Operation *op, PatternRewriter &amp;rewriter) const override {
    auto closureOp = cast&lt;ClosureOp&gt;(op);

    // Constraint: captured variables empty
    if (!closureOp.getCaptured().empty())
      return failure();

    // Rewrite: create FuncRefOp
    rewriter.replaceOpWithNewOp&lt;FuncRefOp&gt;(op, closureOp.getCalleeAttr());
    return success();
  }
};
</code></pre>
<p><strong>4. Pass에 등록:</strong></p>
<pre><code class="language-cpp">void populateFunLangOptimizationPatterns(RewritePatternSet &amp;patterns) {
  patterns.add&lt;SimplifyEmptyClosure&gt;(patterns.getContext());
  // ... other patterns
}
</code></pre>
<h3 id="drr-vs-c-conversionpattern-비교-요약"><a class="header" href="#drr-vs-c-conversionpattern-비교-요약">DRR vs C++ ConversionPattern 비교 요약</a></h3>
<p><strong>ClosureOpLowering을 DRR로 작성하면?</strong></p>
<pre><code class="language-tablegen">// 불가능! DRR로는 표현 못함
def LowerClosure : Pat&lt;
  (FunLang_ClosureOp $callee, $captured),
  (??? 어떻게 for loop을 표현?)  // 캡처 변수 개수만큼 GEP + store
&gt;;
</code></pre>
<p><strong>왜 불가능?</strong></p>
<ul>
<li>DRR은 <strong>fixed-size patterns</strong>만 매칭</li>
<li>가변 개수의 operations 생성 불가 (for loop 없음)</li>
<li>동적 계산 불가 (환경 크기 계산)</li>
</ul>
<p><strong>결론:</strong></p>
<ul>
<li><strong>DRR</strong>: 간단한 최적화 패턴 (peephole, constant folding)</li>
<li><strong>C++ ConversionPattern</strong>: 복잡한 lowering (ClosureOp, ApplyOp)</li>
</ul>
<hr>
<h2 id="complete-lowering-pass"><a class="header" href="#complete-lowering-pass">Complete Lowering Pass</a></h2>
<p><strong>FunLangToLLVMPass</strong>는 FunLang dialect를 LLVM dialect로 lowering하는 완전한 pass다.</p>
<h3 id="pass-정의"><a class="header" href="#pass-정의">Pass 정의</a></h3>
<pre><code class="language-cpp">// FunLangToLLVMPass.cpp
#include "mlir/Conversion/LLVMCommon/Pattern.h"
#include "mlir/Dialect/LLVMIR/LLVMDialect.h"
#include "mlir/Dialect/Func/IR/FuncOps.h"
#include "mlir/Pass/Pass.h"
#include "mlir/Transforms/DialectConversion.h"
#include "FunLang/FunLangDialect.h"
#include "FunLang/FunLangOps.h"

namespace {

struct FunLangToLLVMPass
    : public PassWrapper&lt;FunLangToLLVMPass, OperationPass&lt;ModuleOp&gt;&gt; {

  // ==============================
  // Pass metadata
  // ==============================
  StringRef getArgument() const final {
    return "funlang-to-llvm";
  }

  StringRef getDescription() const final {
    return "Lower FunLang dialect to LLVM dialect";
  }

  // ==============================
  // Dependent dialects
  // ==============================
  void getDependentDialects(DialectRegistry &amp;registry) const override {
    registry.insert&lt;LLVM::LLVMDialect&gt;();
    registry.insert&lt;func::FuncDialect&gt;();
    registry.insert&lt;arith::ArithDialect&gt;();
  }

  // ==============================
  // Pass execution
  // ==============================
  void runOnOperation() override {
    // Get module operation
    ModuleOp module = getOperation();
    MLIRContext *ctx = &amp;getContext();

    // ------------------------------
    // 1. Setup ConversionTarget
    // ------------------------------
    ConversionTarget target(*ctx);

    // Legal: LLVM, func, arith dialects
    target.addLegalDialect&lt;LLVM::LLVMDialect&gt;();
    target.addLegalDialect&lt;func::FuncDialect&gt;();
    target.addLegalDialect&lt;arith::ArithDialect&gt;();

    // Illegal: FunLang dialect (must be lowered)
    target.addIllegalDialect&lt;funlang::FunLangDialect&gt;();

    // ------------------------------
    // 2. Setup TypeConverter
    // ------------------------------
    TypeConverter typeConverter;

    // FunLang types → LLVM types
    typeConverter.addConversion([&amp;](funlang::ClosureType type) {
      return LLVM::LLVMPointerType::get(ctx);
    });

    typeConverter.addConversion([&amp;](funlang::ListType type) {
      return LLVM::LLVMPointerType::get(ctx);
    });

    // Default: keep type as-is (i32, i64, etc.)
    typeConverter.addConversion([](Type type) {
      return type;
    });

    // ------------------------------
    // 3. Setup RewritePatternSet
    // ------------------------------
    RewritePatternSet patterns(ctx);

    // Add lowering patterns
    patterns.add&lt;ClosureOpLowering&gt;(ctx, typeConverter);
    patterns.add&lt;ApplyOpLowering&gt;(ctx, typeConverter);

    // ------------------------------
    // 4. Apply conversion
    // ------------------------------
    if (failed(applyPartialConversion(module, target, std::move(patterns)))) {
      signalPassFailure();
      return;
    }
  }
};

} // namespace

// ==============================
// Pass registration
// ==============================
void registerFunLangToLLVMPass() {
  PassRegistration&lt;FunLangToLLVMPass&gt;();
}
</code></pre>
<h3 id="pass-구성-요소-설명"><a class="header" href="#pass-구성-요소-설명">Pass 구성 요소 설명</a></h3>
<h4 id="1-passwrapper-템플릿"><a class="header" href="#1-passwrapper-템플릿">1. PassWrapper 템플릿</a></h4>
<pre><code class="language-cpp">struct FunLangToLLVMPass
    : public PassWrapper&lt;FunLangToLLVMPass, OperationPass&lt;ModuleOp&gt;&gt; {
</code></pre>
<ul>
<li><strong><code>PassWrapper&lt;Self, Base&gt;</code></strong>: CRTP 패턴</li>
<li><strong><code>OperationPass&lt;ModuleOp&gt;</code></strong>: Module 레벨 pass (전체 IR 처리)</li>
</ul>
<p><strong>다른 pass 레벨:</strong></p>
<ul>
<li><code>OperationPass&lt;func::FuncOp&gt;</code>: Function 레벨 (함수별 처리)</li>
<li><code>OperationPass&lt;&gt;</code>: 모든 operation에 대해</li>
</ul>
<h4 id="2-getdependentdialects"><a class="header" href="#2-getdependentdialects">2. getDependentDialects</a></h4>
<pre><code class="language-cpp">void getDependentDialects(DialectRegistry &amp;registry) const override {
  registry.insert&lt;LLVM::LLVMDialect&gt;();
  registry.insert&lt;func::FuncDialect&gt;();
  registry.insert&lt;arith::ArithDialect&gt;();
}
</code></pre>
<p><strong>역할:</strong> Pass가 사용할 dialects를 등록한다.</p>
<p><strong>왜 필요?</strong></p>
<ul>
<li>MLIR은 lazy dialect loading 사용</li>
<li>Pass가 <code>LLVM::CallOp</code>을 생성하려면 <code>LLVMDialect</code> 로드 필요</li>
<li>명시적 등록으로 dependency 보장</li>
</ul>
<h4 id="3-runonoperation"><a class="header" href="#3-runonoperation">3. runOnOperation</a></h4>
<pre><code class="language-cpp">void runOnOperation() override {
  ModuleOp module = getOperation();
  // ... conversion logic
}
</code></pre>
<p><strong>역할:</strong> Pass의 핵심 로직.</p>
<p><strong>실행 흐름:</strong></p>
<ol>
<li>Target 설정 (legal/illegal dialects)</li>
<li>TypeConverter 설정 (타입 변환 규칙)</li>
<li>Patterns 구성 (lowering patterns)</li>
<li>Conversion 실행 (applyPartialConversion)</li>
<li>실패 시 signalPassFailure()</li>
</ol>
<h3 id="pass-등록"><a class="header" href="#pass-등록">Pass 등록</a></h3>
<pre><code class="language-cpp">void registerFunLangToLLVMPass() {
  PassRegistration&lt;FunLangToLLVMPass&gt;();
}

// 초기화 함수에서 호출
void registerFunLangPasses() {
  registerFunLangToLLVMPass();
  // ... other passes
}
</code></pre>
<p><strong>등록 후 사용:</strong></p>
<pre><code class="language-bash">mlir-opt --funlang-to-llvm input.mlir -o output.mlir
</code></pre>
<h3 id="c-api-shim"><a class="header" href="#c-api-shim">C API Shim</a></h3>
<p><strong>C++ pass를 F#에서 사용하려면 C API가 필요하다.</strong></p>
<pre><code class="language-cpp">// FunLangCAPI.cpp
#include "mlir-c/IR.h"
#include "mlir/CAPI/Wrap.h"
#include "mlir/Pass/PassManager.h"
#include "FunLangPasses.h"

extern "C" {

// Pass 등록
MLIR_CAPI_EXPORTED void mlirFunLangRegisterToLLVMPass() {
  registerFunLangToLLVMPass();
}

// Pass 실행
MLIR_CAPI_EXPORTED void mlirFunLangRunToLLVMPass(MlirModule module) {
  ModuleOp moduleOp = unwrap(module);
  MLIRContext *ctx = moduleOp.getContext();

  PassManager pm(ctx);
  pm.addPass(std::make_unique&lt;FunLangToLLVMPass&gt;());

  if (failed(pm.run(moduleOp))) {
    llvm::errs() &lt;&lt; "FunLangToLLVMPass failed\n";
  }
}

} // extern "C"
</code></pre>
<p><strong>헬퍼 함수:</strong></p>
<pre><code class="language-cpp">// Wrap/unwrap helpers (MLIR-C API)
static inline ModuleOp unwrap(MlirModule module) {
  return ::mlir::unwrap(module);
}

static inline MlirModule wrap(ModuleOp module) {
  return ::mlir::wrap(module);
}
</code></pre>
<h3 id="f-pinvoke"><a class="header" href="#f-pinvoke">F# P/Invoke</a></h3>
<pre><code class="language-fsharp">// Mlir.FunLang.fs
module Mlir.FunLang

open System.Runtime.InteropServices

// ==============================
// P/Invoke declarations
// ==============================

[&lt;DllImport("funlang-dialect", CallingConvention = CallingConvention.Cdecl)&gt;]
extern void mlirFunLangRegisterToLLVMPass()

[&lt;DllImport("funlang-dialect", CallingConvention = CallingConvention.Cdecl)&gt;]
extern void mlirFunLangRunToLLVMPass(MlirModule module)

// ==============================
// F# wrapper functions
// ==============================

/// Initialize FunLang passes (call once at startup)
let initializePasses () =
    mlirFunLangRegisterToLLVMPass()

/// Lower FunLang dialect to LLVM dialect
let lowerToLLVM (module_: MlirModule) =
    mlirFunLangRunToLLVMPass(module_)
</code></pre>
<h3 id="f에서-pass-사용"><a class="header" href="#f에서-pass-사용">F#에서 Pass 사용</a></h3>
<pre><code class="language-fsharp">// CompilerPipeline.fs
open Mlir
open Mlir.FunLang

// 초기화 (프로그램 시작 시 1회)
FunLang.initializePasses()

// 컴파일 파이프라인
let compileToExecutable (source: string) =
    // 1. Parse &amp; build AST
    let ast = Parser.parse source

    // 2. Generate FunLang dialect MLIR
    use ctx = Mlir.createContext()
    use module_ = Mlir.createModule(ctx)
    use builder = Mlir.createOpBuilder(ctx)

    // ... code generation (Chapter 15)

    // 3. Lower FunLang → LLVM
    FunLang.lowerToLLVM(module_)

    // 4. Lower other dialects → LLVM
    Mlir.runPass(module_, "convert-arith-to-llvm")
    Mlir.runPass(module_, "convert-func-to-llvm")

    // 5. Translate LLVM dialect → LLVM IR
    let llvmIR = Mlir.translateToLLVMIR(module_)

    // 6. Compile &amp; link
    let objFile = LLVMCompiler.compile(llvmIR)
    let executable = Linker.link([objFile; "runtime.o"], "gc")

    executable
</code></pre>
<hr>
<h2 id="end-to-end-example"><a class="header" href="#end-to-end-example">End-to-End Example</a></h2>
<p><strong>makeAdder 함수를 전체 파이프라인으로 추적한다.</strong></p>
<h3 id="source-code"><a class="header" href="#source-code">Source Code</a></h3>
<pre><code class="language-fsharp">// FunLang source
let makeAdder n =
    fun x -&gt; x + n

let add5 = makeAdder 5
let result = add5 10
</code></pre>
<h3 id="stage-1-ast"><a class="header" href="#stage-1-ast">Stage 1: AST</a></h3>
<pre><code class="language-fsharp">type Expr =
    | Let of string * Expr * Expr
    | Lambda of string * Expr
    | App of Expr * Expr
    | BinOp of Operator * Expr * Expr
    | Var of string
    | Const of int

// makeAdder AST
Let ("makeAdder",
     Lambda ("n", Lambda ("x", BinOp (Add, Var "x", Var "n"))),
     Let ("add5",
          App (Var "makeAdder", Const 5),
          Let ("result",
               App (Var "add5", Const 10),
               Var "result")))
</code></pre>
<h3 id="stage-2-funlang-dialect-mlir-chapter-15"><a class="header" href="#stage-2-funlang-dialect-mlir-chapter-15">Stage 2: FunLang Dialect MLIR (Chapter 15)</a></h3>
<pre><code class="language-mlir">module {
  // lifted lambda: fun x -&gt; x + n
  func.func @lambda_adder(%env: !llvm.ptr, %x: i32) -&gt; i32 {
    // Load captured n from env[1]
    %n_slot = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
    %n = llvm.load %n_slot : !llvm.ptr -&gt; i32

    // x + n
    %result = arith.addi %x, %n : i32
    func.return %result : i32
  }

  // makeAdder function
  func.func @makeAdder(%n: i32) -&gt; !funlang.closure {
    %closure = funlang.closure @lambda_adder, %n : !funlang.closure
    func.return %closure : !funlang.closure
  }

  // main function
  func.func @funlang_main() -&gt; i32 {
    %c5 = arith.constant 5 : i32
    %c10 = arith.constant 10 : i32

    // makeAdder 5
    %add5 = funlang.closure @lambda_adder, %c5 : !funlang.closure

    // add5 10
    %result = funlang.apply %add5(%c10) : (i32) -&gt; i32

    func.return %result : i32
  }
}
</code></pre>
<h3 id="stage-3-after-funlangtollvm-pass-chapter-16"><a class="header" href="#stage-3-after-funlangtollvm-pass-chapter-16">Stage 3: After FunLangToLLVM Pass (Chapter 16)</a></h3>
<pre><code class="language-mlir">module {
  // lambda_adder (unchanged)
  func.func @lambda_adder(%env: !llvm.ptr, %x: i32) -&gt; i32 {
    %n_slot = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
    %n = llvm.load %n_slot : !llvm.ptr -&gt; i32
    %result = arith.addi %x, %n : i32
    func.return %result : i32
  }

  // makeAdder (funlang.closure lowered)
  func.func @makeAdder(%n: i32) -&gt; !llvm.ptr {
    %c16 = arith.constant 16 : i64
    %env = llvm.call @GC_malloc(%c16) : (i64) -&gt; !llvm.ptr
    %fn_ptr = llvm.mlir.addressof @lambda_adder : !llvm.ptr
    %slot0 = llvm.getelementptr %env[0] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %fn_ptr, %slot0 : !llvm.ptr, !llvm.ptr
    %slot1 = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %n, %slot1 : i32, !llvm.ptr
    func.return %env : !llvm.ptr
  }

  // main (both funlang operations lowered)
  func.func @funlang_main() -&gt; i32 {
    %c5 = arith.constant 5 : i32
    %c10 = arith.constant 10 : i32

    // ClosureOpLowering
    %c16 = arith.constant 16 : i64
    %add5 = llvm.call @GC_malloc(%c16) : (i64) -&gt; !llvm.ptr
    %fn_ptr = llvm.mlir.addressof @lambda_adder : !llvm.ptr
    %slot0 = llvm.getelementptr %add5[0] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %fn_ptr, %slot0 : !llvm.ptr, !llvm.ptr
    %slot1 = llvm.getelementptr %add5[1] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %c5, %slot1 : i32, !llvm.ptr

    // ApplyOpLowering
    %fn_ptr_addr = llvm.getelementptr %add5[0] : (!llvm.ptr) -&gt; !llvm.ptr
    %fn_ptr_loaded = llvm.load %fn_ptr_addr : !llvm.ptr -&gt; !llvm.ptr
    %result = llvm.call %fn_ptr_loaded(%add5, %c10) : (!llvm.ptr, i32) -&gt; i32

    func.return %result : i32
  }
}
</code></pre>
<h3 id="stage-4-after-convert-arith-to-llvm"><a class="header" href="#stage-4-after-convert-arith-to-llvm">Stage 4: After convert-arith-to-llvm</a></h3>
<pre><code class="language-mlir">// arith.constant → llvm.mlir.constant
%c5 = llvm.mlir.constant(5 : i32) : i32
%c10 = llvm.mlir.constant(10 : i32) : i32
%c16 = llvm.mlir.constant(16 : i64) : i64

// arith.addi → llvm.add
%result = llvm.add %x, %n : i32
</code></pre>
<h3 id="stage-5-after-convert-func-to-llvm"><a class="header" href="#stage-5-after-convert-func-to-llvm">Stage 5: After convert-func-to-llvm</a></h3>
<pre><code class="language-mlir">// func.func → llvm.func
llvm.func @lambda_adder(%env: !llvm.ptr, %x: i32) -&gt; i32 {
  ...
  llvm.return %result : i32
}

// func.call → llvm.call (already indirect, no change)
%result = llvm.call %fn_ptr_loaded(%add5, %c10) : (!llvm.ptr, i32) -&gt; i32
</code></pre>
<h3 id="stage-6-llvm-ir-mlir-translate-mlir-to-llvmir"><a class="header" href="#stage-6-llvm-ir-mlir-translate-mlir-to-llvmir">Stage 6: LLVM IR (mlir-translate –mlir-to-llvmir)</a></h3>
<pre><code class="language-llvm">define i32 @lambda_adder(ptr %env, i32 %x) {
  %n_slot = getelementptr ptr, ptr %env, i32 1
  %n = load i32, ptr %n_slot
  %result = add i32 %x, %n
  ret i32 %result
}

define ptr @makeAdder(i32 %n) {
  %env = call ptr @GC_malloc(i64 16)
  %fn_ptr = ptrtoint ptr @lambda_adder to i64
  %slot0 = getelementptr ptr, ptr %env, i32 0
  store i64 %fn_ptr, ptr %slot0
  %slot1 = getelementptr ptr, ptr %env, i32 1
  store i32 %n, ptr %slot1
  ret ptr %env
}

define i32 @funlang_main() {
  %c5 = 5
  %c10 = 10

  ; Closure creation
  %add5 = call ptr @GC_malloc(i64 16)
  %fn_ptr = ptrtoint ptr @lambda_adder to i64
  %slot0 = getelementptr ptr, ptr %add5, i32 0
  store i64 %fn_ptr, ptr %slot0
  %slot1 = getelementptr ptr, ptr %add5, i32 1
  store i32 %c5, ptr %slot1

  ; Closure application
  %fn_ptr_addr = getelementptr ptr, ptr %add5, i32 0
  %fn_ptr_loaded = load ptr, ptr %fn_ptr_addr
  %result = call i32 %fn_ptr_loaded(ptr %add5, i32 %c10)

  ret i32 %result
}
</code></pre>
<h3 id="stage-7-native-code-llc--object-file--executable"><a class="header" href="#stage-7-native-code-llc--object-file--executable">Stage 7: Native Code (llc → object file → executable)</a></h3>
<pre><code class="language-bash"># LLVM IR → object file
llc output.ll -o output.o -filetype=obj

# Link with runtime
clang output.o runtime.o -lgc -o program

# Run
./program
# Output: 15
</code></pre>
<h3 id="컴파일-파이프라인-다이어그램"><a class="header" href="#컴파일-파이프라인-다이어그램">컴파일 파이프라인 다이어그램</a></h3>
<pre><code>┌─────────────────┐
│  FunLang Source │  let makeAdder n = fun x -&gt; x + n
└────────┬────────┘
         │ Parser
         ▼
┌─────────────────┐
│       AST       │  Lambda, App, BinOp nodes
└────────┬────────┘
         │ CodeGen (Chapter 15)
         ▼
┌─────────────────┐
│ FunLang Dialect │  funlang.closure, funlang.apply
│      MLIR       │
└────────┬────────┘
         │ FunLangToLLVM Pass (Chapter 16) ★
         ▼
┌─────────────────┐
│  LLVM Dialect   │  llvm.call, llvm.getelementptr, llvm.store
│      MLIR       │
└────────┬────────┘
         │ convert-arith-to-llvm
         │ convert-func-to-llvm
         ▼
┌─────────────────┐
│  LLVM Dialect   │  All dialects → LLVM dialect
│ (fully lowered) │
└────────┬────────┘
         │ mlir-translate --mlir-to-llvmir
         ▼
┌─────────────────┐
│    LLVM IR      │  %.1 = call ptr @GC_malloc(i64 16)
└────────┬────────┘
         │ llc
         ▼
┌─────────────────┐
│  Object File    │  .o binary
└────────┬────────┘
         │ clang (link)
         ▼
┌─────────────────┐
│   Executable    │  ./program
└─────────────────┘
</code></pre>
<hr>
<h2 id="common-errors"><a class="header" href="#common-errors">Common Errors</a></h2>
<p>Lowering pass 구현 중 자주 발생하는 에러와 해결 방법.</p>
<h3 id="error-1-illegal-operation-remaining"><a class="header" href="#error-1-illegal-operation-remaining">Error 1: Illegal Operation Remaining</a></h3>
<p><strong>증상:</strong></p>
<pre><code>error: failed to legalize operation 'funlang.closure' that was explicitly marked illegal
note: see current operation: %0 = "funlang.closure"() {callee = @foo, ...}
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>Pattern이 등록되지 않음</li>
<li>Pattern이 매치 실패 (<code>matchAndRewrite</code>에서 <code>failure()</code> 리턴)</li>
<li>Target에 illegal로 설정했지만 pattern 없음</li>
</ul>
<p><strong>해결:</strong></p>
<ol>
<li><strong>Pattern 등록 확인:</strong></li>
</ol>
<pre><code class="language-cpp">RewritePatternSet patterns(ctx);
patterns.add&lt;ClosureOpLowering&gt;(ctx, typeConverter);  // 추가했는가?
</code></pre>
<ol start="2">
<li><strong>Pattern 매치 조건 확인:</strong></li>
</ol>
<pre><code class="language-cpp">LogicalResult matchAndRewrite(...) const override {
  // 디버그 출력
  llvm::errs() &lt;&lt; "ClosureOpLowering matched\n";

  // ... lowering logic

  return success();  // failure() 리턴하지 않았는가?
}
</code></pre>
<ol start="3">
<li><strong>Target 설정 확인:</strong></li>
</ol>
<pre><code class="language-cpp">target.addIllegalDialect&lt;funlang::FunLangDialect&gt;();  // Illegal로 설정
</code></pre>
<h3 id="error-2-type-conversion-failure"><a class="header" href="#error-2-type-conversion-failure">Error 2: Type Conversion Failure</a></h3>
<p><strong>증상:</strong></p>
<pre><code>error: type conversion failed for block argument #0
note: see current operation: func.func @foo(%arg0: !funlang.closure) -&gt; i32
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>TypeConverter에 변환 규칙 없음</li>
<li>변환 규칙이 <code>nullptr</code> 리턴</li>
</ul>
<p><strong>해결:</strong></p>
<ol>
<li><strong>TypeConverter에 규칙 추가:</strong></li>
</ol>
<pre><code class="language-cpp">typeConverter.addConversion([&amp;](funlang::ClosureType type) {
    return LLVM::LLVMPointerType::get(ctx);
});
</code></pre>
<ol start="2">
<li><strong>변환 실패 체크:</strong></li>
</ol>
<pre><code class="language-cpp">typeConverter.addConversion([&amp;](funlang::ClosureType type) -&gt; std::optional&lt;Type&gt; {
    if (!isConvertible(type))
        return std::nullopt;  // 변환 불가

    return LLVM::LLVMPointerType::get(ctx);
});
</code></pre>
<h3 id="error-3-wrong-operand-types"><a class="header" href="#error-3-wrong-operand-types">Error 3: Wrong Operand Types</a></h3>
<p><strong>증상:</strong></p>
<pre><code>error: 'llvm.store' op types mismatch between stored value and pointee type
note: stored value: i32, pointee type: !llvm.ptr
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>Store operation에 타입 불일치</li>
<li>GEP 결과를 잘못 사용</li>
</ul>
<p><strong>해결:</strong></p>
<ol>
<li><strong>Store 타입 확인:</strong></li>
</ol>
<pre><code class="language-cpp">// 잘못됨: i32를 !llvm.ptr 슬롯에 저장
rewriter.create&lt;LLVM::StoreOp&gt;(loc, i32Value, ptrSlot);

// 올바름: 타입 일치
rewriter.create&lt;LLVM::StoreOp&gt;(loc, i32Value, i32Slot);
</code></pre>
<ol start="2">
<li><strong>GEP 사용 확인:</strong></li>
</ol>
<pre><code class="language-mlir">// 올바른 GEP 패턴
%slot = llvm.getelementptr %ptr[1] : (!llvm.ptr) -&gt; !llvm.ptr
</code></pre>
<h3 id="error-4-pass-not-registered"><a class="header" href="#error-4-pass-not-registered">Error 4: Pass Not Registered</a></h3>
<p><strong>증상:</strong></p>
<pre><code class="language-bash">$ mlir-opt --funlang-to-llvm test.mlir
error: unknown command line flag '--funlang-to-llvm'
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>Pass 등록 함수가 호출되지 않음</li>
</ul>
<p><strong>해결:</strong></p>
<ol>
<li><strong>Pass 등록 확인:</strong></li>
</ol>
<pre><code class="language-cpp">// 초기화 코드에서 호출
void initializeMLIR() {
  registerFunLangDialect();
  registerFunLangToLLVMPass();  // 등록 함수 호출
}
</code></pre>
<ol start="2">
<li><strong>C API shim 확인:</strong></li>
</ol>
<pre><code class="language-cpp">extern "C" void mlirFunLangRegisterToLLVMPass() {
  registerFunLangToLLVMPass();
}
</code></pre>
<ol start="3">
<li><strong>F# 초기화 확인:</strong></li>
</ol>
<pre><code class="language-fsharp">// 프로그램 시작 시 호출
FunLang.initializePasses()
</code></pre>
<h3 id="error-5-segmentation-fault-in-pattern"><a class="header" href="#error-5-segmentation-fault-in-pattern">Error 5: Segmentation Fault in Pattern</a></h3>
<p><strong>증상:</strong></p>
<pre><code>Segmentation fault (core dumped)
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li><code>rewriter</code> 대신 일반 builder 사용</li>
<li>Null pointer dereference</li>
<li>Use-after-free (op 삭제 후 접근)</li>
</ul>
<p><strong>해결:</strong></p>
<ol>
<li><strong>항상 <code>rewriter</code> 사용:</strong></li>
</ol>
<pre><code class="language-cpp">// 잘못됨!
OpBuilder builder(ctx);
builder.create&lt;...&gt;();

// 올바름
rewriter.create&lt;...&gt;();
</code></pre>
<ol start="2">
<li><strong>Op 삭제 후 접근 금지:</strong></li>
</ol>
<pre><code class="language-cpp">// 잘못됨!
rewriter.replaceOp(op, newValue);
auto attr = op.getAttr("foo");  // Use-after-free!

// 올바름
auto attr = op.getAttr("foo");  // 먼저 읽기
rewriter.replaceOp(op, newValue);
</code></pre>
<ol start="3">
<li><strong>Null 체크:</strong></li>
</ol>
<pre><code class="language-cpp">Value closure = adaptor.getClosure();
if (!closure) {
  return failure();
}
</code></pre>
<hr>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p><strong>Chapter 16에서 배운 것:</strong></p>
<h3 id="1-dialectconversion-framework"><a class="header" href="#1-dialectconversion-framework">1. DialectConversion Framework</a></h3>
<ul>
<li><strong>ConversionTarget</strong>: Legal/illegal operations 정의</li>
<li><strong>RewritePatternSet</strong>: 변환 규칙 집합</li>
<li><strong>TypeConverter</strong>: 타입 변환 규칙</li>
<li><strong>applyPartialConversion</strong>: 부분 변환 실행</li>
</ul>
<h3 id="2-closureop-lowering-pattern"><a class="header" href="#2-closureop-lowering-pattern">2. ClosureOp Lowering Pattern</a></h3>
<ul>
<li><code>funlang.closure</code> → GC_malloc + GEP + store</li>
<li>Chapter 12 클로저 생성 패턴 재사용</li>
<li>OpAdaptor로 변환된 operands 접근</li>
<li>ConversionPatternRewriter로 IR 수정</li>
</ul>
<h3 id="3-applyop-lowering-pattern"><a class="header" href="#3-applyop-lowering-pattern">3. ApplyOp Lowering Pattern</a></h3>
<ul>
<li><code>funlang.apply</code> → GEP + load + llvm.call (indirect)</li>
<li>Chapter 13 간접 호출 패턴 재사용</li>
<li>인자 리스트 구성 (환경 포인터 + 실제 인자)</li>
<li>TypeConverter로 결과 타입 변환</li>
</ul>
<h3 id="4-typeconverter-for-funlang-types"><a class="header" href="#4-typeconverter-for-funlang-types">4. TypeConverter for FunLang Types</a></h3>
<ul>
<li><code>!funlang.closure</code> → <code>!llvm.ptr</code></li>
<li><code>!funlang.list&lt;T&gt;</code> → <code>!llvm.ptr</code></li>
<li>Function signatures 자동 변환</li>
<li>Materialization (optional)</li>
</ul>
<h3 id="5-declarative-rewrite-rules-drr"><a class="header" href="#5-declarative-rewrite-rules-drr">5. Declarative Rewrite Rules (DRR)</a></h3>
<ul>
<li>TableGen 기반 패턴 매칭</li>
<li>간단한 최적화 패턴 (empty closure, known closure inlining)</li>
<li>DRR vs C++ ConversionPattern 비교</li>
<li>mlir-tblgen으로 C++ 코드 생성</li>
</ul>
<h3 id="6-complete-lowering-pass"><a class="header" href="#6-complete-lowering-pass">6. Complete Lowering Pass</a></h3>
<ul>
<li>FunLangToLLVMPass 구현</li>
<li>Pass 등록 및 실행</li>
<li>C API shim for F# integration</li>
<li>F# wrapper functions</li>
</ul>
<h3 id="7-end-to-end-example"><a class="header" href="#7-end-to-end-example">7. End-to-End Example</a></h3>
<ul>
<li>makeAdder: FunLang source → LLVM IR → executable</li>
<li>전체 컴파일 파이프라인 추적</li>
<li>각 단계별 IR 확인</li>
</ul>
<h3 id="8-common-errors"><a class="header" href="#8-common-errors">8. Common Errors</a></h3>
<ul>
<li>Illegal operation remaining</li>
<li>Type conversion failure</li>
<li>Wrong operand types</li>
<li>Pass not registered</li>
<li>Segmentation fault</li>
</ul>
<p><strong>Phase 5 완료!</strong></p>
<ul>
<li><strong>Chapter 14</strong>: Custom dialect design theory</li>
<li><strong>Chapter 15</strong>: Custom operations implementation (funlang.closure, funlang.apply)</li>
<li><strong>Chapter 16</strong>: Lowering passes (FunLangToLLVM)</li>
</ul>
<p><strong>코드 압축 효과:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Before (Phase 4)</th><th>After (Phase 5)</th></tr>
</thead>
<tbody>
<tr><td><strong>Closure creation</strong></td><td>12 lines</td><td>1 line</td></tr>
<tr><td><strong>Closure application</strong></td><td>8 lines</td><td>1 line</td></tr>
<tr><td><strong>Compiler code</strong></td><td>~200 lines</td><td>~100 lines</td></tr>
<tr><td><strong>타입 안전성</strong></td><td><code>!llvm.ptr</code> (opaque)</td><td><code>!funlang.closure</code> (typed)</td></tr>
<tr><td><strong>최적화 가능성</strong></td><td>어려움</td><td>쉬움 (DRR patterns)</td></tr>
</tbody>
</table>
</div>
<p><strong>Phase 6 Preview: Pattern Matching</strong></p>
<p>다음 Phase에서는 <strong>패턴 매칭</strong>을 추가한다:</p>
<pre><code class="language-fsharp">// List operations
let rec length list =
    match list with
    | [] -&gt; 0
    | head :: tail -&gt; 1 + length tail
</code></pre>
<p><strong>새로운 operations:</strong></p>
<ul>
<li><code>funlang.match</code>: 패턴 매칭</li>
<li><code>funlang.nil</code>: 빈 리스트</li>
<li><code>funlang.cons</code>: 리스트 생성</li>
<li><code>funlang.list_head</code>, <code>funlang.list_tail</code>: 리스트 접근</li>
</ul>
<p><strong>새로운 lowering patterns:</strong></p>
<ul>
<li><code>funlang.match</code> → <code>scf.if</code> + <code>llvm.switch</code> (복잡한 제어 흐름)</li>
<li>SCF dialect를 거친 multi-stage lowering</li>
</ul>
<p><strong>Phase 5와 Phase 6의 차이:</strong></p>
<ul>
<li><strong>Phase 5</strong>: FunLang → LLVM (direct lowering)</li>
<li><strong>Phase 6</strong>: FunLang → SCF → LLVM (multi-stage lowering)</li>
</ul>
<p><strong>Chapter 16 완료!</strong> 이제 custom dialect를 설계하고, operations를 정의하고, lowering passes를 구현할 수 있다. FunLang 컴파일러는 high-level 추상화와 low-level 성능을 모두 제공한다.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-17-pattern-matching-theory-pattern-matching-theory"><a class="header" href="#chapter-17-pattern-matching-theory-pattern-matching-theory">Chapter 17: Pattern Matching Theory (Pattern Matching Theory)</a></h1>
<h2 id="소개-17"><a class="header" href="#소개-17">소개</a></h2>
<p><strong>Phase 6이 시작된다.</strong> Phase 5에서 커스텀 MLIR dialect를 구축했다. <code>funlang.closure</code>와 <code>funlang.apply</code>로 클로저를 추상화했고, lowering pass로 LLVM dialect로 변환했다. 이제 <strong>함수형 언어의 핵심 기능</strong>을 추가할 시간이다: **패턴 매칭(pattern matching)**과 <strong>데이터 구조(data structures)</strong>.</p>
<h3 id="phase-6-로드맵"><a class="header" href="#phase-6-로드맵">Phase 6 로드맵</a></h3>
<p><strong>Phase 6: Pattern Matching &amp; Data Structures</strong></p>
<p>이번 phase에서 구현할 내용:</p>
<ol>
<li><strong>Chapter 17 (현재)</strong>: Pattern matching 이론 - Decision tree 알고리즘</li>
<li><strong>Chapter 18</strong>: List operations - <code>funlang.nil</code>, <code>funlang.cons</code> 구현</li>
<li><strong>Chapter 19</strong>: Match compilation - <code>funlang.match</code> operation과 lowering</li>
<li><strong>Chapter 20</strong>: Functional programs - 실전 예제 (map, filter, fold)</li>
</ol>
<p><strong>왜 이 순서인가?</strong></p>
<ul>
<li><strong>이론 먼저:</strong> Decision tree 알고리즘을 이해해야 MLIR 구현이 명확해진다</li>
<li><strong>데이터 구조 다음:</strong> List operations가 있어야 패턴 매칭할 대상이 생긴다</li>
<li><strong>매칭 구현:</strong> <code>funlang.match</code> operation으로 decision tree를 MLIR로 표현한다</li>
<li><strong>실전 활용:</strong> 지금까지 배운 모든 기능을 종합해서 함수형 프로그램을 작성한다</li>
</ul>
<h3 id="phase-5-복습-왜-패턴-매칭이-필요한가"><a class="header" href="#phase-5-복습-왜-패턴-매칭이-필요한가">Phase 5 복습: 왜 패턴 매칭이 필요한가?</a></h3>
<p>Phase 5까지 우리는 이런 코드를 작성할 수 있게 되었다:</p>
<pre><code class="language-fsharp">// F# compiler input
let make_adder n =
    fun x -&gt; x + n

let add_5 = make_adder 5
let result = add_5 10  // 15
</code></pre>
<pre><code class="language-mlir">// Phase 5 MLIR output (FunLang dialect)
%closure = funlang.closure @lambda_adder, %n : !funlang.closure
%result = funlang.apply %closure(%x) : (i32) -&gt; i32
</code></pre>
<p><strong>하지만 함수형 언어의 진짜 힘은 데이터 구조와 패턴 매칭의 조합이다:</strong></p>
<pre><code class="language-fsharp">// F#에서 list 패턴 매칭
let rec sum_list lst =
    match lst with
    | [] -&gt; 0
    | head :: tail -&gt; head + sum_list tail

sum_list [1; 2; 3]  // 6
</code></pre>
<pre><code class="language-ocaml">(* OCaml에서 패턴 매칭 *)
let rec length = function
  | [] -&gt; 0
  | _ :: tail -&gt; 1 + length tail
</code></pre>
<p><strong>패턴 매칭이 제공하는 것:</strong></p>
<ol>
<li><strong>구조적 분해(structural decomposition)</strong>: 데이터를 한 번에 분해하고 변수에 바인딩</li>
<li><strong>Exhaustiveness checking</strong>: 컴파일러가 모든 경우를 다뤘는지 검증</li>
<li><strong>효율적인 분기</strong>: 각 subterm을 최대 한 번만 테스트하는 코드 생성</li>
<li><strong>가독성</strong>: if-else 체인보다 선언적이고 명확한 코드</li>
</ol>
<h3 id="pattern-matching-compilation의-도전"><a class="header" href="#pattern-matching-compilation의-도전">Pattern Matching Compilation의 도전</a></h3>
<p><strong>Naive한 접근:</strong></p>
<pre><code class="language-mlir">// 잘못된 방법: if-else 체인으로 번역
%is_nil = // list가 nil인지 테스트
scf.if %is_nil {
    %zero = arith.constant 0 : i32
    scf.yield %zero : i32
} else {
    %is_cons = // list가 cons인지 테스트 (중복!)
    scf.if %is_cons {
        %head = // head 추출
        %tail = // tail 추출
        %sum_tail = func.call @sum_list(%tail) : (!funlang.list&lt;i32&gt;) -&gt; i32
        %result = arith.addi %head, %sum_tail : i32
        scf.yield %result : i32
    }
}
</code></pre>
<p><strong>문제점:</strong></p>
<ol>
<li><strong>중복 테스트</strong>: Nil 테스트 실패 후 Cons 테스트는 중복이다 (list는 Nil 아니면 Cons)</li>
<li><strong>비효율적 코드</strong>: Nested patterns에서 exponential blowup 발생</li>
<li><strong>Exhaustiveness 검증 어려움</strong>: 모든 case를 다뤘는지 확인이 복잡하다</li>
</ol>
<p><strong>올바른 접근: Decision Tree Compilation</strong></p>
<p>Luc Maranget의 decision tree 알고리즘 (2008)을 사용하면:</p>
<ul>
<li>각 subterm을 <strong>최대 한 번</strong>만 테스트</li>
<li>Pattern matrix representation으로 체계적 변환</li>
<li>Exhaustiveness checking이 자연스럽게 통합됨</li>
<li>최적화된 분기 코드 생성</li>
</ul>
<h3 id="chapter-17-목표"><a class="header" href="#chapter-17-목표">Chapter 17 목표</a></h3>
<p>이 장을 마치면:</p>
<ul>
<li><input disabled="" type="checkbox"> <strong>Pattern matrix 표현법</strong>을 이해한다</li>
<li><input disabled="" type="checkbox"> <strong>Decision tree 알고리즘</strong>의 동작 원리를 안다</li>
<li><input disabled="" type="checkbox"> <strong>Specialization</strong>과 <strong>defaulting</strong> 연산을 설명할 수 있다</li>
<li><input disabled="" type="checkbox"> <strong>Exhaustiveness checking</strong>이 어떻게 동작하는지 안다</li>
<li><input disabled="" type="checkbox"> Chapter 18-19에서 MLIR 구현을 시작할 준비가 된다</li>
</ul>
<p><strong>이론 중심 장(theory-focused chapter):</strong></p>
<p>이 장은 구현 코드가 없다. <strong>알고리즘 설명과 예제</strong>에 집중한다. 왜냐하면:</p>
<ol>
<li>Decision tree 알고리즘은 MLIR과 독립적이다 (OCaml, Haskell, Rust 등 모든 함수형 언어에서 사용)</li>
<li>알고리즘을 먼저 이해하면 MLIR lowering 구현이 명확해진다</li>
<li>Pattern matrix 표기법은 Chapter 19의 <code>funlang.match</code> operation 설계 기반이 된다</li>
</ol>
<h3 id="성공-기준"><a class="header" href="#성공-기준">성공 기준</a></h3>
<p>이 장을 이해했다면:</p>
<ol>
<li>Pattern matrix에서 rows/columns가 무엇을 의미하는지 설명할 수 있다</li>
<li>Specialization 연산이 pattern을 어떻게 분해하는지 예시를 들 수 있다</li>
<li>Default 연산이 wildcard rows를 어떻게 처리하는지 설명할 수 있다</li>
<li>Empty pattern matrix가 왜 non-exhaustive match를 의미하는지 안다</li>
<li>Decision tree가 if-else chain보다 효율적인 이유를 설명할 수 있다</li>
</ol>
<p><strong>Let’s begin.</strong></p>
<hr>
<h2 id="pattern-matching-문제-정의"><a class="header" href="#pattern-matching-문제-정의">Pattern Matching 문제 정의</a></h2>
<p>패턴 매칭 컴파일의 핵심 문제를 정의하자.</p>
<h3 id="ml-계열-언어의-패턴-매칭"><a class="header" href="#ml-계열-언어의-패턴-매칭">ML 계열 언어의 패턴 매칭</a></h3>
<p><strong>OCaml/F# syntax:</strong></p>
<pre><code class="language-ocaml">(* OCaml *)
match expr with
| pattern1 -&gt; action1
| pattern2 -&gt; action2
| pattern3 -&gt; action3
</code></pre>
<pre><code class="language-fsharp">// F#
match expr with
| pattern1 -&gt; action1
| pattern2 -&gt; action2
| pattern3 -&gt; action3
</code></pre>
<p><strong>Example: List length function</strong></p>
<pre><code class="language-ocaml">let rec length lst =
  match lst with
  | [] -&gt; 0
  | _ :: tail -&gt; 1 + length tail
</code></pre>
<p><strong>구성 요소:</strong></p>
<ol>
<li><strong>Scrutinee</strong> (<code>lst</code>): 매칭 대상 expression</li>
<li><strong>Patterns</strong> (<code>[]</code>, <code>_ :: tail</code>): 구조 템플릿</li>
<li><strong>Actions</strong> (<code>0</code>, <code>1 + length tail</code>): 패턴이 매칭되면 실행할 코드</li>
<li><strong>Pattern variables</strong> (<code>tail</code>): 패턴 내부에서 값을 바인딩</li>
</ol>
<h3 id="funlang-패턴-매칭-구문"><a class="header" href="#funlang-패턴-매칭-구문">FunLang 패턴 매칭 구문</a></h3>
<p><strong>FunLang의 제안 syntax</strong> (Phase 6 구현 목표):</p>
<pre><code class="language-fsharp">// match expression
match list with
| Nil -&gt; 0
| Cons(head, tail) -&gt; head + sum tail
</code></pre>
<p><strong>Pattern types:</strong></p>
<ol>
<li><strong>Wildcard pattern</strong> (<code>_</code>): 모든 값과 매칭, 변수 바인딩 없음</li>
<li><strong>Variable pattern</strong> (<code>x</code>, <code>tail</code>): 모든 값과 매칭, 변수에 바인딩</li>
<li><strong>Constructor pattern</strong> (<code>Nil</code>, <code>Cons(x, xs)</code>): 특정 constructor와 매칭</li>
<li><strong>Literal pattern</strong> (<code>0</code>, <code>true</code>): 특정 상수 값과 매칭</li>
</ol>
<p><strong>Constructor patterns의 subpatterns:</strong></p>
<pre><code class="language-fsharp">// Nested constructor patterns
match list with
| Nil -&gt; "empty"
| Cons(x, Nil) -&gt; "singleton"  // tail is Nil
| Cons(x, Cons(y, rest)) -&gt; "at least two elements"
</code></pre>
<p><code>Cons(x, Nil)</code>에서:</p>
<ul>
<li><code>Cons</code>는 constructor</li>
<li><code>x</code>는 head subpattern (variable)</li>
<li><code>Nil</code>은 tail subpattern (constructor)</li>
</ul>
<h3 id="컴파일-문제-patterns--efficient-branching-code"><a class="header" href="#컴파일-문제-patterns--efficient-branching-code">컴파일 문제: Patterns → Efficient Branching Code</a></h3>
<p><strong>Input:</strong> Pattern clauses (scrutinee, patterns, actions)</p>
<pre><code class="language-fsharp">match list with
| Nil -&gt; 0
| Cons(head, tail) -&gt; head + sum tail
</code></pre>
<p><strong>Output:</strong> Efficient branching code (MLIR IR)</p>
<pre><code class="language-mlir">%tag = llvm.extractvalue %list[0] : !llvm.struct&lt;(i32, ptr)&gt;
%is_nil = arith.cmpi eq, %tag, %c0 : i32

%result = scf.if %is_nil -&gt; (i32) {
    %zero = arith.constant 0 : i32
    scf.yield %zero : i32
} else {
    // Cons case: extract head and tail
    %data = llvm.extractvalue %list[1] : !llvm.struct&lt;(i32, ptr)&gt;
    %head = llvm.load %data[0] : !llvm.ptr -&gt; i32
    %tail = llvm.load %data[1] : !llvm.ptr -&gt; !llvm.struct&lt;(i32, ptr)&gt;

    %sum_tail = func.call @sum(%tail) : (!funlang.list&lt;i32&gt;) -&gt; i32
    %result_val = arith.addi %head, %sum_tail : i32
    scf.yield %result_val : i32
}
</code></pre>
<p><strong>핵심 요구사항:</strong></p>
<ol>
<li><strong>Correctness</strong>: 패턴 순서를 존중 (첫 번째 매칭 패턴이 선택됨)</li>
<li><strong>Efficiency</strong>: 각 subterm을 최대 한 번만 테스트</li>
<li><strong>Exhaustiveness</strong>: 모든 가능한 값이 처리되는지 검증</li>
<li><strong>Optimization</strong>: 불필요한 테스트 제거 (Nil 아니면 자동으로 Cons)</li>
</ol>
<h3 id="naive-컴파일의-문제점"><a class="header" href="#naive-컴파일의-문제점">Naive 컴파일의 문제점</a></h3>
<p><strong>If-else chain으로 직접 번역하면?</strong></p>
<pre><code class="language-mlir">// Pattern 1: Nil
%is_nil = // test if tag == 0
scf.if %is_nil {
    scf.yield %zero : i32
} else {
    // Pattern 2: Cons(head, tail)
    %is_cons = // test if tag == 1 (redundant!)
    scf.if %is_cons {
        // extract head, tail, compute result
    } else {
        // No more patterns -&gt; error!
    }
}
</code></pre>
<p><strong>문제 1: 중복 테스트</strong></p>
<p>Nil 테스트가 false면 자동으로 Cons다 (list는 Nil 또는 Cons만 존재). 하지만 naive 번역은 다시 Cons를 테스트한다.</p>
<p><strong>문제 2: Nested patterns의 exponential blowup</strong></p>
<pre><code class="language-fsharp">match (list1, list2) with
| (Nil, Nil) -&gt; 0
| (Nil, Cons(_, _)) -&gt; 1
| (Cons(_, _), Nil) -&gt; 2
| (Cons(x, _), Cons(y, _)) -&gt; x + y
</code></pre>
<p>두 개의 scrutinee를 독립적으로 테스트하면:</p>
<pre><code>list1 test -&gt; list2 test (중복!)
            -&gt; list2 test (중복!)
-&gt; list1 test (중복!)
            -&gt; list2 test (중복!)
            -&gt; list2 test (중복!)
</code></pre>
<p>4개의 패턴이 8번의 테스트를 발생시킨다. Patterns이 늘어나면 <code>2^n</code> 테스트가 필요하다.</p>
<p><strong>문제 3: Exhaustiveness 검증 복잡도</strong></p>
<p>If-else tree를 분석해서 모든 경로가 종료되는지 확인해야 한다. 복잡한 중첩 패턴에서는 거의 불가능하다.</p>
<h3 id="해결책-decision-tree-compilation"><a class="header" href="#해결책-decision-tree-compilation">해결책: Decision Tree Compilation</a></h3>
<p><strong>Key insight (Maranget 2008):</strong></p>
<blockquote>
<p>“패턴 매칭은 <strong>search problem</strong>이다. Pattern clauses를 <strong>structured representation</strong> (pattern matrix)로 변환하면, systematic하게 optimal decision tree를 구성할 수 있다.”</p>
</blockquote>
<p><strong>Decision tree 특징:</strong></p>
<ol>
<li><strong>각 internal node는 하나의 test</strong> (constructor tag, literal value)</li>
<li><strong>각 edge는 test outcome</strong> (Nil vs Cons, 0 vs 1 vs 2)</li>
<li><strong>각 leaf는 action</strong> (실행할 코드)</li>
<li><strong>Root에서 leaf까지 경로는 unique test sequence</strong></li>
</ol>
<p><strong>장점:</strong></p>
<ul>
<li>각 subterm을 최대 한 번만 테스트 (no redundancy)</li>
<li>Test 순서를 최적화 가능 (heuristic으로 선택)</li>
<li>Exhaustiveness checking이 자연스러움 (leaf가 없는 경로 = missing pattern)</li>
</ul>
<p><strong>다음 섹션에서:</strong> Pattern matrix 표기법과 decision tree 구성 알고리즘을 자세히 살펴본다.</p>
<hr>
<h2 id="pattern-matrix-표현법"><a class="header" href="#pattern-matrix-표현법">Pattern Matrix 표현법</a></h2>
<p>Decision tree 알고리즘의 핵심은 <strong>pattern matrix</strong>라는 structured representation이다.</p>
<h3 id="pattern-matrix-정의"><a class="header" href="#pattern-matrix-정의">Pattern Matrix 정의</a></h3>
<p><strong>Pattern matrix는 2차원 테이블이다:</strong></p>
<ul>
<li><strong>Rows</strong>: Pattern clauses (각 row는 하나의 <code>pattern -&gt; action</code>)</li>
<li><strong>Columns</strong>: Scrutinees (매칭 대상 values)</li>
<li><strong>Cells</strong>: Patterns (wildcard, constructor, literal)</li>
</ul>
<p><strong>Notation:</strong></p>
<pre><code>P = | p11  p12  ...  p1m  →  a1
    | p21  p22  ...  p2m  →  a2
    | ...
    | pn1  pn2  ...  pnm  →  an
</code></pre>
<ul>
<li><code>P</code>: Pattern matrix (n rows × m columns)</li>
<li><code>pij</code>: Row i, column j의 pattern</li>
<li><code>ai</code>: Row i의 action</li>
<li><code>m</code>: Scrutinee 개수</li>
<li><code>n</code>: Pattern clause 개수</li>
</ul>
<h3 id="example-1-단일-scrutinee-list-length"><a class="header" href="#example-1-단일-scrutinee-list-length">Example 1: 단일 Scrutinee (List Length)</a></h3>
<p><strong>FunLang code:</strong></p>
<pre><code class="language-fsharp">match list with
| Nil -&gt; 0
| Cons(head, tail) -&gt; 1 + length tail
</code></pre>
<p><strong>Pattern matrix:</strong></p>
<pre><code>Scrutinee: [list]

Matrix:
| Nil             →  0
| Cons(head, tail) →  1 + length tail
</code></pre>
<p><strong>설명:</strong></p>
<ul>
<li>1개의 scrutinee column: <code>list</code></li>
<li>2개의 pattern rows:
<ul>
<li>Row 1: <code>Nil</code> pattern → action은 <code>0</code></li>
<li>Row 2: <code>Cons(head, tail)</code> pattern → action은 <code>1 + length tail</code></li>
</ul>
</li>
</ul>
<p><strong>Constructor patterns의 subpatterns:</strong></p>
<p><code>Cons(head, tail)</code>은 2개의 subpatterns를 가진다:</p>
<ul>
<li><code>head</code>: variable pattern (head 값에 바인딩)</li>
<li><code>tail</code>: variable pattern (tail 값에 바인딩)</li>
</ul>
<p>나중에 이 subpatterns가 <strong>새로운 columns</strong>로 확장된다 (specialization).</p>
<h3 id="example-2-다중-scrutinee-pair-matching"><a class="header" href="#example-2-다중-scrutinee-pair-matching">Example 2: 다중 Scrutinee (Pair Matching)</a></h3>
<p><strong>FunLang code:</strong></p>
<pre><code class="language-fsharp">match (list1, list2) with
| (Nil, Nil) -&gt; 0
| (Nil, Cons(x, _)) -&gt; 1
| (Cons(_, _), Nil) -&gt; 2
| (Cons(x, _), Cons(y, _)) -&gt; x + y
</code></pre>
<p><strong>Pattern matrix:</strong></p>
<pre><code>Scrutinee: [list1, list2]

Matrix:
| Nil         Nil          →  0
| Nil         Cons(x, _)   →  1
| Cons(_, _)  Nil          →  2
| Cons(x, _)  Cons(y, _)   →  x + y
</code></pre>
<p><strong>설명:</strong></p>
<ul>
<li>2개의 scrutinee columns: <code>list1</code>, <code>list2</code></li>
<li>4개의 pattern rows</li>
<li>각 cell은 해당 scrutinee의 pattern</li>
</ul>
<p><strong>Wildcard pattern <code>_</code>:</strong></p>
<p>값을 바인딩하지 않는 pattern. 모든 값과 매칭된다.</p>
<p><strong>Variable pattern <code>x</code>, <code>y</code>:</strong></p>
<p>값을 변수에 바인딩하는 pattern. 모든 값과 매칭되지만 이름을 부여한다.</p>
<blockquote>
<p><strong>Wildcard vs Variable</strong>: Semantically 둘 다 모든 값과 매칭된다. Variable은 추가로 바인딩을 생성한다. Pattern matrix 관점에서는 동일하게 취급된다 (irrefutable pattern).</p>
</blockquote>
<h3 id="example-3-nested-pattern-list-prefix"><a class="header" href="#example-3-nested-pattern-list-prefix">Example 3: Nested Pattern (List Prefix)</a></h3>
<p><strong>FunLang code:</strong></p>
<pre><code class="language-fsharp">match list with
| Nil -&gt; "empty"
| Cons(x, Nil) -&gt; "singleton"
| Cons(x, Cons(y, rest)) -&gt; "at least two"
</code></pre>
<p><strong>Initial pattern matrix:</strong></p>
<pre><code>Scrutinee: [list]

Matrix:
| Nil                   →  "empty"
| Cons(x, Nil)          →  "singleton"
| Cons(x, Cons(y, rest)) →  "at least two"
</code></pre>
<p><strong>Nested constructor <code>Cons(y, rest)</code>:</strong></p>
<p>Row 3의 tail subpattern <code>Cons(y, rest)</code>는 또 다른 constructor pattern이다. 이게 <strong>nested pattern</strong>이다.</p>
<p><strong>Compilation strategy:</strong></p>
<ol>
<li>먼저 <code>list</code>의 constructor (Nil vs Cons) 테스트</li>
<li>Cons인 경우, head와 tail 추출</li>
<li>이제 <code>tail</code>에 대해 다시 pattern matching (Nil vs Cons)</li>
</ol>
<p><strong>Specialization 후 matrix는 확장된다</strong> (나중에 자세히 설명).</p>
<h3 id="occurrence-vectors"><a class="header" href="#occurrence-vectors">Occurrence Vectors</a></h3>
<p><strong>Pattern matrix와 함께 occurrence vectors를 유지한다.</strong></p>
<p><strong>Occurrence vector (π):</strong></p>
<p>Scrutinee values에 <strong>어떻게 접근하는지</strong> 나타내는 경로(path) 목록.</p>
<p><strong>Initial occurrences:</strong></p>
<pre><code>π = [o1, o2, ..., om]
</code></pre>
<ul>
<li><code>o1</code>: First scrutinee (예: <code>list</code>)</li>
<li><code>o2</code>: Second scrutinee (예: <code>list2</code>)</li>
</ul>
<p><strong>Example: Single scrutinee</strong></p>
<pre><code>π = [list]
</code></pre>
<p><strong>Example: Pair of scrutinees</strong></p>
<pre><code>π = [list1, list2]
</code></pre>
<p><strong>Specialization 시 occurrences 확장:</strong></p>
<p>Constructor pattern <code>Cons(x, xs)</code>를 specialize하면:</p>
<pre><code>π = [list]
  → [list.head, list.tail]
</code></pre>
<p><code>list.head</code>와 <code>list.tail</code>은 <strong>subterm access path</strong>를 의미한다 (MLIR에서는 <code>llvm.extractvalue</code> operations).</p>
<p><strong>왜 occurrence vectors가 필요한가?</strong></p>
<p>Decision tree를 생성할 때, 각 test가 <strong>어느 값을 검사하는지</strong> 알아야 한다.</p>
<ul>
<li>Initial: <code>list</code> 자체를 테스트</li>
<li>After specialization: <code>list.head</code>, <code>list.tail</code>을 테스트</li>
</ul>
<p>Occurrence vectors는 <strong>code generation의 기반</strong>이다.</p>
<h3 id="pattern-matrix-properties"><a class="header" href="#pattern-matrix-properties">Pattern Matrix Properties</a></h3>
<p><strong>Irrefutable row:</strong></p>
<p>Row의 모든 patterns가 wildcard 또는 variable이면 <strong>irrefutable</strong>이다 (항상 매칭).</p>
<pre><code>| _  _  _  →  action  // Irrefutable
</code></pre>
<p><strong>Exhaustive matrix:</strong></p>
<p>Matrix가 <strong>exhaustive</strong>하면 모든 가능한 input values가 어떤 row와 매칭된다.</p>
<p><strong>Non-exhaustive matrix:</strong></p>
<p>어떤 input value도 매칭되지 않는 경우가 있으면 <strong>non-exhaustive</strong>.</p>
<p><strong>Empty matrix (P = ∅):</strong></p>
<p>Row가 하나도 없는 matrix. <strong>항상 non-exhaustive</strong>다.</p>
<p><strong>Example: Non-exhaustive pattern</strong></p>
<pre><code class="language-fsharp">match list with
| Nil -&gt; 0
// Missing: Cons case!
</code></pre>
<p>Matrix:</p>
<pre><code>| Nil  →  0
</code></pre>
<p>Input <code>Cons(1, Nil)</code>은 어떤 row와도 매칭 안 됨 → <strong>non-exhaustive</strong>.</p>
<h3 id="pattern-matrix-compilation-goal"><a class="header" href="#pattern-matrix-compilation-goal">Pattern Matrix Compilation Goal</a></h3>
<p><strong>Compilation algorithm의 목표:</strong></p>
<p>Pattern matrix <code>P</code>와 occurrence vector <code>π</code>를 입력받아서:</p>
<ol>
<li><strong>Decision tree를 생성</strong>한다 (efficient branching code)</li>
<li><strong>Exhaustiveness를 검증</strong>한다 (empty matrix 체크)</li>
<li><strong>Optimal test sequence</strong>를 선택한다 (heuristic)</li>
</ol>
<p><strong>Next section:</strong> Decision tree의 구조와 pattern matrix의 관계를 살펴본다.</p>
<hr>
<h2 id="decision-tree-개념"><a class="header" href="#decision-tree-개념">Decision Tree 개념</a></h2>
<p>Pattern matrix를 compile하면 <strong>decision tree</strong>가 생성된다. 이 섹션에서 decision tree의 구조와 특징을 이해한다.</p>
<h3 id="decision-tree-구조"><a class="header" href="#decision-tree-구조">Decision Tree 구조</a></h3>
<p><strong>Decision tree는 다음 요소로 구성된다:</strong></p>
<ol>
<li><strong>Internal nodes (decision nodes)</strong>: Test operations
<ul>
<li>Constructor test: “Is this value Nil or Cons?”</li>
<li>Literal test: “Is this value 0 or 1 or 2?”</li>
</ul>
</li>
<li><strong>Edges</strong>: Test outcomes (branches)
<ul>
<li>Constructor edges: Nil branch, Cons branch</li>
<li>Literal edges: 0 branch, 1 branch, default branch</li>
</ul>
</li>
<li><strong>Leaf nodes</strong>: Actions
<ul>
<li>Success leaf: Execute action (return value)</li>
<li>Failure leaf: Match failure (non-exhaustive error)</li>
</ul>
</li>
</ol>
<p><strong>Tree traversal:</strong></p>
<ul>
<li>Root에서 시작</li>
<li>각 internal node에서 test 실행</li>
<li>Test outcome에 따라 edge 선택</li>
<li>Leaf에 도달하면 종료 (action 실행 또는 failure)</li>
</ul>
<h3 id="example-list-length-decision-tree"><a class="header" href="#example-list-length-decision-tree">Example: List Length Decision Tree</a></h3>
<p><strong>Pattern matrix:</strong></p>
<pre><code>| Nil             →  a1 (return 0)
| Cons(head, tail) →  a2 (return 1 + length tail)
</code></pre>
<p><strong>Decision tree:</strong></p>
<pre><code>       [list]
         |
    Test: constructor
       /   \
     Nil   Cons
     /       \
   Leaf     [head, tail]
   a1          |
             Leaf
              a2
</code></pre>
<p><strong>Tree 설명:</strong></p>
<ol>
<li><strong>Root node</strong>: <code>list</code>의 constructor 테스트</li>
<li><strong>Nil edge</strong>: Nil constructor → Leaf (action a1)</li>
<li><strong>Cons edge</strong>: Cons constructor → Intermediate node (head, tail 추출)</li>
<li><strong>Cons leaf</strong>: Action a2 실행</li>
</ol>
<p><strong>왜 [head, tail] node가 필요한가?</strong></p>
<p>Cons pattern <code>Cons(head, tail)</code>은 subpatterns를 가진다. Cons case에서:</p>
<ul>
<li><code>head</code> 값을 추출해서 변수 <code>head</code>에 바인딩</li>
<li><code>tail</code> 값을 추출해서 변수 <code>tail</code>에 바인딩</li>
</ul>
<p>이 바인딩들이 action a2에서 사용된다.</p>
<p><strong>Simplified view (bindings 생략):</strong></p>
<pre><code>       [list]
         |
    Test: constructor
       /   \
     Nil   Cons
     /       \
   a1        a2
</code></pre>
<p>구현에서는 Cons branch에서 head/tail 추출 코드를 삽입한다.</p>
<h3 id="example-nested-pattern-decision-tree"><a class="header" href="#example-nested-pattern-decision-tree">Example: Nested Pattern Decision Tree</a></h3>
<p><strong>Pattern matrix:</strong></p>
<pre><code>| Nil                   →  a1 ("empty")
| Cons(x, Nil)          →  a2 ("singleton")
| Cons(x, Cons(y, rest)) →  a3 ("at least two")
</code></pre>
<p><strong>Decision tree:</strong></p>
<pre><code>          [list]
            |
       Test: constructor
         /   \
       Nil   Cons
       /       \
     a1      [head, tail]
                |
          Test: tail constructor
              /   \
            Nil   Cons
            /       \
          a2      [y, rest]
                     |
                    a3
</code></pre>
<p><strong>Tree traversal example:</strong></p>
<p>Input: <code>Cons(1, Cons(2, Nil))</code></p>
<ol>
<li>Root: Test <code>list</code> constructor → Cons</li>
<li>Extract <code>head = 1</code>, <code>tail = Cons(2, Nil)</code></li>
<li>Test <code>tail</code> constructor → Cons</li>
<li>Extract <code>y = 2</code>, <code>rest = Nil</code></li>
<li>Leaf a3 (“at least two”)</li>
</ol>
<p><strong>Key property: 각 subterm을 한 번만 테스트</strong></p>
<ul>
<li><code>list</code> constructor: 1번 테스트</li>
<li><code>tail</code> constructor: 1번 테스트</li>
</ul>
<p>Naive if-else chain은 <code>list</code> constructor를 여러 번 테스트할 수 있다.</p>
<h3 id="comparison-decision-tree-vs-if-else-chain"><a class="header" href="#comparison-decision-tree-vs-if-else-chain">Comparison: Decision Tree vs If-Else Chain</a></h3>
<p><strong>If-Else chain (naive compilation):</strong></p>
<pre><code class="language-mlir">// Pattern 1: Nil
%is_nil = arith.cmpi eq, %tag, %c0 : i32
scf.if %is_nil {
    scf.yield %a1 : i32
} else {
    // Pattern 2: Cons(x, Nil)
    %is_cons = arith.cmpi eq, %tag, %c1 : i32  // Redundant test!
    scf.if %is_cons {
        %tail = // extract tail
        %tail_tag = llvm.extractvalue %tail[0] : !llvm.struct&lt;(i32, ptr)&gt;
        %tail_is_nil = arith.cmpi eq, %tail_tag, %c0 : i32
        scf.if %tail_is_nil {
            scf.yield %a2 : i32
        } else {
            // Pattern 3: Cons(x, Cons(y, rest))
            // ... (more tests)
        }
    }
}
</code></pre>
<p><strong>문제:</strong></p>
<ol>
<li><code>%is_cons</code> test는 중복 (Nil이 아니면 자동으로 Cons)</li>
<li>Nested if-else는 depth가 깊어진다</li>
<li>각 level에서 동일한 값을 반복 테스트</li>
</ol>
<p><strong>Decision tree (optimal compilation):</strong></p>
<pre><code class="language-mlir">// Test list constructor once
%tag = llvm.extractvalue %list[0] : !llvm.struct&lt;(i32, ptr)&gt;
%result = scf.index_switch %tag : i32 -&gt; i32
case 0 {  // Nil
    scf.yield %a1 : i32
}
case 1 {  // Cons
    %data = llvm.extractvalue %list[1] : !llvm.struct&lt;(i32, ptr)&gt;
    %head = llvm.load %data[0] : !llvm.ptr -&gt; i32
    %tail_ptr = llvm.getelementptr %data[1] : (!llvm.ptr) -&gt; !llvm.ptr
    %tail = llvm.load %tail_ptr : !llvm.ptr -&gt; !llvm.struct&lt;(i32, ptr)&gt;

    // Test tail constructor once
    %tail_tag = llvm.extractvalue %tail[0] : !llvm.struct&lt;(i32, ptr)&gt;
    %tail_result = scf.index_switch %tail_tag : i32 -&gt; i32
    case 0 {  // Nil
        scf.yield %a2 : i32
    }
    case 1 {  // Cons
        %tail_data = llvm.extractvalue %tail[1] : !llvm.struct&lt;(i32, ptr)&gt;
        %y = llvm.load %tail_data[0] : !llvm.ptr -&gt; i32
        %rest_ptr = llvm.getelementptr %tail_data[1] : (!llvm.ptr) -&gt; !llvm.ptr
        %rest = llvm.load %rest_ptr : !llvm.ptr -&gt; !llvm.struct&lt;(i32, ptr)&gt;
        scf.yield %a3 : i32
    }
    scf.yield %tail_result : i32
}
</code></pre>
<p><strong>장점:</strong></p>
<ol>
<li>각 constructor tag를 정확히 한 번만 테스트 (<code>scf.index_switch</code>)</li>
<li>불필요한 비교 연산 제거</li>
<li>Structured control flow (SCF dialect)로 최적화 기회 제공</li>
</ol>
<h3 id="decision-tree-benefits"><a class="header" href="#decision-tree-benefits">Decision Tree Benefits</a></h3>
<p><strong>1. Efficiency: O(d) tests (d = pattern depth)</strong></p>
<p>Nested pattern의 depth가 d면, 최대 d번의 test만 필요하다.</p>
<ul>
<li>Flat pattern (<code>Nil</code>, <code>Cons(_, _)</code>): 1번 test</li>
<li>Nested pattern (<code>Cons(_, Cons(_, _))</code>): 2번 test (outer, inner)</li>
</ul>
<p>If-else chain은 worst case O(n × d) tests (n = pattern 개수).</p>
<p><strong>2. Exhaustiveness checking: Leaf coverage</strong></p>
<p>모든 가능한 input이 어떤 leaf에 도달하면 exhaustive.</p>
<p>Leaf에 도달하지 않는 경로가 있으면 non-exhaustive.</p>
<p><strong>Example: Non-exhaustive detection</strong></p>
<pre><code>Pattern matrix:
| Nil  →  a1
// Missing Cons case
</code></pre>
<p>Decision tree:</p>
<pre><code>    [list]
      |
  Test: constructor
    /   \
  Nil   Cons
  /       \
a1      FAILURE  // No action for Cons
</code></pre>
<p>Cons branch가 Failure leaf로 이어진다 → Compile error: “non-exhaustive match”</p>
<p><strong>3. Optimization opportunities</strong></p>
<p>Decision tree는 structured representation이라서:</p>
<ul>
<li>Common subexpression elimination (같은 test를 여러 번 안 함)</li>
<li>Dead code elimination (도달 불가능한 patterns 제거)</li>
<li>Branch prediction hints (frequent cases 먼저 테스트)</li>
</ul>
<h3 id="relationship-pattern-matrix--decision-tree"><a class="header" href="#relationship-pattern-matrix--decision-tree">Relationship: Pattern Matrix → Decision Tree</a></h3>
<p><strong>Compilation function:</strong></p>
<pre><code>compile : PatternMatrix × OccurrenceVector → DecisionTree
</code></pre>
<p><strong>Input:</strong></p>
<ul>
<li>Pattern matrix <code>P</code> (n rows × m columns)</li>
<li>Occurrence vector <code>π</code> (m elements)</li>
</ul>
<p><strong>Output:</strong></p>
<ul>
<li>Decision tree <code>T</code></li>
</ul>
<p><strong>Recursive algorithm:</strong></p>
<pre><code>function compile(P, π):
    if P is empty:
        return Failure  // Non-exhaustive

    if first row is irrefutable:
        return Success(action)  // Found match

    column = select_column(P)
    constructors = get_constructors(P, column)

    branches = {}
    for each constructor c:
        P_c = specialize(P, column, c)
        π_c = specialize_occurrences(π, column, c)
        branches[c] = compile(P_c, π_c)

    P_default = default(P, column)
    π_default = default_occurrences(π, column)
    default_branch = compile(P_default, π_default)

    return Switch(π[column], branches, default_branch)
</code></pre>
<p><strong>핵심 operations:</strong></p>
<ol>
<li><strong><code>select_column</code></strong>: 어느 column을 먼저 테스트할지 선택 (heuristic)</li>
<li><strong><code>specialize</code></strong>: Constructor와 매칭되는 rows만 남기고, subpatterns 확장</li>
<li><strong><code>default</code></strong>: Wildcard rows만 남기고, 테스트한 column 제거</li>
</ol>
<p><strong>Next sections:</strong> Specialization과 defaulting을 자세히 설명한다.</p>
<hr>
<h2 id="specialization-연산"><a class="header" href="#specialization-연산">Specialization 연산</a></h2>
<p>Specialization은 decision tree 알고리즘의 <strong>핵심 operation</strong>이다. Constructor test가 성공했을 때 pattern matrix를 어떻게 변환하는지 정의한다.</p>
<h3 id="specialization-정의"><a class="header" href="#specialization-정의">Specialization 정의</a></h3>
<p><strong>Specialization (S):</strong></p>
<pre><code>S(c, i, P) = Specialized pattern matrix
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>c</code>: Constructor (예: <code>Cons</code>, <code>Nil</code>)</li>
<li><code>i</code>: Column index (어느 scrutinee를 테스트하는가)</li>
<li><code>P</code>: Original pattern matrix</li>
</ul>
<p><strong>Operation:</strong></p>
<ol>
<li>Column <code>i</code>의 pattern이 constructor <code>c</code>와 <strong>호환되는</strong> rows만 유지</li>
<li>호환되는 patterns를 <strong>subpatterns로 확장</strong> (constructor decomposition)</li>
<li>Column <code>i</code>를 제거하고 subpattern columns를 삽입</li>
</ol>
<h3 id="example-1-simple-list-specialization-cons"><a class="header" href="#example-1-simple-list-specialization-cons">Example 1: Simple List Specialization (Cons)</a></h3>
<p><strong>Original pattern matrix:</strong></p>
<pre><code>Column: [list]

| Nil             →  a1
| Cons(head, tail) →  a2
| _               →  a3
</code></pre>
<p><strong>Specialize on column 0, constructor Cons:</strong></p>
<p><code>S(Cons, 0, P)</code>:</p>
<p><strong>Step 1: Filter compatible rows</strong></p>
<ul>
<li>Row 1 (<code>Nil</code>): Incompatible with Cons → 제거</li>
<li>Row 2 (<code>Cons(head, tail)</code>): Compatible → 유지</li>
<li>Row 3 (<code>_</code>): Wildcard, compatible → 유지</li>
</ul>
<p><strong>Step 2: Decompose patterns</strong></p>
<ul>
<li>Row 2: <code>Cons(head, tail)</code> → expand to <code>[head, tail]</code></li>
<li>Row 3: <code>_</code> → expand to <code>[_, _]</code> (wildcard for each subpattern)</li>
</ul>
<p><strong>Step 3: Replace column 0 with subpattern columns</strong></p>
<pre><code>Columns: [head, tail]

| head  tail  →  a2
| _     _     →  a3
</code></pre>
<p><strong>Occurrence vector update:</strong></p>
<pre><code>Before: π = [list]
After:  π = [list.head, list.tail]
</code></pre>
<h3 id="example-2-specialization-on-nil"><a class="header" href="#example-2-specialization-on-nil">Example 2: Specialization on Nil</a></h3>
<p><strong>Original pattern matrix:</strong></p>
<pre><code>Column: [list]

| Nil             →  a1
| Cons(head, tail) →  a2
| _               →  a3
</code></pre>
<p><strong>Specialize on column 0, constructor Nil:</strong></p>
<p><code>S(Nil, 0, P)</code>:</p>
<p><strong>Step 1: Filter compatible rows</strong></p>
<ul>
<li>Row 1 (<code>Nil</code>): Compatible → 유지</li>
<li>Row 2 (<code>Cons(head, tail)</code>): Incompatible with Nil → 제거</li>
<li>Row 3 (<code>_</code>): Wildcard, compatible → 유지</li>
</ul>
<p><strong>Step 2: Decompose patterns</strong></p>
<p>Nil constructor는 <strong>subpatterns가 없다</strong> (nullary constructor).</p>
<ul>
<li>Row 1: <code>Nil</code> → no subpatterns</li>
<li>Row 3: <code>_</code> → no subpatterns</li>
</ul>
<p><strong>Step 3: Remove column 0 (no subpatterns to add)</strong></p>
<pre><code>Columns: [] (empty)

| →  a1
| →  a3
</code></pre>
<p><strong>Occurrence vector update:</strong></p>
<pre><code>Before: π = [list]
After:  π = [] (empty)
</code></pre>
<p>Empty occurrence vector는 <strong>모든 tests가 완료</strong>되었음을 의미. 이제 첫 번째 row의 action을 선택한다.</p>
<h3 id="example-3-nested-pattern-specialization"><a class="header" href="#example-3-nested-pattern-specialization">Example 3: Nested Pattern Specialization</a></h3>
<p><strong>Original pattern matrix:</strong></p>
<pre><code>Column: [list]

| Cons(x, Nil)          →  a1
| Cons(x, Cons(y, rest)) →  a2
</code></pre>
<p><strong>Specialize on column 0, constructor Cons:</strong></p>
<p><code>S(Cons, 0, P)</code>:</p>
<p><strong>Step 1: Filter compatible rows</strong></p>
<p>Both rows have <code>Cons</code> → 둘 다 유지</p>
<p><strong>Step 2: Decompose patterns</strong></p>
<ul>
<li>Row 1: <code>Cons(x, Nil)</code> → subpatterns <code>[x, Nil]</code></li>
<li>Row 2: <code>Cons(x, Cons(y, rest))</code> → subpatterns <code>[x, Cons(y, rest)]</code></li>
</ul>
<p><strong>Step 3: Replace column 0 with subpattern columns</strong></p>
<pre><code>Columns: [head, tail]

| x  Nil              →  a1
| x  Cons(y, rest)    →  a2
</code></pre>
<p><strong>Occurrence vector update:</strong></p>
<pre><code>Before: π = [list]
After:  π = [list.head, list.tail]
</code></pre>
<p><strong>이제 column 1 (tail)에 대해 다시 specialization:</strong></p>
<p>Matrix after first specialization:</p>
<pre><code>| x  Nil              →  a1
| x  Cons(y, rest)    →  a2
</code></pre>
<p>Specialize on column 1, constructor Nil:</p>
<pre><code>Columns: [head]

| x  →  a1
</code></pre>
<p>Specialize on column 1, constructor Cons:</p>
<pre><code>Columns: [head, y, rest]

| x  y  rest  →  a2
</code></pre>
<p><strong>Nested patterns는 여러 번의 specialization으로 처리된다.</strong></p>
<h3 id="wildcard-expansion-rule"><a class="header" href="#wildcard-expansion-rule">Wildcard Expansion Rule</a></h3>
<p><strong>Wildcard pattern <code>_</code>의 specialization:</strong></p>
<p>Constructor <code>c</code>가 arity <code>n</code> (subpatterns 개수)를 가지면:</p>
<pre><code>_ → [_, _, ..., _]  (n개의 wildcards)
</code></pre>
<p><strong>Example: Cons constructor (arity 2)</strong></p>
<pre><code>_ → [_, _]  // head wildcard, tail wildcard
</code></pre>
<p><strong>Example: Nil constructor (arity 0)</strong></p>
<pre><code>_ → []  // No subpatterns
</code></pre>
<p><strong>왜 wildcard를 확장하는가?</strong></p>
<p>Wildcard는 “모든 값과 매칭“을 의미한다. Constructor <code>c</code>와 매칭되면, <code>c</code>의 모든 subpatterns도 wildcard로 매칭된다.</p>
<pre><code class="language-fsharp">// Original pattern
| _ -&gt; action

// After specialization on Cons
// Equivalent to:
| Cons(_, _) -&gt; action
</code></pre>
<h3 id="variable-pattern-specialization"><a class="header" href="#variable-pattern-specialization">Variable Pattern Specialization</a></h3>
<p><strong>Variable pattern <code>x</code>의 specialization:</strong></p>
<p>Variable은 wildcard와 동일하게 확장되지만, <strong>binding name을 유지</strong>한다.</p>
<pre><code>x → [_, _, ..., _]  // Subpatterns, 하지만 x는 여전히 전체 값에 바인딩됨
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-fsharp">match list with
| xs -&gt; length xs  // xs는 전체 list에 바인딩
</code></pre>
<p>Specialize on Cons:</p>
<pre><code>Columns: [head, tail]

| _  _  →  length (Cons head tail)
</code></pre>
<p><code>xs</code> 바인딩은 <strong>original occurrence</strong>에 남는다. Specialization 후에도 <code>xs</code>는 사용 가능하다.</p>
<blockquote>
<p><strong>Implementation note:</strong> Variable bindings는 pattern matrix에 직접 저장되지 않고, <strong>occurrence vector와 함께 관리</strong>된다. Action에서 variable을 사용할 때 occurrence path로 접근한다.</p>
</blockquote>
<h3 id="specialization-pseudocode"><a class="header" href="#specialization-pseudocode">Specialization Pseudocode</a></h3>
<p><strong>Algorithm: specialize(P, column, constructor)</strong></p>
<pre><code class="language-python">def specialize(P, column, constructor):
    """
    P: Pattern matrix (n rows × m columns)
    column: Column index to specialize
    constructor: Constructor to match (e.g., Cons, Nil)

    Returns: Specialized matrix
    """
    result_rows = []
    arity = get_arity(constructor)  // Subpattern 개수

    for row in P:
        pattern = row[column]

        if matches_constructor(pattern, constructor):
            # Compatible pattern
            if pattern.is_constructor and pattern.name == constructor:
                # Extract subpatterns
                subpatterns = pattern.subpatterns  // e.g., [head, tail]
            elif pattern.is_wildcard or pattern.is_variable:
                # Expand to wildcard subpatterns
                subpatterns = [Wildcard] * arity  // e.g., [_, _]
            else:
                # Incompatible (different constructor)
                continue  # Skip this row

            # Build new row: columns before + subpatterns + columns after
            new_row = (
                row[:column] +
                subpatterns +
                row[column+1:]
            )
            result_rows.append((new_row, row.action))

    return PatternMatrix(result_rows)

def matches_constructor(pattern, constructor):
    """Check if pattern is compatible with constructor"""
    if pattern.is_wildcard or pattern.is_variable:
        return True  # Wildcard matches everything
    if pattern.is_constructor and pattern.name == constructor:
        return True  # Same constructor
    return False  # Different constructor
</code></pre>
<h3 id="visual-example-specialization-flow"><a class="header" href="#visual-example-specialization-flow">Visual Example: Specialization Flow</a></h3>
<p><strong>Original:</strong></p>
<pre><code>   [list]
     |
| Nil        →  a1
| Cons(x, y) →  a2
| _          →  a3
</code></pre>
<p><strong>After S(Cons, 0, P):</strong></p>
<pre><code>   [x, y]  (head, tail)
     |
| x  y  →  a2  (from Cons(x, y))
| _  _  →  a3  (from _)
</code></pre>
<p>Row 1 (<code>Nil</code>) 제거됨 (incompatible).</p>
<p><strong>After S(Nil, 0, P) on original:</strong></p>
<pre><code>   []  (no occurrences)
    |
| →  a1  (from Nil)
| →  a3  (from _)
</code></pre>
<p>Rows 2 (<code>Cons</code>) 제거됨 (incompatible).</p>
<h3 id="key-insight-specialization--assumption--decomposition"><a class="header" href="#key-insight-specialization--assumption--decomposition">Key Insight: Specialization = Assumption + Decomposition</a></h3>
<p><strong>Specialization의 의미:</strong></p>
<blockquote>
<p>“Column <code>i</code>의 constructor가 <code>c</code>라고 <strong>가정</strong>하면, pattern matrix는 어떻게 변하는가?”</p>
</blockquote>
<p><strong>Assumption:</strong></p>
<ul>
<li>Constructor test가 성공했다 (e.g., <code>list</code>가 <code>Cons</code>)</li>
<li>이제 <code>c</code>의 subpatterns에 접근 가능 (e.g., <code>head</code>, <code>tail</code>)</li>
</ul>
<p><strong>Decomposition:</strong></p>
<ul>
<li>호환되지 않는 rows 제거 (Nil patterns)</li>
<li>호환되는 rows의 patterns를 subpatterns로 확장</li>
</ul>
<p><strong>Next:</strong> Defaulting 연산은 반대 상황을 다룬다 (constructor test 실패).</p>
<hr>
<h2 id="defaulting-연산"><a class="header" href="#defaulting-연산">Defaulting 연산</a></h2>
<p>Defaulting은 specialization의 <strong>complement</strong>다. Constructor test가 <strong>실패</strong>했을 때 (또는 테스트하지 않고 default case로 가려 할 때) pattern matrix를 어떻게 변환하는지 정의한다.</p>
<h3 id="defaulting-정의"><a class="header" href="#defaulting-정의">Defaulting 정의</a></h3>
<p><strong>Defaulting (D):</strong></p>
<pre><code>D(i, P) = Default pattern matrix
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>i</code>: Column index</li>
<li><code>P</code>: Original pattern matrix</li>
</ul>
<p><strong>Operation:</strong></p>
<ol>
<li>Column <code>i</code>의 pattern이 <strong>wildcard 또는 variable</strong>인 rows만 유지</li>
<li>Column <code>i</code>를 <strong>제거</strong> (더 이상 테스트 안 함)</li>
<li>나머지 columns는 유지</li>
</ol>
<p><strong>의미:</strong></p>
<blockquote>
<p>“Column <code>i</code>에 대한 모든 constructor tests가 실패했다. Wildcard rows만 남는다.”</p>
</blockquote>
<h3 id="example-1-simple-list-defaulting"><a class="header" href="#example-1-simple-list-defaulting">Example 1: Simple List Defaulting</a></h3>
<p><strong>Original pattern matrix:</strong></p>
<pre><code>Column: [list]

| Nil             →  a1
| Cons(head, tail) →  a2
| _               →  a3
</code></pre>
<p><strong>Default on column 0:</strong></p>
<p><code>D(0, P)</code>:</p>
<p><strong>Step 1: Filter wildcard rows</strong></p>
<ul>
<li>Row 1 (<code>Nil</code>): Constructor pattern → 제거</li>
<li>Row 2 (<code>Cons(head, tail)</code>): Constructor pattern → 제거</li>
<li>Row 3 (<code>_</code>): Wildcard → 유지</li>
</ul>
<p><strong>Step 2: Remove column 0</strong></p>
<pre><code>Columns: [] (empty)

| →  a3
</code></pre>
<p><strong>Occurrence vector update:</strong></p>
<pre><code>Before: π = [list]
After:  π = [] (empty)
</code></pre>
<p>Empty matrix with one row → Irrefutable → Select action a3.</p>
<h3 id="example-2-empty-default-matrix"><a class="header" href="#example-2-empty-default-matrix">Example 2: Empty Default Matrix</a></h3>
<p><strong>Original pattern matrix:</strong></p>
<pre><code>Column: [list]

| Nil             →  a1
| Cons(head, tail) →  a2
</code></pre>
<p><strong>Default on column 0:</strong></p>
<p><code>D(0, P)</code>:</p>
<p><strong>Step 1: Filter wildcard rows</strong></p>
<ul>
<li>Row 1 (<code>Nil</code>): Constructor pattern → 제거</li>
<li>Row 2 (<code>Cons(head, tail)</code>): Constructor pattern → 제거</li>
</ul>
<p><strong>Result: Empty matrix</strong></p>
<pre><code>Columns: []

(no rows)
</code></pre>
<p><strong>의미: Non-exhaustive match!</strong></p>
<p>모든 rows가 constructor patterns이면, defaulting은 empty matrix를 생성한다. 즉, wildcard case가 없다 → Non-exhaustive.</p>
<p><strong>Compiler action:</strong></p>
<p>Empty default matrix는 <strong>compile error</strong>를 발생시킨다:</p>
<pre><code>Error: Non-exhaustive pattern match
Missing case: (other constructors or wildcard)
</code></pre>
<h3 id="example-3-multiple-columns-defaulting"><a class="header" href="#example-3-multiple-columns-defaulting">Example 3: Multiple Columns Defaulting</a></h3>
<p><strong>Original pattern matrix:</strong></p>
<pre><code>Columns: [list1, list2]

| Nil         Nil          →  a1
| Nil         Cons(x, _)   →  a2
| Cons(_, _)  Nil          →  a3
| Cons(x, _)  Cons(y, _)   →  a4
| _           _            →  a5
</code></pre>
<p><strong>Default on column 0:</strong></p>
<p><code>D(0, P)</code>:</p>
<p><strong>Step 1: Filter wildcard rows on column 0</strong></p>
<ul>
<li>Row 1 (<code>Nil</code>): Constructor → 제거</li>
<li>Row 2 (<code>Nil</code>): Constructor → 제거</li>
<li>Row 3 (<code>Cons(_, _)</code>): Constructor → 제거</li>
<li>Row 4 (<code>Cons(x, _)</code>): Constructor → 제거</li>
<li>Row 5 (<code>_</code>): Wildcard → 유지</li>
</ul>
<p><strong>Step 2: Remove column 0</strong></p>
<pre><code>Columns: [list2]

| _  →  a5
</code></pre>
<p><strong>Occurrence vector update:</strong></p>
<pre><code>Before: π = [list1, list2]
After:  π = [list2]
</code></pre>
<p><strong>이제 column 0 (이전 list2)에 대해 specialization 또는 defaulting을 계속할 수 있다.</strong></p>
<h3 id="defaulting-vs-specialization-when-to-use"><a class="header" href="#defaulting-vs-specialization-when-to-use">Defaulting vs Specialization: When to Use</a></h3>
<p><strong>Specialization:</strong></p>
<p>Constructor test가 <strong>성공</strong>했을 때.</p>
<pre><code>if (tag == CONS) {
    // Specialize on Cons
    S(Cons, 0, P)
}
</code></pre>
<p><strong>Defaulting:</strong></p>
<p>모든 constructor tests가 <strong>실패</strong>했을 때.</p>
<pre><code>if (tag == NIL) {
    S(Nil, 0, P)
} else if (tag == CONS) {
    S(Cons, 0, P)
} else {
    // Default case
    D(0, P)
}
</code></pre>
<p><strong>하지만 list는 Nil 또는 Cons만 존재한다!</strong></p>
<p>완전한 constructor set (Nil, Cons)을 모두 테스트하면 default case는 unreachable이다.</p>
<p><strong>Defaulting이 필요한 경우:</strong></p>
<ol>
<li><strong>Extensible constructors</strong>: Open constructor sets (예: integers)</li>
<li><strong>Incomplete specialization</strong>: 일부 constructors만 테스트</li>
<li><strong>Wildcard-only rows</strong>: 모든 constructors 후 남은 wildcard 처리</li>
</ol>
<p><strong>List의 경우 (closed constructor set):</strong></p>
<pre><code>if (tag == NIL) {
    S(Nil, 0, P)
} else {
    // Must be CONS (only two constructors)
    S(Cons, 0, P)
}
</code></pre>
<p>Default branch는 필요 없다. 하지만 algorithm에서는 여전히 defaulting을 계산해서 <strong>exhaustiveness를 체크</strong>한다.</p>
<h3 id="defaulting-empty-matrix-detection"><a class="header" href="#defaulting-empty-matrix-detection">Defaulting Empty Matrix Detection</a></h3>
<p><strong>Defaulting의 중요한 역할: Exhaustiveness checking</strong></p>
<p><strong>Case 1: Non-empty default matrix</strong></p>
<pre><code>Pattern matrix:
| Cons(x, xs)  →  a1
| _            →  a2  // Wildcard exists
</code></pre>
<p>Default on column 0:</p>
<pre><code>| →  a2  // Non-empty
</code></pre>
<p><strong>Result: Exhaustive</strong> (wildcard catches everything)</p>
<p><strong>Case 2: Empty default matrix</strong></p>
<pre><code>Pattern matrix:
| Cons(x, xs)  →  a1
// No wildcard
</code></pre>
<p>Default on column 0:</p>
<pre><code>(empty matrix)
</code></pre>
<p><strong>Result: Non-exhaustive</strong> (missing Nil case and wildcard)</p>
<p><strong>Compiler error:</strong></p>
<pre><code>Error: Non-exhaustive pattern match
Missing case: Nil
</code></pre>
<h3 id="defaulting-pseudocode"><a class="header" href="#defaulting-pseudocode">Defaulting Pseudocode</a></h3>
<p><strong>Algorithm: default(P, column)</strong></p>
<pre><code class="language-python">def default(P, column):
    """
    P: Pattern matrix (n rows × m columns)
    column: Column index to default

    Returns: Default matrix (wildcard rows only, column removed)
    """
    result_rows = []

    for row in P:
        pattern = row[column]

        if pattern.is_wildcard or pattern.is_variable:
            # Wildcard row: keep it, remove column
            new_row = row[:column] + row[column+1:]
            result_rows.append((new_row, row.action))
        else:
            # Constructor pattern: remove this row
            continue

    return PatternMatrix(result_rows)
</code></pre>
<p><strong>Simplicity:</strong></p>
<p>Defaulting은 specialization보다 간단하다:</p>
<ul>
<li>No subpattern expansion</li>
<li>Just filter wildcard rows and remove column</li>
</ul>
<h3 id="visual-example-defaulting-flow"><a class="header" href="#visual-example-defaulting-flow">Visual Example: Defaulting Flow</a></h3>
<p><strong>Original:</strong></p>
<pre><code>   [list]
     |
| Nil        →  a1
| Cons(x, y) →  a2
| _          →  a3
</code></pre>
<p><strong>After D(0, P):</strong></p>
<pre><code>   []  (no occurrences)
    |
| →  a3  (from _)
</code></pre>
<p>Rows 1 (<code>Nil</code>) and 2 (<code>Cons</code>) 제거됨 (constructor patterns).</p>
<p><strong>Empty default example:</strong></p>
<pre><code>   [list]
     |
| Nil        →  a1
| Cons(x, y) →  a2
</code></pre>
<p><strong>After D(0, P):</strong></p>
<pre><code>   []
    |
(empty - no wildcard rows)
</code></pre>
<p><strong>Compiler:</strong> “Error: Non-exhaustive match”</p>
<h3 id="key-insight-defaulting--catch-all-case"><a class="header" href="#key-insight-defaulting--catch-all-case">Key Insight: Defaulting = Catch-All Case</a></h3>
<p><strong>Defaulting의 의미:</strong></p>
<blockquote>
<p>“모든 명시적 constructor tests가 실패했다. 남은 rows는 wildcard만 있다. Wildcard는 <strong>catch-all</strong>이다.”</p>
</blockquote>
<p><strong>Properties:</strong></p>
<ol>
<li><strong>Default matrix는 항상 wildcards만 포함</strong> (constructors 제거됨)</li>
<li><strong>Empty default matrix = non-exhaustive</strong> (catch-all 없음)</li>
<li><strong>Default 후 irrefutable row가 남으면 항상 매칭</strong> (first wildcard row 선택)</li>
</ol>
<p><strong>Next:</strong> Specialization과 defaulting을 결합해서 complete compilation algorithm을 만든다.</p>
<hr>
<h2 id="complete-compilation-algorithm"><a class="header" href="#complete-compilation-algorithm">Complete Compilation Algorithm</a></h2>
<p>이제 specialization과 defaulting을 결합해서 <strong>complete decision tree compilation algorithm</strong>을 구성한다.</p>
<h3 id="algorithm-overview"><a class="header" href="#algorithm-overview">Algorithm Overview</a></h3>
<p><strong>Recursive function:</strong></p>
<pre><code>compile : PatternMatrix × OccurrenceVector → DecisionTree
</code></pre>
<p><strong>Input:</strong></p>
<ul>
<li>Pattern matrix <code>P</code> (n rows × m columns)</li>
<li>Occurrence vector <code>π</code> (m elements, scrutinee access paths)</li>
</ul>
<p><strong>Output:</strong></p>
<ul>
<li>Decision tree <code>T</code></li>
</ul>
<p><strong>Strategy:</strong></p>
<ol>
<li><strong>Base cases</strong>: Empty matrix, irrefutable first row</li>
<li><strong>Recursive case</strong>: Select column, specialize on constructors, recurse</li>
<li><strong>Default case</strong>: Default on column, recurse</li>
</ol>
<h3 id="base-case-1-empty-matrix"><a class="header" href="#base-case-1-empty-matrix">Base Case 1: Empty Matrix</a></h3>
<p><strong>Condition:</strong></p>
<pre><code class="language-python">if P.is_empty():
</code></pre>
<p><strong>Meaning:</strong></p>
<p>No pattern rows remain. 어떤 pattern도 매칭되지 않는다.</p>
<p><strong>Action:</strong></p>
<pre><code class="language-python">return FailureLeaf()
</code></pre>
<p><strong>MLIR equivalent:</strong></p>
<pre><code class="language-mlir">// Non-exhaustive match error
llvm.call @match_failure() : () -&gt; ()
llvm.unreachable
</code></pre>
<p><strong>Example:</strong></p>
<pre><code>Pattern matrix:
(empty)
</code></pre>
<p>Input: <code>Cons(1, Nil)</code></p>
<p>No patterns → <strong>match failure</strong></p>
<h3 id="base-case-2-irrefutable-first-row"><a class="header" href="#base-case-2-irrefutable-first-row">Base Case 2: Irrefutable First Row</a></h3>
<p><strong>Condition:</strong></p>
<pre><code class="language-python">if all(p.is_wildcard or p.is_variable for p in P[0]):
</code></pre>
<p><strong>Meaning:</strong></p>
<p>첫 번째 row의 모든 patterns가 wildcard 또는 variable이다. 이 row는 <strong>항상 매칭</strong>된다.</p>
<p><strong>Action:</strong></p>
<pre><code class="language-python">return SuccessLeaf(P[0].action)
</code></pre>
<p><strong>Example:</strong></p>
<pre><code>Pattern matrix:
| _  _  →  a1
| ... (more rows, but unreachable)
</code></pre>
<p>Any input → <strong>select action a1</strong></p>
<p><strong>Unreachable rows:</strong></p>
<p>첫 번째 irrefutable row 이후의 rows는 <strong>절대 실행 안 됨</strong>.</p>
<pre><code class="language-fsharp">match list with
| _ -&gt; 0
| Nil -&gt; 1  // Warning: Unreachable pattern
</code></pre>
<p>Compiler warning: “Unreachable pattern (row 2)”</p>
<h3 id="recursive-case-constructor-test"><a class="header" href="#recursive-case-constructor-test">Recursive Case: Constructor Test</a></h3>
<p><strong>Condition:</strong></p>
<pre><code class="language-python">if P is not empty and first row has constructors:
</code></pre>
<p><strong>Steps:</strong></p>
<ol>
<li><strong>Select column</strong>: 어느 occurrence를 테스트할지 선택</li>
<li><strong>Get constructors</strong>: 그 column에 등장하는 constructors 수집</li>
<li><strong>Specialize</strong>: 각 constructor에 대해 specialized matrix 생성, recurse</li>
<li><strong>Default</strong>: Wildcard rows로 default matrix 생성, recurse</li>
</ol>
<p><strong>Pseudocode:</strong></p>
<pre><code class="language-python">def compile(P, π):
    # Base case 1: Empty matrix
    if not P:
        return Failure()

    # Base case 2: Irrefutable first row
    if is_irrefutable(P[0]):
        return Success(P[0].action)

    # Recursive case: Constructor test
    column = select_column(P, π)
    constructors = get_constructors(P, column)

    # Build switch node
    branches = {}
    for c in constructors:
        # Specialize on constructor c
        P_c = specialize(P, column, c)
        π_c = specialize_occurrences(π, column, c)
        branches[c] = compile(P_c, π_c)

    # Default branch (wildcard rows)
    P_default = default(P, column)
    π_default = default_occurrences(π, column)
    default_branch = compile(P_default, π_default)

    return Switch(π[column], branches, default_branch)
</code></pre>
<h3 id="column-selection-heuristic"><a class="header" href="#column-selection-heuristic">Column Selection Heuristic</a></h3>
<p><strong>문제:</strong> 여러 columns가 있을 때, 어느 column을 먼저 테스트하는가?</p>
<p><strong>Heuristic 1: Left-to-right (simple)</strong></p>
<pre><code class="language-python">def select_column(P, π):
    return 0  # Always test first column
</code></pre>
<p><strong>장점:</strong> 간단, 예측 가능
<strong>단점:</strong> 비효율적일 수 있음 (redundant tests)</p>
<p><strong>Heuristic 2: Needed by most rows (Maranget)</strong></p>
<pre><code class="language-python">def select_column(P, π):
    """Select column needed by most rows (first constructor pattern)"""
    for col in range(len(π)):
        needed_count = sum(1 for row in P if not row[col].is_wildcard)
        if needed_count &gt; 0:
            return col
    return 0  # All wildcards, any column works
</code></pre>
<p><strong>의미:</strong></p>
<ul>
<li>Constructor pattern이 가장 많은 column 선택</li>
<li>Wildcards는 어떤 constructor도 요구 안 함 (skip 가능)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code>Columns: [c1, c2]

| _     Cons(x, _)  →  a1  // c1 not needed, c2 needed
| Nil   _           →  a2  // c1 needed, c2 not needed
| _     _           →  a3  // neither needed
</code></pre>
<ul>
<li>c1 needed by: 1 row</li>
<li>c2 needed by: 1 row</li>
<li>Tie → select c1 (left-to-right tie-breaker)</li>
</ul>
<p><strong>Heuristic 3: Minimize combined row count (optimal)</strong></p>
<pre><code class="language-python">def select_column(P, π):
    """Select column that minimizes total specialized matrix sizes"""
    best_column = 0
    min_cost = float('inf')

    for col in range(len(π)):
        constructors = get_constructors(P, col)
        cost = sum(len(specialize(P, col, c)) for c in constructors)
        if cost &lt; min_cost:
            min_cost = cost
            best_column = col

    return best_column
</code></pre>
<p><strong>의미:</strong> Specialized matrices의 크기 합이 최소인 column 선택</p>
<p><strong>Tradeoff:</strong> 계산 비용이 높음 (모든 columns에 대해 specialize 시뮬레이션)</p>
<p><strong>FunLang Phase 6 choice: Heuristic 1 (left-to-right)</strong></p>
<p>간단하고 예측 가능. 대부분의 FunLang patterns는 단순해서 heuristic 차이가 크지 않다.</p>
<h3 id="occurrence-specialization"><a class="header" href="#occurrence-specialization">Occurrence Specialization</a></h3>
<p><strong>Specialization 후 occurrence vector 업데이트:</strong></p>
<p><strong>Example: Cons specialization</strong></p>
<pre><code class="language-python">Before: π = [list]
Constructor: Cons (arity 2)

After: π = [list.head, list.tail]
</code></pre>
<p><strong>Pseudocode:</strong></p>
<pre><code class="language-python">def specialize_occurrences(π, column, constructor):
    """Expand occurrence at column into suboccurrences"""
    arity = get_arity(constructor)
    suboccurrences = [
        Occurrence(π[column].path + f".{i}")
        for i in range(arity)
    ]

    # Replace column with suboccurrences
    return π[:column] + suboccurrences + π[column+1:]
</code></pre>
<p><strong>Occurrence paths:</strong></p>
<ul>
<li><code>list</code> → <code>list.0</code> (head), <code>list.1</code> (tail)</li>
<li><code>list.tail</code> → <code>list.1.0</code> (tail’s head), <code>list.1.1</code> (tail’s tail)</li>
</ul>
<p><strong>MLIR code generation:</strong></p>
<pre><code class="language-mlir">// π = [list]
%list = ...

// π = [list.0, list.1]
%head = llvm.extractvalue %list[0] : !llvm.struct&lt;(i32, ptr)&gt;
%tail_ptr = llvm.getelementptr %list[1] : (!llvm.ptr) -&gt; !llvm.ptr
%tail = llvm.load %tail_ptr : !llvm.ptr -&gt; !llvm.struct&lt;(i32, ptr)&gt;
</code></pre>
<p>Occurrence paths는 <strong>extraction code를 생성하는 template</strong>이다.</p>
<h3 id="occurrence-defaulting"><a class="header" href="#occurrence-defaulting">Occurrence Defaulting</a></h3>
<p><strong>Defaulting 후 occurrence vector 업데이트:</strong></p>
<p><strong>Example:</strong></p>
<pre><code class="language-python">Before: π = [list, other]
Default on column 0:

After: π = [other]
</code></pre>
<p><strong>Pseudocode:</strong></p>
<pre><code class="language-python">def default_occurrences(π, column):
    """Remove occurrence at column"""
    return π[:column] + π[column+1:]
</code></pre>
<p>Defaulting은 column을 제거한다 (더 이상 테스트 안 함).</p>
<h3 id="complete-example-list-length-compilation"><a class="header" href="#complete-example-list-length-compilation">Complete Example: List Length Compilation</a></h3>
<p><strong>Pattern matrix:</strong></p>
<pre><code>π = [list]

| Nil             →  0
| Cons(head, tail) →  1 + length tail
</code></pre>
<p><strong>Step 1: compile(P, [list])</strong></p>
<ul>
<li>Not empty</li>
<li>First row not irrefutable (Nil is constructor)</li>
<li>Select column 0</li>
</ul>
<p><strong>Step 2: Get constructors</strong></p>
<pre><code class="language-python">constructors = [Nil, Cons]
</code></pre>
<p><strong>Step 3: Specialize on Nil</strong></p>
<pre><code class="language-python">P_nil = specialize(P, 0, Nil)
π_nil = [list] → []
</code></pre>
<p>Result:</p>
<pre><code>π = []

| →  0
</code></pre>
<p>Irrefutable → <code>Success(0)</code></p>
<p><strong>Step 4: Specialize on Cons</strong></p>
<pre><code class="language-python">P_cons = specialize(P, 0, Cons)
π_cons = [list] → [list.head, list.tail]
</code></pre>
<p>Result:</p>
<pre><code>π = [list.head, list.tail]

| head  tail  →  1 + length tail
</code></pre>
<p>Irrefutable → <code>Success(1 + length tail)</code></p>
<p><strong>Step 5: Default</strong></p>
<pre><code class="language-python">P_default = default(P, 0)
</code></pre>
<p>Result: Empty (no wildcard rows)</p>
<p><code>compile(P_default, []) = Failure()</code></p>
<p>하지만 Nil + Cons가 complete constructor set이므로 default branch는 unreachable.</p>
<p><strong>Generated decision tree:</strong></p>
<pre><code>Switch(list, {
    Nil: Success(0),
    Cons: Success(1 + length tail)
}, Failure())
</code></pre>
<p><strong>MLIR output:</strong></p>
<pre><code class="language-mlir">%tag = llvm.extractvalue %list[0] : !llvm.struct&lt;(i32, ptr)&gt;
%result = scf.index_switch %tag : i32 -&gt; i32
case 0 {  // Nil
    %zero = arith.constant 0 : i32
    scf.yield %zero : i32
}
case 1 {  // Cons
    %data = llvm.extractvalue %list[1] : !llvm.struct&lt;(i32, ptr)&gt;
    %head = llvm.load %data[0] : !llvm.ptr -&gt; i32
    %tail_ptr = llvm.getelementptr %data[1] : (!llvm.ptr) -&gt; !llvm.ptr
    %tail = llvm.load %tail_ptr : !llvm.ptr -&gt; !llvm.struct&lt;(i32, ptr)&gt;

    %one = arith.constant 1 : i32
    %len_tail = func.call @length(%tail) : (!funlang.list&lt;i32&gt;) -&gt; i32
    %result_val = arith.addi %one, %len_tail : i32
    scf.yield %result_val : i32
}
default {
    llvm.unreachable  // Should never reach (exhaustive)
}
</code></pre>
<h3 id="example-2-nested-pattern-compilation"><a class="header" href="#example-2-nested-pattern-compilation">Example 2: Nested Pattern Compilation</a></h3>
<p><strong>Pattern matrix:</strong></p>
<pre><code>π = [list]

| Cons(x, Nil)          →  "singleton"
| Cons(x, Cons(y, rest)) →  "at least two"
| _                     →  "other"
</code></pre>
<p><strong>Step 1: compile(P, [list])</strong></p>
<p>Select column 0, constructors = [Cons]</p>
<p><strong>Step 2: Specialize on Cons</strong></p>
<pre><code class="language-python">P_cons = specialize(P, 0, Cons)
π_cons = [list.head, list.tail]
</code></pre>
<p>Result:</p>
<pre><code>π = [list.head, list.tail]

| x  Nil              →  "singleton"
| x  Cons(y, rest)    →  "at least two"
| _  _                →  "other"
</code></pre>
<p><strong>Step 3: compile(P_cons, [list.head, list.tail])</strong></p>
<p>First row not irrefutable (column 1 has Nil constructor).</p>
<p>Select column 1 (tail), constructors = [Nil, Cons]</p>
<p><strong>Step 4: Specialize on Nil (column 1)</strong></p>
<pre><code class="language-python">P_cons_nil = specialize(P_cons, 1, Nil)
π_cons_nil = [list.head]
</code></pre>
<p>Result:</p>
<pre><code>π = [list.head]

| x  →  "singleton"
| _  →  "other"
</code></pre>
<p>First row irrefutable → <code>Success("singleton")</code></p>
<p><strong>Step 5: Specialize on Cons (column 1)</strong></p>
<pre><code class="language-python">P_cons_cons = specialize(P_cons, 1, Cons)
π_cons_cons = [list.head, list.tail.head, list.tail.tail]
</code></pre>
<p>Result:</p>
<pre><code>π = [list.head, list.tail.head, list.tail.tail]

| x  y  rest  →  "at least two"
| _  _  _     →  "other"
</code></pre>
<p>First row irrefutable → <code>Success("at least two")</code></p>
<p><strong>Step 6: Default (column 1)</strong></p>
<pre><code class="language-python">P_cons_default = default(P_cons, 1)
π_cons_default = [list.head]
</code></pre>
<p>Result:</p>
<pre><code>π = [list.head]

| _  →  "other"
</code></pre>
<p>Irrefutable → <code>Success("other")</code></p>
<p><strong>Step 7: Default on column 0 (original)</strong></p>
<pre><code class="language-python">P_default = default(P, 0)
π_default = []
</code></pre>
<p>Result:</p>
<pre><code>π = []

| →  "other"
</code></pre>
<p>Irrefutable → <code>Success("other")</code></p>
<p><strong>Generated decision tree:</strong></p>
<pre><code>Switch(list, {
    Cons: Switch(list.tail, {
        Nil: Success("singleton"),
        Cons: Success("at least two")
    }, Success("other"))
}, Success("other"))
</code></pre>
<p><strong>Nested structure:</strong> Cons branch 안에 또 다른 switch (tail test).</p>
<hr>
<h2 id="exhaustiveness-checking"><a class="header" href="#exhaustiveness-checking">Exhaustiveness Checking</a></h2>
<p>Exhaustiveness checking은 decision tree 알고리즘에 <strong>자연스럽게 통합</strong>된다.</p>
<h3 id="exhaustiveness-정의"><a class="header" href="#exhaustiveness-정의">Exhaustiveness 정의</a></h3>
<p><strong>Exhaustive pattern match:</strong></p>
<p>모든 가능한 input values가 어떤 pattern과 매칭된다.</p>
<p><strong>Non-exhaustive pattern match:</strong></p>
<p>어떤 input value는 어떤 pattern과도 매칭되지 않는다.</p>
<p><strong>Example: Exhaustive</strong></p>
<pre><code class="language-fsharp">match list with
| Nil -&gt; 0
| Cons(_, _) -&gt; 1
</code></pre>
<p>모든 list는 Nil 또는 Cons다 → Exhaustive.</p>
<p><strong>Example: Non-exhaustive</strong></p>
<pre><code class="language-fsharp">match list with
| Nil -&gt; 0
// Missing: Cons case
</code></pre>
<p>Input <code>Cons(1, Nil)</code>은 매칭 안 됨 → Non-exhaustive.</p>
<h3 id="empty-matrix--non-exhaustive"><a class="header" href="#empty-matrix--non-exhaustive">Empty Matrix = Non-Exhaustive</a></h3>
<p><strong>Key insight:</strong></p>
<p>Empty pattern matrix는 <strong>어떤 input도 매칭 안 됨</strong>을 의미한다.</p>
<p><strong>Compilation algorithm:</strong></p>
<pre><code class="language-python">def compile(P, π):
    if not P:
        return Failure()  # Non-exhaustive!
</code></pre>
<p><strong>Detection points:</strong></p>
<ol>
<li><strong>Initial matrix empty</strong>: 아예 patterns가 없음</li>
<li><strong>Specialization 후 empty</strong>: 특정 constructor case가 없음</li>
<li><strong>Default 후 empty</strong>: Wildcard case가 없음</li>
</ol>
<h3 id="example-1-missing-constructor-case"><a class="header" href="#example-1-missing-constructor-case">Example 1: Missing Constructor Case</a></h3>
<p><strong>Pattern matrix:</strong></p>
<pre><code>π = [list]

| Nil  →  0
</code></pre>
<p><strong>Compile:</strong></p>
<ul>
<li>Specialize on Nil: <code>Success(0)</code></li>
<li>Specialize on Cons: <code>specialize(P, 0, Cons)</code> → <strong>empty matrix</strong>
<ul>
<li>No Cons patterns in original matrix</li>
<li>Result: <code>Failure()</code></li>
</ul>
</li>
</ul>
<p><strong>Decision tree:</strong></p>
<pre><code>Switch(list, {
    Nil: Success(0),
    Cons: Failure()  // Non-exhaustive!
}, Failure())
</code></pre>
<p><strong>Compiler error:</strong></p>
<pre><code>Error: Non-exhaustive pattern match
Location: match list with ...
Missing case: Cons(_, _)
</code></pre>
<h3 id="example-2-missing-wildcard"><a class="header" href="#example-2-missing-wildcard">Example 2: Missing Wildcard</a></h3>
<p><strong>Pattern matrix:</strong></p>
<pre><code>π = [list]

| Nil         →  0
| Cons(x, xs) →  1
</code></pre>
<p><strong>Compile:</strong></p>
<ul>
<li>Specialize on Nil: <code>Success(0)</code></li>
<li>Specialize on Cons: <code>Success(1)</code></li>
<li>Default: <code>default(P, 0)</code> → <strong>empty matrix</strong>
<ul>
<li>No wildcard rows</li>
<li>Result: <code>Failure()</code></li>
</ul>
</li>
</ul>
<p><strong>하지만 이 경우는 실제로 exhaustive다!</strong></p>
<p>Nil + Cons가 <strong>complete constructor set</strong>이므로 default branch는 unreachable.</p>
<p><strong>Optimization:</strong></p>
<p>Complete constructor set일 때 default branch를 생략할 수 있다.</p>
<pre><code class="language-python">def compile(P, π):
    # ...
    constructors = get_constructors(P, column)
    if is_complete_set(constructors):
        # No default branch needed
        return Switch(π[column], branches, None)
    else:
        # Default branch for incomplete sets
        default_branch = compile(default(P, column), ...)
        return Switch(π[column], branches, default_branch)
</code></pre>
<p><strong>Complete constructor sets:</strong></p>
<ul>
<li>List: <code>{Nil, Cons}</code></li>
<li>Bool: <code>{True, False}</code></li>
<li>Option: <code>{None, Some}</code></li>
</ul>
<h3 id="example-3-nested-non-exhaustiveness"><a class="header" href="#example-3-nested-non-exhaustiveness">Example 3: Nested Non-Exhaustiveness</a></h3>
<p><strong>Pattern matrix:</strong></p>
<pre><code>π = [list]

| Cons(x, Nil)  →  "singleton"
// Missing: Cons(x, Cons(y, rest))
// Missing: Nil
</code></pre>
<p><strong>Compile:</strong></p>
<ol>
<li>
<p>Specialize on Cons:</p>
<pre><code>π = [list.head, list.tail]

| x  Nil  →  "singleton"
</code></pre>
</li>
<li>
<p>Specialize on Nil (column 1):</p>
<pre><code>π = [list.head]

| x  →  "singleton"
</code></pre>
<p>Result: <code>Success("singleton")</code></p>
</li>
<li>
<p>Specialize on Cons (column 1):</p>
<pre><code>(empty matrix)  // No Cons(x, Cons(...)) pattern
</code></pre>
<p>Result: <code>Failure()</code> → <strong>Non-exhaustive</strong></p>
</li>
<li>
<p>Default on column 0:</p>
<pre><code>(empty matrix)  // No wildcard or Nil pattern
</code></pre>
<p>Result: <code>Failure()</code> → <strong>Non-exhaustive</strong></p>
</li>
</ol>
<p><strong>Decision tree:</strong></p>
<pre><code>Switch(list, {
    Cons: Switch(list.tail, {
        Nil: Success("singleton"),
        Cons: Failure()  // Missing!
    }, Failure()),
}, Failure())  // Missing Nil!
</code></pre>
<p><strong>Compiler error:</strong></p>
<pre><code>Error: Non-exhaustive pattern match
Missing cases:
  - Nil
  - Cons(_, Cons(_, _))
</code></pre>
<h3 id="exhaustiveness-error-reporting"><a class="header" href="#exhaustiveness-error-reporting">Exhaustiveness Error Reporting</a></h3>
<p><strong>Basic approach: Failure leaf</strong></p>
<p>Compile 중 empty matrix 발견 시 error 발생:</p>
<pre><code class="language-python">def compile(P, π):
    if not P:
        raise CompileError("Non-exhaustive pattern match")
</code></pre>
<p><strong>Advanced approach: Missing pattern reconstruction</strong></p>
<p>Empty matrix가 발생한 경로를 추적해서 missing pattern 생성:</p>
<pre><code class="language-python">def compile(P, π, path=[]):
    if not P:
        missing = reconstruct_pattern(path)
        raise CompileError(f"Missing case: {missing}")

    # ...
    for c in constructors:
        P_c = specialize(P, column, c)
        compile(P_c, π_c, path + [(column, c)])
</code></pre>
<p><strong>Example path:</strong></p>
<pre><code>path = [(0, Cons), (1, Cons)]
→ Missing pattern: Cons(_, Cons(_, _))
</code></pre>
<p><strong>FunLang Phase 6 approach:</strong></p>
<p>간단한 error message만 제공:</p>
<pre><code>Error: Non-exhaustive pattern match at line X
Consider adding a wildcard pattern: | _ -&gt; ...
</code></pre>
<p>자세한 missing case 분석은 나중 phase 또는 bonus 섹션에서 다룬다.</p>
<h3 id="exhaustiveness-check가-자연스러운-이유"><a class="header" href="#exhaustiveness-check가-자연스러운-이유">Exhaustiveness Check가 자연스러운 이유</a></h3>
<p><strong>Decision tree 알고리즘의 장점:</strong></p>
<blockquote>
<p>“Exhaustiveness checking은 <strong>별도의 분석 pass가 아니다</strong>. Compilation 과정에서 자동으로 발견된다.”</p>
</blockquote>
<p><strong>왜 자연스러운가?</strong></p>
<ol>
<li><strong>Empty matrix는 명확한 신호</strong>: No patterns left = no matches possible</li>
<li><strong>Recursive structure</strong>: 각 specialization/default 단계에서 independently 체크</li>
<li><strong>Complete constructor sets</strong>: 간단한 rule로 false positives 제거 가능</li>
</ol>
<p><strong>Contrast with if-else chain analysis:</strong></p>
<p>If-else tree를 분석하려면:</p>
<ul>
<li>모든 경로를 traverse</li>
<li>각 경로가 종료되는지 확인</li>
<li>Missing 경로를 역으로 추론</li>
</ul>
<p>Decision tree는 construction 과정에서 바로 확인된다.</p>
<hr>
<h2 id="리터럴-패턴과-와일드카드-최적화"><a class="header" href="#리터럴-패턴과-와일드카드-최적화">리터럴 패턴과 와일드카드 최적화</a></h2>
<p>지금까지 constructor patterns (Nil, Cons)를 중심으로 설명했다. 하지만 실제 프로그래밍에서는 <strong>리터럴 패턴</strong>과 <strong>와일드카드 패턴</strong>도 매우 중요하다.</p>
<h3 id="리터럴-패턴-컴파일-literal-pattern-compilation"><a class="header" href="#리터럴-패턴-컴파일-literal-pattern-compilation">리터럴 패턴 컴파일 (Literal Pattern Compilation)</a></h3>
<p><strong>리터럴 패턴이란?</strong></p>
<p>리터럴 패턴은 특정 <strong>상수 값</strong>과 매칭되는 패턴이다:</p>
<pre><code class="language-fsharp">// 정수 리터럴 패턴
match x with
| 0 -&gt; "zero"
| 1 -&gt; "one"
| 2 -&gt; "two"
| _ -&gt; "other"

// 문자열 리터럴 패턴 (문자열 타입이 있다면)
match color with
| "red" -&gt; 0xFF0000
| "green" -&gt; 0x00FF00
| "blue" -&gt; 0x0000FF
| _ -&gt; 0x000000
</code></pre>
<p><strong>Constructor patterns와의 차이:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>특성</th><th>Constructor Pattern</th><th>Literal Pattern</th></tr>
</thead>
<tbody>
<tr><td>예제</td><td><code>Nil</code>, <code>Cons(x, xs)</code></td><td><code>0</code>, <code>1</code>, <code>42</code></td></tr>
<tr><td>분해</td><td>Subpatterns 있음</td><td>Subpatterns 없음</td></tr>
<tr><td>값의 개수</td><td>유한 (finite set)</td><td>무한 (infinite set)</td></tr>
<tr><td>테스트 방법</td><td>Tag switch</td><td>Equality comparison</td></tr>
<tr><td>MLIR operation</td><td><code>scf.index_switch</code></td><td><code>arith.cmpi</code> + <code>scf.if</code></td></tr>
</tbody>
</table>
</div>
<p><strong>리터럴 패턴의 특징:</strong></p>
<ol>
<li><strong>분해되지 않음:</strong> <code>Cons(x, xs)</code>는 <code>x</code>와 <code>xs</code>로 분해되지만, <code>42</code>는 그 자체로 atomic하다</li>
<li><strong>무한 가능성:</strong> 정수는 무한히 많으므로 모든 case를 나열할 수 없다</li>
<li><strong>등호 테스트:</strong> Constructor tag가 아니라 값 자체를 비교해야 한다</li>
</ol>
<h3 id="리터럴-패턴의-pattern-matrix"><a class="header" href="#리터럴-패턴의-pattern-matrix">리터럴 패턴의 Pattern Matrix</a></h3>
<p><strong>Example: Modulo 3 classification</strong></p>
<pre><code class="language-fsharp">let classify_mod3 n =
    match n % 3 with
    | 0 -&gt; "divisible by 3"
    | 1 -&gt; "remainder 1"
    | 2 -&gt; "remainder 2"
    | _ -&gt; "unexpected"  // 논리적으로 unreachable
</code></pre>
<p><strong>Pattern matrix:</strong></p>
<pre><code>Scrutinee: [x]  (where x = n % 3)

Matrix:
| 0   →  "divisible by 3"
| 1   →  "remainder 1"
| 2   →  "remainder 2"
| _   →  "unexpected"
</code></pre>
<p><strong>리터럴 패턴의 specialization:</strong></p>
<p>리터럴 <code>lit</code>에 대한 specialization <code>S(lit, 0, P)</code>:</p>
<pre><code>S(0, 0, P):
| →  "divisible by 3"   (from 0 pattern)
| →  "unexpected"       (from _ pattern)
</code></pre>
<p><strong>리터럴 0과 호환되는 rows만 남는다:</strong></p>
<ul>
<li>Row 1 (<code>0</code>): 리터럴 0과 일치 → 유지</li>
<li>Row 2 (<code>1</code>): 리터럴 1 ≠ 0 → 제거</li>
<li>Row 3 (<code>2</code>): 리터럴 2 ≠ 0 → 제거</li>
<li>Row 4 (<code>_</code>): Wildcard는 모든 값과 호환 → 유지</li>
</ul>
<p><strong>리터럴 specialization 후에는 column이 사라진다</strong> (리터럴은 subpatterns가 없음).</p>
<h3 id="리터럴-패턴-vs-constructor-패턴-컴파일"><a class="header" href="#리터럴-패턴-vs-constructor-패턴-컴파일">리터럴 패턴 vs Constructor 패턴 컴파일</a></h3>
<p><strong>Constructor patterns (유한 set):</strong></p>
<pre><code class="language-mlir">// List patterns: {Nil, Cons} = complete set
%tag = llvm.extractvalue %list[0] : !llvm.struct&lt;(i32, ptr)&gt;
%result = scf.index_switch %tag : i32 -&gt; i32
case 0 { /* Nil */ }
case 1 { /* Cons */ }
default { /* unreachable */ }
</code></pre>
<p><strong>O(1) dispatch:</strong> Tag 값으로 바로 jump.</p>
<p><strong>Literal patterns (무한 set):</strong></p>
<pre><code class="language-mlir">// Integer patterns: 0, 1, 2, ... = infinite set
%is_zero = arith.cmpi eq, %x, %c0 : i32
%result = scf.if %is_zero -&gt; i32 {
    scf.yield %zero_result : i32
} else {
    %is_one = arith.cmpi eq, %x, %c1 : i32
    %result1 = scf.if %is_one -&gt; i32 {
        scf.yield %one_result : i32
    } else {
        %is_two = arith.cmpi eq, %x, %c2 : i32
        %result2 = scf.if %is_two -&gt; i32 {
            scf.yield %two_result : i32
        } else {
            scf.yield %default_result : i32
        }
        scf.yield %result2 : i32
    }
    scf.yield %result1 : i32
}
</code></pre>
<p><strong>O(n) sequential tests:</strong> 각 리터럴을 순서대로 비교.</p>
<h3 id="decision-tree-for-literal-patterns"><a class="header" href="#decision-tree-for-literal-patterns">Decision Tree for Literal Patterns</a></h3>
<p><strong>Example: FizzBuzz remainder check</strong></p>
<pre><code class="language-fsharp">match (n % 3, n % 5) with
| (0, 0) -&gt; "FizzBuzz"
| (0, _) -&gt; "Fizz"
| (_, 0) -&gt; "Buzz"
| (_, _) -&gt; string_of_int n
</code></pre>
<p><strong>Decision tree:</strong></p>
<pre><code>       [n % 3]
          |
    Test: == 0?
      /      \
   Yes        No
   /            \
 [n % 5]      [n % 5]
   |            |
 == 0?        == 0?
  / \          / \
Yes  No      Yes  No
 |    |       |    |
FB   Fizz   Buzz  n
</code></pre>
<p><strong>생성된 코드:</strong></p>
<pre><code class="language-mlir">%mod3 = arith.remsi %n, %c3 : i32
%mod5 = arith.remsi %n, %c5 : i32

%is_div3 = arith.cmpi eq, %mod3, %c0 : i32
%result = scf.if %is_div3 -&gt; !llvm.ptr&lt;i8&gt; {
    // First column is 0
    %is_div5 = arith.cmpi eq, %mod5, %c0 : i32
    %inner = scf.if %is_div5 -&gt; !llvm.ptr&lt;i8&gt; {
        scf.yield %fizzbuzz : !llvm.ptr&lt;i8&gt;
    } else {
        scf.yield %fizz : !llvm.ptr&lt;i8&gt;
    }
    scf.yield %inner : !llvm.ptr&lt;i8&gt;
} else {
    // First column is not 0
    %is_div5_2 = arith.cmpi eq, %mod5, %c0 : i32
    %inner2 = scf.if %is_div5_2 -&gt; !llvm.ptr&lt;i8&gt; {
        scf.yield %buzz : !llvm.ptr&lt;i8&gt;
    } else {
        %str = func.call @int_to_string(%n) : (i32) -&gt; !llvm.ptr&lt;i8&gt;
        scf.yield %str : !llvm.ptr&lt;i8&gt;
    }
    scf.yield %inner2 : !llvm.ptr&lt;i8&gt;
}
</code></pre>
<h3 id="와일드카드-최적화-wildcard-optimization"><a class="header" href="#와일드카드-최적화-wildcard-optimization">와일드카드 최적화 (Wildcard Optimization)</a></h3>
<p><strong>와일드카드 패턴 <code>_</code>의 핵심 특성:</strong></p>
<blockquote>
<p>Wildcard는 <strong>어떤 런타임 테스트도 생성하지 않는다.</strong></p>
</blockquote>
<p><strong>Example 1: Wildcard in constructor pattern</strong></p>
<pre><code class="language-fsharp">match list with
| Cons(_, tail) -&gt; length tail + 1
| Nil -&gt; 0
</code></pre>
<p><strong><code>_</code> vs named variable:</strong></p>
<pre><code class="language-fsharp">// Case A: Wildcard (no extraction)
| Cons(_, tail) -&gt; ...

// Case B: Named variable (extraction needed)
| Cons(head, tail) -&gt; ...
</code></pre>
<p><strong>생성된 코드 비교:</strong></p>
<pre><code class="language-mlir">// Case A: Wildcard - head 추출 안 함
case 1 {  // Cons
    // %head = 추출 안 함! (unused)
    %tail_ptr = llvm.getelementptr %data[1] : (!llvm.ptr) -&gt; !llvm.ptr
    %tail = llvm.load %tail_ptr : !llvm.ptr -&gt; !llvm.struct&lt;(i32, ptr)&gt;
    // ...
}

// Case B: Named variable - head 추출 필요
case 1 {  // Cons
    %head = llvm.load %data : !llvm.ptr -&gt; i32  // 추출함
    %tail_ptr = llvm.getelementptr %data[1] : (!llvm.ptr) -&gt; !llvm.ptr
    %tail = llvm.load %tail_ptr : !llvm.ptr -&gt; !llvm.struct&lt;(i32, ptr)&gt;
    // ...
}
</code></pre>
<p><strong>Wildcard 최적화 효과:</strong></p>
<ul>
<li><strong>메모리 접근 감소:</strong> 불필요한 load 제거</li>
<li><strong>레지스터 절약:</strong> 사용하지 않는 값을 저장 안 함</li>
<li><strong>Dead code elimination 촉진:</strong> 컴파일러가 더 쉽게 최적화</li>
</ul>
<p><strong>Example 2: Wildcard as default case</strong></p>
<pre><code class="language-fsharp">match color_code with
| 0 -&gt; "black"
| 1 -&gt; "white"
| _ -&gt; "unknown"
</code></pre>
<p><strong>Wildcard default는 테스트를 생성하지 않는다:</strong></p>
<pre><code class="language-mlir">%is_black = arith.cmpi eq, %color, %c0 : i32
%result = scf.if %is_black -&gt; !llvm.ptr&lt;i8&gt; {
    scf.yield %black_str : !llvm.ptr&lt;i8&gt;
} else {
    %is_white = arith.cmpi eq, %color, %c1 : i32
    %result1 = scf.if %is_white -&gt; !llvm.ptr&lt;i8&gt; {
        scf.yield %white_str : !llvm.ptr&lt;i8&gt;
    } else {
        // _ case: NO TEST, just yield
        scf.yield %unknown_str : !llvm.ptr&lt;i8&gt;
    }
    scf.yield %result1 : !llvm.ptr&lt;i8&gt;
}
</code></pre>
<p><strong>Default branch에서는 equality test가 없다!</strong></p>
<p>이전 tests가 모두 실패했으면 자동으로 default case가 실행된다.</p>
<h3 id="생성-코드-비교-generated-code-comparison"><a class="header" href="#생성-코드-비교-generated-code-comparison">생성 코드 비교 (Generated Code Comparison)</a></h3>
<p><strong>패턴 종류별 MLIR operation mapping:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Pattern Type</th><th>Test Operation</th><th>Dispatch Method</th><th>Branch Count</th></tr>
</thead>
<tbody>
<tr><td>Constructor (closed)</td><td><code>llvm.extractvalue</code> (tag)</td><td><code>scf.index_switch</code></td><td>O(1)</td></tr>
<tr><td>Constructor (open)</td><td><code>llvm.extractvalue</code> (tag)</td><td><code>scf.index_switch</code> + default</td><td>O(1)</td></tr>
<tr><td>Literal</td><td><code>arith.cmpi eq</code></td><td><code>scf.if</code> chain</td><td>O(n) sequential</td></tr>
<tr><td>Wildcard</td><td>None</td><td>Fallthrough</td><td>0 (no test)</td></tr>
<tr><td>Variable</td><td>None</td><td>Binding only</td><td>0 (no test)</td></tr>
</tbody>
</table>
</div>
<p><strong>Complete example: Mixed patterns</strong></p>
<pre><code class="language-fsharp">match (list, n) with
| (Nil, _) -&gt; 0
| (Cons(x, _), 0) -&gt; x
| (Cons(x, xs), n) -&gt; x + process xs (n - 1)
</code></pre>
<p><strong>Decision tree structure:</strong></p>
<pre><code>        [list]
           |
      Constructor test
        /        \
      Nil       Cons
       |          |
    yield 0    [n]
              Literal test
                /    \
            n==0    n!=0
              |        |
          yield x  yield x + ...
</code></pre>
<p><strong>생성된 MLIR (simplified):</strong></p>
<pre><code class="language-mlir">// Step 1: Constructor test on list
%list_tag = llvm.extractvalue %list[0] : !llvm.struct&lt;(i32, ptr)&gt;
%tag_index = arith.index_cast %list_tag : i32 to index

%result = scf.index_switch %tag_index : index -&gt; i32
case 0 {  // Nil
    // Wildcard _ on n: NO TEST
    %zero = arith.constant 0 : i32
    scf.yield %zero : i32
}
case 1 {  // Cons
    %data = llvm.extractvalue %list[1] : !llvm.struct&lt;(i32, ptr)&gt;
    %x = llvm.load %data : !llvm.ptr -&gt; i32

    // Step 2: Literal test on n
    %is_zero = arith.cmpi eq, %n, %c0 : i32
    %inner = scf.if %is_zero -&gt; i32 {
        // Literal 0 matched, wildcard _ on tail: NO extraction
        scf.yield %x : i32
    } else {
        // Default case, extract tail for recursion
        %tail_ptr = llvm.getelementptr %data[1] : (!llvm.ptr) -&gt; !llvm.ptr
        %xs = llvm.load %tail_ptr : !llvm.ptr -&gt; !llvm.struct&lt;(i32, ptr)&gt;
        %n_minus_1 = arith.subi %n, %c1 : i32
        %rest = func.call @process(%xs, %n_minus_1) : (...) -&gt; i32
        %sum = arith.addi %x, %rest : i32
        scf.yield %sum : i32
    }
    scf.yield %inner : i32
}
</code></pre>
<h3 id="리터럴-패턴-최적화-기회"><a class="header" href="#리터럴-패턴-최적화-기회">리터럴 패턴 최적화 기회</a></h3>
<p><strong>1. Jump table for dense ranges</strong></p>
<p>리터럴이 0, 1, 2, …와 같이 연속적일 때:</p>
<pre><code class="language-mlir">// Before: Sequential tests
%is_0 = arith.cmpi eq, %x, %c0
scf.if %is_0 { ... } else {
    %is_1 = arith.cmpi eq, %x, %c1
    scf.if %is_1 { ... } else { ... }
}

// After: Range check + index_switch
%in_range = arith.cmpi ult, %x, %c3 : i32
scf.if %in_range {
    %idx = arith.index_cast %x : i32 to index
    scf.index_switch %idx {
        case 0 { ... }
        case 1 { ... }
        case 2 { ... }
    }
} else {
    // default
}
</code></pre>
<p><strong>2. LLVM switch optimization</strong></p>
<p>LLVM backend는 sequential comparisons를 자동으로 switch instruction으로 변환할 수 있다:</p>
<pre><code class="language-llvm">; Input: sequential icmp + br
%cmp0 = icmp eq i32 %x, 0
br i1 %cmp0, label %case0, label %check1
check1:
%cmp1 = icmp eq i32 %x, 1
br i1 %cmp1, label %case1, label %default

; Optimized: switch instruction
switch i32 %x, label %default [
    i32 0, label %case0
    i32 1, label %case1
]
</code></pre>
<p><strong>3. Guard patterns (future)</strong></p>
<p>리터럴 테스트와 predicate guard를 결합:</p>
<pre><code class="language-fsharp">match x with
| n when n &gt; 0 &amp;&amp; n &lt; 100 -&gt; "small positive"
| n when n &gt;= 100 -&gt; "large positive"
| _ -&gt; "non-positive"
</code></pre>
<p>이런 guard patterns는 Phase 7 이후에 다룰 수 있다.</p>
<h3 id="wildcard-specialization-규칙-상세"><a class="header" href="#wildcard-specialization-규칙-상세">Wildcard Specialization 규칙 상세</a></h3>
<p><strong>Wildcard expansion for different constructor arities:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Constructor</th><th>Arity</th><th>Wildcard Expansion</th></tr>
</thead>
<tbody>
<tr><td>Nil</td><td>0</td><td><code>[]</code> (empty)</td></tr>
<tr><td>Cons</td><td>2</td><td><code>[_, _]</code></td></tr>
<tr><td>Some</td><td>1</td><td><code>[_]</code></td></tr>
<tr><td>Pair</td><td>2</td><td><code>[_, _]</code></td></tr>
<tr><td>Triple</td><td>3</td><td><code>[_, _, _]</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Example: Option type</strong></p>
<pre><code class="language-fsharp">type 'a option = None | Some of 'a

match opt with
| Some x -&gt; x + 1
| _ -&gt; 0
</code></pre>
<p><strong>Specialization of <code>_</code> on <code>Some</code>:</strong></p>
<pre><code>Original:
| Some x  →  x + 1
| _       →  0

S(Some, 0, P):
| x  →  x + 1    (from Some x)
| _  →  0        (from _, expanded to Some _)
</code></pre>
<p><strong>Wildcard는 어떤 constructor와도 호환된다!</strong></p>
<h3 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h3>
<ol>
<li><strong>리터럴 패턴은 equality tests를 생성한다</strong> (<code>arith.cmpi eq</code>)</li>
<li><strong>Constructor 패턴은 tag switch를 생성한다</strong> (<code>scf.index_switch</code>)</li>
<li><strong>Wildcard는 테스트를 생성하지 않는다</strong> (fallthrough/binding only)</li>
<li><strong>리터럴 set이 연속적이면 switch 최적화 가능</strong></li>
<li><strong>Wildcard default는 마지막 else branch로 컴파일</strong></li>
<li><strong>Named variables와 wildcards는 semantics만 다름</strong> (binding vs no binding)</li>
</ol>
<hr>
<h2 id="summary-and-next-steps"><a class="header" href="#summary-and-next-steps">Summary and Next Steps</a></h2>
<h3 id="chapter-17-핵심-개념-정리"><a class="header" href="#chapter-17-핵심-개념-정리">Chapter 17 핵심 개념 정리</a></h3>
<p><strong>1. Pattern Matrix Representation</strong></p>
<ul>
<li>Rows = pattern clauses</li>
<li>Columns = scrutinees</li>
<li>Cells = patterns (wildcard, constructor, literal)</li>
<li>Occurrence vectors = access paths to values</li>
</ul>
<p><strong>2. Decision Tree Structure</strong></p>
<ul>
<li>Internal nodes = tests (constructor, literal)</li>
<li>Edges = outcomes (Nil, Cons, default)</li>
<li>Leaves = actions (success, failure)</li>
<li>Property: Each subterm tested at most once</li>
</ul>
<p><strong>3. Specialization Operation</strong></p>
<ul>
<li>Filters rows compatible with constructor</li>
<li>Expands constructor patterns to subpatterns</li>
<li>Updates occurrence vector with subpaths</li>
<li>Formula: <code>S(c, i, P) = specialized matrix</code></li>
</ul>
<p><strong>4. Defaulting Operation</strong></p>
<ul>
<li>Keeps only wildcard rows</li>
<li>Removes tested column</li>
<li>Detects non-exhaustiveness (empty result)</li>
<li>Formula: <code>D(i, P) = default matrix</code></li>
</ul>
<p><strong>5. Compilation Algorithm</strong></p>
<ul>
<li>Recursive function: <code>compile(P, π) = DecisionTree</code></li>
<li>Base cases: empty (failure), irrefutable (success)</li>
<li>Recursive case: select column, specialize, default</li>
<li>Heuristics: column selection strategy</li>
</ul>
<p><strong>6. Exhaustiveness Checking</strong></p>
<ul>
<li>Empty matrix = non-exhaustive match</li>
<li>Complete constructor sets = no default needed</li>
<li>Natural integration with compilation</li>
<li>Error reporting from failure leaves</li>
</ul>
<h3 id="decision-tree-algorithm의-장점-요약"><a class="header" href="#decision-tree-algorithm의-장점-요약">Decision Tree Algorithm의 장점 요약</a></h3>
<p><strong>Efficiency:</strong></p>
<ul>
<li>O(d) tests (d = pattern depth), not O(n × d)</li>
<li>Each subterm tested exactly once</li>
<li>No redundant comparisons</li>
</ul>
<p><strong>Correctness:</strong></p>
<ul>
<li>Respects pattern order (first-match semantics)</li>
<li>Handles nested patterns systematically</li>
<li>Works with any constructor arity</li>
</ul>
<p><strong>Verification:</strong></p>
<ul>
<li>Exhaustiveness checking built-in</li>
<li>Detects missing cases at compile time</li>
<li>Identifies unreachable patterns</li>
</ul>
<p><strong>Optimization:</strong></p>
<ul>
<li>Structured representation enables optimizations</li>
<li>Column selection heuristics improve code quality</li>
<li>Complete constructor sets eliminate default branches</li>
</ul>
<h3 id="pattern-matrix-workflow"><a class="header" href="#pattern-matrix-workflow">Pattern Matrix Workflow</a></h3>
<p><strong>전체 과정 요약:</strong></p>
<pre><code>1. FunLang match expression
   ↓
2. Pattern matrix + occurrence vector
   ↓
3. Recursive compilation algorithm
   ├─ Specialization (constructor tests)
   ├─ Defaulting (wildcard cases)
   └─ Column selection (heuristic)
   ↓
4. Decision tree
   ↓
5. MLIR IR (scf.index_switch, scf.if)
   ↓
6. LLVM IR (switch, br)
</code></pre>
<h3 id="connection-to-mlir-lowering"><a class="header" href="#connection-to-mlir-lowering">Connection to MLIR Lowering</a></h3>
<p><strong>Chapter 17 (theory) → Chapter 19 (implementation):</strong></p>
<p><strong>Pattern matrix → <code>funlang.match</code> operation:</strong></p>
<pre><code class="language-mlir">%result = funlang.match %list : !funlang.list&lt;i32&gt; -&gt; i32 {
^nil:
    %zero = arith.constant 0 : i32
    funlang.yield %zero : i32
^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
    %one = arith.constant 1 : i32
    %len_tail = func.call @length(%tail) : (!funlang.list&lt;i32&gt;) -&gt; i32
    %result = arith.addi %one, %len_tail : i32
    funlang.yield %result : i32
}
</code></pre>
<p><strong>Decision tree → SCF dialect:</strong></p>
<pre><code class="language-mlir">%tag = llvm.extractvalue %list[0] : !llvm.struct&lt;(i32, ptr)&gt;
%result = scf.index_switch %tag : i32 -&gt; i32
case 0 { ... }  // Nil branch
case 1 { ... }  // Cons branch
</code></pre>
<p><strong>Specialization → Region block arguments:</strong></p>
<pre><code class="language-mlir">^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
// Block arguments = pattern variables from specialization
</code></pre>
<p><strong>Exhaustiveness → Verification:</strong></p>
<pre><code class="language-cpp">LogicalResult FunLang::MatchOp::verify() {
    // Check all constructor cases are present or wildcard exists
    if (!isExhaustive()) {
        return emitOpError("non-exhaustive pattern match");
    }
    return success();
}
</code></pre>
<h3 id="chapter-18-20-preview"><a class="header" href="#chapter-18-20-preview">Chapter 18-20 Preview</a></h3>
<p><strong>Chapter 18: List Operations</strong></p>
<ul>
<li><code>funlang.nil</code> operation: Create empty list</li>
<li><code>funlang.cons</code> operation: Prepend element to list</li>
<li><code>!funlang.list&lt;T&gt;</code> type: Parameterized list type</li>
<li>LLVM representation: <code>!llvm.struct&lt;(i32, ptr)&gt;</code> with tag</li>
<li>Heap allocation with GC_malloc</li>
</ul>
<p><strong>Chapter 19: Match Compilation</strong></p>
<ul>
<li><code>funlang.match</code> operation: Region-based pattern matching</li>
<li>Region block arguments for pattern variables</li>
<li>Lowering to SCF dialect (<code>scf.index_switch</code>)</li>
<li>OpConversionPattern with region handling</li>
<li>Type conversion for <code>!funlang.list&lt;T&gt;</code></li>
</ul>
<p><strong>Chapter 20: Functional Programs</strong></p>
<ul>
<li>Complete examples: map, filter, fold</li>
<li>List manipulation functions</li>
<li>Recursive list traversal</li>
<li>Higher-order functions on lists</li>
<li>Performance analysis</li>
</ul>
<h3 id="practice-questions"><a class="header" href="#practice-questions">Practice Questions</a></h3>
<p>이 장을 이해했는지 확인하는 질문들:</p>
<p><strong>Q1: Pattern matrix의 각 요소는 무엇을 의미하는가?</strong></p>
<details>
<summary>Answer</summary>
<ul>
<li>Rows: Pattern clauses (하나의 <code>pattern -&gt; action</code>)</li>
<li>Columns: Scrutinees (매칭 대상 values)</li>
<li>Cells: Patterns (wildcard, constructor, literal)</li>
<li>Actions: 각 row가 매칭되면 실행할 코드</li>
</ul>
</details>
<p><strong>Q2: Specialization이 <code>Cons(x, Nil)</code> pattern을 어떻게 변환하는가?</strong></p>
<details>
<summary>Answer</summary>
<p><code>Cons(x, Nil)</code> → 두 개의 subpattern columns <code>[x, Nil]</code></p>
<ul>
<li><code>x</code>: variable pattern (head)</li>
<li><code>Nil</code>: constructor pattern (tail)</li>
</ul>
<p>Occurrence vector도 확장:</p>
<ul>
<li><code>[list]</code> → <code>[list.head, list.tail]</code></li>
</ul>
</details>
<p><strong>Q3: Defaulting 후 empty matrix는 무엇을 의미하는가?</strong></p>
<details>
<summary>Answer</summary>
<p>Non-exhaustive pattern match.</p>
<ul>
<li>모든 rows가 constructor patterns → wildcard 없음</li>
<li>Default case가 없음 → 일부 values가 매칭 안 됨</li>
<li>Compiler error 발생</li>
</ul>
</details>
<p><strong>Q4: Decision tree가 if-else chain보다 효율적인 이유는?</strong></p>
<details>
<summary>Answer</summary>
<ol>
<li>각 subterm을 최대 한 번만 테스트 (no redundancy)</li>
<li>Complete constructor sets에서 불필요한 비교 제거</li>
<li>Structured representation으로 optimization 가능</li>
<li>O(d) tests (d = depth), not O(n × d) (n = patterns)</li>
</ol>
</details>
<p><strong>Q5: Column selection heuristic이 왜 필요한가?</strong></p>
<details>
<summary>Answer</summary>
<p>여러 scrutinees가 있을 때 테스트 순서가 효율성에 영향을 준다.</p>
<ul>
<li>좋은 순서: Constructor patterns가 많은 column 먼저</li>
<li>나쁜 순서: Wildcard가 많은 column 먼저 (별 정보 없음)</li>
</ul>
<p>Heuristic으로 optimal에 가까운 decision tree 생성.</p>
</details>
<h3 id="성공-기준-달성-확인"><a class="header" href="#성공-기준-달성-확인">성공 기준 달성 확인</a></h3>
<p>이 장의 목표를 모두 달성했는가?</p>
<ul>
<li>
<p><input disabled="" type="checkbox" checked=""> Pattern matrix 표현법을 이해한다</p>
<ul>
<li>Rows, columns, occurrences 개념 설명</li>
<li>Example matrices with nested patterns</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""> Decision tree 알고리즘의 동작 원리를 안다</p>
<ul>
<li>Recursive compilation function</li>
<li>Base cases (empty, irrefutable)</li>
<li>Recursive case (specialize, default)</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""> Specialization과 defaulting 연산을 설명할 수 있다</p>
<ul>
<li>Specialization: constructor assumption + decomposition</li>
<li>Defaulting: wildcard filtering + column removal</li>
<li>Occurrence vector updates</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""> Exhaustiveness checking이 어떻게 동작하는지 안다</p>
<ul>
<li>Empty matrix detection</li>
<li>Complete constructor sets</li>
<li>Error reporting strategies</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""> Chapter 18-19에서 MLIR 구현을 시작할 준비가 된다</p>
<ul>
<li>Pattern matrix → <code>funlang.match</code> operation mapping</li>
<li>Decision tree → SCF dialect lowering</li>
<li>Specialization → Region block arguments</li>
</ul>
</li>
</ul>
<p><strong>Next chapter: Let’s build the foundation for pattern matching—list data structures!</strong></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-18-list-operations-list-operations"><a class="header" href="#chapter-18-list-operations-list-operations">Chapter 18: List Operations (List Operations)</a></h1>
<h2 id="소개-18"><a class="header" href="#소개-18">소개</a></h2>
<p><strong>Chapter 17</strong>에서는 패턴 매칭 컴파일의 <strong>이론적 기반</strong>을 다뤘다:</p>
<ul>
<li>Decision tree 알고리즘 (Maranget 2008)</li>
<li>Pattern matrix 표현법</li>
<li>Specialization과 defaulting 연산</li>
<li>Exhaustiveness checking</li>
</ul>
<p><strong>Chapter 18</strong>에서는 패턴 매칭이 작동할 <strong>데이터 구조</strong>를 구현한다. FunLang dialect에 list operations를 추가하여 불변 리스트를 만들고 조작할 수 있게 한다.</p>
<h3 id="chapter-17-복습-왜-list-operations가-먼저인가"><a class="header" href="#chapter-17-복습-왜-list-operations가-먼저인가">Chapter 17 복습: 왜 List Operations가 먼저인가?</a></h3>
<p>Chapter 17에서 우리는 decision tree 알고리즘을 배웠다:</p>
<pre><code class="language-fsharp">// F# 패턴 매칭 예제
let rec sum_list lst =
    match lst with
    | [] -&gt; 0                           // Nil pattern
    | head :: tail -&gt; head + sum_list tail  // Cons pattern

sum_list [1; 2; 3]  // 6
</code></pre>
<p>Decision tree 컴파일 과정:</p>
<ol>
<li><strong>Pattern matrix 구성</strong>: <code>[[]; [Cons(head, tail)]]</code></li>
<li><strong>Specialization</strong>: Nil case, Cons case 분리</li>
<li><strong>Code generation</strong>: 각 case에 대한 MLIR 코드 생성</li>
</ol>
<p><strong>하지만 MLIR로 변환하려면 무엇이 필요한가?</strong></p>
<pre><code class="language-mlir">// 목표: 이런 MLIR을 생성하고 싶다
%result = funlang.match %list : !funlang.list&lt;i32&gt; -&gt; i32 {
  ^nil:
    %zero = arith.constant 0 : i32
    funlang.yield %zero : i32
  ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
    // ... recursive call ...
    funlang.yield %sum : i32
}
</code></pre>
<p><strong>필요한 요소들:</strong></p>
<ol>
<li><strong>List data structure</strong>: <code>!funlang.list&lt;T&gt;</code> 타입으로 리스트 표현</li>
<li><strong>List construction</strong>: <code>funlang.nil</code>, <code>funlang.cons</code>로 리스트 생성</li>
<li><strong>Pattern matching</strong>: <code>funlang.match</code>로 리스트 분해 (Chapter 19)</li>
</ol>
<p><strong>왜 이 순서인가?</strong></p>
<ul>
<li>데이터 구조 없이는 패턴 매칭할 대상이 없다</li>
<li><code>funlang.match</code>는 <code>!funlang.list</code> 타입을 입력으로 받는다</li>
<li>List operations를 먼저 구현하면 Chapter 19에서 <code>funlang.match</code>만 집중할 수 있다</li>
</ul>
<h3 id="chapter-18의-목표"><a class="header" href="#chapter-18의-목표">Chapter 18의 목표</a></h3>
<p><strong>이 장에서 구현할 것:</strong></p>
<ol>
<li>
<p><strong>List Representation Design</strong></p>
<ul>
<li>Tagged union으로 Nil/Cons 구분</li>
<li>GC-allocated cons cells</li>
<li>Immutable shared structure</li>
</ul>
</li>
<li>
<p><strong>FunLang List Type</strong></p>
<ul>
<li><code>!funlang.list&lt;T&gt;</code> parameterized type</li>
<li>TableGen 정의, C API shim, F# bindings</li>
</ul>
</li>
<li>
<p><strong>funlang.nil Operation</strong></p>
<ul>
<li>Empty list 생성</li>
<li>Constant representation (no allocation)</li>
</ul>
</li>
<li>
<p><strong>funlang.cons Operation</strong></p>
<ul>
<li>Cons cell 생성 (head :: tail)</li>
<li>GC allocation for cell</li>
</ul>
</li>
<li>
<p><strong>TypeConverter for Lists</strong></p>
<ul>
<li><code>!funlang.list&lt;T&gt;</code> → <code>!llvm.struct&lt;(i32, ptr)&gt;</code> 변환</li>
<li>Extending FunLangTypeConverter from Chapter 16</li>
</ul>
</li>
<li>
<p><strong>Lowering Patterns</strong></p>
<ul>
<li>NilOpLowering: struct construction</li>
<li>ConsOpLowering: GC_malloc + store operations</li>
</ul>
</li>
</ol>
<h3 id="before-vs-after-list-operations의-위력"><a class="header" href="#before-vs-after-list-operations의-위력">Before vs After: List Operations의 위력</a></h3>
<p><strong>Before (만약 list operations 없이 직접 구현한다면):</strong></p>
<pre><code class="language-mlir">// Empty list: 수동으로 struct 구성
%tag_zero = arith.constant 0 : i32
%null_ptr = llvm.mlir.zero : !llvm.ptr
%undef = llvm.mlir.undef : !llvm.struct&lt;(i32, ptr)&gt;
%s1 = llvm.insertvalue %tag_zero, %undef[0] : !llvm.struct&lt;(i32, ptr)&gt;
%empty = llvm.insertvalue %null_ptr, %s1[1] : !llvm.struct&lt;(i32, ptr)&gt;

// Cons cell: 8줄 이상의 GC_malloc + store 패턴
%cell_size = arith.constant 16 : i64
%cell_ptr = llvm.call @GC_malloc(%cell_size) : (i64) -&gt; !llvm.ptr
%head_ptr = llvm.getelementptr %cell_ptr[0] : (!llvm.ptr) -&gt; !llvm.ptr
llvm.store %head_val, %head_ptr : i32, !llvm.ptr
%tail_ptr = llvm.getelementptr %cell_ptr[1] : (!llvm.ptr) -&gt; !llvm.ptr
llvm.store %tail_val, %tail_ptr : !llvm.ptr, !llvm.ptr
%tag_one = arith.constant 1 : i32
%s1 = llvm.insertvalue %tag_one, %undef[0] : !llvm.struct&lt;(i32, ptr)&gt;
%list = llvm.insertvalue %cell_ptr, %s1[1] : !llvm.struct&lt;(i32, ptr)&gt;
</code></pre>
<p><strong>After (Chapter 18 구현 후):</strong></p>
<pre><code class="language-mlir">// Empty list: 1줄!
%empty = funlang.nil : !funlang.list&lt;i32&gt;

// Cons cell: 1줄!
%list = funlang.cons %head, %tail : !funlang.list&lt;i32&gt;

// Building [1, 2, 3]: 4줄
%nil = funlang.nil : !funlang.list&lt;i32&gt;
%lst1 = funlang.cons %c3, %nil : !funlang.list&lt;i32&gt;
%lst2 = funlang.cons %c2, %lst1 : !funlang.list&lt;i32&gt;
%lst3 = funlang.cons %c1, %lst2 : !funlang.list&lt;i32&gt;
</code></pre>
<p><strong>개선 효과:</strong></p>
<ul>
<li><strong>코드 줄 수</strong>: 15+ 줄 → 1-2줄 (90%+ 감소!)</li>
<li><strong>가독성</strong>: 저수준 struct 조작 제거, 의도 명확</li>
<li><strong>타입 안전성</strong>: <code>!funlang.list&lt;T&gt;</code> parameterized type으로 element type 검증</li>
<li><strong>최적화 가능성</strong>: Empty list sharing, cons cell inlining</li>
</ul>
<h3 id="chapter-15-복습-custom-operations-패턴"><a class="header" href="#chapter-15-복습-custom-operations-패턴">Chapter 15 복습: Custom Operations 패턴</a></h3>
<p>Chapter 15에서 우리는 <code>funlang.closure</code>와 <code>funlang.apply</code>를 구현하며 custom operations 패턴을 배웠다:</p>
<p><strong>1. TableGen ODS 정의</strong></p>
<pre><code class="language-tablegen">def FunLang_ClosureOp : FunLang_Op&lt;"closure", [Pure]&gt; {
  let summary = "Create closure";
  let arguments = (ins FlatSymbolRefAttr:$fn, Variadic&lt;AnyType&gt;:$captures);
  let results = (outs FunLang_ClosureType:$result);
  let assemblyFormat = "$fn `,` $captures attr-dict `:` type($result)";
}
</code></pre>
<p><strong>2. C API Shim</strong></p>
<pre><code class="language-cpp">extern "C" MlirOperation mlirFunLangClosureOpCreate(
    MlirLocation loc, MlirAttribute fn, MlirValue *captures, intptr_t nCaptures) {
  return wrap(builder.create&lt;funlang::ClosureOp&gt;(loc, fn, ValueRange));
}
</code></pre>
<p><strong>3. F# Bindings</strong></p>
<pre><code class="language-fsharp">member this.CreateClosure(fn: string, captures: MlirValue list) : MlirValue =
    let op = funlang.CreateClosureOp(loc, fn, captures)
    GetOperationResult(op, 0)
</code></pre>
<p><strong>Chapter 18에서도 동일한 패턴을 적용한다:</strong></p>
<ul>
<li><code>funlang.nil</code> ← TableGen → C API → F# bindings</li>
<li><code>funlang.cons</code> ← TableGen → C API → F# bindings</li>
<li><code>!funlang.list&lt;T&gt;</code> ← TableGen → C API → F# bindings</li>
</ul>
<h3 id="chapter-18-로드맵"><a class="header" href="#chapter-18-로드맵">Chapter 18 로드맵</a></h3>
<p><strong>Part 1 (현재 섹션):</strong></p>
<ul>
<li>List representation design</li>
<li><code>!funlang.list&lt;T&gt;</code> parameterized type</li>
<li><code>funlang.nil</code> operation</li>
<li><code>funlang.cons</code> operation</li>
</ul>
<p><strong>Part 2 (다음 섹션):</strong></p>
<ul>
<li>TypeConverter for <code>!funlang.list&lt;T&gt;</code></li>
<li>NilOpLowering pattern</li>
<li>ConsOpLowering pattern</li>
<li>Complete lowering pass update</li>
</ul>
<h3 id="성공-기준-1"><a class="header" href="#성공-기준-1">성공 기준</a></h3>
<p>이 장을 완료하면:</p>
<ul>
<li><input disabled="" type="checkbox"> List의 메모리 표현(tagged union)을 이해한다</li>
<li><input disabled="" type="checkbox"> <code>!funlang.list&lt;T&gt;</code> 타입을 TableGen으로 정의할 수 있다</li>
<li><input disabled="" type="checkbox"> <code>funlang.nil</code>과 <code>funlang.cons</code>의 동작 원리를 안다</li>
<li><input disabled="" type="checkbox"> TypeConverter로 FunLang → LLVM 타입 변환을 구현할 수 있다</li>
<li><input disabled="" type="checkbox"> Lowering pattern으로 operation을 LLVM dialect로 변환할 수 있다</li>
<li><input disabled="" type="checkbox"> Chapter 19에서 <code>funlang.match</code> 구현을 시작할 준비가 된다</li>
</ul>
<p><strong>Let’s build the foundation for pattern matching—list data structures!</strong></p>
<hr>
<h2 id="list-representation-design"><a class="header" href="#list-representation-design">List Representation Design</a></h2>
<p>함수형 언어에서 리스트는 가장 기본적인 데이터 구조다. <strong>Immutable linked list</strong>는 다음 특징을 가진다:</p>
<ul>
<li><strong>Immutability</strong>: 한번 생성되면 변경 불가 (functional purity)</li>
<li><strong>Structural sharing</strong>: 서브리스트를 공유하여 메모리 효율적</li>
<li><strong>Recursive structure</strong>: Nil (empty) 또는 Cons (head, tail)</li>
</ul>
<h3 id="list는-algebraic-data-type이다"><a class="header" href="#list는-algebraic-data-type이다">List는 Algebraic Data Type이다</a></h3>
<p>함수형 언어에서 리스트는 <strong>sum type</strong> (tagged union)으로 정의된다:</p>
<pre><code class="language-fsharp">// F#
type List&lt;'T&gt; =
    | Nil
    | Cons of 'T * List&lt;'T&gt;

// 예제
let empty = Nil
let one = Cons(1, Nil)               // [1]
let three = Cons(1, Cons(2, Cons(3, Nil)))  // [1; 2; 3]
</code></pre>
<pre><code class="language-ocaml">(* OCaml *)
type 'a list =
  | []
  | (::) of 'a * 'a list

(* 예제 *)
let empty = []
let one = 1 :: []
let three = 1 :: 2 :: 3 :: []
</code></pre>
<pre><code class="language-haskell">-- Haskell
data List a = Nil | Cons a (List a)

-- 예제
empty = Nil
one = Cons 1 Nil
three = Cons 1 (Cons 2 (Cons 3 Nil))
</code></pre>
<p><strong>공통 패턴:</strong></p>
<ol>
<li><strong>Two constructors</strong>: Nil (empty), Cons (non-empty)</li>
<li><strong>Type parameter</strong>: <code>'T</code>, <code>'a</code>, <code>a</code> (element type)</li>
<li><strong>Recursive definition</strong>: Cons의 tail은 List 자체</li>
</ol>
<h3 id="tagged-union-representation"><a class="header" href="#tagged-union-representation">Tagged Union Representation</a></h3>
<p>LLVM에서 sum type을 표현하는 일반적인 방법:</p>
<p><strong>Discriminator tag + Data pointer</strong></p>
<pre><code>struct TaggedUnion {
    i32 tag;        // 0 = Nil, 1 = Cons, 2 = OtherVariant, ...
    ptr data;       // variant-specific data
}
</code></pre>
<p><strong>List의 경우:</strong></p>
<pre><code>!llvm.struct&lt;(i32, ptr)&gt;

- tag = 0: Nil (data = null)
- tag = 1: Cons (data = pointer to {head, tail})
</code></pre>
<p><strong>메모리 레이아웃:</strong></p>
<pre><code>Nil representation:
┌─────┬──────┐
│  0  │ null │
└─────┴──────┘
  tag   data

Cons representation:
┌─────┬──────┐        ┌────────┬──────────┐
│  1  │ ptr  │───────&gt;│  head  │   tail   │
└─────┴──────┘        └────────┴──────────┘
  tag   data            element   ptr/struct
</code></pre>
<h3 id="cons-cell-memory-layout"><a class="header" href="#cons-cell-memory-layout">Cons Cell Memory Layout</a></h3>
<p>Cons cell은 heap에 할당되는 구조체다:</p>
<pre><code>Cons Cell = struct {
    element: T,           // head value
    tail: !llvm.struct&lt;(i32, ptr)&gt;  // tail as tagged union
}
</code></pre>
<p><strong>예제: 리스트 [1, 2, 3]의 메모리 구조</strong></p>
<pre><code>%lst3 = Cons(1, Cons(2, Cons(3, Nil)))

Stack (list values as tagged unions):
%lst3: {1, ptr_to_cell1}
%lst2: {1, ptr_to_cell2}
%lst1: {1, ptr_to_cell3}
%nil:  {0, null}

Heap (cons cells):
cell1: {1, %lst2}
       ↑   ↓
     head  tail

cell2: {2, %lst1}
       ↑   ↓
     head  tail

cell3: {3, %nil}
       ↑   ↓
     head  tail (= {0, null})
</code></pre>
<p><strong>Visual representation:</strong></p>
<pre><code>%lst3               cell1              %lst2              cell2              %lst1              cell3              %nil
┌───┬────┐          ┌───┬──────┐       ┌───┬────┐         ┌───┬──────┐       ┌───┬────┐         ┌───┬──────┐       ┌───┬──────┐
│ 1 │ ●──┼─────────&gt;│ 1 │ ●────┼──────&gt;│ 1 │ ●──┼────────&gt;│ 2 │ ●────┼──────&gt;│ 1 │ ●──┼────────&gt;│ 3 │ ●────┼──────&gt;│ 0 │ null │
└───┴────┘          └───┴──────┘       └───┴────┘         └───┴──────┘       └───┴────┘         └───┴──────┘       └───┴──────┘
</code></pre>
<h3 id="gc-allocation-for-cons-cells"><a class="header" href="#gc-allocation-for-cons-cells">GC Allocation for Cons Cells</a></h3>
<p>Cons cell은 항상 <strong>heap에 할당</strong>된다:</p>
<p><strong>이유:</strong></p>
<ol>
<li><strong>Escape analysis</strong>: 리스트는 함수 반환값으로 사용됨 (upward funarg)</li>
<li><strong>Sharing</strong>: 여러 리스트가 같은 tail을 공유할 수 있음</li>
<li><strong>Lifetime</strong>: 리스트의 lifetime은 생성 함수보다 길 수 있음</li>
</ol>
<p><strong>Allocation strategy:</strong></p>
<pre><code class="language-mlir">// funlang.cons %head, %tail

// Lowering:
%cell_size = arith.constant 16 : i64  // sizeof(element) + sizeof(ptr)
%cell_ptr = llvm.call @GC_malloc(%cell_size) : (i64) -&gt; !llvm.ptr

// Store head
%head_offset = llvm.getelementptr %cell_ptr[0] : (!llvm.ptr) -&gt; !llvm.ptr
llvm.store %head, %head_offset : i32, !llvm.ptr

// Store tail
%tail_offset = llvm.getelementptr %cell_ptr[1] : (!llvm.ptr) -&gt; !llvm.ptr
llvm.store %tail, %tail_offset : !llvm.struct&lt;(i32, ptr)&gt;, !llvm.ptr

// Build tagged union
%tag = arith.constant 1 : i32
%undef = llvm.mlir.undef : !llvm.struct&lt;(i32, ptr)&gt;
%s1 = llvm.insertvalue %tag, %undef[0] : !llvm.struct&lt;(i32, ptr)&gt;
%result = llvm.insertvalue %cell_ptr, %s1[1] : !llvm.struct&lt;(i32, ptr)&gt;
</code></pre>
<p><strong>GC의 역할:</strong></p>
<ul>
<li>Cons cells는 명시적으로 free하지 않는다</li>
<li>Boehm GC가 reachability를 추적하여 자동으로 수집</li>
<li>Chapter 9에서 설정한 GC infrastructure 활용</li>
</ul>
<h3 id="immutability와-structural-sharing"><a class="header" href="#immutability와-structural-sharing">Immutability와 Structural Sharing</a></h3>
<p><strong>Immutability:</strong></p>
<pre><code class="language-mlir">// 리스트 생성
%lst1 = funlang.cons %x, %nil : !funlang.list&lt;i32&gt;

// "수정" 불가능 (새 리스트 생성)
%lst2 = funlang.cons %y, %lst1 : !funlang.list&lt;i32&gt;
// %lst1은 변경되지 않음!
</code></pre>
<p><strong>Structural sharing:</strong></p>
<pre><code class="language-mlir">%nil = funlang.nil : !funlang.list&lt;i32&gt;
%lst1 = funlang.cons %c1, %nil : !funlang.list&lt;i32&gt;  // [1]
%lst2 = funlang.cons %c2, %lst1 : !funlang.list&lt;i32&gt;  // [2, 1]
%lst3 = funlang.cons %c3, %lst1 : !funlang.list&lt;i32&gt;  // [3, 1]

// %lst2와 %lst3는 %lst1을 tail로 공유!
</code></pre>
<p><strong>메모리 효율:</strong></p>
<pre><code>Without sharing (mutable arrays):
[2, 1]: 2개 원소 저장
[3, 1]: 2개 원소 저장
Total: 4개 원소

With sharing (immutable lists):
[2, 1]: cell(2) → cell(1) → Nil
[3, 1]: cell(3) ──┘
Total: 3개 cons cells (원소 중복 없음)
</code></pre>
<p><strong>장점:</strong></p>
<ol>
<li><strong>메모리 효율</strong>: 공통 sublist를 재사용</li>
<li><strong>안전성</strong>: Aliasing bugs 없음 (immutable)</li>
<li><strong>병렬성</strong>: Race conditions 없음</li>
<li><strong>Persistent data structures</strong>: 이전 버전 유지 가능</li>
</ol>
<h3 id="element-type-considerations"><a class="header" href="#element-type-considerations">Element Type Considerations</a></h3>
<p>리스트는 <strong>parameterized type</strong>이어야 한다:</p>
<p><strong>타입 안전성:</strong></p>
<pre><code class="language-mlir">// 올바른 타입: !funlang.list&lt;i32&gt;
%int_list = funlang.nil : !funlang.list&lt;i32&gt;
%int_cons = funlang.cons %x, %int_list : !funlang.list&lt;i32&gt;
// Type checker verifies: %x must be i32

// 잘못된 타입: !funlang.list (opaque - no element type)
%list = funlang.nil : !funlang.list
%cons = funlang.cons %x, %list : !funlang.list
// Type checker CANNOT verify: %x type unknown
</code></pre>
<p><strong>Cons cell storage:</strong></p>
<ul>
<li>Element type은 cons cell에 저장됨 (not in list struct)</li>
<li>List struct는 tag + pointer만 포함</li>
<li>Element type은 컴파일 타임 정보 (type safety)</li>
</ul>
<p><strong>Type parameter in lowering:</strong></p>
<pre><code>!funlang.list&lt;i32&gt; → !llvm.struct&lt;(i32, ptr)&gt;
!funlang.list&lt;f64&gt; → !llvm.struct&lt;(i32, ptr)&gt;
!funlang.list&lt;!funlang.closure&gt; → !llvm.struct&lt;(i32, ptr)&gt;

// 런타임 표현은 동일! (opaque pointer)
// 컴파일 타임에만 element type 검증
</code></pre>
<h3 id="list-representation-vs-array-representation"><a class="header" href="#list-representation-vs-array-representation">List Representation vs Array Representation</a></h3>
<p><strong>왜 linked list인가? 배열보다 나은가?</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Linked List</th><th>Array</th></tr>
</thead>
<tbody>
<tr><td>Random access</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Prepend (cons)</td><td>O(1)</td><td>O(n) - copy</td></tr>
<tr><td>Append</td><td>O(n)</td><td>O(1) or O(n)</td></tr>
<tr><td>Structural sharing</td><td>O(1)</td><td>Impossible (mutable)</td></tr>
<tr><td>Pattern matching</td><td>Natural (Nil/Cons)</td><td>Complex (length check + index)</td></tr>
<tr><td>Memory</td><td>Pointer overhead</td><td>Contiguous, cache-friendly</td></tr>
</tbody>
</table>
</div>
<p><strong>함수형 언어에서 linked list를 선호하는 이유:</strong></p>
<ol>
<li><strong>Immutability</strong>: Sharing이 메모리 효율적</li>
<li><strong>Pattern matching</strong>: Constructor-based decomposition 자연스러움</li>
<li><strong>Recursion</strong>: Recursive structure와 recursive functions 매칭</li>
<li><strong>Prepend</strong>: 대부분의 list operations는 prepend 중심 (cons, map, filter)</li>
</ol>
<p><strong>Array가 더 나은 경우:</strong></p>
<ul>
<li>Random access가 주요 operation</li>
<li>Numeric computing (SIMD, vectorization)</li>
<li>Cache locality가 중요한 tight loop</li>
</ul>
<p><strong>FunLang의 선택:</strong></p>
<ul>
<li>Phase 6는 linked list로 구현 (함수형 언어 교육 목적)</li>
<li>Phase 7에서 array/vector 추가 가능 (performance-critical code)</li>
</ul>
<h3 id="comparison-with-other-implementations"><a class="header" href="#comparison-with-other-implementations">Comparison with Other Implementations</a></h3>
<p><strong>OCaml list representation:</strong></p>
<pre><code class="language-c">// OCaml runtime
typedef uintnat value;

#define Val_int(x) ((value)((x) &lt;&lt; 1) + 1)
#define Int_val(x) ((long)(x) &gt;&gt; 1)

// List: []
#define Val_emptylist Val_int(0)

// List: head :: tail
struct list_cell {
    value header;  // GC header
    value head;
    value tail;
};
</code></pre>
<p><strong>Haskell list representation (GHC):</strong></p>
<pre><code class="language-c">// Haskell runtime
typedef struct {
    StgHeader header;
    StgClosure *head;
    StgClosure *tail;
} StgCons;

// [] is a special constructor (static object)
</code></pre>
<p><strong>FunLang’s simpler approach:</strong></p>
<ul>
<li>No GC header (Boehm GC handles this internally)</li>
<li>Tagged union explicit (tag + data)</li>
<li>Uniform representation (LLVM struct)</li>
</ul>
<h3 id="summary-list-representation-design"><a class="header" href="#summary-list-representation-design">Summary: List Representation Design</a></h3>
<p><strong>핵심 결정사항:</strong></p>
<ol>
<li><strong>Tagged union</strong>: <code>!llvm.struct&lt;(i32, ptr)&gt;</code> for Nil/Cons discrimination</li>
<li><strong>Cons cells</strong>: Heap-allocated <code>{element, tail}</code> structs via GC_malloc</li>
<li><strong>Immutability</strong>: 리스트는 생성 후 변경 불가</li>
<li><strong>Structural sharing</strong>: 여러 리스트가 tail을 공유 가능</li>
<li><strong>Parameterized type</strong>: <code>!funlang.list&lt;T&gt;</code> for type safety</li>
</ol>
<p><strong>다음 섹션에서:</strong></p>
<ul>
<li><code>!funlang.list&lt;T&gt;</code> TableGen 정의</li>
<li><code>funlang.nil</code> operation 구현</li>
<li><code>funlang.cons</code> operation 구현</li>
</ul>
<hr>
<h2 id="funlang-list-type"><a class="header" href="#funlang-list-type">FunLang List Type</a></h2>
<p>이제 list를 표현할 <strong>MLIR type</strong>을 정의한다. Chapter 15에서 배운 parameterized type 패턴을 적용한다.</p>
<h3 id="parameterized-type의-필요성"><a class="header" href="#parameterized-type의-필요성">Parameterized Type의 필요성</a></h3>
<p><strong>왜 <code>!funlang.list</code>가 아니라 <code>!funlang.list&lt;T&gt;</code>인가?</strong></p>
<pre><code class="language-mlir">// 잘못된 설계: Opaque list type
def FunLang_ListType : FunLang_Type&lt;"List", "list"&gt; {
  // No type parameters!
}

// 사용 예
%list1 = funlang.nil : !funlang.list  // 어떤 타입의 원소?
%list2 = funlang.cons %x, %list1 : !funlang.list  // %x의 타입은?

// 문제점:
// 1. Type checker가 element type을 검증할 수 없음
// 2. funlang.cons의 head 타입이 tail의 element type과 일치하는지 확인 불가
// 3. funlang.match의 cons region에서 head의 타입을 추론할 수 없음
</code></pre>
<p><strong>올바른 설계: Parameterized type</strong></p>
<pre><code class="language-mlir">def FunLang_ListType : FunLang_Type&lt;"List", "list", [
    TypeParameter&lt;"Type", "elementType"&gt;
]&gt; {
  // Type parameter: T
}

// 사용 예
%int_list = funlang.nil : !funlang.list&lt;i32&gt;
%float_list = funlang.nil : !funlang.list&lt;f64&gt;
%closure_list = funlang.nil : !funlang.list&lt;!funlang.closure&gt;

// 장점:
// 1. Type checker가 element type 검증
// 2. funlang.cons %x, %tail에서 %x : T (T는 tail의 element type)
// 3. funlang.match의 ^cons region에서 head : T
</code></pre>
<h3 id="tablegen-type-definition"><a class="header" href="#tablegen-type-definition">TableGen Type Definition</a></h3>
<p><strong>파일: <code>mlir/include/mlir/Dialect/FunLang/FunLangOps.td</code></strong></p>
<pre><code class="language-tablegen">//===----------------------------------------------------------------------===//
// FunLang Types
//===----------------------------------------------------------------------===//

// ClosureType (Chapter 15)
def FunLang_ClosureType : FunLang_Type&lt;"Closure", "closure"&gt; {
  let summary = "FunLang closure type (opaque)";

  let description = [{
    Represents a closure (function + captured environment).

    Syntax: `!funlang.closure`

    Lowering:
    - FunLang dialect: !funlang.closure
    - LLVM dialect: !llvm.ptr

    Internal representation (after lowering):
    ```
    struct {
        ptr fn_ptr;      // function pointer
        T1 capture1;     // captured variable 1
        T2 capture2;     // captured variable 2
        ...
    }
    ```
  }];
}

// ListType (Chapter 18)
def FunLang_ListType : FunLang_Type&lt;"List", "list", [
    TypeParameter&lt;"Type", "elementType"&gt;
]&gt; {
  let summary = "FunLang immutable list type";

  let description = [{
    Represents an immutable linked list with type parameter.

    Syntax: `!funlang.list&lt;T&gt;`

    Type parameter:
    - T: Element type (any MLIR type)

    Examples:
    ```
    !funlang.list&lt;i32&gt;          // List of integers
    !funlang.list&lt;f64&gt;          // List of floats
    !funlang.list&lt;!funlang.closure&gt;  // List of closures
    !funlang.list&lt;!funlang.list&lt;i32&gt;&gt;  // List of lists (nested)
    ```

    Lowering:
    - FunLang dialect: !funlang.list&lt;T&gt;
    - LLVM dialect: !llvm.struct&lt;(i32, ptr)&gt;

    Internal representation (after lowering):
    ```
    struct TaggedUnion {
        i32 tag;        // 0 = Nil, 1 = Cons
        ptr data;       // nullptr for Nil, cons cell pointer for Cons
    }

    struct ConsCell {
        T element;      // head element
        TaggedUnion tail;  // tail list
    }
    ```

    Note: Element type T is compile-time information only.
          Runtime representation is uniform (opaque pointer).
  }];

  let parameters = (ins "Type":$elementType);

  let assemblyFormat = "`&lt;` $elementType `&gt;`";

  let builders = [
    TypeBuilder&lt;(ins "Type":$elementType), [{
      return Base::get($_ctxt, elementType);
    }]&gt;
  ];
}
</code></pre>
<p><strong>핵심 요소:</strong></p>
<ol>
<li>
<p><strong>Type parameter</strong>: <code>TypeParameter&lt;"Type", "elementType"&gt;</code></p>
<ul>
<li>C++ 클래스에서 <code>Type getElementType() const</code> 메서드 생성</li>
<li>Assembly format에서 <code>!funlang.list&lt;i32&gt;</code> 형태로 출력</li>
</ul>
</li>
<li>
<p><strong>Assembly format</strong>: <code>"`&lt;` $elementType `&gt;`"</code></p>
<ul>
<li><code>&lt;T&gt;</code> syntax for parameterized type</li>
<li>TableGen이 parser/printer 자동 생성</li>
</ul>
</li>
<li>
<p><strong>Builder</strong>: 편의를 위한 생성자</p>
<ul>
<li><code>FunLangListType::get(context, elementType)</code></li>
</ul>
</li>
</ol>
<h3 id="generated-c-interface"><a class="header" href="#generated-c-interface">Generated C++ Interface</a></h3>
<p>TableGen이 생성하는 C++ 코드:</p>
<pre><code class="language-cpp">// mlir/include/mlir/Dialect/FunLang/FunLangTypes.h

namespace mlir {
namespace funlang {

class FunLangListType : public Type::TypeBase&lt;
    FunLangListType,
    Type,
    detail::FunLangListTypeStorage,   // Storage for type parameters
    TypeTrait::HasTypeParameter&gt; {    // Trait for parameterized types
public:
  using Base::Base;

  /// Create !funlang.list&lt;elementType&gt;
  static FunLangListType get(MLIRContext *context, Type elementType);

  /// Get element type from !funlang.list&lt;T&gt;
  Type getElementType() const;

  /// Parse !funlang.list&lt;T&gt; from assembly
  static Type parse(AsmParser &amp;parser);

  /// Print !funlang.list&lt;T&gt; to assembly
  void print(AsmPrinter &amp;printer) const;

  /// Verify type parameter is valid
  static LogicalResult verify(
      function_ref&lt;InFlightDiagnostic()&gt; emitError,
      Type elementType);
};

} // namespace funlang
} // namespace mlir
</code></pre>
<p><strong>Storage implementation (TableGen이 생성):</strong></p>
<pre><code class="language-cpp">namespace mlir {
namespace funlang {
namespace detail {

struct FunLangListTypeStorage : public TypeStorage {
  using KeyTy = Type;  // elementType is the key

  FunLangListTypeStorage(Type elementType) : elementType(elementType) {}

  bool operator==(const KeyTy &amp;key) const {
    return elementType == key;
  }

  static FunLangListTypeStorage *construct(
      TypeStorageAllocator &amp;allocator, const KeyTy &amp;key) {
    return new (allocator.allocate&lt;FunLangListTypeStorage&gt;())
        FunLangListTypeStorage(key);
  }

  Type elementType;
};

} // namespace detail
} // namespace funlang
} // namespace mlir
</code></pre>
<h3 id="type-uniquing"><a class="header" href="#type-uniquing">Type Uniquing</a></h3>
<p>MLIR은 type uniquing을 자동으로 수행한다:</p>
<pre><code class="language-cpp">// Same element type → same type instance
auto ctx = /* context */;
auto i32Ty = IntegerType::get(ctx, 32);

auto listTy1 = FunLangListType::get(ctx, i32Ty);
auto listTy2 = FunLangListType::get(ctx, i32Ty);

assert(listTy1 == listTy2);  // Same pointer!
</code></pre>
<p><strong>장점:</strong></p>
<ul>
<li>Type comparison은 pointer equality (<code>==</code>)</li>
<li>Type hashing 효율적</li>
<li>Memory 효율적 (각 unique type은 한 번만 저장)</li>
</ul>
<h3 id="c-api-shim-1"><a class="header" href="#c-api-shim-1">C API Shim</a></h3>
<p>F#에서 사용하기 위한 C API:</p>
<p><strong>파일: <code>mlir/lib/CAPI/Dialect/FunLang.cpp</code></strong></p>
<pre><code class="language-cpp">//===----------------------------------------------------------------------===//
// ListType
//===----------------------------------------------------------------------===//

/// Create !funlang.list&lt;elementType&gt;
MlirType mlirFunLangListTypeGet(MlirContext ctx, MlirType elementType) {
  return wrap(funlang::FunLangListType::get(
      unwrap(ctx), unwrap(elementType)));
}

/// Check if type is !funlang.list
bool mlirTypeIsAFunLangListType(MlirType ty) {
  return unwrap(ty).isa&lt;funlang::FunLangListType&gt;();
}

/// Get element type from !funlang.list&lt;T&gt;
MlirType mlirFunLangListTypeGetElementType(MlirType ty) {
  auto listTy = unwrap(ty).cast&lt;funlang::FunLangListType&gt;();
  return wrap(listTy.getElementType());
}
</code></pre>
<p><strong>헤더 파일: <code>mlir/include/mlir-c/Dialect/FunLang.h</code></strong></p>
<pre><code class="language-c">#ifndef MLIR_C_DIALECT_FUNLANG_H
#define MLIR_C_DIALECT_FUNLANG_H

#include "mlir-c/IR.h"

#ifdef __cplusplus
extern "C" {
#endif

//===----------------------------------------------------------------------===//
// ListType
//===----------------------------------------------------------------------===//

/// Create !funlang.list&lt;elementType&gt; type
MLIR_CAPI_EXPORTED MlirType
mlirFunLangListTypeGet(MlirContext ctx, MlirType elementType);

/// Check if type is !funlang.list
MLIR_CAPI_EXPORTED bool
mlirTypeIsAFunLangListType(MlirType ty);

/// Get element type from !funlang.list&lt;T&gt;
MLIR_CAPI_EXPORTED MlirType
mlirFunLangListTypeGetElementType(MlirType ty);

#ifdef __cplusplus
}
#endif

#endif // MLIR_C_DIALECT_FUNLANG_H
</code></pre>
<h3 id="f-bindings"><a class="header" href="#f-bindings">F# Bindings</a></h3>
<p><strong>파일: <code>FunLang.Compiler/MlirBindings.fs</code></strong></p>
<pre><code class="language-fsharp">module FunLangBindings =
    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirFunLangListTypeGet(MlirContext ctx, MlirType elementType)

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern bool mlirTypeIsAFunLangListType(MlirType ty)

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirFunLangListTypeGetElementType(MlirType ty)
</code></pre>
<p><strong>FunLangDialect wrapper:</strong></p>
<pre><code class="language-fsharp">type FunLangDialect(ctx: MlirContext) =
    member this.Context = ctx

    //==========================================================================
    // Types
    //==========================================================================

    /// Create !funlang.closure type
    member this.ClosureType() : MlirType =
        FunLangBindings.mlirFunLangClosureTypeGet(this.Context)

    /// Check if type is !funlang.closure
    member this.IsClosureType(ty: MlirType) : bool =
        FunLangBindings.mlirTypeIsAFunLangClosureType(ty)

    /// Create !funlang.list&lt;T&gt; type
    member this.ListType(elementType: MlirType) : MlirType =
        FunLangBindings.mlirFunLangListTypeGet(this.Context, elementType)

    /// Check if type is !funlang.list
    member this.IsListType(ty: MlirType) : bool =
        FunLangBindings.mlirTypeIsAFunLangListType(ty)

    /// Get element type from !funlang.list&lt;T&gt;
    member this.ListElementType(ty: MlirType) : MlirType =
        if not (this.IsListType(ty)) then
            invalidArg "ty" "Expected !funlang.list type"
        FunLangBindings.mlirFunLangListTypeGetElementType(ty)
</code></pre>
<p><strong>OpBuilder extension:</strong></p>
<pre><code class="language-fsharp">type OpBuilder with
    /// Create !funlang.list&lt;T&gt; type
    member this.FunLangListType(elementType: MlirType) : MlirType =
        let funlang = FunLangDialect(this.Context)
        funlang.ListType(elementType)
</code></pre>
<h3 id="f-usage-examples"><a class="header" href="#f-usage-examples">F# Usage Examples</a></h3>
<pre><code class="language-fsharp">// F# compiler code
let compileListExpr (builder: OpBuilder) =
    // Create type: !funlang.list&lt;i32&gt;
    let i32Type = builder.IntegerType(32)
    let listType = builder.FunLangListType(i32Type)

    // Create empty list
    let nil = builder.CreateNil(listType)

    // Create cons cell
    let head = (* some i32 value *)
    let cons = builder.CreateCons(head, nil)

    cons

// Check if type is list type
let isListType (ty: MlirType) =
    let funlang = FunLangDialect(ctx)
    funlang.IsListType(ty)

// Get element type
let getElementType (listTy: MlirType) =
    let funlang = FunLangDialect(ctx)
    if funlang.IsListType(listTy) then
        Some (funlang.ListElementType(listTy))
    else
        None
</code></pre>
<h3 id="nested-list-types"><a class="header" href="#nested-list-types">Nested List Types</a></h3>
<p>Parameterized type이므로 중첩 가능:</p>
<pre><code class="language-mlir">// List of lists
!funlang.list&lt;!funlang.list&lt;i32&gt;&gt;

// Example: [[1, 2], [3, 4]]
%inner_nil = funlang.nil : !funlang.list&lt;i32&gt;
%inner1 = funlang.cons %c2, %inner_nil : !funlang.list&lt;i32&gt;
%inner1 = funlang.cons %c1, %inner1 : !funlang.list&lt;i32&gt;  // [1, 2]

%inner2 = funlang.cons %c4, %inner_nil : !funlang.list&lt;i32&gt;
%inner2 = funlang.cons %c3, %inner2 : !funlang.list&lt;i32&gt;  // [3, 4]

%outer_nil = funlang.nil : !funlang.list&lt;!funlang.list&lt;i32&gt;&gt;
%outer = funlang.cons %inner2, %outer_nil : !funlang.list&lt;!funlang.list&lt;i32&gt;&gt;
%outer = funlang.cons %inner1, %outer : !funlang.list&lt;!funlang.list&lt;i32&gt;&gt;
// [[1, 2], [3, 4]]
</code></pre>
<p><strong>Lowering:</strong></p>
<pre><code>!funlang.list&lt;!funlang.list&lt;i32&gt;&gt; → !llvm.struct&lt;(i32, ptr)&gt;

// 동일한 표현! Element type은 컴파일 타임 정보만
</code></pre>
<h3 id="type-verification"><a class="header" href="#type-verification">Type Verification</a></h3>
<p>TableGen이 자동으로 verification 생성하지만, 추가 검증 가능:</p>
<pre><code class="language-cpp">LogicalResult FunLangListType::verify(
    function_ref&lt;InFlightDiagnostic()&gt; emitError,
    Type elementType) {
  // Element type must be non-null
  if (!elementType)
    return emitError() &lt;&lt; "list element type cannot be null";

  // Additional constraints (if needed)
  // e.g., element type must be first-class (no void, etc.)

  return success();
}
</code></pre>
<h3 id="summary-funlang-list-type"><a class="header" href="#summary-funlang-list-type">Summary: FunLang List Type</a></h3>
<p><strong>구현 완료:</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""> <code>!funlang.list&lt;T&gt;</code> parameterized type in TableGen</li>
<li><input disabled="" type="checkbox" checked=""> C++ interface with <code>getElementType()</code> method</li>
<li><input disabled="" type="checkbox" checked=""> C API shim: <code>mlirFunLangListTypeGet</code>, <code>mlirTypeIsAFunLangListType</code>, <code>mlirFunLangListTypeGetElementType</code></li>
<li><input disabled="" type="checkbox" checked=""> F# bindings in <code>FunLangDialect</code> class</li>
<li><input disabled="" type="checkbox" checked=""> OpBuilder extension for convenient usage</li>
</ul>
<p><strong>다음 섹션:</strong></p>
<ul>
<li><code>funlang.nil</code> operation으로 empty list 생성</li>
<li><code>funlang.cons</code> operation으로 cons cell 생성</li>
</ul>
<hr>
<h2 id="funlangnil-operation"><a class="header" href="#funlangnil-operation">funlang.nil Operation</a></h2>
<p>Empty list를 생성하는 operation을 구현한다.</p>
<h3 id="purpose-and-semantics"><a class="header" href="#purpose-and-semantics">Purpose and Semantics</a></h3>
<p><strong>funlang.nil의 역할:</strong></p>
<ul>
<li>Empty list (빈 리스트) 생성</li>
<li>리스트의 base case (재귀의 종료 조건)</li>
<li>Runtime allocation 불필요 (constant representation)</li>
</ul>
<p><strong>예제:</strong></p>
<pre><code class="language-mlir">// Create empty list of integers
%nil = funlang.nil : !funlang.list&lt;i32&gt;

// Create empty list of floats
%nil = funlang.nil : !funlang.list&lt;f64&gt;

// Create empty list of closures
%nil = funlang.nil : !funlang.list&lt;!funlang.closure&gt;
</code></pre>
<p><strong>의미:</strong></p>
<pre><code>funlang.nil : !funlang.list&lt;T&gt;

// Equivalent to (after lowering):
{tag: 0, data: null}
</code></pre>
<h3 id="tablegen-ods-definition"><a class="header" href="#tablegen-ods-definition">TableGen ODS Definition</a></h3>
<p><strong>파일: <code>mlir/include/mlir/Dialect/FunLang/FunLangOps.td</code></strong></p>
<pre><code class="language-tablegen">//===----------------------------------------------------------------------===//
// List Operations
//===----------------------------------------------------------------------===//

def FunLang_NilOp : FunLang_Op&lt;"nil", [Pure]&gt; {
  let summary = "Create empty list";

  let description = [{
    Creates an empty list (Nil constructor).

    Syntax:
    ```
    %nil = funlang.nil : !funlang.list&lt;T&gt;
    ```

    The result type specifies the element type of the list.

    Examples:
    ```
    // Empty list of integers
    %nil_int = funlang.nil : !funlang.list&lt;i32&gt;

    // Empty list of closures
    %nil_closure = funlang.nil : !funlang.list&lt;!funlang.closure&gt;
    ```

    Lowering:
    ```
    %nil = funlang.nil : !funlang.list&lt;i32&gt;

    // Lowers to:
    %tag = arith.constant 0 : i32
    %null = llvm.mlir.zero : !llvm.ptr
    %undef = llvm.mlir.undef : !llvm.struct&lt;(i32, ptr)&gt;
    %s1 = llvm.insertvalue %tag, %undef[0] : !llvm.struct&lt;(i32, ptr)&gt;
    %nil = llvm.insertvalue %null, %s1[1] : !llvm.struct&lt;(i32, ptr)&gt;
    ```

    Traits: Pure (no side effects, no memory allocation)
  }];

  let arguments = (ins);

  let results = (outs FunLang_ListType:$result);

  let assemblyFormat = "attr-dict `:` type($result)";

  let builders = [
    OpBuilder&lt;(ins "Type":$elementType), [{
      auto listType = funlang::FunLangListType::get($_builder.getContext(), elementType);
      $_state.addTypes(listType);
    }]&gt;
  ];
}
</code></pre>
<p><strong>핵심 요소:</strong></p>
<ol>
<li>
<p><strong>Pure trait</strong>: No side effects, 메모리 할당 없음</p>
<ul>
<li>CSE (Common Subexpression Elimination) 가능</li>
<li>같은 element type의 nil은 한 번만 생성 가능</li>
</ul>
</li>
<li>
<p><strong>No arguments</strong>: Empty list는 인자 불필요</p>
</li>
<li>
<p><strong>Result type</strong>: <code>!funlang.list&lt;T&gt;</code> (element type 명시 필요)</p>
</li>
<li>
<p><strong>Assembly format</strong>: <code>funlang.nil : !funlang.list&lt;i32&gt;</code></p>
<ul>
<li>Type suffix로 element type 지정</li>
</ul>
</li>
<li>
<p><strong>Builder</strong>: Element type만으로 NilOp 생성 가능</p>
</li>
</ol>
<h3 id="generated-c-interface-1"><a class="header" href="#generated-c-interface-1">Generated C++ Interface</a></h3>
<p>TableGen이 생성하는 C++ 코드:</p>
<pre><code class="language-cpp">// mlir/include/mlir/Dialect/FunLang/FunLangOps.h

namespace mlir {
namespace funlang {

class NilOp : public Op&lt;
    NilOp,
    OpTrait::ZeroOperands,
    OpTrait::OneResult,
    OpTrait::Pure&gt; {
public:
  using Op::Op;

  static StringRef getOperationName() { return "funlang.nil"; }

  /// Get result type (!funlang.list&lt;T&gt;)
  FunLangListType getType() {
    return getResult().getType().cast&lt;FunLangListType&gt;();
  }

  /// Get element type (T from !funlang.list&lt;T&gt;)
  Type getElementType() {
    return getType().getElementType();
  }

  /// Build NilOp with element type
  static void build(
      OpBuilder &amp;builder,
      OperationState &amp;state,
      Type elementType);

  /// Verify operation
  LogicalResult verify();

  /// Parse from assembly
  static ParseResult parse(OpAsmParser &amp;parser, OperationState &amp;result);

  /// Print to assembly
  void print(OpAsmPrinter &amp;p);
};

} // namespace funlang
} // namespace mlir
</code></pre>
<h3 id="verification"><a class="header" href="#verification">Verification</a></h3>
<pre><code class="language-cpp">LogicalResult NilOp::verify() {
  // Result must be !funlang.list&lt;T&gt;
  auto resultTy = getResult().getType();
  if (!resultTy.isa&lt;FunLangListType&gt;()) {
    return emitOpError("result must be !funlang.list type");
  }

  // Element type must be valid (checked by FunLangListType::verify)
  return success();
}
</code></pre>
<h3 id="c-api-shim-1-1"><a class="header" href="#c-api-shim-1-1">C API Shim</a></h3>
<p><strong>파일: <code>mlir/lib/CAPI/Dialect/FunLang.cpp</code></strong></p>
<pre><code class="language-cpp">//===----------------------------------------------------------------------===//
// NilOp
//===----------------------------------------------------------------------===//

MlirOperation mlirFunLangNilOpCreate(
    MlirLocation loc,
    MlirType elementType) {
  mlir::OpBuilder builder(unwrap(loc)-&gt;getContext());
  builder.setInsertionPointToStart(/* appropriate block */);

  auto listType = funlang::FunLangListType::get(
      unwrap(loc)-&gt;getContext(), unwrap(elementType));

  auto op = builder.create&lt;funlang::NilOp&gt;(
      unwrap(loc), listType);

  return wrap(op.getOperation());
}
</code></pre>
<p><strong>헤더 파일: <code>mlir/include/mlir-c/Dialect/FunLang.h</code></strong></p>
<pre><code class="language-c">//===----------------------------------------------------------------------===//
// NilOp
//===----------------------------------------------------------------------===//

/// Create funlang.nil operation
/// Returns MlirOperation (not MlirValue - use mlirOperationGetResult)
MLIR_CAPI_EXPORTED MlirOperation
mlirFunLangNilOpCreate(MlirLocation loc, MlirType elementType);
</code></pre>
<h3 id="f-bindings-1"><a class="header" href="#f-bindings-1">F# Bindings</a></h3>
<p><strong>파일: <code>FunLang.Compiler/MlirBindings.fs</code></strong></p>
<pre><code class="language-fsharp">module FunLangBindings =
    // ... (previous bindings) ...

    //==========================================================================
    // Operations - NilOp
    //==========================================================================

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirFunLangNilOpCreate(MlirLocation loc, MlirType elementType)
</code></pre>
<p><strong>FunLangDialect wrapper:</strong></p>
<pre><code class="language-fsharp">type FunLangDialect(ctx: MlirContext) =
    // ... (previous members) ...

    //==========================================================================
    // Operation Creation
    //==========================================================================

    /// Create funlang.nil operation
    member this.CreateNilOp(loc: MlirLocation, elementType: MlirType) : MlirOperation =
        FunLangBindings.mlirFunLangNilOpCreate(loc, elementType)

    /// Create funlang.nil and return the result value
    member this.CreateNil(loc: MlirLocation, elementType: MlirType) : MlirValue =
        let op = this.CreateNilOp(loc, elementType)
        MlirHelpers.GetOperationResult(op, 0)
</code></pre>
<p><strong>OpBuilder extension:</strong></p>
<pre><code class="language-fsharp">type OpBuilder with
    // ... (previous members) ...

    /// Create funlang.nil operation
    member this.CreateNilOp(elementType: MlirType) : MlirOperation =
        let funlang = FunLangDialect(this.Context)
        funlang.CreateNilOp(this.UnknownLoc, elementType)

    /// Create funlang.nil and return result value
    member this.CreateNil(elementType: MlirType) : MlirValue =
        let funlang = FunLangDialect(this.Context)
        funlang.CreateNil(this.UnknownLoc, elementType)
</code></pre>
<h3 id="f-usage-examples-1"><a class="header" href="#f-usage-examples-1">F# Usage Examples</a></h3>
<pre><code class="language-fsharp">// Example 1: Basic usage
let builder = OpBuilder(ctx)

let i32Type = builder.IntegerType(32)
let nilValue = builder.CreateNil(i32Type)
// %nil = funlang.nil : !funlang.list&lt;i32&gt;

// Example 2: Building list [1, 2, 3] (forward)
let nil = builder.CreateNil(i32Type)
let c1 = builder.CreateConstantInt(1, 32)
let c2 = builder.CreateConstantInt(2, 32)
let c3 = builder.CreateConstantInt(3, 32)

// Build from right to left: 3 → 2 → 1 → nil
let lst1 = builder.CreateCons(c3, nil)    // [3]
let lst2 = builder.CreateCons(c2, lst1)   // [2, 3]
let lst3 = builder.CreateCons(c1, lst2)   // [1, 2, 3]

// Example 3: Empty list of different types
let floatType = builder.FloatType(64)
let nilFloat = builder.CreateNil(floatType)
// %nil = funlang.nil : !funlang.list&lt;f64&gt;

let closureType = builder.FunLangClosureType()
let nilClosure = builder.CreateNil(closureType)
// %nil = funlang.nil : !funlang.list&lt;!funlang.closure&gt;
</code></pre>
<h3 id="no-runtime-allocation-needed"><a class="header" href="#no-runtime-allocation-needed">No Runtime Allocation Needed</a></h3>
<p><strong>중요한 최적화 기회:</strong></p>
<pre><code class="language-mlir">// Multiple nil operations
%nil1 = funlang.nil : !funlang.list&lt;i32&gt;
%nil2 = funlang.nil : !funlang.list&lt;i32&gt;
%nil3 = funlang.nil : !funlang.list&lt;i32&gt;

// Pure trait enables CSE:
// → All replaced with single %nil!

// Lowering (only once):
%tag = arith.constant 0 : i32
%null = llvm.mlir.zero : !llvm.ptr
%undef = llvm.mlir.undef : !llvm.struct&lt;(i32, ptr)&gt;
%s1 = llvm.insertvalue %tag, %undef[0] : !llvm.struct&lt;(i32, ptr)&gt;
%nil = llvm.insertvalue %null, %s1[1] : !llvm.struct&lt;(i32, ptr)&gt;

// No GC_malloc call! (constant struct)
</code></pre>
<p><strong>Static empty list (advanced optimization - Phase 7):</strong></p>
<pre><code class="language-cpp">// Could use global constant for empty list
static const struct { int tag; void* data; } EMPTY_LIST = {0, NULL};

// All funlang.nil → load from EMPTY_LIST address
</code></pre>
<h3 id="summary-funlangnil-operation"><a class="header" href="#summary-funlangnil-operation">Summary: funlang.nil Operation</a></h3>
<p><strong>구현 완료:</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""> TableGen ODS definition with Pure trait</li>
<li><input disabled="" type="checkbox" checked=""> No arguments, result type is <code>!funlang.list&lt;T&gt;</code></li>
<li><input disabled="" type="checkbox" checked=""> C API shim: <code>mlirFunLangNilOpCreate</code></li>
<li><input disabled="" type="checkbox" checked=""> F# bindings: <code>CreateNilOp</code>, <code>CreateNil</code></li>
<li><input disabled="" type="checkbox" checked=""> OpBuilder extension for convenient usage</li>
</ul>
<p><strong>특징:</strong></p>
<ul>
<li>Pure operation (CSE 가능)</li>
<li>No runtime allocation</li>
<li>Result type으로 element type 지정</li>
</ul>
<p><strong>다음 섹션:</strong></p>
<ul>
<li><code>funlang.cons</code> operation으로 cons cell 생성</li>
</ul>
<hr>
<h2 id="funlangcons-operation"><a class="header" href="#funlangcons-operation">funlang.cons Operation</a></h2>
<p>Cons cell을 생성하는 operation을 구현한다. 리스트의 핵심 생성자다.</p>
<h3 id="purpose-and-semantics-1"><a class="header" href="#purpose-and-semantics-1">Purpose and Semantics</a></h3>
<p><strong>funlang.cons의 역할:</strong></p>
<ul>
<li>Non-empty list 생성 (head :: tail)</li>
<li>리스트의 recursive case</li>
<li>GC를 통한 heap allocation</li>
</ul>
<p><strong>예제:</strong></p>
<pre><code class="language-mlir">// Prepend element to list
%lst = funlang.cons %head, %tail : !funlang.list&lt;i32&gt;

// Build list [1, 2, 3]
%nil = funlang.nil : !funlang.list&lt;i32&gt;
%c3 = arith.constant 3 : i32
%lst1 = funlang.cons %c3, %nil : !funlang.list&lt;i32&gt;    // [3]
%c2 = arith.constant 2 : i32
%lst2 = funlang.cons %c2, %lst1 : !funlang.list&lt;i32&gt;   // [2, 3]
%c1 = arith.constant 1 : i32
%lst3 = funlang.cons %c1, %lst2 : !funlang.list&lt;i32&gt;   // [1, 2, 3]
</code></pre>
<p><strong>의미:</strong></p>
<pre><code>funlang.cons %head, %tail : !funlang.list&lt;T&gt;

// Equivalent to (after lowering):
cell = GC_malloc(sizeof(T) + sizeof(ptr))
cell-&gt;head = %head
cell-&gt;tail = %tail
result = {tag: 1, data: cell}
</code></pre>
<h3 id="tablegen-ods-definition-1"><a class="header" href="#tablegen-ods-definition-1">TableGen ODS Definition</a></h3>
<p><strong>파일: <code>mlir/include/mlir/Dialect/FunLang/FunLangOps.td</code></strong></p>
<pre><code class="language-tablegen">def FunLang_ConsOp : FunLang_Op&lt;"cons", []&gt; {
  let summary = "Create cons cell (non-empty list)";

  let description = [{
    Creates a cons cell by prepending an element to a list.

    Syntax:
    ```
    %result = funlang.cons %head, %tail : !funlang.list&lt;T&gt;
    ```

    Arguments:
    - `head`: Element to prepend (type T)
    - `tail`: Existing list (type !funlang.list&lt;T&gt;)

    Result:
    - New list with `head` prepended to `tail` (type !funlang.list&lt;T&gt;)

    Type constraints:
    - `head` type must match element type of `tail` list
    - Result type is same as `tail` type

    Examples:
    ```
    // Create [1]
    %nil = funlang.nil : !funlang.list&lt;i32&gt;
    %c1 = arith.constant 1 : i32
    %lst = funlang.cons %c1, %nil : !funlang.list&lt;i32&gt;

    // Create [1, 2, 3]
    %c3 = arith.constant 3 : i32
    %lst1 = funlang.cons %c3, %nil : !funlang.list&lt;i32&gt;
    %c2 = arith.constant 2 : i32
    %lst2 = funlang.cons %c2, %lst1 : !funlang.list&lt;i32&gt;
    %lst3 = funlang.cons %c1, %lst2 : !funlang.list&lt;i32&gt;
    ```

    Lowering:
    ```
    %lst = funlang.cons %head, %tail : !funlang.list&lt;i32&gt;

    // Lowers to:
    // 1. Allocate cons cell
    %size = arith.constant 16 : i64  // sizeof(i32) + sizeof(struct)
    %cell = llvm.call @GC_malloc(%size) : (i64) -&gt; !llvm.ptr

    // 2. Store head
    %head_ptr = llvm.getelementptr %cell[0] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %head, %head_ptr : i32, !llvm.ptr

    // 3. Store tail
    %tail_ptr = llvm.getelementptr %cell[1] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %tail, %tail_ptr : !llvm.struct&lt;(i32, ptr)&gt;, !llvm.ptr

    // 4. Build tagged union
    %tag = arith.constant 1 : i32
    %undef = llvm.mlir.undef : !llvm.struct&lt;(i32, ptr)&gt;
    %s1 = llvm.insertvalue %tag, %undef[0] : !llvm.struct&lt;(i32, ptr)&gt;
    %lst = llvm.insertvalue %cell, %s1[1] : !llvm.struct&lt;(i32, ptr)&gt;
    ```

    Note: No Pure trait (allocates memory via GC_malloc)
  }];

  let arguments = (ins AnyType:$head, FunLang_ListType:$tail);

  let results = (outs FunLang_ListType:$result);

  let assemblyFormat = "$head `,` $tail attr-dict `:` type($result)";

  let builders = [
    OpBuilder&lt;(ins "Value":$head, "Value":$tail), [{
      auto tailType = tail.getType().cast&lt;funlang::FunLangListType&gt;();
      $_state.addOperands({head, tail});
      $_state.addTypes(tailType);
    }]&gt;
  ];

  let extraClassDeclaration = [{
    /// Get element type (T from !funlang.list&lt;T&gt;)
    Type getElementType() {
      return getResult().getType().cast&lt;FunLangListType&gt;().getElementType();
    }
  }];
}
</code></pre>
<p><strong>핵심 요소:</strong></p>
<ol>
<li>
<p><strong>No Pure trait</strong>: GC_malloc 호출로 side effect 발생</p>
<ul>
<li>CSE 불가능 (각 cons는 새로운 cell 할당)</li>
<li>Dead code elimination 신중하게 (allocation 유지 필요할 수도)</li>
</ul>
</li>
<li>
<p><strong>Arguments</strong>: <code>head</code> (element), <code>tail</code> (list)</p>
<ul>
<li><code>head</code>: AnyType (element type은 tail과 검증)</li>
<li><code>tail</code>: FunLang_ListType</li>
</ul>
</li>
<li>
<p><strong>Result type</strong>: Same as <code>tail</code> type</p>
<ul>
<li>Builder가 자동으로 tail의 타입을 result에 사용</li>
</ul>
</li>
<li>
<p><strong>Assembly format</strong>: <code>funlang.cons %head, %tail : !funlang.list&lt;i32&gt;</code></p>
</li>
<li>
<p><strong>extraClassDeclaration</strong>: <code>getElementType()</code> 헬퍼 메서드</p>
</li>
</ol>
<h3 id="type-constraints-and-verification"><a class="header" href="#type-constraints-and-verification">Type Constraints and Verification</a></h3>
<pre><code class="language-cpp">LogicalResult ConsOp::verify() {
  // Tail must be !funlang.list&lt;T&gt;
  auto tailType = getTail().getType().dyn_cast&lt;FunLangListType&gt;();
  if (!tailType) {
    return emitOpError("tail must be !funlang.list type");
  }

  // Result must be same type as tail
  auto resultType = getResult().getType().dyn_cast&lt;FunLangListType&gt;();
  if (!resultType || resultType != tailType) {
    return emitOpError("result type must match tail type");
  }

  // Head type must match element type of list
  Type headType = getHead().getType();
  Type elemType = tailType.getElementType();
  if (headType != elemType) {
    return emitOpError("head type (")
        &lt;&lt; headType &lt;&lt; ") must match list element type (" &lt;&lt; elemType &lt;&lt; ")";
  }

  return success();
}
</code></pre>
<p><strong>검증하는 제약조건:</strong></p>
<ol>
<li>Tail은 <code>!funlang.list&lt;T&gt;</code> 타입이어야 함</li>
<li>Result 타입은 tail 타입과 동일해야 함</li>
<li>Head 타입은 list의 element 타입과 일치해야 함</li>
</ol>
<p><strong>예제: Type errors</strong></p>
<pre><code class="language-mlir">// Error: head type mismatch
%nil = funlang.nil : !funlang.list&lt;i32&gt;
%f = arith.constant 3.14 : f64
%bad = funlang.cons %f, %nil : !funlang.list&lt;i32&gt;
// Error: head type (f64) must match list element type (i32)

// Error: tail not a list
%x = arith.constant 42 : i32
%bad = funlang.cons %x, %x : !funlang.list&lt;i32&gt;
// Error: tail must be !funlang.list type

// Error: result type mismatch
%nil_int = funlang.nil : !funlang.list&lt;i32&gt;
%x = arith.constant 42 : i32
%bad = funlang.cons %x, %nil_int : !funlang.list&lt;f64&gt;
// Error: result type must match tail type
</code></pre>
<h3 id="c-api-shim-2"><a class="header" href="#c-api-shim-2">C API Shim</a></h3>
<p><strong>파일: <code>mlir/lib/CAPI/Dialect/FunLang.cpp</code></strong></p>
<pre><code class="language-cpp">//===----------------------------------------------------------------------===//
// ConsOp
//===----------------------------------------------------------------------===//

MlirOperation mlirFunLangConsOpCreate(
    MlirLocation loc,
    MlirValue head,
    MlirValue tail) {
  mlir::OpBuilder builder(unwrap(loc)-&gt;getContext());
  builder.setInsertionPointToStart(/* appropriate block */);

  auto op = builder.create&lt;funlang::ConsOp&gt;(
      unwrap(loc),
      unwrap(head),
      unwrap(tail));

  return wrap(op.getOperation());
}
</code></pre>
<p><strong>헤더 파일: <code>mlir/include/mlir-c/Dialect/FunLang.h</code></strong></p>
<pre><code class="language-c">//===----------------------------------------------------------------------===//
// ConsOp
//===----------------------------------------------------------------------===//

/// Create funlang.cons operation
/// Arguments:
///   - head: Element to prepend
///   - tail: Existing list
/// Returns MlirOperation (use mlirOperationGetResult to get value)
MLIR_CAPI_EXPORTED MlirOperation
mlirFunLangConsOpCreate(
    MlirLocation loc,
    MlirValue head,
    MlirValue tail);
</code></pre>
<h3 id="f-bindings-2"><a class="header" href="#f-bindings-2">F# Bindings</a></h3>
<p><strong>파일: <code>FunLang.Compiler/MlirBindings.fs</code></strong></p>
<pre><code class="language-fsharp">module FunLangBindings =
    // ... (previous bindings) ...

    //==========================================================================
    // Operations - ConsOp
    //==========================================================================

    [&lt;DllImport("MLIR-FunLang-CAPI", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirFunLangConsOpCreate(
        MlirLocation loc,
        MlirValue head,
        MlirValue tail)
</code></pre>
<p><strong>FunLangDialect wrapper:</strong></p>
<pre><code class="language-fsharp">type FunLangDialect(ctx: MlirContext) =
    // ... (previous members) ...

    /// Create funlang.cons operation
    member this.CreateConsOp(loc: MlirLocation, head: MlirValue, tail: MlirValue) : MlirOperation =
        FunLangBindings.mlirFunLangConsOpCreate(loc, head, tail)

    /// Create funlang.cons and return the result value
    member this.CreateCons(loc: MlirLocation, head: MlirValue, tail: MlirValue) : MlirValue =
        let op = this.CreateConsOp(loc, head, tail)
        MlirHelpers.GetOperationResult(op, 0)
</code></pre>
<p><strong>OpBuilder extension:</strong></p>
<pre><code class="language-fsharp">type OpBuilder with
    // ... (previous members) ...

    /// Create funlang.cons operation
    member this.CreateConsOp(head: MlirValue, tail: MlirValue) : MlirOperation =
        let funlang = FunLangDialect(this.Context)
        funlang.CreateConsOp(this.UnknownLoc, head, tail)

    /// Create funlang.cons and return result value
    member this.CreateCons(head: MlirValue, tail: MlirValue) : MlirValue =
        let funlang = FunLangDialect(this.Context)
        funlang.CreateCons(this.UnknownLoc, head, tail)
</code></pre>
<h3 id="f-usage-examples-2"><a class="header" href="#f-usage-examples-2">F# Usage Examples</a></h3>
<pre><code class="language-fsharp">// Example 1: Build single-element list [42]
let builder = OpBuilder(ctx)
let i32Type = builder.IntegerType(32)

let nil = builder.CreateNil(i32Type)
let c42 = builder.CreateConstantInt(42, 32)
let lst = builder.CreateCons(c42, nil)
// %lst = funlang.cons %c42, %nil : !funlang.list&lt;i32&gt;

// Example 2: Build list [1, 2, 3]
let nil = builder.CreateNil(i32Type)
let c1 = builder.CreateConstantInt(1, 32)
let c2 = builder.CreateConstantInt(2, 32)
let c3 = builder.CreateConstantInt(3, 32)

// Build from right to left
let lst1 = builder.CreateCons(c3, nil)    // [3]
let lst2 = builder.CreateCons(c2, lst1)   // [2, 3]
let lst3 = builder.CreateCons(c1, lst2)   // [1, 2, 3]

// Example 3: Build list from F# list
let buildList (builder: OpBuilder) (elements: MlirValue list) (elemType: MlirType) =
    let nil = builder.CreateNil(elemType)
    List.foldBack (fun elem acc -&gt;
        builder.CreateCons(elem, acc)
    ) elements nil

let values = [c1; c2; c3]
let lst = buildList builder values i32Type
// funlang.cons %c1, (funlang.cons %c2, (funlang.cons %c3, %nil))

// Example 4: Type inference from tail
let tail = (* existing !funlang.list&lt;i32&gt; *)
let head = builder.CreateConstantInt(99, 32)
let extended = builder.CreateCons(head, tail)
// Result type inferred from tail type
</code></pre>
<h3 id="memory-allocation-details"><a class="header" href="#memory-allocation-details">Memory Allocation Details</a></h3>
<p><strong>Cons cell size calculation:</strong></p>
<pre><code>ConsCell&lt;T&gt; = struct {
    T element;
    TaggedUnion tail;  // struct { i32 tag; ptr data }
}

Size = sizeof(T) + sizeof(i32) + sizeof(ptr)

Examples:
- i32: 4 + 4 + 8 = 16 bytes
- f64: 8 + 4 + 8 = 20 bytes (alignment → 24 bytes)
- !funlang.closure (ptr): 8 + 4 + 8 = 20 bytes (alignment → 24 bytes)
</code></pre>
<p><strong>Lowering에서 size 계산:</strong></p>
<pre><code class="language-cpp">// ConsOpLowering::matchAndRewrite
Value ConsOpLowering::calculateCellSize(
    OpBuilder &amp;builder, Location loc, Type elementType) {
  auto &amp;dataLayout = getDataLayout();

  // Get element size
  uint64_t elemSize = dataLayout.getTypeSize(elementType);

  // TaggedUnion size: i32 (4 bytes) + ptr (8 bytes) = 12 bytes
  // But alignment: struct&lt;(i32, ptr)&gt; → 16 bytes on 64-bit
  uint64_t tailSize = 16;  // Hardcoded for simplicity

  uint64_t totalSize = elemSize + tailSize;

  // Align to 8 bytes
  totalSize = (totalSize + 7) &amp; ~7;

  return builder.create&lt;arith::ConstantIntOp&gt;(
      loc, totalSize, builder.getI64Type());
}
</code></pre>
<h3 id="list-construction-patterns"><a class="header" href="#list-construction-patterns">List Construction Patterns</a></h3>
<p><strong>Pattern 1: Build from literal</strong></p>
<pre><code class="language-fsharp">// F# source: [1; 2; 3]
let lst = [1; 2; 3]

// MLIR output:
%nil = funlang.nil : !funlang.list&lt;i32&gt;
%c3 = arith.constant 3 : i32
%lst1 = funlang.cons %c3, %nil : !funlang.list&lt;i32&gt;
%c2 = arith.constant 2 : i32
%lst2 = funlang.cons %c2, %lst1 : !funlang.list&lt;i32&gt;
%c1 = arith.constant 1 : i32
%lst3 = funlang.cons %c1, %lst2 : !funlang.list&lt;i32&gt;
</code></pre>
<p><strong>Pattern 2: Recursive construction</strong></p>
<pre><code class="language-fsharp">// F# source
let rec range n =
    if n &lt;= 0 then []
    else n :: range (n - 1)

// MLIR output (simplified):
func.func @range(%n: i32) -&gt; !funlang.list&lt;i32&gt; {
    %zero = arith.constant 0 : i32
    %cond = arith.cmpi sle, %n, %zero : i32
    %result = scf.if %cond -&gt; !funlang.list&lt;i32&gt; {
        %nil = funlang.nil : !funlang.list&lt;i32&gt;
        scf.yield %nil : !funlang.list&lt;i32&gt;
    } else {
        %one = arith.constant 1 : i32
        %n_minus_1 = arith.subi %n, %one : i32
        %tail = func.call @range(%n_minus_1) : (i32) -&gt; !funlang.list&lt;i32&gt;
        %cons = funlang.cons %n, %tail : !funlang.list&lt;i32&gt;
        scf.yield %cons : !funlang.list&lt;i32&gt;
    }
    func.return %result : !funlang.list&lt;i32&gt;
}
</code></pre>
<p><strong>Pattern 3: List transformation (map)</strong></p>
<pre><code class="language-fsharp">// F# source
let rec map f lst =
    match lst with
    | [] -&gt; []
    | head :: tail -&gt; f head :: map f tail

// MLIR output (with funlang.match - Chapter 19):
func.func @map(
    %f: !funlang.closure,
    %lst: !funlang.list&lt;i32&gt;
) -&gt; !funlang.list&lt;i32&gt; {
    %result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; !funlang.list&lt;i32&gt; {
      ^nil:
        %nil = funlang.nil : !funlang.list&lt;i32&gt;
        funlang.yield %nil : !funlang.list&lt;i32&gt;
      ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
        %new_head = funlang.apply %f(%head) : (i32) -&gt; i32
        %new_tail = func.call @map(%f, %tail)
            : (!funlang.closure, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;
        %new_cons = funlang.cons %new_head, %new_tail : !funlang.list&lt;i32&gt;
        funlang.yield %new_cons : !funlang.list&lt;i32&gt;
    }
    func.return %result : !funlang.list&lt;i32&gt;
}
</code></pre>
<h3 id="summary-funlangcons-operation"><a class="header" href="#summary-funlangcons-operation">Summary: funlang.cons Operation</a></h3>
<p><strong>구현 완료:</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""> TableGen ODS definition (no Pure trait)</li>
<li><input disabled="" type="checkbox" checked=""> Arguments: head (element), tail (list)</li>
<li><input disabled="" type="checkbox" checked=""> Type verification: head type matches element type</li>
<li><input disabled="" type="checkbox" checked=""> C API shim: <code>mlirFunLangConsOpCreate</code></li>
<li><input disabled="" type="checkbox" checked=""> F# bindings: <code>CreateConsOp</code>, <code>CreateCons</code></li>
<li><input disabled="" type="checkbox" checked=""> OpBuilder extension for convenient usage</li>
</ul>
<p><strong>특징:</strong></p>
<ul>
<li>GC allocation for cons cells</li>
<li>Type-safe: head type must match list element type</li>
<li>Result type inferred from tail type</li>
</ul>
<p><strong>다음 Part:</strong></p>
<ul>
<li>TypeConverter for <code>!funlang.list&lt;T&gt;</code></li>
<li>NilOpLowering pattern</li>
<li>ConsOpLowering pattern</li>
<li>Complete lowering pass integration</li>
</ul>
<hr>
<h2 id="튜플-타입과-연산-tuple-type-and-operations"><a class="header" href="#튜플-타입과-연산-tuple-type-and-operations">튜플 타입과 연산 (Tuple Type and Operations)</a></h2>
<p>리스트와 함께 함수형 프로그래밍에서 필수적인 또 다른 데이터 구조가 있다: **튜플(tuple)**이다. 리스트가 같은 타입의 여러 원소를 가변 개수로 담는다면, 튜플은 서로 다른 타입의 원소들을 고정된 개수로 묶는다.</p>
<h3 id="튜플-vs-리스트-근본적인-차이"><a class="header" href="#튜플-vs-리스트-근본적인-차이">튜플 vs 리스트: 근본적인 차이</a></h3>
<p><strong>List:</strong></p>
<ul>
<li>가변 개수 (0개부터 N개까지)</li>
<li>동질적 (모든 원소가 같은 타입)</li>
<li>런타임에 태그로 Nil/Cons 구분 필요</li>
<li>패턴 매칭에서 여러 case 필요</li>
</ul>
<pre><code class="language-fsharp">// 리스트: 가변 길이, 같은 타입
let numbers: int list = [1; 2; 3; 4; 5]
let empty: int list = []
let singleton: int list = [42]
</code></pre>
<p><strong>Tuple:</strong></p>
<ul>
<li>고정 개수 (컴파일 타임에 결정)</li>
<li>이질적 (원소마다 다른 타입 가능)</li>
<li>태그 불필요 (항상 같은 구조)</li>
<li>패턴 매칭에서 단일 case (항상 매칭)</li>
</ul>
<pre><code class="language-fsharp">// 튜플: 고정 길이, 다른 타입 가능
let pair: int * string = (42, "hello")
let triple: int * float * bool = (1, 3.14, true)
let person: string * int = ("Alice", 30)
</code></pre>
<p><strong>메모리 표현의 차이:</strong></p>
<pre><code>List [1, 2, 3] (가변, 태그 필요):
┌─────────┬─────────┐     ┌─────────┬─────────┐     ┌─────────┬─────────┐     ┌─────────┬─────────┐
│ tag=1   │ ptr  ───────► │ head=1  │ tail ────────► │ head=2  │ tail ────────► │ head=3  │ tail=NULL │
│ (Cons)  │         │     │         │         │     │         │         │     │         │         │
└─────────┴─────────┘     └─────────┴─────────┘     └─────────┴─────────┘     └─────────┴─────────┘

Tuple (1, "hello") (고정, 태그 불필요):
┌─────────┬─────────┐
│  int=1  │ ptr ────────► "hello"
│ (slot0) │ (slot1) │
└─────────┴─────────┘
</code></pre>
<h3 id="튜플-타입-설계-tuple-type-design"><a class="header" href="#튜플-타입-설계-tuple-type-design">튜플 타입 설계 (Tuple Type Design)</a></h3>
<p>FunLang에서 튜플 타입의 문법:</p>
<pre><code class="language-mlir">// 2-tuple (pair)
!funlang.tuple&lt;i32, f64&gt;

// 3-tuple (triple)
!funlang.tuple&lt;i32, string, bool&gt;

// Nested tuple
!funlang.tuple&lt;!funlang.tuple&lt;i32, i32&gt;, f64&gt;

// Tuple of lists
!funlang.tuple&lt;!funlang.list&lt;i32&gt;, !funlang.list&lt;f64&gt;&gt;
</code></pre>
<p><strong>타입 시스템에서의 특징:</strong></p>
<ol>
<li><strong>Arity가 타입에 인코딩</strong>: <code>!funlang.tuple&lt;i32&gt;</code> (1-tuple)과 <code>!funlang.tuple&lt;i32, i32&gt;</code> (2-tuple)은 다른 타입</li>
<li><strong>원소 타입 순서가 중요</strong>: <code>!funlang.tuple&lt;i32, f64&gt;</code> ≠ <code>!funlang.tuple&lt;f64, i32&gt;</code></li>
<li><strong>Unit type</strong>: 0-tuple <code>!funlang.tuple&lt;&gt;</code>은 unit type으로 사용 가능</li>
</ol>
<p><strong>LLVM으로의 lowering:</strong></p>
<pre><code class="language-mlir">// FunLang tuple type
!funlang.tuple&lt;i32, f64&gt;

// LLVM struct type (no tag needed!)
!llvm.struct&lt;(i32, f64)&gt;
</code></pre>
<p>리스트와 달리:</p>
<ul>
<li><strong>태그 필요 없음</strong>: 튜플은 항상 같은 구조</li>
<li><strong>포인터 indirection 없음</strong>: 값 자체를 struct에 저장 (작은 튜플의 경우)</li>
<li><strong>스택 할당 가능</strong>: escape하지 않으면 힙 할당 불필요</li>
</ul>
<h3 id="tablegen-정의-tablegen-definition"><a class="header" href="#tablegen-정의-tablegen-definition">TableGen 정의 (TableGen Definition)</a></h3>
<p><strong>파일: <code>mlir/include/Dialect/FunLang/FunLangTypes.td</code></strong></p>
<pre><code class="language-tablegen">//===----------------------------------------------------------------------===//
// Tuple Type
//===----------------------------------------------------------------------===//

def FunLang_TupleType : FunLang_Type&lt;"Tuple", "tuple"&gt; {
  let summary = "FunLang tuple type";
  let description = [{
    A fixed-size product type with heterogeneous elements.
    Unlike lists, tuples have a known arity at compile time.

    Examples:
    - `!funlang.tuple&lt;i32, f64&gt;` is a pair of integer and float
    - `!funlang.tuple&lt;i32, i32, i32&gt;` is a triple of integers
    - `!funlang.tuple&lt;&gt;` is the unit type (empty tuple)

    Tuples are lowered to LLVM structs directly, without tags,
    because they always have the same structure (no variants).
  }];

  let parameters = (ins
    ArrayRefParameter&lt;"mlir::Type", "element types"&gt;:$elementTypes
  );

  let assemblyFormat = "`&lt;` $elementTypes `&gt;`";

  let extraClassDeclaration = [{
    /// Get the number of elements in this tuple
    size_t getNumElements() const { return getElementTypes().size(); }

    /// Get the element type at the given index
    mlir::Type getElementType(size_t index) const {
      return getElementTypes()[index];
    }

    /// Check if this is a pair (2-tuple)
    bool isPair() const { return getNumElements() == 2; }

    /// Check if this is a unit type (0-tuple)
    bool isUnit() const { return getNumElements() == 0; }
  }];
}
</code></pre>
<p><strong>핵심 요소 분석:</strong></p>
<ol>
<li>
<p><strong><code>ArrayRefParameter</code></strong>: 가변 개수의 타입 파라미터</p>
<ul>
<li><code>Variadic&lt;Type&gt;</code>이 아닌 <code>ArrayRefParameter&lt;"mlir::Type"&gt;</code></li>
<li>TableGen이 자동으로 storage와 accessor 생성</li>
</ul>
</li>
<li>
<p><strong><code>assemblyFormat</code></strong>: <code>&lt;</code> 원소타입들 <code>&gt;</code></p>
<ul>
<li><code>!funlang.tuple&lt;i32, f64&gt;</code> 형태로 파싱/프린팅</li>
</ul>
</li>
<li>
<p><strong><code>extraClassDeclaration</code></strong>: 유틸리티 메서드</p>
<ul>
<li><code>getNumElements()</code>, <code>getElementType(index)</code> 등</li>
</ul>
</li>
</ol>
<p><strong>생성되는 C++ 코드:</strong></p>
<pre><code class="language-cpp">// Auto-generated from TableGen
class TupleType : public mlir::Type::TypeBase&lt;TupleType,
                                               mlir::Type,
                                               detail::TupleTypeStorage&gt; {
public:
  using Base::Base;

  static TupleType get(mlir::MLIRContext *context,
                       llvm::ArrayRef&lt;mlir::Type&gt; elementTypes);

  llvm::ArrayRef&lt;mlir::Type&gt; getElementTypes() const;
  size_t getNumElements() const { return getElementTypes().size(); }
  mlir::Type getElementType(size_t index) const {
    return getElementTypes()[index];
  }
  bool isPair() const { return getNumElements() == 2; }
  bool isUnit() const { return getNumElements() == 0; }
};
</code></pre>
<h3 id="funlangmake_tuple-연산-make_tuple-operation"><a class="header" href="#funlangmake_tuple-연산-make_tuple-operation">funlang.make_tuple 연산 (make_tuple Operation)</a></h3>
<p><strong>파일: <code>mlir/include/Dialect/FunLang/FunLangOps.td</code></strong></p>
<pre><code class="language-tablegen">//===----------------------------------------------------------------------===//
// make_tuple Operation
//===----------------------------------------------------------------------===//

def FunLang_MakeTupleOp : FunLang_Op&lt;"make_tuple", [Pure]&gt; {
  let summary = "Create a tuple from values";
  let description = [{
    Constructs a tuple from the given element values.
    The result type must match the types of the input elements.

    Example:
    ```mlir
    %c1 = arith.constant 1 : i32
    %c2 = arith.constant 3.14 : f64
    %pair = funlang.make_tuple(%c1, %c2) : !funlang.tuple&lt;i32, f64&gt;
    ```

    The operation is marked Pure because it has no side effects.
    This enables CSE (Common Subexpression Elimination) optimization.
  }];

  let arguments = (ins
    Variadic&lt;AnyType&gt;:$elements
  );

  let results = (outs
    FunLang_TupleType:$result
  );

  let assemblyFormat = [{
    `(` $elements `)` attr-dict `:` type($result)
  }];

  let builders = [
    OpBuilder&lt;(ins "mlir::ValueRange":$elements), [{
      // Infer result type from element types
      llvm::SmallVector&lt;mlir::Type&gt; elemTypes;
      for (auto elem : elements)
        elemTypes.push_back(elem.getType());

      auto tupleType = TupleType::get($_builder.getContext(), elemTypes);
      build($_builder, $_state, tupleType, elements);
    }]&gt;
  ];

  let hasVerifier = 1;
}
</code></pre>
<p><strong>핵심 요소 분석:</strong></p>
<ol>
<li>
<p><strong><code>Variadic&lt;AnyType&gt;</code></strong>: 0개 이상의 임의 타입 operands</p>
<ul>
<li><code>make_tuple()</code> (unit), <code>make_tuple(%a)</code> (singleton), <code>make_tuple(%a, %b)</code> (pair) 모두 가능</li>
</ul>
</li>
<li>
<p><strong><code>Pure</code> trait</strong>: 순수 함수</p>
<ul>
<li>부작용 없음, 같은 입력 → 같은 출력</li>
<li>CSE 최적화 가능: 동일한 make_tuple 호출 합치기</li>
</ul>
</li>
<li>
<p><strong>Custom builder</strong>: 타입 추론</p>
<ul>
<li>element 타입들로부터 결과 tuple 타입 자동 추론</li>
<li>사용자가 명시적으로 타입을 지정할 필요 없음</li>
</ul>
</li>
<li>
<p><strong>Verifier</strong>: 타입 일관성 검증</p>
<ul>
<li>element 개수와 tuple 타입의 arity 일치</li>
<li>각 element 타입과 tuple의 대응 위치 타입 일치</li>
</ul>
</li>
</ol>
<p><strong>Verifier 구현:</strong></p>
<pre><code class="language-cpp">// FunLangOps.cpp
LogicalResult MakeTupleOp::verify() {
  auto tupleType = getType().cast&lt;TupleType&gt;();
  auto elements = getElements();

  // Check element count matches tuple arity
  if (elements.size() != tupleType.getNumElements()) {
    return emitOpError() &lt;&lt; "expected " &lt;&lt; tupleType.getNumElements()
                         &lt;&lt; " elements but got " &lt;&lt; elements.size();
  }

  // Check each element type matches
  for (size_t i = 0; i &lt; elements.size(); ++i) {
    Type expectedType = tupleType.getElementType(i);
    Type actualType = elements[i].getType();
    if (expectedType != actualType) {
      return emitOpError() &lt;&lt; "element " &lt;&lt; i &lt;&lt; " type mismatch: expected "
                           &lt;&lt; expectedType &lt;&lt; " but got " &lt;&lt; actualType;
    }
  }

  return success();
}
</code></pre>
<p><strong>사용 예제:</strong></p>
<pre><code class="language-mlir">// Empty tuple (unit)
%unit = funlang.make_tuple() : !funlang.tuple&lt;&gt;

// Pair of int and float
%c1 = arith.constant 42 : i32
%c2 = arith.constant 3.14 : f64
%pair = funlang.make_tuple(%c1, %c2) : !funlang.tuple&lt;i32, f64&gt;

// Triple of ints
%a = arith.constant 1 : i32
%b = arith.constant 2 : i32
%c = arith.constant 3 : i32
%triple = funlang.make_tuple(%a, %b, %c) : !funlang.tuple&lt;i32, i32, i32&gt;

// Nested tuple
%inner = funlang.make_tuple(%a, %b) : !funlang.tuple&lt;i32, i32&gt;
%outer = funlang.make_tuple(%inner, %c2) : !funlang.tuple&lt;!funlang.tuple&lt;i32, i32&gt;, f64&gt;

// Tuple containing list
%list = funlang.cons %c1, %nil : !funlang.list&lt;i32&gt;
%mixed = funlang.make_tuple(%list, %c2) : !funlang.tuple&lt;!funlang.list&lt;i32&gt;, f64&gt;
</code></pre>
<h3 id="튜플-로우어링-tuple-lowering"><a class="header" href="#튜플-로우어링-tuple-lowering">튜플 로우어링 (Tuple Lowering)</a></h3>
<p>튜플의 lowering은 리스트보다 훨씬 간단하다. 태그 없이 직접 LLVM struct로 변환한다.</p>
<p><strong>TypeConverter 확장:</strong></p>
<pre><code class="language-cpp">// FunLangTypeConverter에 추가
addConversion([](funlang::TupleType type) {
  auto ctx = type.getContext();

  // Convert each element type
  llvm::SmallVector&lt;mlir::Type&gt; llvmTypes;
  for (auto elemType : type.getElementTypes()) {
    // Recursively convert element types
    // (handles nested tuples, lists, etc.)
    auto convertedType = convertType(elemType);
    llvmTypes.push_back(convertedType);
  }

  // Create LLVM struct type
  return LLVM::LLVMStructType::getLiteral(ctx, llvmTypes);
});
</code></pre>
<p><strong>변환 예제:</strong></p>
<pre><code class="language-mlir">// Before: FunLang types
!funlang.tuple&lt;i32, f64&gt;
!funlang.tuple&lt;i32, i32, i32&gt;
!funlang.tuple&lt;!funlang.list&lt;i32&gt;, f64&gt;

// After: LLVM types
!llvm.struct&lt;(i32, f64)&gt;
!llvm.struct&lt;(i32, i32, i32)&gt;
!llvm.struct&lt;(!llvm.struct&lt;(i32, ptr)&gt;, f64)&gt;  // list becomes tagged union struct
</code></pre>
<p><strong>MakeTupleOpLowering 패턴:</strong></p>
<pre><code class="language-cpp">class MakeTupleOpLowering : public OpConversionPattern&lt;funlang::MakeTupleOp&gt; {
public:
  using OpConversionPattern::OpConversionPattern;

  LogicalResult matchAndRewrite(funlang::MakeTupleOp op,
                                 OpAdaptor adaptor,
                                 ConversionPatternRewriter &amp;rewriter) const override {
    Location loc = op.getLoc();
    auto elements = adaptor.getElements();  // Already converted by TypeConverter

    // Get the converted result type (LLVM struct)
    auto resultType = getTypeConverter()-&gt;convertType(op.getType());
    auto structType = resultType.cast&lt;LLVM::LLVMStructType&gt;();

    // Start with undef struct
    Value structVal = rewriter.create&lt;LLVM::UndefOp&gt;(loc, structType);

    // Insert each element at its position
    for (size_t i = 0; i &lt; elements.size(); ++i) {
      structVal = rewriter.create&lt;LLVM::InsertValueOp&gt;(
          loc, structVal, elements[i], i);
    }

    // Replace make_tuple with the constructed struct
    rewriter.replaceOp(op, structVal);
    return success();
  }
};
</code></pre>
<p><strong>Lowering 과정 시각화:</strong></p>
<pre><code class="language-mlir">// Before lowering
%c1 = arith.constant 42 : i32
%c2 = arith.constant 3.14 : f64
%pair = funlang.make_tuple(%c1, %c2) : !funlang.tuple&lt;i32, f64&gt;

// After lowering
%c1 = arith.constant 42 : i32
%c2 = arith.constant 3.14 : f64
%0 = llvm.mlir.undef : !llvm.struct&lt;(i32, f64)&gt;
%1 = llvm.insertvalue %c1, %0[0] : !llvm.struct&lt;(i32, f64)&gt;
%pair = llvm.insertvalue %c2, %1[1] : !llvm.struct&lt;(i32, f64)&gt;
</code></pre>
<p><strong>리스트 vs 튜플 lowering 비교:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>구분</th><th>List</th><th>Tuple</th></tr>
</thead>
<tbody>
<tr><td>태그</td><td>필요 (Nil=0, Cons=1)</td><td>불필요</td></tr>
<tr><td>힙 할당</td><td>필요 (GC_malloc)</td><td>불필요 (값 의미론)</td></tr>
<tr><td>간접 참조</td><td>있음 (ptr → data)</td><td>없음 (직접 저장)</td></tr>
<tr><td>Lowering 복잡도</td><td>높음</td><td>낮음</td></tr>
</tbody>
</table>
</div>
<h3 id="c-api-및-f-바인딩-c-api-and-f-bindings"><a class="header" href="#c-api-및-f-바인딩-c-api-and-f-bindings">C API 및 F# 바인딩 (C API and F# Bindings)</a></h3>
<p><strong>C API Shim:</strong></p>
<pre><code class="language-cpp">// mlir/lib/Dialect/FunLang/CAPI/FunLangCAPI.cpp

//===----------------------------------------------------------------------===//
// Tuple Type
//===----------------------------------------------------------------------===//

extern "C" MlirType funlangTupleTypeGet(MlirContext ctx,
                                        MlirType *elementTypes,
                                        intptr_t numElements) {
  llvm::SmallVector&lt;mlir::Type&gt; types;
  for (intptr_t i = 0; i &lt; numElements; ++i) {
    types.push_back(unwrap(elementTypes[i]));
  }
  return wrap(funlang::TupleType::get(unwrap(ctx), types));
}

extern "C" intptr_t funlangTupleTypeGetNumElements(MlirType type) {
  return unwrap(type).cast&lt;funlang::TupleType&gt;().getNumElements();
}

extern "C" MlirType funlangTupleTypeGetElementType(MlirType type, intptr_t index) {
  return wrap(unwrap(type).cast&lt;funlang::TupleType&gt;().getElementType(index));
}

extern "C" bool funlangTypeIsATupleType(MlirType type) {
  return unwrap(type).isa&lt;funlang::TupleType&gt;();
}

//===----------------------------------------------------------------------===//
// make_tuple Operation
//===----------------------------------------------------------------------===//

extern "C" MlirOperation funlangMakeTupleOpCreate(MlirLocation loc,
                                                   MlirType resultType,
                                                   MlirValue *elements,
                                                   intptr_t numElements,
                                                   MlirBlock block) {
  OpBuilder builder(unwrap(block)-&gt;getParent());
  builder.setInsertionPointToEnd(unwrap(block));

  llvm::SmallVector&lt;mlir::Value&gt; values;
  for (intptr_t i = 0; i &lt; numElements; ++i) {
    values.push_back(unwrap(elements[i]));
  }

  auto tupleType = unwrap(resultType).cast&lt;funlang::TupleType&gt;();
  auto op = builder.create&lt;funlang::MakeTupleOp&gt;(
      unwrap(loc), tupleType, values);
  return wrap(op.getOperation());
}
</code></pre>
<p><strong>F# Bindings:</strong></p>
<pre><code class="language-fsharp">// FunLang.Bindings/FunLangTypes.fs

module FunLangTypes

open System.Runtime.InteropServices

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirType funlangTupleTypeGet(MlirContext ctx, MlirType[] elementTypes, nativeint numElements)

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern nativeint funlangTupleTypeGetNumElements(MlirType type_)

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirType funlangTupleTypeGetElementType(MlirType type_, nativeint index)

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern bool funlangTypeIsATupleType(MlirType type_)

type MLIRTypeExtensions =
    /// Create a tuple type with the given element types
    static member CreateTupleType(ctx: MlirContext, elementTypes: MlirType list) : MlirType =
        let typesArray = elementTypes |&gt; List.toArray
        funlangTupleTypeGet(ctx, typesArray, nativeint typesArray.Length)

    /// Check if a type is a tuple type
    static member IsTupleType(t: MlirType) : bool =
        funlangTypeIsATupleType(t)

    /// Get the number of elements in a tuple type
    static member GetTupleNumElements(t: MlirType) : int =
        int (funlangTupleTypeGetNumElements(t))

    /// Get an element type from a tuple type
    static member GetTupleElementType(t: MlirType, index: int) : MlirType =
        funlangTupleTypeGetElementType(t, nativeint index)
</code></pre>
<pre><code class="language-fsharp">// FunLang.Bindings/FunLangOps.fs

module FunLangOps

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirOperation funlangMakeTupleOpCreate(
    MlirLocation loc,
    MlirType resultType,
    MlirValue[] elements,
    nativeint numElements,
    MlirBlock block)

type OpBuilderExtensions =
    /// Create a make_tuple operation
    member this.CreateMakeTupleOp(loc: MlirLocation, elements: MlirValue list) : MlirOperation =
        // Infer tuple type from elements
        let elementTypes = elements |&gt; List.map (fun e -&gt; e.GetType())
        let tupleType = MLIRTypeExtensions.CreateTupleType(this.Context, elementTypes)
        let elemArray = elements |&gt; List.toArray
        funlangMakeTupleOpCreate(loc, tupleType, elemArray, nativeint elemArray.Length, this.CurrentBlock)

    /// Create a tuple and return its value
    member this.CreateMakeTuple(loc: MlirLocation, elements: MlirValue list) : MlirValue =
        let op = this.CreateMakeTupleOp(loc, elements)
        op.GetResult(0)

    /// Create a pair (2-tuple)
    member this.CreatePair(loc: MlirLocation, first: MlirValue, second: MlirValue) : MlirValue =
        this.CreateMakeTuple(loc, [first; second])
</code></pre>
<p><strong>사용 예제:</strong></p>
<pre><code class="language-fsharp">// F# code using the bindings
let createPointTuple (builder: OpBuilder) (x: MlirValue) (y: MlirValue) =
    let loc = builder.GetUnknownLoc()

    // Create pair using convenience method
    let point = builder.CreatePair(loc, x, y)

    // Or explicitly with CreateMakeTuple
    let point' = builder.CreateMakeTuple(loc, [x; y])

    point

let createMixedTuple (builder: OpBuilder) (intVal: MlirValue) (floatVal: MlirValue) (listVal: MlirValue) =
    let loc = builder.GetUnknownLoc()

    // 3-tuple with mixed types
    let mixed = builder.CreateMakeTuple(loc, [intVal; floatVal; listVal])

    // Check the type
    let tupleType = mixed.GetType()
    assert (MLIRTypeExtensions.IsTupleType(tupleType))
    assert (MLIRTypeExtensions.GetTupleNumElements(tupleType) = 3)

    mixed
</code></pre>
<h3 id="summary-튜플-타입과-연산"><a class="header" href="#summary-튜플-타입과-연산">Summary: 튜플 타입과 연산</a></h3>
<p><strong>구현 완료:</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""> <code>!funlang.tuple&lt;T1, T2, ...&gt;</code> 타입 정의 (TableGen)</li>
<li><input disabled="" type="checkbox" checked=""> ArrayRefParameter로 가변 개수 타입 파라미터</li>
<li><input disabled="" type="checkbox" checked=""> <code>funlang.make_tuple</code> 연산 정의</li>
<li><input disabled="" type="checkbox" checked=""> Pure trait (CSE 최적화 가능)</li>
<li><input disabled="" type="checkbox" checked=""> TypeConverter에 튜플 → LLVM struct 변환 추가</li>
<li><input disabled="" type="checkbox" checked=""> MakeTupleOpLowering 패턴</li>
<li><input disabled="" type="checkbox" checked=""> C API shim 함수</li>
<li><input disabled="" type="checkbox" checked=""> F# bindings</li>
</ul>
<p><strong>튜플의 특징:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>특성</th><th>리스트</th><th>튜플</th></tr>
</thead>
<tbody>
<tr><td>Arity</td><td>가변</td><td>고정</td></tr>
<tr><td>원소 타입</td><td>동질적 (T)</td><td>이질적 (T1, T2, …)</td></tr>
<tr><td>런타임 태그</td><td>필요</td><td>불필요</td></tr>
<tr><td>메모리 할당</td><td>힙 (GC)</td><td>스택/인라인 가능</td></tr>
<tr><td>패턴 매칭 case</td><td>다중 (Nil/Cons)</td><td>단일 (항상 매칭)</td></tr>
<tr><td>Lowering 대상</td><td><code>!llvm.struct&lt;(i32, ptr)&gt;</code></td><td><code>!llvm.struct&lt;(T1, T2, ...)&gt;</code></td></tr>
</tbody>
</table>
</div>
<p><strong>다음:</strong></p>
<ul>
<li>Chapter 19에서 튜플 패턴 매칭 구현</li>
<li>extractvalue로 튜플 원소 추출</li>
<li>중첩 패턴 (튜플 + 리스트 조합)</li>
</ul>
<hr>
<h2 id="typeconverter-for-list-types"><a class="header" href="#typeconverter-for-list-types">TypeConverter for List Types</a></h2>
<p>Chapter 16에서 우리는 <strong>TypeConverter</strong>를 배웠다. FunLang types를 LLVM types로 변환하는 규칙을 정의한다.</p>
<h3 id="chapter-16-복습-typeconverter란"><a class="header" href="#chapter-16-복습-typeconverter란">Chapter 16 복습: TypeConverter란?</a></h3>
<p><strong>TypeConverter의 역할:</strong></p>
<pre><code class="language-cpp">// Type conversion rules
!funlang.closure → !llvm.ptr
!funlang.list&lt;T&gt; → !llvm.struct&lt;(i32, ptr)&gt;
i32 → i32 (identity)
</code></pre>
<p><strong>왜 필요한가?</strong></p>
<ul>
<li>Operations를 lowering할 때 operand/result types도 변환해야 함</li>
<li>Type consistency 유지 필요</li>
<li>DialectConversion framework가 자동으로 type materialization 수행</li>
</ul>
<h3 id="funlangtypeconverter-확장"><a class="header" href="#funlangtypeconverter-확장">FunLangTypeConverter 확장</a></h3>
<p>Chapter 16에서 closure type 변환만 구현했다. 이제 list type 변환을 추가한다.</p>
<p><strong>파일: <code>mlir/lib/Dialect/FunLang/Transforms/FunLangToLLVM.cpp</code></strong></p>
<pre><code class="language-cpp">class FunLangTypeConverter : public TypeConverter {
public:
  FunLangTypeConverter(MLIRContext *ctx) {
    // Identity conversion for built-in types
    addConversion([](Type type) { return type; });

    // !funlang.closure → !llvm.ptr (Chapter 16)
    addConversion([](funlang::FunLangClosureType type) {
      return LLVM::LLVMPointerType::get(type.getContext());
    });

    // !funlang.list&lt;T&gt; → !llvm.struct&lt;(i32, ptr)&gt; (Chapter 18)
    addConversion([](funlang::FunLangListType type) {
      auto ctx = type.getContext();
      auto i32Type = IntegerType::get(ctx, 32);
      auto ptrType = LLVM::LLVMPointerType::get(ctx);
      return LLVM::LLVMStructType::getLiteral(ctx, {i32Type, ptrType});
    });

    // Materialization for unconverted types
    addSourceMaterialization([&amp;](OpBuilder &amp;builder, Type type,
                                  ValueRange inputs, Location loc) -&gt; Value {
      if (inputs.size() != 1)
        return nullptr;
      return inputs[0];
    });

    addTargetMaterialization([&amp;](OpBuilder &amp;builder, Type type,
                                  ValueRange inputs, Location loc) -&gt; Value {
      if (inputs.size() != 1)
        return nullptr;
      return builder.create&lt;UnrealizedConversionCastOp&gt;(loc, type, inputs)
          .getResult(0);
    });
  }
};
</code></pre>
<p><strong>핵심 포인트:</strong></p>
<ol>
<li>
<p><strong>List type conversion</strong>:</p>
<pre><code class="language-cpp">!funlang.list&lt;T&gt; → !llvm.struct&lt;(i32, ptr)&gt;
</code></pre>
<ul>
<li>Element type <code>T</code>는 버려짐 (runtime representation에 불필요)</li>
<li>Tagged union: tag (i32) + data (ptr)</li>
</ul>
</li>
<li>
<p><strong>Type parameter 무시</strong>:</p>
<pre><code class="language-cpp">!funlang.list&lt;i32&gt; → !llvm.struct&lt;(i32, ptr)&gt;
!funlang.list&lt;f64&gt; → !llvm.struct&lt;(i32, ptr)&gt;
!funlang.list&lt;!funlang.closure&gt; → !llvm.struct&lt;(i32, ptr)&gt;
// 모두 동일한 LLVM type!
</code></pre>
</li>
<li>
<p><strong>Opaque pointer</strong>:</p>
<ul>
<li>Cons cell은 <code>!llvm.ptr</code>로 표현 (opaque)</li>
<li>Element type 정보는 컴파일 타임에만 존재</li>
</ul>
</li>
</ol>
<h3 id="element-type은-어디로"><a class="header" href="#element-type은-어디로">Element Type은 어디로?</a></h3>
<p><strong>질문:</strong> Element type <code>T</code>를 버려도 괜찮은가?</p>
<p><strong>답:</strong> 네, 컴파일 타임에만 필요하기 때문입니다.</p>
<p><strong>Element type의 용도:</strong></p>
<ol>
<li>
<p><strong>Type checking</strong> (compile time):</p>
<pre><code class="language-mlir">%cons = funlang.cons %head, %tail : !funlang.list&lt;i32&gt;
// Verifier checks: %head must be i32
</code></pre>
</li>
<li>
<p><strong>Pattern matching</strong> (compile time):</p>
<pre><code class="language-mlir">%result = funlang.match %list : !funlang.list&lt;i32&gt; -&gt; i32 {
  ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
    // %head type inferred from list element type
}
</code></pre>
</li>
<li>
<p><strong>Lowering</strong> (code generation):</p>
<pre><code class="language-cpp">// ConsOpLowering::matchAndRewrite
Type elemType = consOp.getElementType();  // Get T from !funlang.list&lt;T&gt;
uint64_t elemSize = dataLayout.getTypeSize(elemType);  // Calculate cell size
</code></pre>
</li>
</ol>
<p><strong>Runtime에는 불필요:</strong></p>
<ul>
<li>Runtime에는 tag만 확인 (0=Nil, 1=Cons)</li>
<li>Cons cell에서 데이터 로드할 때 타입 정보 불필요 (opaque pointer)</li>
<li>GC가 타입 정보 없이도 메모리 관리 가능</li>
</ul>
<p><strong>비유:</strong></p>
<pre><code class="language-cpp">// C++ template (compile time)
template&lt;typename T&gt;
struct List {
    int tag;
    void* data;
};

List&lt;int&gt; intList;      // Compile time: T = int
List&lt;double&gt; doubleList;  // Compile time: T = double

// Runtime: sizeof(List&lt;int&gt;) == sizeof(List&lt;double&gt;)
// Runtime에는 T 정보 사라짐 (type erasure)
</code></pre>
<h3 id="recursive-list-types"><a class="header" href="#recursive-list-types">Recursive List Types</a></h3>
<p><strong>중첩 리스트:</strong></p>
<pre><code class="language-mlir">!funlang.list&lt;!funlang.list&lt;i32&gt;&gt;
</code></pre>
<p><strong>TypeConverter가 자동으로 처리:</strong></p>
<pre><code class="language-cpp">// Step 1: Convert inner list
!funlang.list&lt;i32&gt; → !llvm.struct&lt;(i32, ptr)&gt;

// Step 2: Convert outer list (element type = inner list)
!funlang.list&lt;!funlang.list&lt;i32&gt;&gt;
  → !funlang.list&lt;!llvm.struct&lt;(i32, ptr)&gt;&gt;  // Inner converted
  → !llvm.struct&lt;(i32, ptr)&gt;                 // Outer converted

// Result: Same as flat list!
</code></pre>
<p><strong>이것도 type erasure:</strong></p>
<ul>
<li>Cons cell에는 element가 <code>!llvm.struct&lt;(i32, ptr)&gt;</code>로 저장됨</li>
<li>하지만 outer list의 표현은 여전히 <code>!llvm.struct&lt;(i32, ptr)&gt;</code></li>
</ul>
<h3 id="type-materialization"><a class="header" href="#type-materialization">Type Materialization</a></h3>
<p><strong>Materialization이란?</strong></p>
<p>Type conversion 중 intermediate values가 필요할 때 자동으로 생성되는 operations.</p>
<p><strong>예제:</strong></p>
<pre><code class="language-mlir">// Before lowering
func.func @foo(%lst: !funlang.list&lt;i32&gt;) -&gt; i32 {
    // %lst uses: !funlang.list&lt;i32&gt;
}

// After lowering
func.func @foo(%arg: !llvm.struct&lt;(i32, ptr)&gt;) -&gt; i32 {
    // But some operations might still reference old type temporarily
    // Materialization creates cast operations
}
</code></pre>
<p><strong>FunLangTypeConverter에서:</strong></p>
<pre><code class="language-cpp">// Source materialization: LLVM type → FunLang type (usually no-op)
addSourceMaterialization([&amp;](OpBuilder &amp;builder, Type type,
                              ValueRange inputs, Location loc) -&gt; Value {
  if (inputs.size() != 1)
    return nullptr;
  return inputs[0];  // Identity cast
});

// Target materialization: FunLang type → LLVM type
addTargetMaterialization([&amp;](OpBuilder &amp;builder, Type type,
                              ValueRange inputs, Location loc) -&gt; Value {
  if (inputs.size() != 1)
    return nullptr;
  return builder.create&lt;UnrealizedConversionCastOp&gt;(loc, type, inputs)
      .getResult(0);
});
</code></pre>
<p><strong>UnrealizedConversionCastOp:</strong></p>
<ul>
<li>Temporary operation for type conversion</li>
<li>Should be removed by complete conversion</li>
<li>If it remains after pass, conversion failed (verification error)</li>
</ul>
<h3 id="complete-funlangtypeconverter"><a class="header" href="#complete-funlangtypeconverter">Complete FunLangTypeConverter</a></h3>
<p><strong>전체 TypeConverter (Closure + List):</strong></p>
<pre><code class="language-cpp">// mlir/lib/Dialect/FunLang/Transforms/FunLangToLLVM.cpp

class FunLangTypeConverter : public TypeConverter {
public:
  FunLangTypeConverter(MLIRContext *ctx, const DataLayout &amp;dataLayout)
      : dataLayout(dataLayout) {
    // Keep identity conversions (i32, f64, etc.)
    addConversion([](Type type) { return type; });

    // Closure type conversion (Phase 5)
    addConversion([](funlang::FunLangClosureType type) {
      return LLVM::LLVMPointerType::get(type.getContext());
    });

    // List type conversion (Phase 6)
    addConversion([](funlang::FunLangListType type) {
      auto ctx = type.getContext();
      auto i32Type = IntegerType::get(ctx, 32);
      auto ptrType = LLVM::LLVMPointerType::get(ctx);
      // Tagged union: {i32 tag, ptr data}
      return LLVM::LLVMStructType::getLiteral(ctx, {i32Type, ptrType});
    });

    // Function type conversion
    addConversion([this](FunctionType type) {
      return convertFunctionType(type);
    });

    // Materialization hooks
    addSourceMaterialization(materializeSource);
    addTargetMaterialization(materializeTarget);
    addArgumentMaterialization(materializeSource);
  }

  // Get element type from list type (helper for lowering patterns)
  Type getListElementType(funlang::FunLangListType listType) const {
    return listType.getElementType();
  }

  // Calculate cons cell size for element type
  uint64_t getConsCellSize(Type elementType) const {
    uint64_t elemSize = dataLayout.getTypeSize(elementType);
    uint64_t tailSize = 16;  // sizeof(struct&lt;(i32, ptr)&gt;) with alignment
    uint64_t totalSize = elemSize + tailSize;
    // Align to 8 bytes
    return (totalSize + 7) &amp; ~7;
  }

private:
  const DataLayout &amp;dataLayout;

  FunctionType convertFunctionType(FunctionType type) {
    SmallVector&lt;Type&gt; inputs;
    SmallVector&lt;Type&gt; results;

    if (failed(convertTypes(type.getInputs(), inputs)) ||
        failed(convertTypes(type.getResults(), results)))
      return nullptr;

    return FunctionType::get(type.getContext(), inputs, results);
  }

  static Value materializeSource(OpBuilder &amp;builder, Type type,
                                   ValueRange inputs, Location loc) {
    if (inputs.size() != 1)
      return nullptr;
    return inputs[0];
  }

  static Value materializeTarget(OpBuilder &amp;builder, Type type,
                                   ValueRange inputs, Location loc) {
    if (inputs.size() != 1)
      return nullptr;
    return builder.create&lt;UnrealizedConversionCastOp&gt;(loc, type, inputs)
        .getResult(0);
  }
};
</code></pre>
<h3 id="typeconverter-in-lowering-pass"><a class="header" href="#typeconverter-in-lowering-pass">TypeConverter in Lowering Pass</a></h3>
<p><strong>Pass에서 TypeConverter 사용:</strong></p>
<pre><code class="language-cpp">struct FunLangToLLVMPass : public PassWrapper&lt;FunLangToLLVMPass, OperationPass&lt;ModuleOp&gt;&gt; {
  void runOnOperation() override {
    auto module = getOperation();
    auto *ctx = &amp;getContext();

    // Get data layout from module
    auto dataLayout = DataLayout(module);

    // Create type converter
    FunLangTypeConverter typeConverter(ctx, dataLayout);

    // Setup conversion target
    ConversionTarget target(*ctx);
    target.addLegalDialect&lt;LLVM::LLVMDialect, arith::ArithDialect&gt;();
    target.addIllegalDialect&lt;funlang::FunLangDialect&gt;();

    // Populate rewrite patterns
    RewritePatternSet patterns(ctx);
    patterns.add&lt;ClosureOpLowering&gt;(typeConverter, ctx);
    patterns.add&lt;ApplyOpLowering&gt;(typeConverter, ctx);
    patterns.add&lt;NilOpLowering&gt;(typeConverter, ctx);     // New!
    patterns.add&lt;ConsOpLowering&gt;(typeConverter, ctx);    // New!

    // Run conversion
    if (failed(applyPartialConversion(module, target, std::move(patterns)))) {
      signalPassFailure();
    }
  }
};
</code></pre>
<p><strong>ConversionPattern에서 typeConverter 사용:</strong></p>
<pre><code class="language-cpp">class NilOpLowering : public OpConversionPattern&lt;funlang::NilOp&gt; {
public:
  using OpConversionPattern::OpConversionPattern;

  LogicalResult matchAndRewrite(
      funlang::NilOp op,
      OpAdaptor adaptor,
      ConversionPatternRewriter &amp;rewriter) const override {

    auto loc = op.getLoc();

    // Get converted result type: !llvm.struct&lt;(i32, ptr)&gt;
    Type convertedType = typeConverter-&gt;convertType(op.getType());

    // Build Nil representation: {0, null}
    // ...
  }
};
</code></pre>
<h3 id="summary-typeconverter-for-list-types"><a class="header" href="#summary-typeconverter-for-list-types">Summary: TypeConverter for List Types</a></h3>
<p><strong>구현 완료:</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""> <code>!funlang.list&lt;T&gt;</code> → <code>!llvm.struct&lt;(i32, ptr)&gt;</code> conversion</li>
<li><input disabled="" type="checkbox" checked=""> Element type handling (compile-time only)</li>
<li><input disabled="" type="checkbox" checked=""> Recursive list types (automatic handling)</li>
<li><input disabled="" type="checkbox" checked=""> Type materialization hooks</li>
<li><input disabled="" type="checkbox" checked=""> Helper methods for lowering patterns (<code>getConsCellSize</code>)</li>
</ul>
<p><strong>핵심 통찰:</strong></p>
<ul>
<li>Element type은 컴파일 타임 정보만</li>
<li>Runtime representation은 모든 list types에 대해 uniform</li>
<li>Type erasure로 효율적인 메모리 사용</li>
</ul>
<p><strong>다음 섹션:</strong></p>
<ul>
<li>NilOpLowering pattern으로 empty list 생성</li>
</ul>
<hr>
<h2 id="nilop-lowering-pattern"><a class="header" href="#nilop-lowering-pattern">NilOp Lowering Pattern</a></h2>
<p>이제 <code>funlang.nil</code>을 LLVM dialect로 lowering하는 pattern을 작성한다.</p>
<h3 id="lowering-strategy"><a class="header" href="#lowering-strategy">Lowering Strategy</a></h3>
<p><strong>Before:</strong></p>
<pre><code class="language-mlir">%nil = funlang.nil : !funlang.list&lt;i32&gt;
</code></pre>
<p><strong>After:</strong></p>
<pre><code class="language-mlir">// Build struct {0, null}
%tag = arith.constant 0 : i32
%null = llvm.mlir.zero : !llvm.ptr
%undef = llvm.mlir.undef : !llvm.struct&lt;(i32, ptr)&gt;
%s1 = llvm.insertvalue %tag, %undef[0] : !llvm.struct&lt;(i32, ptr)&gt;
%nil = llvm.insertvalue %null, %s1[1] : !llvm.struct&lt;(i32, ptr)&gt;
</code></pre>
<p><strong>핵심 LLVM operations:</strong></p>
<ol>
<li><strong>arith.constant</strong>: Create tag value (0 for Nil)</li>
<li><strong>llvm.mlir.zero</strong>: Create null pointer</li>
<li><strong>llvm.mlir.undef</strong>: Create undefined struct (placeholder)</li>
<li><strong>llvm.insertvalue</strong>: Insert values into struct fields</li>
</ol>
<h3 id="conversionpattern-structure"><a class="header" href="#conversionpattern-structure">ConversionPattern Structure</a></h3>
<pre><code class="language-cpp">class NilOpLowering : public OpConversionPattern&lt;funlang::NilOp&gt; {
public:
  using OpConversionPattern::OpConversionPattern;

  LogicalResult matchAndRewrite(
      funlang::NilOp op,
      OpAdaptor adaptor,
      ConversionPatternRewriter &amp;rewriter) const override;
};
</code></pre>
<p><strong>OpConversionPattern vs OpRewritePattern:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>OpConversionPattern</th><th>OpRewritePattern</th></tr>
</thead>
<tbody>
<tr><td>Framework</td><td>DialectConversion</td><td>Greedy rewriter</td></tr>
<tr><td>Type conversion</td><td>Automatic (TypeConverter)</td><td>Manual</td></tr>
<tr><td>Adaptor</td><td>Yes (adaptor.getOperands())</td><td>No (op.getOperands())</td></tr>
<tr><td>Use case</td><td>Dialect lowering</td><td>Optimization</td></tr>
</tbody>
</table>
</div>
<p><strong>OpAdaptor:</strong></p>
<ul>
<li>Provides <strong>converted operands</strong> (types already converted by TypeConverter)</li>
<li>Example: <code>adaptor.getTail()</code> returns tail with LLVM type, not FunLang type</li>
</ul>
<h3 id="implementation"><a class="header" href="#implementation">Implementation</a></h3>
<p><strong>파일: <code>mlir/lib/Dialect/FunLang/Transforms/FunLangToLLVM.cpp</code></strong></p>
<pre><code class="language-cpp">//===----------------------------------------------------------------------===//
// NilOpLowering
//===----------------------------------------------------------------------===//

class NilOpLowering : public OpConversionPattern&lt;funlang::NilOp&gt; {
public:
  using OpConversionPattern::OpConversionPattern;

  LogicalResult matchAndRewrite(
      funlang::NilOp op,
      OpAdaptor adaptor,
      ConversionPatternRewriter &amp;rewriter) const override {

    auto loc = op.getLoc();
    auto ctx = op.getContext();

    // Get converted result type: !llvm.struct&lt;(i32, ptr)&gt;
    Type convertedType = typeConverter-&gt;convertType(op.getType());
    auto structType = convertedType.cast&lt;LLVM::LLVMStructType&gt;();

    // Step 1: Create tag value (0 for Nil)
    auto i32Type = IntegerType::get(ctx, 32);
    auto tagValue = rewriter.create&lt;arith::ConstantIntOp&gt;(loc, 0, i32Type);

    // Step 2: Create null pointer
    auto ptrType = LLVM::LLVMPointerType::get(ctx);
    auto nullPtr = rewriter.create&lt;LLVM::ZeroOp&gt;(loc, ptrType);

    // Step 3: Create undefined struct (placeholder)
    auto undefStruct = rewriter.create&lt;LLVM::UndefOp&gt;(loc, structType);

    // Step 4: Insert tag into struct at index 0
    auto withTag = rewriter.create&lt;LLVM::InsertValueOp&gt;(
        loc, undefStruct, tagValue, ArrayRef&lt;int64_t&gt;{0});

    // Step 5: Insert null pointer into struct at index 1
    auto nilValue = rewriter.create&lt;LLVM::InsertValueOp&gt;(
        loc, withTag, nullPtr, ArrayRef&lt;int64_t&gt;{1});

    // Replace funlang.nil with constructed struct
    rewriter.replaceOp(op, nilValue.getResult());

    return success();
  }
};
</code></pre>
<h3 id="step-by-step-explanation"><a class="header" href="#step-by-step-explanation">Step-by-Step Explanation</a></h3>
<p><strong>Step 1: Tag value (0)</strong></p>
<pre><code class="language-cpp">auto tagValue = rewriter.create&lt;arith::ConstantIntOp&gt;(loc, 0, i32Type);
</code></pre>
<p>생성되는 MLIR:</p>
<pre><code class="language-mlir">%tag = arith.constant 0 : i32
</code></pre>
<p><strong>Step 2: Null pointer</strong></p>
<pre><code class="language-cpp">auto nullPtr = rewriter.create&lt;LLVM::ZeroOp&gt;(loc, ptrType);
</code></pre>
<p>생성되는 MLIR:</p>
<pre><code class="language-mlir">%null = llvm.mlir.zero : !llvm.ptr
</code></pre>
<p><strong>llvm.mlir.zero vs llvm.null:</strong></p>
<ul>
<li><code>llvm.mlir.zero</code>: MLIR의 zero initializer (opaque pointers)</li>
<li>Old LLVM: <code>llvm.null</code> (deprecated with opaque pointers)</li>
</ul>
<p><strong>Step 3: Undefined struct</strong></p>
<pre><code class="language-cpp">auto undefStruct = rewriter.create&lt;LLVM::UndefOp&gt;(loc, structType);
</code></pre>
<p>생성되는 MLIR:</p>
<pre><code class="language-mlir">%undef = llvm.mlir.undef : !llvm.struct&lt;(i32, ptr)&gt;
</code></pre>
<p><strong>왜 undef부터 시작?</strong></p>
<ul>
<li>LLVM structs는 immutable (SSA form)</li>
<li><code>insertvalue</code>로 필드를 하나씩 채워 나감</li>
<li>초기값은 undefined (나중에 덮어씀)</li>
</ul>
<p><strong>Step 4-5: Insert values</strong></p>
<pre><code class="language-cpp">auto withTag = rewriter.create&lt;LLVM::InsertValueOp&gt;(
    loc, undefStruct, tagValue, ArrayRef&lt;int64_t&gt;{0});
auto nilValue = rewriter.create&lt;LLVM::InsertValueOp&gt;(
    loc, withTag, nullPtr, ArrayRef&lt;int64_t&gt;{1});
</code></pre>
<p>생성되는 MLIR:</p>
<pre><code class="language-mlir">%s1 = llvm.insertvalue %tag, %undef[0] : !llvm.struct&lt;(i32, ptr)&gt;
%nil = llvm.insertvalue %null, %s1[1] : !llvm.struct&lt;(i32, ptr)&gt;
</code></pre>
<p><strong>InsertValueOp syntax:</strong></p>
<ul>
<li><code>llvm.insertvalue %value, %struct[index]</code></li>
<li>index: struct field index (0 = tag, 1 = data)</li>
<li>Returns new struct with field updated</li>
</ul>
<p><strong>Step 6: Replace operation</strong></p>
<pre><code class="language-cpp">rewriter.replaceOp(op, nilValue.getResult());
</code></pre>
<ul>
<li>Remove original <code>funlang.nil</code> operation</li>
<li>Replace all uses with new struct value</li>
<li><code>nilValue.getResult()</code>: Extract Value from Operation</li>
</ul>
<h3 id="no-memory-allocation"><a class="header" href="#no-memory-allocation">No Memory Allocation</a></h3>
<p><strong>중요한 최적화:</strong></p>
<ul>
<li>NilOp lowering은 <strong>pure computation</strong> (no side effects)</li>
<li>Stack-only operations (constant, undef, insertvalue)</li>
<li><strong>No GC_malloc call</strong> (unlike ConsOp)</li>
</ul>
<p><strong>LLVM optimization 기회:</strong></p>
<pre><code class="language-mlir">// Multiple nil operations
%nil1 = funlang.nil : !funlang.list&lt;i32&gt;
%nil2 = funlang.nil : !funlang.list&lt;i32&gt;

// After lowering:
%tag = arith.constant 0 : i32
%null = llvm.mlir.zero : !llvm.ptr
%undef = llvm.mlir.undef : !llvm.struct&lt;(i32, ptr)&gt;
%s1 = llvm.insertvalue %tag, %undef[0] : !llvm.struct&lt;(i32, ptr)&gt;
%nil = llvm.insertvalue %null, %s1[1] : !llvm.struct&lt;(i32, ptr)&gt;
// LLVM CSE: %nil1 and %nil2 → same %nil!
</code></pre>
<p><strong>Advanced optimization (Phase 7):</strong></p>
<ul>
<li>Global constant for empty list</li>
<li>All nil operations → load from constant</li>
<li>Zero runtime cost</li>
</ul>
<h3 id="c-api-shim-if-needed"><a class="header" href="#c-api-shim-if-needed">C API Shim (if needed)</a></h3>
<p>NilOpLowering은 C++에서만 사용되므로 C API shim 불필요. 하지만 testing을 위해 제공 가능:</p>
<pre><code class="language-cpp">// For testing lowering pass from F#
void mlirFunLangRegisterNilOpLowering(MlirRewritePatternSet patterns) {
  auto *ctx = unwrap(patterns)-&gt;getContext();
  FunLangTypeConverter typeConverter(ctx, /* dataLayout */);
  unwrap(patterns)-&gt;add&lt;NilOpLowering&gt;(typeConverter, ctx);
}
</code></pre>
<h3 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h3>
<p><strong>Input MLIR (FunLang dialect):</strong></p>
<pre><code class="language-mlir">func.func @test_nil() -&gt; !funlang.list&lt;i32&gt; {
    %nil = funlang.nil : !funlang.list&lt;i32&gt;
    func.return %nil : !funlang.list&lt;i32&gt;
}
</code></pre>
<p><strong>After NilOpLowering (LLVM dialect):</strong></p>
<pre><code class="language-mlir">func.func @test_nil() -&gt; !llvm.struct&lt;(i32, ptr)&gt; {
    %c0 = arith.constant 0 : i32
    %null = llvm.mlir.zero : !llvm.ptr
    %0 = llvm.mlir.undef : !llvm.struct&lt;(i32, ptr)&gt;
    %1 = llvm.insertvalue %c0, %0[0] : !llvm.struct&lt;(i32, ptr)&gt;
    %nil = llvm.insertvalue %null, %1[1] : !llvm.struct&lt;(i32, ptr)&gt;
    func.return %nil : !llvm.struct&lt;(i32, ptr)&gt;
}
</code></pre>
<p><strong>After LLVM optimization:</strong></p>
<pre><code class="language-llvm">define { i32, ptr } @test_nil() {
  ; Constant struct {0, null} directly
  ret { i32, ptr } { i32 0, ptr null }
}
</code></pre>
<h3 id="summary-nilop-lowering-pattern"><a class="header" href="#summary-nilop-lowering-pattern">Summary: NilOp Lowering Pattern</a></h3>
<p><strong>구현 완료:</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""> OpConversionPattern for funlang.nil</li>
<li><input disabled="" type="checkbox" checked=""> Tagged union construction: {tag: 0, data: null}</li>
<li><input disabled="" type="checkbox" checked=""> No memory allocation (pure computation)</li>
<li><input disabled="" type="checkbox" checked=""> LLVM optimization friendly</li>
</ul>
<p><strong>핵심 패턴:</strong></p>
<ol>
<li>Undefined struct as starting point</li>
<li>InsertValueOp for field-by-field construction</li>
<li>replaceOp to complete rewriting</li>
</ol>
<p><strong>다음 섹션:</strong></p>
<ul>
<li>ConsOpLowering pattern으로 cons cell allocation</li>
</ul>
<hr>
<h2 id="consop-lowering-pattern"><a class="header" href="#consop-lowering-pattern">ConsOp Lowering Pattern</a></h2>
<p>이제 <code>funlang.cons</code>를 LLVM dialect로 lowering한다. NilOp보다 복잡하다 - <strong>memory allocation</strong>이 필요하기 때문이다.</p>
<h3 id="lowering-strategy-1"><a class="header" href="#lowering-strategy-1">Lowering Strategy</a></h3>
<p><strong>Before:</strong></p>
<pre><code class="language-mlir">%lst = funlang.cons %head, %tail : !funlang.list&lt;i32&gt;
</code></pre>
<p><strong>After:</strong></p>
<pre><code class="language-mlir">// 1. Allocate cons cell
%cell_size = arith.constant 16 : i64
%cell_ptr = llvm.call @GC_malloc(%cell_size) : (i64) -&gt; !llvm.ptr

// 2. Store head element
%head_ptr = llvm.getelementptr %cell_ptr[0] : (!llvm.ptr) -&gt; !llvm.ptr
llvm.store %head, %head_ptr : i32, !llvm.ptr

// 3. Store tail list
%tail_ptr = llvm.getelementptr %cell_ptr[1] : (!llvm.ptr) -&gt; !llvm.ptr
llvm.store %tail, %tail_ptr : !llvm.struct&lt;(i32, ptr)&gt;, !llvm.ptr

// 4. Build tagged union {1, cell_ptr}
%tag = arith.constant 1 : i32
%undef = llvm.mlir.undef : !llvm.struct&lt;(i32, ptr)&gt;
%s1 = llvm.insertvalue %tag, %undef[0] : !llvm.struct&lt;(i32, ptr)&gt;
%lst = llvm.insertvalue %cell_ptr, %s1[1] : !llvm.struct&lt;(i32, ptr)&gt;
</code></pre>
<p><strong>핵심 작업:</strong></p>
<ol>
<li><strong>GC_malloc</strong>: Heap에 cons cell 할당</li>
<li><strong>GEP (GetElementPtr)</strong>: Struct field 주소 계산</li>
<li><strong>Store</strong>: Head와 tail을 cell에 저장</li>
<li><strong>InsertValue</strong>: Tagged union 구성</li>
</ol>
<h3 id="memory-layout-recap"><a class="header" href="#memory-layout-recap">Memory Layout Recap</a></h3>
<p><strong>Cons cell structure:</strong></p>
<pre><code>struct ConsCell {
    T element;                    // Offset 0
    TaggedUnion tail;             // Offset sizeof(T)
}

TaggedUnion = struct {
    i32 tag;                      // 4 bytes
    ptr data;                     // 8 bytes
}
</code></pre>
<p><strong>예제: <code>!funlang.list&lt;i32&gt;</code></strong></p>
<pre><code>ConsCell&lt;i32&gt; = {
    i32 element;        // 4 bytes at offset 0
    struct {            // 16 bytes at offset 4 (aligned to 8)
        i32 tag;        // 4 bytes
        ptr data;       // 8 bytes
    } tail;
}

Total size: 4 + 16 = 20 bytes → aligned to 24 bytes
</code></pre>
<h3 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h3>
<p><strong>파일: <code>mlir/lib/Dialect/FunLang/Transforms/FunLangToLLVM.cpp</code></strong></p>
<pre><code class="language-cpp">//===----------------------------------------------------------------------===//
// ConsOpLowering
//===----------------------------------------------------------------------===//

class ConsOpLowering : public OpConversionPattern&lt;funlang::ConsOp&gt; {
public:
  using OpConversionPattern::OpConversionPattern;

  LogicalResult matchAndRewrite(
      funlang::ConsOp op,
      OpAdaptor adaptor,
      ConversionPatternRewriter &amp;rewriter) const override {

    auto loc = op.getLoc();
    auto ctx = op.getContext();

    // Get converted types
    Type convertedResultType = typeConverter-&gt;convertType(op.getType());
    auto structType = convertedResultType.cast&lt;LLVM::LLVMStructType&gt;();

    // Get element type (from original FunLang type)
    Type elementType = op.getElementType();

    // Get converted operands (TypeConverter already converted them)
    Value headValue = adaptor.getHead();
    Value tailValue = adaptor.getTail();

    // Step 1: Calculate cons cell size
    auto cellSize = calculateCellSize(rewriter, loc, elementType);

    // Step 2: Allocate cons cell via GC_malloc
    auto cellPtr = allocateConsCell(rewriter, loc, cellSize);

    // Step 3: Store head element
    storeHead(rewriter, loc, cellPtr, headValue, elementType);

    // Step 4: Store tail list
    storeTail(rewriter, loc, cellPtr, tailValue, elementType);

    // Step 5: Build tagged union {1, cellPtr}
    auto consValue = buildTaggedUnion(rewriter, loc, structType, cellPtr);

    // Replace funlang.cons with constructed value
    rewriter.replaceOp(op, consValue);

    return success();
  }

private:
  // Calculate cons cell size: sizeof(element) + sizeof(TaggedUnion)
  Value calculateCellSize(
      OpBuilder &amp;builder, Location loc, Type elementType) const {

    auto *typeConverter = getTypeConverter();
    auto dataLayout = DataLayout::closest(loc.getParentModule());

    // Get element size
    uint64_t elemSize = dataLayout.getTypeSize(elementType);

    // TaggedUnion size: struct&lt;(i32, ptr)&gt; = 4 + 8 = 12, aligned to 16
    uint64_t tailSize = 16;

    uint64_t totalSize = elemSize + tailSize;

    // Align to 8 bytes
    totalSize = (totalSize + 7) &amp; ~7;

    auto i64Type = builder.getI64Type();
    return builder.create&lt;arith::ConstantIntOp&gt;(loc, totalSize, i64Type);
  }

  // Allocate cons cell via GC_malloc
  Value allocateConsCell(
      OpBuilder &amp;builder, Location loc, Value size) const {

    auto ctx = builder.getContext();
    auto ptrType = LLVM::LLVMPointerType::get(ctx);
    auto i64Type = builder.getI64Type();

    // Get or declare GC_malloc
    auto module = loc-&gt;getParentOfType&lt;ModuleOp&gt;();
    auto gcMalloc = module.lookupSymbol&lt;LLVM::LLVMFuncOp&gt;("GC_malloc");
    if (!gcMalloc) {
      OpBuilder::InsertionGuard guard(builder);
      builder.setInsertionPointToStart(module.getBody());

      auto funcType = LLVM::LLVMFunctionType::get(ptrType, {i64Type});
      gcMalloc = builder.create&lt;LLVM::LLVMFuncOp&gt;(
          loc, "GC_malloc", funcType);
    }

    // Call GC_malloc
    auto callOp = builder.create&lt;LLVM::CallOp&gt;(
        loc, gcMalloc, ValueRange{size});

    return callOp.getResult();
  }

  // Store head element at offset 0
  void storeHead(
      OpBuilder &amp;builder, Location loc, Value cellPtr,
      Value headValue, Type elementType) const {

    // GEP to head field: cell[0]
    auto headPtr = builder.create&lt;LLVM::GEPOp&gt;(
        loc, cellPtr.getType(), cellPtr,
        ArrayRef&lt;LLVM::GEPArg&gt;{0},
        elementType);

    // Store head
    builder.create&lt;LLVM::StoreOp&gt;(loc, headValue, headPtr);
  }

  // Store tail list at offset sizeof(element)
  void storeTail(
      OpBuilder &amp;builder, Location loc, Value cellPtr,
      Value tailValue, Type elementType) const {

    auto ctx = builder.getContext();
    auto dataLayout = DataLayout::closest(loc.getParentModule());

    // Calculate tail offset
    uint64_t elemSize = dataLayout.getTypeSize(elementType);
    uint64_t tailOffset = (elemSize + 7) &amp; ~7;  // Align to 8 bytes

    // GEP to tail field: cell + tailOffset bytes
    auto tailPtr = builder.create&lt;LLVM::GEPOp&gt;(
        loc, cellPtr.getType(), cellPtr,
        ArrayRef&lt;LLVM::GEPArg&gt;{static_cast&lt;int32_t&gt;(tailOffset)},
        builder.getI8Type());

    // Store tail
    builder.create&lt;LLVM::StoreOp&gt;(loc, tailValue, tailPtr);
  }

  // Build tagged union: {tag: 1, data: cellPtr}
  Value buildTaggedUnion(
      OpBuilder &amp;builder, Location loc,
      LLVM::LLVMStructType structType, Value cellPtr) const {

    auto ctx = builder.getContext();
    auto i32Type = builder.getI32Type();

    // Tag = 1 (Cons)
    auto tagValue = builder.create&lt;arith::ConstantIntOp&gt;(loc, 1, i32Type);

    // Start with undefined struct
    auto undefStruct = builder.create&lt;LLVM::UndefOp&gt;(loc, structType);

    // Insert tag
    auto withTag = builder.create&lt;LLVM::InsertValueOp&gt;(
        loc, undefStruct, tagValue, ArrayRef&lt;int64_t&gt;{0});

    // Insert cell pointer
    auto withData = builder.create&lt;LLVM::InsertValueOp&gt;(
        loc, withTag, cellPtr, ArrayRef&lt;int64_t&gt;{1});

    return withData.getResult();
  }
};
</code></pre>
<h3 id="detailed-breakdown"><a class="header" href="#detailed-breakdown">Detailed Breakdown</a></h3>
<p><strong>Step 1: Cell size calculation</strong></p>
<pre><code class="language-cpp">uint64_t elemSize = dataLayout.getTypeSize(elementType);
uint64_t tailSize = 16;  // struct&lt;(i32, ptr)&gt; aligned
uint64_t totalSize = elemSize + tailSize;
totalSize = (totalSize + 7) &amp; ~7;  // Align to 8 bytes
</code></pre>
<p><strong>Examples:</strong></p>
<pre><code>i32: 4 + 16 = 20 → 24 bytes
f64: 8 + 16 = 24 → 24 bytes
!funlang.closure (ptr): 8 + 16 = 24 → 24 bytes
</code></pre>
<p><strong>Step 2: GC_malloc call</strong></p>
<pre><code class="language-cpp">auto gcMalloc = module.lookupSymbol&lt;LLVM::LLVMFuncOp&gt;("GC_malloc");
if (!gcMalloc) {
  // Declare if not exists
  auto funcType = LLVM::LLVMFunctionType::get(ptrType, {i64Type});
  gcMalloc = builder.create&lt;LLVM::LLVMFuncOp&gt;(loc, "GC_malloc", funcType);
}
auto callOp = builder.create&lt;LLVM::CallOp&gt;(loc, gcMalloc, ValueRange{size});
</code></pre>
<p>생성되는 MLIR:</p>
<pre><code class="language-mlir">llvm.func @GC_malloc(i64) -&gt; !llvm.ptr
%cell_ptr = llvm.call @GC_malloc(%cell_size) : (i64) -&gt; !llvm.ptr
</code></pre>
<p><strong>Step 3: Store head</strong></p>
<pre><code class="language-cpp">auto headPtr = builder.create&lt;LLVM::GEPOp&gt;(
    loc, cellPtr.getType(), cellPtr,
    ArrayRef&lt;LLVM::GEPArg&gt;{0}, elementType);
builder.create&lt;LLVM::StoreOp&gt;(loc, headValue, headPtr);
</code></pre>
<p>생성되는 MLIR:</p>
<pre><code class="language-mlir">%head_ptr = llvm.getelementptr %cell_ptr[0] : (!llvm.ptr) -&gt; !llvm.ptr, i32
llvm.store %head, %head_ptr : i32, !llvm.ptr
</code></pre>
<p><strong>GEPOp (GetElementPtr):</strong></p>
<ul>
<li>Opaque pointers 시대의 GEP</li>
<li>Type hint: <code>elementType</code> (i32, f64, etc.)</li>
<li>Offset: <code>[0]</code> (first field)</li>
</ul>
<p><strong>Step 4: Store tail</strong></p>
<pre><code class="language-cpp">uint64_t tailOffset = (elemSize + 7) &amp; ~7;  // Aligned offset
auto tailPtr = builder.create&lt;LLVM::GEPOp&gt;(
    loc, cellPtr.getType(), cellPtr,
    ArrayRef&lt;LLVM::GEPArg&gt;{static_cast&lt;int32_t&gt;(tailOffset)},
    builder.getI8Type());
builder.create&lt;LLVM::StoreOp&gt;(loc, tailValue, tailPtr);
</code></pre>
<p>생성되는 MLIR:</p>
<pre><code class="language-mlir">%tail_ptr = llvm.getelementptr %cell_ptr[8] : (!llvm.ptr) -&gt; !llvm.ptr, i8
llvm.store %tail, %tail_ptr : !llvm.struct&lt;(i32, ptr)&gt;, !llvm.ptr
</code></pre>
<p><strong>Byte-offset GEP:</strong></p>
<ul>
<li>Type hint: <code>i8</code> (byte-addressable)</li>
<li>Offset: <code>[8]</code> (after 4-byte i32, aligned to 8)</li>
</ul>
<p><strong>Step 5: Tagged union</strong></p>
<pre><code class="language-cpp">auto tagValue = builder.create&lt;arith::ConstantIntOp&gt;(loc, 1, i32Type);
auto undefStruct = builder.create&lt;LLVM::UndefOp&gt;(loc, structType);
auto withTag = builder.create&lt;LLVM::InsertValueOp&gt;(
    loc, undefStruct, tagValue, ArrayRef&lt;int64_t&gt;{0});
auto withData = builder.create&lt;LLVM::InsertValueOp&gt;(
    loc, withTag, cellPtr, ArrayRef&lt;int64_t&gt;{1});
</code></pre>
<p>생성되는 MLIR:</p>
<pre><code class="language-mlir">%tag = arith.constant 1 : i32
%undef = llvm.mlir.undef : !llvm.struct&lt;(i32, ptr)&gt;
%s1 = llvm.insertvalue %tag, %undef[0] : !llvm.struct&lt;(i32, ptr)&gt;
%cons = llvm.insertvalue %cell_ptr, %s1[1] : !llvm.struct&lt;(i32, ptr)&gt;
</code></pre>
<h3 id="opadaptor-usage"><a class="header" href="#opadaptor-usage">OpAdaptor Usage</a></h3>
<p><strong>OpAdaptor가 중요한 이유:</strong></p>
<pre><code class="language-cpp">Value headValue = adaptor.getHead();  // Converted type!
Value tailValue = adaptor.getTail();  // Converted type!
</code></pre>
<p><strong>Type conversion 자동 처리:</strong></p>
<pre><code class="language-mlir">// Before lowering
%cons = funlang.cons %head, %tail : !funlang.list&lt;i32&gt;
// %head: i32
// %tail: !funlang.list&lt;i32&gt;

// During lowering (via OpAdaptor)
// adaptor.getHead(): i32 (unchanged)
// adaptor.getTail(): !llvm.struct&lt;(i32, ptr)&gt; (converted!)
</code></pre>
<p><strong>이미 TypeConverter가 처리함:</strong></p>
<ul>
<li>OpAdaptor는 TypeConverter가 변환한 operands 제공</li>
<li>Pattern 코드는 converted types로 작업</li>
<li>수동 type conversion 불필요</li>
</ul>
<h3 id="complete-example-1"><a class="header" href="#complete-example-1">Complete Example</a></h3>
<p><strong>Input MLIR (FunLang dialect):</strong></p>
<pre><code class="language-mlir">func.func @build_list() -&gt; !funlang.list&lt;i32&gt; {
    %c1 = arith.constant 1 : i32
    %c2 = arith.constant 2 : i32
    %c3 = arith.constant 3 : i32

    %nil = funlang.nil : !funlang.list&lt;i32&gt;
    %lst1 = funlang.cons %c3, %nil : !funlang.list&lt;i32&gt;
    %lst2 = funlang.cons %c2, %lst1 : !funlang.list&lt;i32&gt;
    %lst3 = funlang.cons %c1, %lst2 : !funlang.list&lt;i32&gt;

    func.return %lst3 : !funlang.list&lt;i32&gt;
}
</code></pre>
<p><strong>After lowering (LLVM dialect):</strong></p>
<pre><code class="language-mlir">func.func @build_list() -&gt; !llvm.struct&lt;(i32, ptr)&gt; {
    %c1 = arith.constant 1 : i32
    %c2 = arith.constant 2 : i32
    %c3 = arith.constant 3 : i32

    // Nil
    %c0_tag = arith.constant 0 : i32
    %null = llvm.mlir.zero : !llvm.ptr
    %nil_undef = llvm.mlir.undef : !llvm.struct&lt;(i32, ptr)&gt;
    %nil_1 = llvm.insertvalue %c0_tag, %nil_undef[0] : !llvm.struct&lt;(i32, ptr)&gt;
    %nil = llvm.insertvalue %null, %nil_1[1] : !llvm.struct&lt;(i32, ptr)&gt;

    // Cons %c3, %nil
    %size1 = arith.constant 24 : i64
    %cell1 = llvm.call @GC_malloc(%size1) : (i64) -&gt; !llvm.ptr
    %head1_ptr = llvm.getelementptr %cell1[0] : (!llvm.ptr) -&gt; !llvm.ptr, i32
    llvm.store %c3, %head1_ptr : i32, !llvm.ptr
    %tail1_ptr = llvm.getelementptr %cell1[8] : (!llvm.ptr) -&gt; !llvm.ptr, i8
    llvm.store %nil, %tail1_ptr : !llvm.struct&lt;(i32, ptr)&gt;, !llvm.ptr
    %c1_tag = arith.constant 1 : i32
    %lst1_undef = llvm.mlir.undef : !llvm.struct&lt;(i32, ptr)&gt;
    %lst1_1 = llvm.insertvalue %c1_tag, %lst1_undef[0] : !llvm.struct&lt;(i32, ptr)&gt;
    %lst1 = llvm.insertvalue %cell1, %lst1_1[1] : !llvm.struct&lt;(i32, ptr)&gt;

    // Cons %c2, %lst1
    %size2 = arith.constant 24 : i64
    %cell2 = llvm.call @GC_malloc(%size2) : (i64) -&gt; !llvm.ptr
    %head2_ptr = llvm.getelementptr %cell2[0] : (!llvm.ptr) -&gt; !llvm.ptr, i32
    llvm.store %c2, %head2_ptr : i32, !llvm.ptr
    %tail2_ptr = llvm.getelementptr %cell2[8] : (!llvm.ptr) -&gt; !llvm.ptr, i8
    llvm.store %lst1, %tail2_ptr : !llvm.struct&lt;(i32, ptr)&gt;, !llvm.ptr
    %lst2_1 = llvm.insertvalue %c1_tag, %lst1_undef[0] : !llvm.struct&lt;(i32, ptr)&gt;
    %lst2 = llvm.insertvalue %cell2, %lst2_1[1] : !llvm.struct&lt;(i32, ptr)&gt;

    // Cons %c1, %lst2
    %size3 = arith.constant 24 : i64
    %cell3 = llvm.call @GC_malloc(%size3) : (i64) -&gt; !llvm.ptr
    %head3_ptr = llvm.getelementptr %cell3[0] : (!llvm.ptr) -&gt; !llvm.ptr, i32
    llvm.store %c1, %head3_ptr : i32, !llvm.ptr
    %tail3_ptr = llvm.getelementptr %cell3[8] : (!llvm.ptr) -&gt; !llvm.ptr, i8
    llvm.store %lst2, %tail3_ptr : !llvm.struct&lt;(i32, ptr)&gt;, !llvm.ptr
    %lst3_1 = llvm.insertvalue %c1_tag, %lst1_undef[0] : !llvm.struct&lt;(i32, ptr)&gt;
    %lst3 = llvm.insertvalue %cell3, %lst3_1[1] : !llvm.struct&lt;(i32, ptr)&gt;

    func.return %lst3 : !llvm.struct&lt;(i32, ptr)&gt;
}
</code></pre>
<h3 id="summary-consop-lowering-pattern"><a class="header" href="#summary-consop-lowering-pattern">Summary: ConsOp Lowering Pattern</a></h3>
<p><strong>구현 완료:</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""> OpConversionPattern for funlang.cons</li>
<li><input disabled="" type="checkbox" checked=""> GC_malloc call for cons cell allocation</li>
<li><input disabled="" type="checkbox" checked=""> GEP + Store for head and tail</li>
<li><input disabled="" type="checkbox" checked=""> Tagged union construction with tag=1</li>
<li><input disabled="" type="checkbox" checked=""> OpAdaptor for converted operands</li>
</ul>
<p><strong>핵심 패턴:</strong></p>
<ol>
<li>Calculate cell size from element type</li>
<li>Allocate via GC_malloc</li>
<li>Store head and tail with GEP</li>
<li>Build tagged union with InsertValueOp</li>
</ol>
<p><strong>다음 섹션:</strong></p>
<ul>
<li>Complete lowering pass integration</li>
<li>Common errors and debugging</li>
</ul>
<hr>
<h2 id="complete-lowering-pass-update"><a class="header" href="#complete-lowering-pass-update">Complete Lowering Pass Update</a></h2>
<p>이제 NilOpLowering과 ConsOpLowering을 FunLangToLLVM pass에 등록한다.</p>
<h3 id="funlangtollvm-pass-structure"><a class="header" href="#funlangtollvm-pass-structure">FunLangToLLVM Pass Structure</a></h3>
<p><strong>파일: <code>mlir/lib/Dialect/FunLang/Transforms/FunLangToLLVM.cpp</code></strong></p>
<pre><code class="language-cpp">//===----------------------------------------------------------------------===//
// FunLangToLLVM Pass
//===----------------------------------------------------------------------===//

struct FunLangToLLVMPass
    : public PassWrapper&lt;FunLangToLLVMPass, OperationPass&lt;ModuleOp&gt;&gt; {

  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FunLangToLLVMPass)

  StringRef getArgument() const final { return "convert-funlang-to-llvm"; }
  StringRef getDescription() const final {
    return "Convert FunLang dialect to LLVM dialect";
  }

  void runOnOperation() override {
    auto module = getOperation();
    auto *ctx = &amp;getContext();

    // Get data layout from module
    auto dataLayout = DataLayout::closest(module);

    // Create type converter
    FunLangTypeConverter typeConverter(ctx, dataLayout);

    // Setup conversion target
    ConversionTarget target(*ctx);

    // Legal dialects (after conversion)
    target.addLegalDialect&lt;LLVM::LLVMDialect&gt;();
    target.addLegalDialect&lt;arith::ArithDialect&gt;();
    target.addLegalDialect&lt;func::FuncDialect&gt;();

    // Illegal dialects (must be converted)
    target.addIllegalDialect&lt;funlang::FunLangDialect&gt;();

    // Function signatures must be converted
    target.addDynamicallyLegalOp&lt;func::FuncOp&gt;([&amp;](func::FuncOp op) {
      return typeConverter.isSignatureLegal(op.getFunctionType());
    });

    // Populate rewrite patterns
    RewritePatternSet patterns(ctx);

    // Phase 5 patterns (Chapter 16)
    patterns.add&lt;ClosureOpLowering&gt;(typeConverter, ctx);
    patterns.add&lt;ApplyOpLowering&gt;(typeConverter, ctx);

    // Phase 6 patterns (Chapter 18)
    patterns.add&lt;NilOpLowering&gt;(typeConverter, ctx);
    patterns.add&lt;ConsOpLowering&gt;(typeConverter, ctx);

    // Function signature conversion
    populateFunctionOpInterfaceTypeConversionPattern&lt;func::FuncOp&gt;(
        patterns, typeConverter);

    // Run partial conversion
    if (failed(applyPartialConversion(module, target, std::move(patterns)))) {
      signalPassFailure();
    }
  }
};

// Register pass
void registerFunLangToLLVMPass() {
  PassRegistration&lt;FunLangToLLVMPass&gt;();
}
</code></pre>
<h3 id="pattern-registration-order"><a class="header" href="#pattern-registration-order">Pattern Registration Order</a></h3>
<p><strong>순서가 중요한가?</strong></p>
<p>일반적으로 <strong>순서 무관</strong>하다. DialectConversion framework가 모든 patterns를 시도한다.</p>
<p><strong>하지만 성능 최적화를 위해:</strong></p>
<ul>
<li>자주 매칭되는 patterns를 먼저 등록</li>
<li>복잡한 patterns를 나중에 등록 (matching cost 고려)</li>
</ul>
<p><strong>FunLang의 경우:</strong></p>
<pre><code class="language-cpp">// Frequency: ClosureOp &gt; ApplyOp &gt; ConsOp &gt; NilOp (typical functional code)
patterns.add&lt;ClosureOpLowering&gt;(typeConverter, ctx);    // Most frequent
patterns.add&lt;ApplyOpLowering&gt;(typeConverter, ctx);
patterns.add&lt;ConsOpLowering&gt;(typeConverter, ctx);
patterns.add&lt;NilOpLowering&gt;(typeConverter, ctx);        // Least frequent
</code></pre>
<p>하지만 <strong>실용적으로는 로직 순서</strong>로 배치:</p>
<pre><code class="language-cpp">// Logical grouping
// Phase 5 operations
patterns.add&lt;ClosureOpLowering&gt;(typeConverter, ctx);
patterns.add&lt;ApplyOpLowering&gt;(typeConverter, ctx);

// Phase 6 operations
patterns.add&lt;NilOpLowering&gt;(typeConverter, ctx);
patterns.add&lt;ConsOpLowering&gt;(typeConverter, ctx);
</code></pre>
<h3 id="pass-manager-integration"><a class="header" href="#pass-manager-integration">Pass Manager Integration</a></h3>
<p><strong>F# compiler pipeline:</strong></p>
<pre><code class="language-fsharp">// FunLang.Compiler/Compiler.fs
let lowerToLLVM (mlirModule: MlirModule) =
    let pm = PassManager(mlirModule.Context)

    // Phase 5-6: FunLang → LLVM
    pm.AddPass("convert-funlang-to-llvm")

    // Standard MLIR lowering
    pm.AddPass("convert-func-to-llvm")
    pm.AddPass("convert-arith-to-llvm")
    pm.AddPass("reconcile-unrealized-casts")

    pm.Run(mlirModule)
</code></pre>
<p><strong>Pass order:</strong></p>
<ol>
<li><strong>convert-funlang-to-llvm</strong>: FunLang ops → LLVM ops</li>
<li><strong>convert-func-to-llvm</strong>: func.func → llvm.func</li>
<li><strong>convert-arith-to-llvm</strong>: arith ops → llvm ops</li>
<li><strong>reconcile-unrealized-casts</strong>: Remove UnrealizedConversionCastOps</li>
</ol>
<h3 id="testing-list-construction"><a class="header" href="#testing-list-construction">Testing List Construction</a></h3>
<p><strong>Test case:</strong></p>
<pre><code class="language-fsharp">// F# source
let test_list = [1; 2; 3]
</code></pre>
<p><strong>Compiled MLIR (FunLang dialect):</strong></p>
<pre><code class="language-mlir">module {
  func.func @test_list() -&gt; !funlang.list&lt;i32&gt; {
    %c1 = arith.constant 1 : i32
    %c2 = arith.constant 2 : i32
    %c3 = arith.constant 3 : i32

    %nil = funlang.nil : !funlang.list&lt;i32&gt;
    %lst1 = funlang.cons %c3, %nil : !funlang.list&lt;i32&gt;
    %lst2 = funlang.cons %c2, %lst1 : !funlang.list&lt;i32&gt;
    %lst3 = funlang.cons %c1, %lst2 : !funlang.list&lt;i32&gt;

    func.return %lst3 : !funlang.list&lt;i32&gt;
  }
}
</code></pre>
<p><strong>After lowering:</strong></p>
<pre><code class="language-bash">mlir-opt test.mlir \
  --convert-funlang-to-llvm \
  --convert-func-to-llvm \
  --convert-arith-to-llvm \
  --reconcile-unrealized-casts
</code></pre>
<p><strong>Result (LLVM dialect):</strong></p>
<pre><code class="language-mlir">module {
  llvm.func @GC_malloc(i64) -&gt; !llvm.ptr

  llvm.func @test_list() -&gt; !llvm.struct&lt;(i32, ptr)&gt; {
    %c1 = llvm.mlir.constant(1 : i32) : i32
    %c2 = llvm.mlir.constant(2 : i32) : i32
    %c3 = llvm.mlir.constant(3 : i32) : i32

    // Nil
    %c0 = llvm.mlir.constant(0 : i32) : i32
    %null = llvm.mlir.zero : !llvm.ptr
    %nil_undef = llvm.mlir.undef : !llvm.struct&lt;(i32, ptr)&gt;
    %nil_1 = llvm.insertvalue %c0, %nil_undef[0] : !llvm.struct&lt;(i32, ptr)&gt;
    %nil = llvm.insertvalue %null, %nil_1[1] : !llvm.struct&lt;(i32, ptr)&gt;

    // Cons cells (similar to previous example)
    // ...

    llvm.return %lst3 : !llvm.struct&lt;(i32, ptr)&gt;
  }
}
</code></pre>
<h3 id="end-to-end-example-1"><a class="header" href="#end-to-end-example-1">End-to-End Example</a></h3>
<p><strong>Complete workflow:</strong></p>
<pre><code class="language-fsharp">// 1. F# AST → FunLang MLIR
let ast = parseExpression "[1; 2; 3]"
let mlirModule = compileToFunLang ast

// 2. FunLang MLIR → LLVM MLIR
lowerToLLVM mlirModule

// 3. LLVM MLIR → LLVM IR
let llvmIR = translateToLLVMIR mlirModule

// 4. LLVM IR → Object file
let objFile = compileLLVMIR llvmIR

// 5. Link with runtime
let executable = linkWithRuntime objFile

// 6. Run!
runExecutable executable
</code></pre>
<p><strong>Memory diagram at runtime:</strong></p>
<pre><code>Stack:
  %lst3: {1, 0x1000}

Heap (GC-managed):
  0x1000: ConsCell { head: 1, tail: {1, 0x2000} }
  0x2000: ConsCell { head: 2, tail: {1, 0x3000} }
  0x3000: ConsCell { head: 3, tail: {0, null} }
</code></pre>
<h3 id="summary-complete-lowering-pass"><a class="header" href="#summary-complete-lowering-pass">Summary: Complete Lowering Pass</a></h3>
<p><strong>구현 완료:</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""> FunLangToLLVMPass with all patterns</li>
<li><input disabled="" type="checkbox" checked=""> Pattern registration (Closure, Apply, Nil, Cons)</li>
<li><input disabled="" type="checkbox" checked=""> Pass manager integration</li>
<li><input disabled="" type="checkbox" checked=""> End-to-end list construction</li>
</ul>
<p><strong>Pass pipeline:</strong></p>
<ol>
<li>convert-funlang-to-llvm</li>
<li>convert-func-to-llvm</li>
<li>convert-arith-to-llvm</li>
<li>reconcile-unrealized-casts</li>
</ol>
<p><strong>다음 섹션:</strong></p>
<ul>
<li>Common errors and debugging strategies</li>
</ul>
<hr>
<h2 id="common-errors-1"><a class="header" href="#common-errors-1">Common Errors</a></h2>
<p>Lowering pass 구현 시 흔히 발생하는 오류와 해결 방법.</p>
<h3 id="error-1-wrong-cons-cell-size"><a class="header" href="#error-1-wrong-cons-cell-size">Error 1: Wrong Cons Cell Size</a></h3>
<p><strong>증상:</strong></p>
<pre><code>Runtime segfault when accessing tail
</code></pre>
<p><strong>원인:</strong></p>
<pre><code class="language-cpp">// 잘못된 코드
uint64_t totalSize = elemSize + 12;  // struct&lt;(i32, ptr)&gt; = 12 bytes?
// 실제: struct는 alignment 때문에 16 bytes!
</code></pre>
<p><strong>해결:</strong></p>
<pre><code class="language-cpp">// 올바른 코드
uint64_t tailSize = 16;  // Aligned struct size
uint64_t totalSize = elemSize + tailSize;
totalSize = (totalSize + 7) &amp; ~7;  // Align total to 8 bytes
</code></pre>
<p><strong>디버깅:</strong></p>
<pre><code class="language-cpp">// Print sizes in lowering pass
llvm::errs() &lt;&lt; "Element size: " &lt;&lt; elemSize &lt;&lt; "\n";
llvm::errs() &lt;&lt; "Total cell size: " &lt;&lt; totalSize &lt;&lt; "\n";
</code></pre>
<h3 id="error-2-type-mismatch-in-store-operations"><a class="header" href="#error-2-type-mismatch-in-store-operations">Error 2: Type Mismatch in Store Operations</a></h3>
<p><strong>증상:</strong></p>
<pre><code>error: 'llvm.store' op operand #0 type 'i32' does not match
  destination pointer element type '!llvm.struct&lt;(i32, ptr)&gt;'
</code></pre>
<p><strong>원인:</strong></p>
<pre><code class="language-cpp">// 잘못된 GEP - head pointer로 tail을 store
llvm.store %tail, %head_ptr : !llvm.struct&lt;(i32, ptr)&gt;, !llvm.ptr
</code></pre>
<p><strong>해결:</strong></p>
<pre><code class="language-cpp">// 올바른 GEP offsets
auto headPtr = builder.create&lt;LLVM::GEPOp&gt;(
    loc, cellPtr.getType(), cellPtr, ArrayRef&lt;LLVM::GEPArg&gt;{0}, elementType);
    // ^^^^^^^^ offset 0 for head

auto tailPtr = builder.create&lt;LLVM::GEPOp&gt;(
    loc, cellPtr.getType(), cellPtr,
    ArrayRef&lt;LLVM::GEPArg&gt;{tailOffset}, builder.getI8Type());
    // ^^^^^^^^^^^^^^^^ byte offset for tail
</code></pre>
<h3 id="error-3-missing-typeconverter-rule"><a class="header" href="#error-3-missing-typeconverter-rule">Error 3: Missing TypeConverter Rule</a></h3>
<p><strong>증상:</strong></p>
<pre><code>error: failed to legalize operation 'funlang.cons'
  operand #1 type '!funlang.list&lt;i32&gt;' is not legal
</code></pre>
<p><strong>원인:</strong></p>
<p>TypeConverter에 list type 변환 규칙 없음.</p>
<p><strong>해결:</strong></p>
<pre><code class="language-cpp">// TypeConverter에 추가
addConversion([](funlang::FunLangListType type) {
  auto ctx = type.getContext();
  auto i32Type = IntegerType::get(ctx, 32);
  auto ptrType = LLVM::LLVMPointerType::get(ctx);
  return LLVM::LLVMStructType::getLiteral(ctx, {i32Type, ptrType});
});
</code></pre>
<h3 id="error-4-gep-index-confusion"><a class="header" href="#error-4-gep-index-confusion">Error 4: GEP Index Confusion</a></h3>
<p><strong>증상:</strong></p>
<pre><code>Runtime crash: accessing wrong memory offset
</code></pre>
<p><strong>원인:</strong></p>
<pre><code class="language-cpp">// Element index vs byte offset 혼동
auto tailPtr = builder.create&lt;LLVM::GEPOp&gt;(
    loc, cellPtr.getType(), cellPtr,
    ArrayRef&lt;LLVM::GEPArg&gt;{1},  // Element index 1? No!
    structType);
</code></pre>
<p><strong>해결:</strong></p>
<pre><code class="language-cpp">// Byte offset 사용
uint64_t tailOffset = (elemSize + 7) &amp; ~7;
auto tailPtr = builder.create&lt;LLVM::GEPOp&gt;(
    loc, cellPtr.getType(), cellPtr,
    ArrayRef&lt;LLVM::GEPArg&gt;{static_cast&lt;int32_t&gt;(tailOffset)},
    builder.getI8Type());  // i8 for byte-addressable
</code></pre>
<p><strong>GEP modes:</strong></p>
<ul>
<li><strong>Type-based</strong>: <code>GEP ptr, [index]</code> with element type → element index</li>
<li><strong>Byte-based</strong>: <code>GEP ptr, [offset]</code> with i8 type → byte offset</li>
</ul>
<h3 id="debugging-strategies"><a class="header" href="#debugging-strategies">Debugging Strategies</a></h3>
<p><strong>Strategy 1: Print intermediate MLIR</strong></p>
<pre><code class="language-bash">mlir-opt input.mlir \
  --convert-funlang-to-llvm \
  --print-ir-after-all \
  -o output.mlir
</code></pre>
<p><strong>Strategy 2: Use mlir-opt with debug flags</strong></p>
<pre><code class="language-bash">mlir-opt input.mlir \
  --convert-funlang-to-llvm \
  --debug-only=dialect-conversion \
  --mlir-print-debuginfo
</code></pre>
<p><strong>Strategy 3: Add assertions in lowering patterns</strong></p>
<pre><code class="language-cpp">LogicalResult matchAndRewrite(...) const override {
  // Check preconditions
  assert(adaptor.getTail().getType().isa&lt;LLVM::LLVMStructType&gt;() &amp;&amp;
         "Tail must be converted to struct type");

  // Pattern logic...
}
</code></pre>
<p><strong>Strategy 4: Test incrementally</strong></p>
<pre><code class="language-mlir">// Test NilOp alone first
func.func @test_nil() -&gt; !funlang.list&lt;i32&gt; {
    %nil = funlang.nil : !funlang.list&lt;i32&gt;
    func.return %nil : !funlang.list&lt;i32&gt;
}

// Then ConsOp with nil
func.func @test_cons_nil() -&gt; !funlang.list&lt;i32&gt; {
    %nil = funlang.nil : !funlang.list&lt;i32&gt;
    %c1 = arith.constant 1 : i32
    %cons = funlang.cons %c1, %nil : !funlang.list&lt;i32&gt;
    func.return %cons : !funlang.list&lt;i32&gt;
}

// Then multiple cons
// ...
</code></pre>
<h3 id="summary-common-errors"><a class="header" href="#summary-common-errors">Summary: Common Errors</a></h3>
<p><strong>주요 실수:</strong></p>
<ol>
<li>Cons cell size 계산 오류 (alignment 무시)</li>
<li>GEP offset 혼동 (element index vs byte offset)</li>
<li>TypeConverter 규칙 누락</li>
<li>Store type mismatch</li>
</ol>
<p><strong>디버깅 도구:</strong></p>
<ul>
<li><code>mlir-opt --print-ir-after-all</code></li>
<li><code>--debug-only=dialect-conversion</code></li>
<li>Assertions in pattern code</li>
<li>Incremental testing</li>
</ul>
<p><strong>다음 섹션:</strong></p>
<ul>
<li>Chapter 18 summary and Chapter 19 preview</li>
</ul>
<hr>
<h2 id="summary-and-chapter-19-preview"><a class="header" href="#summary-and-chapter-19-preview">Summary and Chapter 19 Preview</a></h2>
<h3 id="chapter-18-복습"><a class="header" href="#chapter-18-복습">Chapter 18 복습</a></h3>
<p><strong>이 장에서 구현한 것:</strong></p>
<ol>
<li>
<p><strong>List Representation Design</strong></p>
<ul>
<li>Tagged union: <code>!llvm.struct&lt;(i32, ptr)&gt;</code></li>
<li>Cons cells: Heap-allocated <code>{element, tail}</code> structs</li>
<li>Immutability and structural sharing</li>
</ul>
</li>
<li>
<p><strong>FunLang List Type</strong></p>
<ul>
<li><code>!funlang.list&lt;T&gt;</code> parameterized type</li>
<li>TableGen definition with type parameter</li>
<li>C API shim and F# bindings</li>
</ul>
</li>
<li>
<p><strong>funlang.nil Operation</strong></p>
<ul>
<li>Empty list constructor</li>
<li>Pure trait (no allocation)</li>
<li>Lowering: constant struct {0, null}</li>
</ul>
</li>
<li>
<p><strong>funlang.cons Operation</strong></p>
<ul>
<li>Cons cell constructor</li>
<li>Type-safe head/tail constraints</li>
<li>Lowering: GC_malloc + GEP + store</li>
</ul>
</li>
<li>
<p><strong>TypeConverter Extension</strong></p>
<ul>
<li><code>!funlang.list&lt;T&gt;</code> → <code>!llvm.struct&lt;(i32, ptr)&gt;</code></li>
<li>Element type erasure at runtime</li>
<li>Integration with FunLangTypeConverter</li>
</ul>
</li>
<li>
<p><strong>Lowering Patterns</strong></p>
<ul>
<li>NilOpLowering: InsertValueOp for struct construction</li>
<li>ConsOpLowering: GC_malloc + GEP + store + InsertValueOp</li>
<li>Complete pass integration</li>
</ul>
</li>
</ol>
<h3 id="list-operations의-의의"><a class="header" href="#list-operations의-의의">List Operations의 의의</a></h3>
<p><strong>Before Chapter 18:</strong></p>
<pre><code class="language-mlir">// 리스트 표현 불가
// 패턴 매칭 불가
</code></pre>
<p><strong>After Chapter 18:</strong></p>
<pre><code class="language-mlir">// 리스트 생성 가능
%nil = funlang.nil : !funlang.list&lt;i32&gt;
%lst = funlang.cons %head, %tail : !funlang.list&lt;i32&gt;

// Chapter 19에서 패턴 매칭 추가:
%result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
  ^nil: ...
  ^cons(%h, %t): ...
}
</code></pre>
<h3 id="성공-기준-달성-확인-1"><a class="header" href="#성공-기준-달성-확인-1">성공 기준 달성 확인</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""> List의 메모리 표현(tagged union)을 이해한다</li>
<li><input disabled="" type="checkbox" checked=""> <code>!funlang.list&lt;T&gt;</code> 타입을 TableGen으로 정의할 수 있다</li>
<li><input disabled="" type="checkbox" checked=""> <code>funlang.nil</code>과 <code>funlang.cons</code>의 동작 원리를 안다</li>
<li><input disabled="" type="checkbox" checked=""> TypeConverter로 FunLang → LLVM 타입 변환을 구현할 수 있다</li>
<li><input disabled="" type="checkbox" checked=""> Lowering pattern으로 operation을 LLVM dialect로 변환할 수 있다</li>
<li><input disabled="" type="checkbox" checked=""> Chapter 19에서 <code>funlang.match</code> 구현을 시작할 준비가 된다</li>
</ul>
<h3 id="chapter-19-preview-match-compilation"><a class="header" href="#chapter-19-preview-match-compilation">Chapter 19 Preview: Match Compilation</a></h3>
<p><strong>Chapter 19의 목표:</strong></p>
<p><code>funlang.match</code> operation으로 패턴 매칭을 MLIR로 표현하고, decision tree 알고리즘을 lowering으로 구현한다.</p>
<p><strong>funlang.match operation (preview):</strong></p>
<pre><code class="language-mlir">%sum = funlang.match %list : !funlang.list&lt;i32&gt; -&gt; i32 {
  ^nil:
    %zero = arith.constant 0 : i32
    funlang.yield %zero : i32

  ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
    %sum_tail = func.call @sum_list(%tail) : (!funlang.list&lt;i32&gt;) -&gt; i32
    %result = arith.addi %head, %sum_tail : i32
    funlang.yield %result : i32
}
</code></pre>
<p><strong>Lowering strategy:</strong></p>
<pre><code class="language-mlir">// funlang.match lowering → scf.if + tag dispatch

// Extract tag
%tag_ptr = llvm.getelementptr %list[0] : ...
%tag = llvm.load %tag_ptr : ...

// Dispatch
%is_nil = arith.cmpi eq, %tag, %c0 : i32
%result = scf.if %is_nil -&gt; i32 {
  // Nil case
  %zero = arith.constant 0 : i32
  scf.yield %zero : i32
} else {
  // Cons case: extract head and tail
  %data_ptr = llvm.getelementptr %list[1] : ...
  %cell = llvm.load %data_ptr : ...
  %head = llvm.load %head_ptr : ...
  %tail = llvm.load %tail_ptr : ...

  // Execute cons body
  %sum_tail = func.call @sum_list(%tail) : ...
  %result = arith.addi %head, %sum_tail : i32
  scf.yield %result : i32
}
</code></pre>
<p><strong>Chapter 19 구조:</strong></p>
<ol>
<li><strong>funlang.match Operation</strong>: Region-based pattern matching</li>
<li><strong>MatchOp Lowering</strong>: Decision tree → scf.if/cf.br</li>
<li><strong>Pattern Decomposition</strong>: Tag dispatch + field extraction</li>
<li><strong>Exhaustiveness Checking</strong>: Verification at operation level</li>
<li><strong>End-to-End Examples</strong>: sum_list, length, map, filter</li>
</ol>
<h3 id="phase-6-progress"><a class="header" href="#phase-6-progress">Phase 6 Progress</a></h3>
<p><strong>Completed:</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""> Chapter 17: Pattern Matching Theory (decision tree algorithm)</li>
<li><input disabled="" type="checkbox" checked=""> Chapter 18: List Operations (nil, cons, lowering)</li>
</ul>
<p><strong>Remaining:</strong></p>
<ul>
<li><input disabled="" type="checkbox"> Chapter 19: Match Compilation (funlang.match operation and lowering)</li>
<li><input disabled="" type="checkbox"> Chapter 20: Functional Programs (실전 예제: map, filter, fold)</li>
</ul>
<p><strong>Phase 6이 완료되면:</strong></p>
<ul>
<li>완전한 함수형 언어 (closures + pattern matching + data structures)</li>
<li>Real-world functional programs 작성 가능</li>
<li>Phase 7 (optimizations)의 기반 완성</li>
</ul>
<h3 id="마무리"><a class="header" href="#마무리">마무리</a></h3>
<p><strong>Chapter 18에서 배운 핵심 개념:</strong></p>
<ol>
<li><strong>Parameterized types</strong>: <code>!funlang.list&lt;T&gt;</code> for type safety</li>
<li><strong>Tagged unions</strong>: Runtime representation of sum types</li>
<li><strong>GC allocation</strong>: Heap-allocated cons cells</li>
<li><strong>Type erasure</strong>: Element type as compile-time information</li>
<li><strong>ConversionPattern</strong>: OpConversionPattern + TypeConverter + OpAdaptor</li>
</ol>
<p><strong>Next chapter: Let’s implement pattern matching with funlang.match!</strong></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-19-match-compilation-match-compilation"><a class="header" href="#chapter-19-match-compilation-match-compilation">Chapter 19: Match Compilation (Match Compilation)</a></h1>
<h2 id="소개-19"><a class="header" href="#소개-19">소개</a></h2>
<p><strong>Chapter 17</strong>에서는 패턴 매칭의 <strong>이론적 기반</strong>을 다뤘다:</p>
<ul>
<li>Decision tree 알고리즘 (Maranget 2008)</li>
<li>Pattern matrix와 specialization/defaulting 연산</li>
<li>Exhaustiveness checking과 unreachable case detection</li>
</ul>
<p><strong>Chapter 18</strong>에서는 패턴 매칭이 작동할 <strong>데이터 구조</strong>를 구현했다:</p>
<ul>
<li><code>!funlang.list&lt;T&gt;</code> parameterized type</li>
<li><code>funlang.nil</code>과 <code>funlang.cons</code> operations</li>
<li>TypeConverter로 tagged union 변환</li>
<li>NilOpLowering과 ConsOpLowering patterns</li>
</ul>
<p><strong>Chapter 19</strong>에서는 모든 것을 종합하여 <strong>패턴 매칭 컴파일</strong>을 완성한다. <code>funlang.match</code> operation을 정의하고 SCF dialect로 lowering하여 실행 가능한 코드를 생성한다.</p>
<h3 id="두-장의-복습-왜-match-operation이-필요한가"><a class="header" href="#두-장의-복습-왜-match-operation이-필요한가">두 장의 복습: 왜 Match Operation이 필요한가?</a></h3>
<p>Chapter 17에서 우리는 decision tree 알고리즘을 배웠다:</p>
<pre><code class="language-fsharp">// F# 패턴 매칭 예제
let rec sum_list lst =
    match lst with
    | [] -&gt; 0
    | head :: tail -&gt; head + sum_list tail

sum_list [1; 2; 3]  // 6
</code></pre>
<p>Decision tree 컴파일 결과:</p>
<pre><code>Switch on lst:
  Case Nil -&gt; return 0
  Case Cons(head, tail) -&gt; return head + sum_list tail
</code></pre>
<p>Chapter 18에서 우리는 리스트 데이터 구조를 구현했다:</p>
<pre><code class="language-mlir">// Empty list
%empty = funlang.nil : !funlang.list&lt;i32&gt;

// List construction: [1, 2, 3]
%three = arith.constant 3 : i32
%t3 = funlang.nil : !funlang.list&lt;i32&gt;
%l3 = funlang.cons %three, %t3 : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;

%two = arith.constant 2 : i32
%l2 = funlang.cons %two, %l3 : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;

%one = arith.constant 1 : i32
%l1 = funlang.cons %one, %l2 : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;
</code></pre>
<p><strong>이제 이 두 가지를 연결할 방법이 필요하다:</strong></p>
<pre><code class="language-mlir">// 목표: sum_list를 MLIR로 표현
func.func @sum_list(%lst: !funlang.list&lt;i32&gt;) -&gt; i32 {
  %result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
    ^nil:
      %zero = arith.constant 0 : i32
      funlang.yield %zero : i32
    ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
      %tail_sum = func.call @sum_list(%tail) : (!funlang.list&lt;i32&gt;) -&gt; i32
      %sum = arith.addi %head, %tail_sum : i32
      funlang.yield %sum : i32
  }
  return %result : i32
}
</code></pre>
<h3 id="funlangmatch-the-most-complex-operation"><a class="header" href="#funlangmatch-the-most-complex-operation">funlang.match: The Most Complex Operation</a></h3>
<p><strong>왜 <code>funlang.match</code>가 가장 복잡한가?</strong></p>
<p>지금까지 우리가 구현한 FunLang operations:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Complexity</th><th>Why</th></tr>
</thead>
<tbody>
<tr><td><code>funlang.nil</code></td><td>Simple</td><td>Zero arguments, constant value</td></tr>
<tr><td><code>funlang.cons</code></td><td>Moderate</td><td>Two operands, GC allocation</td></tr>
<tr><td><code>funlang.closure</code></td><td>Moderate</td><td>Function ref + captures, GC allocation</td></tr>
<tr><td><code>funlang.apply</code></td><td>Moderate</td><td>Indirect call, block arguments</td></tr>
<tr><td><strong><code>funlang.match</code></strong></td><td><strong>Complex</strong></td><td><strong>Multiple regions, block arguments, type conversion</strong></td></tr>
</tbody>
</table>
</div>
<p><strong><code>funlang.match</code>의 복잡성:</strong></p>
<ol>
<li><strong>Region-based structure</strong>: 각 case가 별도의 region (not just basic block)</li>
<li><strong>Variable number of cases</strong>: Nil/Cons 2개부터 임의의 pattern 개수까지</li>
<li><strong>Block arguments per case</strong>: Cons case는 <code>(%head, %tail)</code> 같은 바인딩 필요</li>
<li><strong>Type conversion in regions</strong>: 각 region 내부의 operations도 lowering 필요</li>
<li><strong>Multi-stage lowering</strong>: FunLang → SCF → CF → LLVM</li>
</ol>
<p><strong>Chapter 15 Preview 복습:</strong></p>
<p>Chapter 15에서 우리는 <code>funlang.match</code>를 미리 살짝 봤다:</p>
<pre><code class="language-tablegen">// Chapter 15의 preview (간략 버전)
def FunLang_MatchOp : FunLang_Op&lt;"match"&gt; {
  let summary = "Pattern matching operation";
  let arguments = (ins AnyType:$input);
  let results = (outs AnyType:$result);
  let regions = (region VariadicRegion&lt;SizedRegion&lt;1&gt;&gt;:$cases);
}
</code></pre>
<p><strong>Chapter 19에서는 완전한 버전을 구현한다:</strong></p>
<ul>
<li>Full TableGen definition with verification</li>
<li>Custom assembly format (parser/printer)</li>
<li>C API shim for region-based operation</li>
<li>F# bindings with builder callback</li>
<li>Lowering pattern to SCF dialect</li>
</ul>
<h3 id="multi-stage-lowering-funlang--scf--llvm"><a class="header" href="#multi-stage-lowering-funlang--scf--llvm">Multi-Stage Lowering: FunLang → SCF → LLVM</a></h3>
<p><strong>왜 SCF dialect를 거치는가?</strong></p>
<p>Phase 5에서 우리는 FunLang operations를 직접 LLVM dialect로 lowering했다:</p>
<pre><code>funlang.closure → llvm.alloca + llvm.store  (direct lowering)
funlang.apply   → llvm.load + llvm.call     (direct lowering)
</code></pre>
<p><strong>하지만 <code>funlang.match</code>는 다르다:</strong></p>
<pre><code>funlang.match → scf.index_switch → cf.switch → llvm.switch
              (structured)        (CFG)       (machine)
</code></pre>
<p><strong>이유:</strong></p>
<ol>
<li><strong>Structured control flow preservation</strong>: SCF는 high-level structure 유지</li>
<li><strong>Optimization opportunities</strong>: SCF level에서 최적화 가능 (dead case elimination, etc.)</li>
<li><strong>Debugging</strong>: SCF IR이 source 구조를 반영하여 디버깅 쉬움</li>
<li><strong>Separation of concerns</strong>: Pattern matching logic과 low-level branching 분리</li>
</ol>
<p><strong>SCF Dialect란?</strong></p>
<p>SCF = <strong>Structured Control Flow</strong></p>
<p>MLIR의 standard dialect 중 하나로, high-level control flow operations 제공:</p>
<pre><code class="language-mlir">// scf.if: two-way branching (Chapter 8에서 사용)
%result = scf.if %cond : i1 -&gt; i32 {
  %x = arith.constant 42 : i32
  scf.yield %x : i32
} else {
  %y = arith.constant 0 : i32
  scf.yield %y : i32
}

// scf.index_switch: multi-way branching (Chapter 19에서 사용)
%result = scf.index_switch %tag : index -&gt; i32
case 0 {
  %zero = arith.constant 0 : i32
  scf.yield %zero : i32
}
case 1 {
  %one = arith.constant 1 : i32
  scf.yield %one : i32
}
default {
  %minus = arith.constant -1 : i32
  scf.yield %minus : i32
}
</code></pre>
<p><strong>SCF vs CF (Control Flow) dialect:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Dialect</th><th>Level</th><th>Structure</th><th>When</th></tr>
</thead>
<tbody>
<tr><td>SCF</td><td>High-level</td><td>Structured (nested regions)</td><td>Pattern matching, loops</td></tr>
<tr><td>CF</td><td>Low-level</td><td>Unstructured (goto-like)</td><td>After SCF lowering</td></tr>
</tbody>
</table>
</div>
<p><strong>Complete lowering pipeline:</strong></p>
<pre><code>FunLang Dialect
    ↓ (FunLangToSCFPass)
SCF + FunLang (partially lowered)
    ↓ (FunLangToLLVMPass - for nil/cons/closure/apply)
SCF + LLVM
    ↓ (SCFToControlFlowPass)
CF + LLVM
    ↓ (ControlFlowToLLVMPass)
LLVM Dialect only
    ↓ (LLVMToObjectPass)
Machine code
</code></pre>
<h3 id="chapter-19-goals"><a class="header" href="#chapter-19-goals">Chapter 19 Goals</a></h3>
<p><strong>이 장에서 배울 것:</strong></p>
<ol>
<li>
<p><strong>Match Operation Definition</strong> (Part 1)</p>
<ul>
<li>Region-based operation structure</li>
<li>TableGen definition with VariadicRegion</li>
<li>Custom verifier for region semantics</li>
<li>YieldOp terminator for match results</li>
<li>C API shim for region-based operations</li>
<li>F# bindings with builder callback pattern</li>
</ul>
</li>
<li>
<p><strong>SCF Lowering</strong> (Part 2)</p>
<ul>
<li>SCF dialect overview and <code>scf.index_switch</code></li>
<li>MatchOpLowering pattern implementation</li>
<li>Region cloning and type conversion</li>
<li>Block argument remapping</li>
<li>Common errors and debugging strategies</li>
</ul>
</li>
<li>
<p><strong>End-to-End Example</strong></p>
<ul>
<li>length function: complete compilation pipeline</li>
<li>Stage-by-stage IR transformation</li>
<li>Performance comparison vs naive approach</li>
</ul>
</li>
</ol>
<p><strong>Success criteria:</strong></p>
<ul>
<li>✅ <code>funlang.match</code> operation defined and verified</li>
<li>✅ Lowering to <code>scf.index_switch</code> working</li>
<li>✅ Pattern variables bound via block arguments</li>
<li>✅ End-to-end compilation of recursive list functions</li>
</ul>
<p>Let’s begin!</p>
<hr>
<h2 id="part-1-match-operation-definition"><a class="header" href="#part-1-match-operation-definition">Part 1: Match Operation Definition</a></h2>
<h3 id="region-based-operations-the-foundation"><a class="header" href="#region-based-operations-the-foundation">Region-Based Operations: The Foundation</a></h3>
<p><strong>Region이란 무엇인가?</strong></p>
<p>MLIR에서 <strong>region</strong>은 <strong>basic blocks의 container</strong>다.</p>
<pre><code>Region
  ├─ Block 1 (entry block)
  │   ├─ Operation 1
  │   ├─ Operation 2
  │   └─ Terminator
  ├─ Block 2
  │   └─ ...
  └─ Block N
</code></pre>
<p><strong>우리가 이미 본 region-based operations:</strong></p>
<p>Chapter 8에서 <code>scf.if</code>:</p>
<pre><code class="language-mlir">scf.if %cond : i1 -&gt; i32 {
  // "then" region (1 block)
  %x = arith.constant 42 : i32
  scf.yield %x : i32
} else {
  // "else" region (1 block)
  %y = arith.constant 0 : i32
  scf.yield %y : i32
}
</code></pre>
<ul>
<li><code>scf.if</code>는 2개의 regions (then, else)</li>
<li>각 region은 exactly 1 block</li>
<li>각 block은 <code>scf.yield</code> terminator로 끝남</li>
</ul>
<p>Chapter 10에서 <code>func.func</code>:</p>
<pre><code class="language-mlir">func.func @my_function(%arg: i32) -&gt; i32 {
  // function body region (1 or more blocks)
  %result = arith.addi %arg, %arg : i32
  return %result : i32
}
</code></pre>
<ul>
<li><code>func.func</code>는 1개의 region (body)</li>
<li>Region은 1개 이상의 blocks (control flow로 여러 block 가능)</li>
<li>Entry block은 function arguments as block arguments</li>
</ul>
<p><strong>왜 basic blocks이 아니라 regions인가?</strong></p>
<p><strong>Scenario: match expression with 3 cases</strong></p>
<pre><code class="language-fsharp">// F# code
match shape with
| Circle r -&gt; compute_circle_area r
| Rectangle (w, h) -&gt; compute_rectangle_area w h
| Triangle (a, b, c) -&gt; compute_triangle_area a b c
</code></pre>
<p><strong>Option 1: Basic blocks (NOT what we do)</strong></p>
<pre><code class="language-mlir">// 잘못된 접근: basic blocks only
func.func @match_shape(%shape: !funlang.shape) -&gt; f32 {
  // ... tag extraction ...
  cf.br ^dispatch

^dispatch:
  cf.switch %tag [
    ^circle,
    ^rectangle,
    ^triangle
  ]

^circle:
  // Circle case logic
  cf.br ^exit

^rectangle:
  // Rectangle case logic
  cf.br ^exit

^triangle:
  // Triangle case logic
  cf.br ^exit

^exit(%result: f32):
  return %result : f32
}
</code></pre>
<p><strong>문제점:</strong></p>
<ol>
<li><strong>All blocks in same scope</strong>: ^circle, ^rectangle, ^triangle은 모두 같은 function body region</li>
<li><strong>No encapsulation</strong>: Case logic이 function CFG에 섞임</li>
<li><strong>Hard to verify</strong>: “각 case가 정확히 1개의 yield를 가지는가?” 검증 어려움</li>
<li><strong>Type conversion complexity</strong>: Lowering pass가 case blocks을 구분하기 어려움</li>
</ol>
<p><strong>Option 2: Regions (What we do)</strong></p>
<pre><code class="language-mlir">// 올바른 접근: regions
func.func @match_shape(%shape: !funlang.shape) -&gt; f32 {
  %result = funlang.match %shape : !funlang.shape -&gt; f32 {
    ^circle(%r: f32):
      %area = call @compute_circle_area(%r) : (f32) -&gt; f32
      funlang.yield %area : f32
    ^rectangle(%w: f32, %h: f32):
      %area = call @compute_rectangle_area(%w, %h) : (f32, f32) -&gt; f32
      funlang.yield %area : f32
    ^triangle(%a: f32, %b: f32, %c: f32):
      %area = call @compute_triangle_area(%a, %b, %c) : (f32, f32, f32) -&gt; f32
      funlang.yield %area : f32
  }
  return %result : f32
}
</code></pre>
<p><strong>장점:</strong></p>
<ol>
<li><strong>Encapsulation</strong>: 각 case가 자신만의 region (isolated scope)</li>
<li><strong>Clear structure</strong>: match operation이 모든 cases를 소유</li>
<li><strong>Easy verification</strong>: 각 region은 정확히 1 block, 1 terminator</li>
<li><strong>Lowering-friendly</strong>: Region 단위로 type conversion 수행 가능</li>
</ol>
<p><strong>Region vs Block vs Operation:</strong></p>
<pre><code>Operation: funlang.match
  ↓ has
Regions: [case 1 region, case 2 region, ...]
  ↓ each contains
Blocks: [entry block]
  ↓ contains
Operations: [arith.constant, func.call, funlang.yield, ...]
</code></pre>
<h3 id="match-operation-semantics"><a class="header" href="#match-operation-semantics">Match Operation Semantics</a></h3>
<p><strong><code>funlang.match</code>의 의미론:</strong></p>
<pre><code class="language-mlir">%result = funlang.match %input : InputType -&gt; ResultType {
  ^case1(...pattern_vars1...):
    // case 1 logic
    funlang.yield %value1 : ResultType
  ^case2(...pattern_vars2...):
    // case 2 logic
    funlang.yield %value2 : ResultType
  ...
}
</code></pre>
<p><strong>Execution semantics:</strong></p>
<ol>
<li><strong>Input evaluation</strong>: <code>%input</code> 값을 runtime에 evaluate</li>
<li><strong>Tag extraction</strong>: Tagged union에서 tag value 추출</li>
<li><strong>Case selection</strong>: Tag에 따라 해당 region 선택</li>
<li><strong>Pattern variable binding</strong>: Region의 block arguments에 values 바인딩</li>
<li><strong>Case execution</strong>: 선택된 region 실행</li>
<li><strong>Result yielding</strong>: Region의 <code>funlang.yield</code>가 <code>%result</code>에 값 전달</li>
</ol>
<p><strong>Example: sum_list</strong></p>
<pre><code class="language-mlir">func.func @sum_list(%lst: !funlang.list&lt;i32&gt;) -&gt; i32 {
  %result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
    ^nil:
      %zero = arith.constant 0 : i32
      funlang.yield %zero : i32
    ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
      %tail_sum = func.call @sum_list(%tail) : (!funlang.list&lt;i32&gt;) -&gt; i32
      %sum = arith.addi %head, %tail_sum : i32
      funlang.yield %sum : i32
  }
  return %result : i32
}
</code></pre>
<p><strong>Runtime execution: sum_list([1, 2])</strong></p>
<ol>
<li><strong>Call</strong>: <code>@sum_list([1, 2])</code></li>
<li><strong>Tag extraction</strong>: Tag = 1 (Cons)</li>
<li><strong>Case selection</strong>: ^cons region</li>
<li><strong>Variable binding</strong>: <code>%head = 1</code>, <code>%tail = [2]</code></li>
<li><strong>Recursive call</strong>: <code>@sum_list([2])</code>
<ul>
<li>Tag = 1 (Cons)</li>
<li><code>%head = 2</code>, <code>%tail = []</code></li>
<li>Recursive call: <code>@sum_list([])</code>
<ul>
<li>Tag = 0 (Nil)</li>
<li>Return 0</li>
</ul>
</li>
<li><code>%sum = 2 + 0 = 2</code></li>
<li>Return 2</li>
</ul>
</li>
<li><strong>Final sum</strong>: <code>1 + 2 = 3</code></li>
<li><strong>Return</strong>: 3</li>
</ol>
<h3 id="block-arguments-for-pattern-variables"><a class="header" href="#block-arguments-for-pattern-variables">Block Arguments for Pattern Variables</a></h3>
<p><strong>패턴 변수는 어떻게 바인딩되는가?</strong></p>
<p>Chapter 2에서 우리는 <strong>block arguments</strong>를 배웠다:</p>
<pre><code class="language-mlir">^entry_block(%arg0: i32, %arg1: i32):
  %sum = arith.addi %arg0, %arg1 : i32
</code></pre>
<p>Block arguments는 PHI nodes의 structured 대안이다.</p>
<p><strong>Match operation에서 block arguments 활용:</strong></p>
<pre><code class="language-mlir">funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
  ^nil:
    // Nil case: 패턴 변수 없음 → block arguments 없음
    funlang.yield %zero : i32

  ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
    // Cons case: 2개 패턴 변수 → 2개 block arguments
    // %head: i32          → cons cell의 head field
    // %tail: !funlang.list&lt;i32&gt; → cons cell의 tail field
    funlang.yield %sum : i32
}
</code></pre>
<p><strong>Lowering이 block arguments를 채우는 방법:</strong></p>
<pre><code class="language-mlir">// funlang.match lowering 후 (pseudo-code)
%tag = // extract tag from %lst
scf.index_switch %tag {
  case 0 {  // Nil case
    // No data to extract, no arguments
    %zero = arith.constant 0 : i32
    scf.yield %zero : i32
  }
  case 1 {  // Cons case
    // Extract head and tail from cons cell
    %head = // extract field 0 from data pointer
    %tail = // extract field 1 from data pointer
    // Now pass to the ^cons block's body (with arguments bound)
    ^cons(%head, %tail):
      // User code here
  }
}
</code></pre>
<p><strong>실제로는 region을 clone하고 IRMapping으로 arguments를 remap한다</strong> (Part 2에서 자세히)</p>
<p><strong>Block arguments vs Let bindings:</strong></p>
<pre><code class="language-mlir">// Option 1: Block arguments (what we do)
^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
  %sum = arith.addi %head, ... : i32

// Option 2: Let-style extraction (what we DON'T do)
^cons:
  %head = funlang.extract_head %lst : !funlang.list&lt;i32&gt; -&gt; i32
  %tail = funlang.extract_tail %lst : !funlang.list&lt;i32&gt; -&gt; !funlang.list&lt;i32&gt;
  %sum = arith.addi %head, ... : i32
</code></pre>
<p><strong>Block arguments가 더 나은 이유:</strong></p>
<ol>
<li><strong>Declarative</strong>: Pattern structure가 arguments에 직접 반영</li>
<li><strong>SSA-friendly</strong>: Block entry에서 values가 이미 available</li>
<li><strong>No redundant ops</strong>: extract operations 불필요</li>
<li><strong>Verification</strong>: Argument types로 pattern structure 검증 가능</li>
</ol>
<h3 id="tablegen-definition-matchop"><a class="header" href="#tablegen-definition-matchop">TableGen Definition: MatchOp</a></h3>
<p>이제 <code>funlang.match</code> operation의 TableGen 정의를 작성한다.</p>
<p><strong>File: <code>FunLang/FunLangOps.td</code></strong> (conceptual, 실제로는 C++ codebase)</p>
<pre><code class="language-tablegen">def FunLang_MatchOp : FunLang_Op&lt;"match", [
    RecursiveSideEffect,
    SingleBlockImplicitTerminator&lt;"YieldOp"&gt;
  ]&gt; {
  let summary = "Pattern matching operation";
  let description = [{
    The `funlang.match` operation performs pattern matching on a value.
    Each case is represented as a separate region with exactly one block.

    The entry block of each region may have arguments corresponding to
    pattern variables. For example, a Cons case has two arguments:
    the head element and the tail list.

    Each region must terminate with a `funlang.yield` operation that
    returns a value of the result type.

    Example:
    ```mlir
    %result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
      ^nil:
        %zero = arith.constant 0 : i32
        funlang.yield %zero : i32
      ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
        %sum = func.call @sum_list(%tail) : (!funlang.list&lt;i32&gt;) -&gt; i32
        %result = arith.addi %head, %sum : i32
        funlang.yield %result : i32
    }
    ```
  }];

  let arguments = (ins AnyType:$input);
  let results = (outs AnyType:$result);
  let regions = (region VariadicRegion&lt;SizedRegion&lt;1&gt;&gt;:$cases);

  let hasCustomAssemblyFormat = 1;
  let hasVerifier = 1;
}
</code></pre>
<p><strong>핵심 요소 설명:</strong></p>
<p><strong>1. Traits: RecursiveSideEffect</strong></p>
<pre><code class="language-tablegen">RecursiveSideEffect
</code></pre>
<p><strong>의미:</strong> 이 operation의 side effects는 내부 regions의 operations에 의존한다.</p>
<p><strong>왜 필요한가?</strong></p>
<p>MLIR optimizer는 side effects를 분석하여 dead code elimination, common subexpression elimination 등을 수행한다.</p>
<ul>
<li><code>funlang.nil</code>은 <code>Pure</code> trait → no side effects</li>
<li><code>funlang.cons</code>는 side effects 있음 (GC allocation)</li>
</ul>
<p><strong>Match operation은?</strong></p>
<pre><code class="language-mlir">%result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
  ^nil:
    %x = funlang.nil : !funlang.list&lt;i32&gt;  // Pure
    funlang.yield %zero : i32
  ^cons(%h, %t):
    %y = funlang.cons %h, %t : ...  // Side effect!
    funlang.yield %sum : i32
}
</code></pre>
<ul>
<li>Nil case: no side effects</li>
<li>Cons case: side effect (funlang.cons)</li>
</ul>
<p><strong>RecursiveSideEffect trait는 MLIR에게 말한다:</strong></p>
<p>“이 operation의 side effects는 내부 regions을 재귀적으로 분석해서 결정해라”</p>
<p><strong>없으면 어떻게 되나?</strong></p>
<ul>
<li>Conservative assumption: match는 항상 side effects 있음</li>
<li>Optimizer가 legitimate optimizations를 못함</li>
<li>예: dead match elimination 불가</li>
</ul>
<p><strong>2. Traits: SingleBlockImplicitTerminator</strong></p>
<pre><code class="language-tablegen">SingleBlockImplicitTerminator&lt;"YieldOp"&gt;
</code></pre>
<p><strong>의미:</strong> 각 region은 정확히 1개의 block을 가지며, 그 block은 <code>YieldOp</code>로 끝나야 한다.</p>
<p><strong>검증 자동화:</strong></p>
<p>이 trait가 있으면 MLIR이 자동으로 검증:</p>
<ol>
<li>각 region이 정확히 1 block인가?</li>
<li>그 block이 <code>funlang.yield</code>로 끝나는가?</li>
</ol>
<p><strong>없으면 어떻게 되나?</strong></p>
<p>Custom verifier에서 수동 검증 필요:</p>
<pre><code class="language-cpp">// Without the trait (manual verification)
LogicalResult MatchOp::verify() {
  for (Region&amp; region : getCases()) {
    if (!region.hasOneBlock()) {
      return emitError("each case must have exactly one block");
    }
    Block&amp; block = region.front();
    if (!isa&lt;YieldOp&gt;(block.getTerminator())) {
      return emitError("each case must terminate with funlang.yield");
    }
  }
  return success();
}
</code></pre>
<p>Trait가 이 boilerplate를 제거한다!</p>
<p><strong>3. Regions: VariadicRegion&lt;SizedRegion&lt;1&gt;&gt;</strong></p>
<pre><code class="language-tablegen">let regions = (region VariadicRegion&lt;SizedRegion&lt;1&gt;&gt;:$cases);
</code></pre>
<p><strong>분해:</strong></p>
<ul>
<li><code>VariadicRegion</code>: 가변 개수의 regions (Nil/Cons = 2개, 더 많은 patterns = N개)</li>
<li><code>SizedRegion&lt;1&gt;</code>: 각 region은 정확히 1개의 block</li>
<li><code>:$cases</code>: C++ accessor name → <code>getCases()</code> method</li>
</ul>
<p><strong>대안들과 비교:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Declaration</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>region AnyRegion:$body</code></td><td>Exactly 1 region, any number of blocks</td></tr>
<tr><td><code>region SizedRegion&lt;1&gt;:$body</code></td><td>Exactly 1 region, exactly 1 block</td></tr>
<tr><td><code>region VariadicRegion&lt;AnyRegion&gt;:$cases</code></td><td>N regions, each with any blocks</td></tr>
<tr><td><code>region VariadicRegion&lt;SizedRegion&lt;1&gt;&gt;:$cases</code></td><td>N regions, each with 1 block ✅</td></tr>
</tbody>
</table>
</div>
<p><strong>scf.if와 비교:</strong></p>
<pre><code class="language-tablegen">// scf.if (exactly 2 regions)
def SCF_IfOp : ... {
  let regions = (region SizedRegion&lt;1&gt;:$thenRegion,
                        SizedRegion&lt;1&gt;:$elseRegion);
}

// funlang.match (variable number of regions)
def FunLang_MatchOp : ... {
  let regions = (region VariadicRegion&lt;SizedRegion&lt;1&gt;&gt;:$cases);
}
</code></pre>
<p><strong>4. Custom Assembly Format</strong></p>
<pre><code class="language-tablegen">let hasCustomAssemblyFormat = 1;
</code></pre>
<p><strong>이유:</strong> Generic format은 readable하지 않다.</p>
<p><strong>Generic format (자동 생성):</strong></p>
<pre><code class="language-mlir">%result = "funlang.match"(%lst) ({
  ^bb0:
    %zero = arith.constant 0 : i32
    "funlang.yield"(%zero) : (i32) -&gt; ()
}, {
  ^bb0(%head: i32, %tail: !funlang.list&lt;i32&gt;):
    %sum = arith.addi %head, %tail_sum : i32
    "funlang.yield"(%sum) : (i32) -&gt; ()
}) : (!funlang.list&lt;i32&gt;) -&gt; i32
</code></pre>
<p><strong>Custom format (우리가 작성):</strong></p>
<pre><code class="language-mlir">%result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
  ^nil:
    %zero = arith.constant 0 : i32
    funlang.yield %zero : i32
  ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
    %sum = arith.addi %head, %tail_sum : i32
    funlang.yield %sum : i32
}
</code></pre>
<p><strong>Custom parser/printer 구현 필요 (C++ code):</strong></p>
<pre><code class="language-cpp">// File: FunLangOps.cpp

void MatchOp::print(OpAsmPrinter&amp; p) {
  p &lt;&lt; " " &lt;&lt; getInput() &lt;&lt; " : " &lt;&lt; getInput().getType()
    &lt;&lt; " -&gt; " &lt;&lt; getResult().getType() &lt;&lt; " ";

  p.printRegion(getCases(), /*printEntryBlockArgs=*/true);
}

ParseResult MatchOp::parse(OpAsmParser&amp; parser, OperationState&amp; result) {
  OpAsmParser::UnresolvedOperand input;
  Type inputType, resultType;
  Region* casesRegion = result.addRegion();

  if (parser.parseOperand(input) ||
      parser.parseColon() ||
      parser.parseType(inputType) ||
      parser.parseArrow() ||
      parser.parseType(resultType) ||
      parser.parseRegion(*casesRegion, /*arguments=*/{}, /*argTypes=*/{}))
    return failure();

  result.addTypes(resultType);
  return success();
}
</code></pre>
<p><em>실제 구현은 더 복잡하지만, F# tutorial에서는 C API로 추상화됨</em></p>
<p><strong>5. Custom Verifier</strong></p>
<pre><code class="language-tablegen">let hasVerifier = 1;
</code></pre>
<p><strong>검증할 내용:</strong></p>
<ol>
<li>✅ Region count &gt; 0</li>
<li>✅ 각 region의 block arguments types 검증</li>
<li>✅ 각 region의 yield type이 result type과 일치</li>
<li>✅ Input type이 matchable type (현재는 !funlang.list<t>)</t></li>
</ol>
<p><strong>C++ verifier implementation:</strong></p>
<pre><code class="language-cpp">// File: FunLangOps.cpp

LogicalResult MatchOp::verify() {
  // Check: at least one case
  if (getCases().empty()) {
    return emitError("match must have at least one case");
  }

  Type resultType = getResult().getType();

  // Check each case region
  for (Region&amp; region : getCases()) {
    if (region.empty())
      return emitError("case region cannot be empty");

    Block&amp; block = region.front();

    // Verify terminator (already checked by SingleBlockImplicitTerminator)
    auto yieldOp = dyn_cast&lt;YieldOp&gt;(block.getTerminator());
    if (!yieldOp)
      return emitError("case must terminate with funlang.yield");

    // Verify yield type matches result type
    if (yieldOp.getValue().getType() != resultType) {
      return emitError("yield type ")
             &lt;&lt; yieldOp.getValue().getType()
             &lt;&lt; " does not match result type " &lt;&lt; resultType;
    }
  }

  return success();
}
</code></pre>
<p><strong>실전 예제:</strong></p>
<pre><code class="language-mlir">// ERROR: No cases
%result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
}
// Error: match must have at least one case

// ERROR: Type mismatch
%result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
  ^nil:
    %x = arith.constant 3.14 : f32  // Wrong type!
    funlang.yield %x : f32
}
// Error: yield type f32 does not match result type i32
</code></pre>
<h3 id="yieldop-match-result-terminator"><a class="header" href="#yieldop-match-result-terminator">YieldOp: Match Result Terminator</a></h3>
<p><strong>각 match case는 <code>funlang.yield</code>로 끝나야 한다.</strong></p>
<p><strong>TableGen definition:</strong></p>
<pre><code class="language-tablegen">def FunLang_YieldOp : FunLang_Op&lt;"yield", [
    Terminator,
    HasParent&lt;"MatchOp"&gt;
  ]&gt; {
  let summary = "Yield a value from a match case";
  let description = [{
    The `funlang.yield` operation terminates a match case region and
    returns a value to the parent `funlang.match` operation.

    Example:
    ```mlir
    funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
      ^nil:
        %zero = arith.constant 0 : i32
        funlang.yield %zero : i32  // Yield from nil case
      ^cons(%h, %t):
        %sum = arith.addi %h, ... : i32
        funlang.yield %sum : i32   // Yield from cons case
    }
    ```
  }];

  let arguments = (ins AnyType:$value);
  let results = (outs);

  let assemblyFormat = "$value attr-dict `:` type($value)";
}
</code></pre>
<p><strong>핵심 요소:</strong></p>
<p><strong>1. Trait: Terminator</strong></p>
<pre><code class="language-tablegen">Terminator
</code></pre>
<p><strong>의미:</strong> 이 operation은 basic block을 종료한다.</p>
<p><strong>Block의 terminator 규칙:</strong></p>
<ul>
<li>모든 block은 정확히 1개의 terminator로 끝나야 함</li>
<li>Terminator는 block의 마지막 operation이어야 함</li>
<li>Terminator 예: <code>func.return</code>, <code>cf.br</code>, <code>scf.yield</code>, <code>funlang.yield</code></li>
</ul>
<p><strong>2. Trait: HasParent&lt;“MatchOp”&gt;</strong></p>
<pre><code class="language-tablegen">HasParent&lt;"MatchOp"&gt;
</code></pre>
<p><strong>의미:</strong> 이 operation은 <code>MatchOp</code>의 region 내에서만 사용 가능.</p>
<p><strong>검증 자동화:</strong></p>
<pre><code class="language-mlir">// OK: inside funlang.match
funlang.match %lst {
  ^nil:
    funlang.yield %zero : i32  // ✅
}

// ERROR: outside match
func.func @wrong() -&gt; i32 {
  %x = arith.constant 42 : i32
  funlang.yield %x : i32  // ❌ Error: funlang.yield must be inside MatchOp
}
</code></pre>
<p><strong>3. Assembly Format</strong></p>
<pre><code class="language-tablegen">let assemblyFormat = "$value attr-dict `:` type($value)";
</code></pre>
<p><strong>생성되는 format:</strong></p>
<pre><code class="language-mlir">funlang.yield %sum : i32
</code></pre>
<p><strong>Generic format과 비교:</strong></p>
<pre><code class="language-mlir">// Generic (verbose)
"funlang.yield"(%sum) : (i32) -&gt; ()

// Custom (readable)
funlang.yield %sum : i32
</code></pre>
<h3 id="scfyield와-비교"><a class="header" href="#scfyield와-비교">scf.yield와 비교</a></h3>
<p><strong>MLIR에는 여러 yield operations이 있다:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Parent</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>scf.yield</code></td><td><code>scf.if</code>, <code>scf.for</code>, <code>scf.while</code></td><td>SCF control flow</td></tr>
<tr><td><code>funlang.yield</code></td><td><code>funlang.match</code></td><td>FunLang pattern matching</td></tr>
<tr><td><code>affine.yield</code></td><td><code>affine.for</code>, <code>affine.if</code></td><td>Affine loops</td></tr>
</tbody>
</table>
</div>
<p><strong>왜 <code>scf.yield</code>를 재사용하지 않는가?</strong></p>
<p><strong>Option 1: 재사용 (하지 않음)</strong></p>
<pre><code class="language-mlir">funlang.match %lst {
  ^nil:
    scf.yield %zero : i32  // Reuse scf.yield?
}
</code></pre>
<p><strong>문제:</strong></p>
<ol>
<li>
<p><strong>Trait conflict</strong>: <code>scf.yield</code>는 <code>HasParent&lt;"IfOp", "ForOp", ...&gt;</code></p>
<ul>
<li><code>MatchOp</code>이 parent list에 없으면 verifier 실패</li>
<li>SCF dialect 수정 필요 (bad coupling)</li>
</ul>
</li>
<li>
<p><strong>Semantic confusion</strong>: <code>scf.yield</code>는 SCF dialect semantics</p>
<ul>
<li>Lowering pass에서 <code>scf.yield</code> 처리 시 match context 고려해야 함</li>
<li>Separation of concerns 위반</li>
</ul>
</li>
</ol>
<p><strong>Option 2: 전용 operation (우리가 하는 것)</strong></p>
<pre><code class="language-mlir">funlang.match %lst {
  ^nil:
    funlang.yield %zero : i32  // FunLang-specific yield
}
</code></pre>
<p><strong>장점:</strong></p>
<ol>
<li><strong>Clear ownership</strong>: FunLang dialect이 자신의 terminators 소유</li>
<li><strong>Lowering flexibility</strong>: <code>funlang.yield</code> → <code>scf.yield</code> 변환을 명시적으로 제어</li>
<li><strong>Future extensions</strong>: 나중에 <code>funlang.yield</code>에 attributes 추가 가능</li>
</ol>
<h3 id="c-api-and-f-integration"><a class="header" href="#c-api-and-f-integration">C API and F# Integration</a></h3>
<p><strong>Region-based operations는 C API 설계가 복잡하다.</strong></p>
<p><strong>문제: Regions를 어떻게 F#에서 구축하는가?</strong></p>
<p><strong>Simple operations (Chapter 15):</strong></p>
<pre><code class="language-fsharp">// funlang.cons: no regions, straightforward
let cons =
    FunLangOps.CreateConsOp(builder, head, tail, listType)
</code></pre>
<p><strong>Region-based operations (Chapter 19):</strong></p>
<pre><code class="language-fsharp">// funlang.match: multiple regions, complex
let matchOp = FunLangOps.CreateMatchOp(builder, input, resultType, [
    // How to build regions here???
    nilRegion;
    consRegion
])
</code></pre>
<p><strong>Challenge:</strong></p>
<ul>
<li>Region 구축은 F# side에서 일어나야 함 (pattern cases logic)</li>
<li>하지만 MLIR C++ API를 직접 호출할 수 없음 (C API만 가능)</li>
<li>Builder callback pattern 필요!</li>
</ul>
<h3 id="c-api-shim-builder-callback-pattern"><a class="header" href="#c-api-shim-builder-callback-pattern">C API Shim: Builder Callback Pattern</a></h3>
<p><strong>Pattern: C API가 F# callback을 받아서 region을 채움</strong></p>
<p><strong>C API shim (C wrapper):</strong></p>
<pre><code class="language-c">// File: FunLang-C/FunLangOps.h

typedef void (*FunLangMatchCaseBuilder)(
    MlirOpBuilder builder,
    MlirBlock block,
    void* userData
);

typedef struct {
    FunLangMatchCaseBuilder builder;
    void* userData;
} FunLangMatchCase;

MLIR_CAPI_EXPORTED MlirOperation funlangMatchOpCreate(
    MlirOpBuilder builder,
    MlirLocation loc,
    MlirValue input,
    MlirType resultType,
    FunLangMatchCase* cases,
    intptr_t numCases
);
</code></pre>
<p><strong>Implementation (C++):</strong></p>
<pre><code class="language-cpp">// File: FunLang-C/FunLangOps.cpp

MlirOperation funlangMatchOpCreate(
    MlirOpBuilder builder,
    MlirLocation loc,
    MlirValue input,
    MlirType resultType,
    FunLangMatchCase* cases,
    intptr_t numCases
) {
  OpBuilder&amp; cppBuilder = unwrap(builder);
  Location cppLoc = unwrap(loc);
  Value cppInput = unwrap(input);
  Type cppResultType = unwrap(resultType);

  // Create match operation
  auto matchOp = cppBuilder.create&lt;MatchOp&gt;(
      cppLoc, cppResultType, cppInput, numCases);

  // Build each case region
  for (intptr_t i = 0; i &lt; numCases; ++i) {
    Region&amp; region = matchOp.getCases()[i];
    Block* block = cppBuilder.createBlock(&amp;region);

    // Invoke F# callback to populate the block
    MlirBlock wrappedBlock = wrap(block);
    cases[i].builder(builder, wrappedBlock, cases[i].userData);
  }

  return wrap(matchOp.getOperation());
}
</code></pre>
<p><strong>핵심 아이디어:</strong></p>
<ol>
<li>C API가 empty regions를 가진 <code>MatchOp</code> 생성</li>
<li>각 region에 대해 F# callback 호출</li>
<li>F# callback이 region의 block을 채움 (operations + yield)</li>
</ol>
<h3 id="f-bindings-3"><a class="header" href="#f-bindings-3">F# Bindings</a></h3>
<p><strong>Low-level binding:</strong></p>
<pre><code class="language-fsharp">// File: FunLang.Interop/FunLangOps.fs

type MatchCaseBuilder =
    MlirOpBuilder -&gt; MlirBlock -&gt; nativeint -&gt; unit

[&lt;Struct&gt;]
type MatchCase =
    val Builder: MatchCaseBuilder
    val UserData: nativeint

    new(builder, userData) =
        { Builder = builder; UserData = userData }

[&lt;DllImport("FunLang-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirOperation funlangMatchOpCreate(
    MlirOpBuilder builder,
    MlirLocation loc,
    MlirValue input,
    MlirType resultType,
    MatchCase[] cases,
    nativeint numCases
)
</code></pre>
<p><strong>High-level wrapper:</strong></p>
<pre><code class="language-fsharp">// File: FunLang.Compiler/OpBuilder.fs

type OpBuilder with
    member this.CreateMatchOp(
        input: MlirValue,
        resultType: MlirType,
        buildCases: (OpBuilder -&gt; Block -&gt; unit) list
    ) : MlirOperation =

        // Convert F# functions to C callbacks
        let cases =
            buildCases
            |&gt; List.map (fun buildCase -&gt;
                let callback builder block userData =
                    let opBuilder = new OpBuilder(builder)
                    let mlirBlock = new Block(block)
                    buildCase opBuilder mlirBlock

                MatchCase(callback, 0n)
            )
            |&gt; List.toArray

        let numCases = nativeint cases.Length
        let loc = this.UnknownLoc()

        funlangMatchOpCreate(
            this.Handle,
            loc,
            input,
            resultType,
            cases,
            numCases
        )
</code></pre>
<p><strong>사용 예제 (F# compiler code):</strong></p>
<pre><code class="language-fsharp">// File: FunLang.Compiler/Codegen.fs

let compileMatch (builder: OpBuilder) (scrutinee: MlirValue) (cases: MatchCase list) =
    let resultType = // infer from cases

    let buildCases =
        cases |&gt; List.map (fun case -&gt;
            fun (builder: OpBuilder) (block: Block) -&gt;
                match case with
                | NilCase expr -&gt;
                    // Build nil case body
                    let value = compileExpr builder env expr
                    builder.CreateYieldOp(value) |&gt; ignore

                | ConsCase (headVar, tailVar, expr) -&gt;
                    // Add block arguments for head and tail
                    let headType = builder.GetIntegerType(32)
                    let tailType = builder.GetFunLangListType(headType)
                    block.AddArgument(headType) |&gt; ignore
                    block.AddArgument(tailType) |&gt; ignore

                    // Build cons case body with extended environment
                    let env' =
                        env
                        |&gt; Map.add headVar (block.GetArgument(0))
                        |&gt; Map.add tailVar (block.GetArgument(1))

                    let value = compileExpr builder env' expr
                    builder.CreateYieldOp(value) |&gt; ignore
        )

    builder.CreateMatchOp(scrutinee, resultType, buildCases)
</code></pre>
<p><strong>Generated MLIR:</strong></p>
<pre><code class="language-mlir">%result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
  ^nil:
    %zero = arith.constant 0 : i32
    funlang.yield %zero : i32
  ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
    %tail_sum = func.call @sum_list(%tail) : (!funlang.list&lt;i32&gt;) -&gt; i32
    %sum = arith.addi %head, %tail_sum : i32
    funlang.yield %sum : i32
}
</code></pre>
<p><strong>Builder callback pattern의 장점:</strong></p>
<ol>
<li><strong>Flexibility</strong>: F# code가 region 내용을 완전히 제어</li>
<li><strong>Type safety</strong>: F# compiler가 callback signature 검증</li>
<li><strong>Composability</strong>: Nested match expressions 지원 (callback 안에서 또 match 생성)</li>
</ol>
<h3 id="block-arguments-in-builder-callback"><a class="header" href="#block-arguments-in-builder-callback">Block Arguments in Builder Callback</a></h3>
<p><strong>위 코드에서 중요한 부분:</strong></p>
<pre><code class="language-fsharp">| ConsCase (headVar, tailVar, expr) -&gt;
    // Add block arguments for pattern variables
    block.AddArgument(headType) |&gt; ignore
    block.AddArgument(tailType) |&gt; ignore

    // Use block arguments in environment
    let env' =
        env
        |&gt; Map.add headVar (block.GetArgument(0))
        |&gt; Map.add tailVar (block.GetArgument(1))
</code></pre>
<p><strong>F# callback이 하는 일:</strong></p>
<ol>
<li><strong>Pattern structure 분석</strong>: ConsCase는 2개 변수 (head, tail)</li>
<li><strong>Block arguments 추가</strong>: Cons case block에 2개 arguments</li>
<li><strong>Environment extension</strong>: Pattern variables를 block arguments로 바인딩</li>
<li><strong>Body compilation</strong>: Extended environment로 case expression 컴파일</li>
</ol>
<p><strong>Lowering pass의 책임:</strong></p>
<p>Lowering pass는 이 block arguments를 실제 데이터로 채운다:</p>
<pre><code class="language-cpp">// MatchOpLowering (Part 2에서 자세히)
// 1. Extract head and tail from cons cell
Value head = extractHead(builder, consCellPtr);
Value tail = extractTail(builder, consCellPtr);

// 2. Clone cons region
IRMapping mapper;
mapper.map(consBlock-&gt;getArgument(0), head);  // Map %head
mapper.map(consBlock-&gt;getArgument(1), tail);  // Map %tail

// 3. Clone operations with mapped values
for (Operation&amp; op : consBlock-&gt;getOperations()) {
    builder.clone(op, mapper);
}
</code></pre>
<p><strong>결과: Block arguments가 실제 values로 대체됨</strong></p>
<hr>
<h2 id="중간-정리-part-1-완료"><a class="header" href="#중간-정리-part-1-완료">중간 정리: Part 1 완료</a></h2>
<p><strong>Part 1에서 다룬 내용:</strong></p>
<p>✅ <strong>Region-based operation structure</strong></p>
<ul>
<li>Regions vs basic blocks</li>
<li>Encapsulation과 verification 장점</li>
</ul>
<p>✅ <strong>Match operation semantics</strong></p>
<ul>
<li>Runtime execution model</li>
<li>Tag extraction → case selection → variable binding → yield</li>
</ul>
<p>✅ <strong>TableGen definition</strong></p>
<ul>
<li>Traits: RecursiveSideEffect, SingleBlockImplicitTerminator</li>
<li>VariadicRegion&lt;SizedRegion&lt;1&gt;&gt; for variable cases</li>
<li>Custom assembly format과 verifier</li>
</ul>
<p>✅ <strong>YieldOp terminator</strong></p>
<ul>
<li>Terminator trait</li>
<li>HasParent&lt;“MatchOp”&gt; constraint</li>
<li>Comparison with scf.yield</li>
</ul>
<p>✅ <strong>C API and F# integration</strong></p>
<ul>
<li>Builder callback pattern</li>
<li>High-level wrapper for match construction</li>
<li>Block arguments for pattern variables</li>
</ul>
<p><strong>다음 Part 2에서:</strong></p>
<ul>
<li>SCF dialect 상세 설명</li>
<li>MatchOpLowering pattern 완전 구현</li>
<li>Region cloning과 IRMapping</li>
<li>전체 pipeline 예제 (sum_list)</li>
<li>Common errors와 debugging</li>
</ul>
<hr>
<h2 id="part-2-scf-lowering-and-pipeline"><a class="header" href="#part-2-scf-lowering-and-pipeline">Part 2: SCF Lowering and Pipeline</a></h2>
<h3 id="scf-dialect-structured-control-flow"><a class="header" href="#scf-dialect-structured-control-flow">SCF Dialect: Structured Control Flow</a></h3>
<p><strong>SCF = Structured Control Flow</strong></p>
<p>Chapter 8에서 우리는 <code>scf.if</code>를 사용했다:</p>
<pre><code class="language-mlir">%result = scf.if %cond : i1 -&gt; i32 {
  %then_val = arith.constant 42 : i32
  scf.yield %then_val : i32
} else {
  %else_val = arith.constant 0 : i32
  scf.yield %else_val : i32
}
</code></pre>
<p><strong>SCF dialect의 핵심 operations:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Purpose</th><th>Regions</th></tr>
</thead>
<tbody>
<tr><td><code>scf.if</code></td><td>Two-way branch</td><td>2 (then, else)</td></tr>
<tr><td><code>scf.index_switch</code></td><td>Multi-way branch</td><td>N (cases) + default</td></tr>
<tr><td><code>scf.for</code></td><td>Counted loop</td><td>1 (body)</td></tr>
<tr><td><code>scf.while</code></td><td>Conditional loop</td><td>2 (before, after)</td></tr>
</tbody>
</table>
</div>
<p><strong>Chapter 19에서는 <code>scf.index_switch</code>를 사용한다.</strong></p>
<h3 id="scfindex_switch-multi-way-branching"><a class="header" href="#scfindex_switch-multi-way-branching">scf.index_switch: Multi-Way Branching</a></h3>
<p><strong>Syntax:</strong></p>
<pre><code class="language-mlir">%result = scf.index_switch %selector : index -&gt; ResultType
case 0 {
  // Case 0 operations
  scf.yield %value0 : ResultType
}
case 1 {
  // Case 1 operations
  scf.yield %value1 : ResultType
}
default {
  // Default case (optional)
  scf.yield %default_val : ResultType
}
</code></pre>
<p><strong>Semantics:</strong></p>
<ol>
<li><strong>Selector evaluation</strong>: <code>%selector</code> 값을 runtime에 evaluate (index type)</li>
<li><strong>Case selection</strong>: Selector 값에 해당하는 case region 선택</li>
<li><strong>Fallback</strong>: 해당하는 case가 없으면 default region (있다면)</li>
<li><strong>Result yielding</strong>: 선택된 region의 <code>scf.yield</code>가 결과 전달</li>
</ol>
<p><strong>Example: Tag dispatch for list</strong></p>
<pre><code class="language-mlir">// %lst: !funlang.list&lt;i32&gt;
// Tag extraction
%struct = // convert %lst to !llvm.struct&lt;(i32, ptr)&gt;
%tag = llvm.extractvalue %struct[0] : !llvm.struct&lt;(i32, ptr)&gt;
%tag_index = arith.index_cast %tag : i32 to index

// Dispatch on tag
%result = scf.index_switch %tag_index : index -&gt; i32
case 0 {  // Nil case (tag = 0)
  %zero = arith.constant 0 : i32
  scf.yield %zero : i32
}
case 1 {  // Cons case (tag = 1)
  %ptr = llvm.extractvalue %struct[1] : !llvm.struct&lt;(i32, ptr)&gt;
  %head = llvm.load %ptr : !llvm.ptr -&gt; i32
  // ... compute with head ...
  scf.yield %sum : i32
}
default {
  // Unreachable for {Nil, Cons} (complete constructor set)
  %minus = arith.constant -1 : i32
  scf.yield %minus : i32
}
</code></pre>
<h3 id="why-scf-before-llvm"><a class="header" href="#why-scf-before-llvm">Why SCF Before LLVM?</a></h3>
<p><strong>Option 1: Direct lowering funlang.match → LLVM (what we DON’T do)</strong></p>
<pre><code class="language-mlir">// Directly to LLVM dialect
%tag = llvm.extractvalue ...
llvm.switch %tag [
  0: ^nil_block,
  1: ^cons_block
]

^nil_block:
  // ... operations ...
  llvm.br ^merge_block(%zero)

^cons_block:
  // ... operations ...
  llvm.br ^merge_block(%sum)

^merge_block(%result: i32):
  llvm.return %result
</code></pre>
<p><strong>문제점:</strong></p>
<ol>
<li><strong>Lost structure</strong>: CFG는 원래 match의 case structure를 상실</li>
<li><strong>Harder optimization</strong>: Which blocks belong to which case? 불명확</li>
<li><strong>Debugging</strong>: LLVM IR에서 source pattern matching 추적 어려움</li>
<li><strong>Lowering complexity</strong>: funlang.match → LLVM을 한 번에 구현해야 함</li>
</ol>
<p><strong>Option 2: Progressive lowering funlang.match → SCF → CF → LLVM (what we do)</strong></p>
<pre><code class="language-mlir">// Stage 1: FunLang
%result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
  ^nil: funlang.yield %zero : i32
  ^cons(%h, %t): funlang.yield %sum : i32
}

// Stage 2: SCF (structured, high-level)
%tag_index = // extract tag and cast to index
%result = scf.index_switch %tag_index : index -&gt; i32
case 0 { scf.yield %zero : i32 }
case 1 { scf.yield %sum : i32 }

// Stage 3: CF (goto-style, low-level)
cf.switch %tag_index [
  0: ^block_0,
  1: ^block_1
]
^block_0: cf.br ^merge(%zero)
^block_1: cf.br ^merge(%sum)
^merge(%result: i32): ...

// Stage 4: LLVM (machine-level)
llvm.switch %tag_i8 [
  0: ^llvm_0,
  1: ^llvm_1
]
// ... LLVM blocks ...
</code></pre>
<p><strong>장점:</strong></p>
<ol>
<li><strong>Separation of concerns</strong>: 각 lowering pass는 하나의 변환만 책임</li>
<li><strong>Optimization hooks</strong>: SCF level에서 pattern-specific optimizations</li>
<li><strong>Incremental verification</strong>: 각 stage마다 IR 검증 가능</li>
<li><strong>Easier debugging</strong>: 문제 발생 시 어느 stage에서 일어났는지 명확</li>
</ol>
<p><strong>Comparison: SCF vs CF</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>SCF</th><th>CF</th></tr>
</thead>
<tbody>
<tr><td>Structure</td><td>Nested regions</td><td>Flat blocks</td></tr>
<tr><td>Control flow</td><td>Implicit (yield returns)</td><td>Explicit (br/switch)</td></tr>
<tr><td>Source mapping</td><td>Preserves match structure</td><td>Lost</td></tr>
<tr><td>Optimization</td><td>High-level (dead case elimination)</td><td>Low-level (block merging)</td></tr>
<tr><td>Readability</td><td>High (similar to source)</td><td>Low (machine-like)</td></tr>
</tbody>
</table>
</div>
<p><strong>Example: Dead case elimination at SCF level</strong></p>
<pre><code class="language-mlir">// Input: match on statically-known value
%nil = funlang.nil : !funlang.list&lt;i32&gt;
%result = funlang.match %nil : !funlang.list&lt;i32&gt; -&gt; i32 {
  ^nil: funlang.yield %zero : i32
  ^cons(%h, %t): funlang.yield %sum : i32  // Dead!
}

// After lowering to SCF
%tag_index = arith.constant 0 : index  // Statically known!
%result = scf.index_switch %tag_index : index -&gt; i32
case 0 { scf.yield %zero : i32 }
case 1 { scf.yield %sum : i32 }  // Dead case!

// SCF optimizer can eliminate case 1
%result = scf.index_switch %tag_index : index -&gt; i32
case 0 { scf.yield %zero : i32 }
// case 1 removed

// Further optimization: constant folding
%result = %zero  // Direct replacement!
</code></pre>
<p>이런 최적화는 CF level에서는 훨씬 어렵다.</p>
<h3 id="matchop-lowering-strategy"><a class="header" href="#matchop-lowering-strategy">MatchOp Lowering Strategy</a></h3>
<p><strong>Goal: <code>funlang.match</code> → <code>scf.index_switch</code> 변환</strong></p>
<p><strong>Input (FunLang):</strong></p>
<pre><code class="language-mlir">%result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
  ^nil:
    %zero = arith.constant 0 : i32
    funlang.yield %zero : i32
  ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
    %tail_sum = func.call @sum_list(%tail) : (!funlang.list&lt;i32&gt;) -&gt; i32
    %sum = arith.addi %head, %tail_sum : i32
    funlang.yield %sum : i32
}
</code></pre>
<p><strong>Output (SCF + LLVM):</strong></p>
<pre><code class="language-mlir">// 1. Convert list type to struct
%struct = builtin.unrealized_conversion_cast %lst
    : !funlang.list&lt;i32&gt; to !llvm.struct&lt;(i32, ptr)&gt;

// 2. Extract tag
%tag_i32 = llvm.extractvalue %struct[0] : !llvm.struct&lt;(i32, ptr)&gt;
%tag_index = arith.index_cast %tag_i32 : i32 to index

// 3. Extract data pointer (for cons case)
%data_ptr = llvm.extractvalue %struct[1] : !llvm.struct&lt;(i32, ptr)&gt;

// 4. Multi-way switch
%result = scf.index_switch %tag_index : index -&gt; i32
case 0 {
  // Nil case: no data to extract
  %zero = arith.constant 0 : i32
  scf.yield %zero : i32
}
case 1 {
  // Cons case: extract head and tail
  %head_ptr = %data_ptr  // Points to [head, tail] array
  %head = llvm.load %head_ptr : !llvm.ptr -&gt; i32

  %tail_ptr = llvm.getelementptr %data_ptr[1] : (!llvm.ptr) -&gt; !llvm.ptr
  %tail_struct_ptr = llvm.load %tail_ptr : !llvm.ptr -&gt; !llvm.ptr
  %tail_struct = llvm.load %tail_struct_ptr : !llvm.ptr -&gt; !llvm.struct&lt;(i32, ptr)&gt;
  %tail = builtin.unrealized_conversion_cast %tail_struct
      : !llvm.struct&lt;(i32, ptr)&gt; to !funlang.list&lt;i32&gt;

  // Cons case body (converted)
  %tail_sum = func.call @sum_list(%tail) : (!funlang.list&lt;i32&gt;) -&gt; i32
  %sum = arith.addi %head, %tail_sum : i32
  scf.yield %sum : i32
}
default {
  // Unreachable for {Nil, Cons}
  %minus = arith.constant -1 : i32
  scf.yield %minus : i32
}
</code></pre>
<p><strong>Lowering steps:</strong></p>
<ol>
<li><strong>Type conversion</strong>: <code>!funlang.list&lt;T&gt;</code> → <code>!llvm.struct&lt;(i32, ptr)&gt;</code></li>
<li><strong>Tag extraction</strong>: <code>llvm.extractvalue</code> to get tag field</li>
<li><strong>Index casting</strong>: <code>arith.index_cast</code> for <code>scf.index_switch</code> selector</li>
<li><strong>Case region cloning</strong>: 각 funlang.match case를 scf.index_switch case로 복사</li>
<li><strong>Block argument mapping</strong>: Pattern variables를 extracted values로 대체</li>
<li><strong>Terminator conversion</strong>: <code>funlang.yield</code> → <code>scf.yield</code></li>
</ol>
<h3 id="tag-value-mapping"><a class="header" href="#tag-value-mapping">Tag Value Mapping</a></h3>
<p><strong>Chapter 18 recap: List representation</strong></p>
<pre><code class="language-cpp">// NilOpLowering
Value tag = builder.create&lt;arith::ConstantIntOp&gt;(loc, 0, builder.getI32Type());

// ConsOpLowering
Value tag = builder.create&lt;arith::ConstantIntOp&gt;(loc, 1, builder.getI32Type());
</code></pre>
<p><strong>Tag mapping:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Constructor</th><th>Tag Value</th></tr>
</thead>
<tbody>
<tr><td>Nil</td><td>0</td></tr>
<tr><td>Cons</td><td>1</td></tr>
</tbody>
</table>
</div>
<p><strong>MatchOpLowering은 이 mapping을 알아야 한다:</strong></p>
<pre><code class="language-cpp">// In MatchOpLowering::matchAndRewrite
// Case 0 → Nil pattern
// Case 1 → Cons pattern
for (auto [index, region] : llvm::enumerate(matchOp.getCases())) {
  // index = 0 → Nil
  // index = 1 → Cons
  builder.create&lt;scf::IndexSwitchCaseOp&gt;(loc, index);
  // ... clone region ...
}
</code></pre>
<p><strong>Future extension: 임의의 ADT</strong></p>
<p>지금은 hardcoded mapping (Nil=0, Cons=1)이지만, 나중에는:</p>
<pre><code class="language-tablegen">// Extensible ADT definition
def Shape : FunLang_ADT&lt;"shape"&gt; {
  let constructors = [
    Constructor&lt;"circle", [F32]&gt;,           // tag = 0
    Constructor&lt;"rectangle", [F32, F32]&gt;,   // tag = 1
    Constructor&lt;"triangle", [F32, F32, F32]&gt;  // tag = 2
  ];
}
</code></pre>
<p>Compiler가 자동으로 tag 할당.</p>
<h3 id="pattern-variable-binding"><a class="header" href="#pattern-variable-binding">Pattern Variable Binding</a></h3>
<p><strong>Cons case의 challenge: block arguments를 어떻게 채우는가?</strong></p>
<p><strong>Source (FunLang):</strong></p>
<pre><code class="language-mlir">^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
  // %head와 %tail이 어디서 오는가?
  funlang.yield %sum : i32
</code></pre>
<p><strong>Lowering 후 (SCF):</strong></p>
<pre><code class="language-mlir">case 1 {
  // 여기서 %head와 %tail을 extract해야 함
  %head = llvm.load %data_ptr : !llvm.ptr -&gt; i32
  %tail = // ... complex extraction ...

  // 이제 body를 clone하면서 block arguments를 이 values로 map
  // (IRMapping 사용)
}
</code></pre>
<p><strong>IRMapping: SSA Value Remapping</strong></p>
<p>MLIR의 <code>IRMapping</code> class는 “old value → new value” mapping을 저장한다.</p>
<pre><code class="language-cpp">IRMapping mapper;
mapper.map(oldValue1, newValue1);
mapper.map(oldValue2, newValue2);

// Clone operation with mapped values
Operation* newOp = builder.clone(*oldOp, mapper);
// oldOp의 operands가 oldValue1, oldValue2였다면
// newOp의 operands는 newValue1, newValue2로 대체됨
</code></pre>
<p><strong>MatchOpLowering에서 IRMapping 사용:</strong></p>
<pre><code class="language-cpp">// Cons case region
Region&amp; consRegion = matchOp.getCases()[1];
Block* consBlock = &amp;consRegion.front();

// consBlock의 block arguments:
// consBlock-&gt;getArgument(0) = %head (i32)
// consBlock-&gt;getArgument(1) = %tail (!funlang.list&lt;i32&gt;)

// Extract actual values
Value actualHead = extractHead(builder, dataPtrConverted);
Value actualTail = extractTail(builder, dataPtrConverted, typeConverter);

// Map block arguments to extracted values
IRMapping mapper;
mapper.map(consBlock-&gt;getArgument(0), actualHead);
mapper.map(consBlock-&gt;getArgument(1), actualTail);

// Clone operations in consBlock with mapping
for (Operation&amp; op : consBlock-&gt;getOperations()) {
  if (isa&lt;YieldOp&gt;(op)) {
    // Convert funlang.yield → scf.yield
    builder.create&lt;scf::YieldOp&gt;(op.getLoc(),
                                  mapper.lookupOrDefault(op.getOperand(0)));
  } else {
    // Clone other operations with mapped operands
    builder.clone(op, mapper);
  }
}
</code></pre>
<p><strong>Result: Block arguments가 사라지고 extracted values로 대체됨</strong></p>
<pre><code class="language-mlir">// Before (funlang.match case)
^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
  %sum = arith.addi %head, %tail_sum : i32
  funlang.yield %sum : i32

// After (scf.index_switch case)
case 1 {
  %head = llvm.load ...  // Extracted value
  %tail = ...            // Extracted value
  %sum = arith.addi %head, %tail_sum : i32  // %head mapped
  scf.yield %sum : i32
}
</code></pre>
<h3 id="matchoplowering-pattern-complete-implementation"><a class="header" href="#matchoplowering-pattern-complete-implementation">MatchOpLowering Pattern: Complete Implementation</a></h3>
<p><strong>이제 전체 lowering pattern을 구현한다.</strong></p>
<p><strong>File: <code>FunLang/Transforms/FunLangToSCF.cpp</code></strong> (conceptual C++ code)</p>
<pre><code class="language-cpp">#include "mlir/Conversion/SCFToControlFlow/SCFToControlFlow.h"
#include "mlir/Dialect/Arith/IR/Arith.h"
#include "mlir/Dialect/Func/IR/FuncOps.h"
#include "mlir/Dialect/LLVM/LLVMDialect.h"
#include "mlir/Dialect/SCF/IR/SCF.h"
#include "mlir/IR/IRMapping.h"
#include "mlir/Transforms/DialectConversion.h"
#include "FunLang/IR/FunLangOps.h"
#include "FunLang/Transforms/TypeConverter.h"

using namespace mlir;
using namespace mlir::funlang;

namespace {

// Helper: Extract head from cons cell
// Input: %data_ptr points to [head, tail] array
// Output: %head value
Value extractHead(OpBuilder&amp; builder, Location loc,
                  Value dataPtrConverted, Type headType) {
  // %data_ptr already points to cons cell array
  // Load first element (head)
  Value head = builder.create&lt;LLVM::LoadOp&gt;(loc, headType, dataPtrConverted);
  return head;
}

// Helper: Extract tail from cons cell
// Input: %data_ptr points to [head, tail] array
// Output: %tail value (converted back to !funlang.list&lt;T&gt;)
Value extractTail(OpBuilder&amp; builder, Location loc,
                  Value dataPtrConverted,
                  FunLangTypeConverter* typeConverter,
                  Type tailFunLangType) {
  // GEP to second element (tail)
  Value one = builder.create&lt;arith::ConstantIntOp&gt;(loc, 1, builder.getI32Type());
  Value tailPtr = builder.create&lt;LLVM::GEPOp&gt;(
      loc, LLVM::LLVMPointerType::get(builder.getContext()),
      dataPtrConverted, ValueRange{one});

  // Load tail pointer
  Value tailStructPtr = builder.create&lt;LLVM::LoadOp&gt;(
      loc, LLVM::LLVMPointerType::get(builder.getContext()), tailPtr);

  // Load tail struct
  Type tailStructType = typeConverter-&gt;convertType(tailFunLangType);
  Value tailStruct = builder.create&lt;LLVM::LoadOp&gt;(
      loc, tailStructType, tailStructPtr);

  // Convert back to FunLang type (for remaining funlang operations in body)
  Value tail = builder.create&lt;UnrealizedConversionCastOp&gt;(
      loc, tailFunLangType, tailStruct).getResult(0);

  return tail;
}

// Helper: Convert funlang.yield to scf.yield in region
void convertYieldOps(Region&amp; region, OpBuilder&amp; builder, IRMapping&amp; mapper) {
  for (Block&amp; block : region) {
    for (Operation&amp; op : llvm::make_early_inc_range(block)) {
      if (auto yieldOp = dyn_cast&lt;YieldOp&gt;(&amp;op)) {
        builder.setInsertionPoint(yieldOp);
        Value yieldValue = mapper.lookupOrDefault(yieldOp.getValue());
        builder.create&lt;scf::YieldOp&gt;(yieldOp.getLoc(), yieldValue);
        yieldOp.erase();
      }
    }
  }
}

// Main lowering pattern
class MatchOpLowering : public OpConversionPattern&lt;MatchOp&gt; {
public:
  using OpConversionPattern&lt;MatchOp&gt;::OpConversionPattern;

  LogicalResult matchAndRewrite(
      MatchOp matchOp,
      OpAdaptor adaptor,
      ConversionPatternRewriter&amp; rewriter) const override {

    Location loc = matchOp.getLoc();
    Value input = adaptor.getInput();
    Type resultType = matchOp.getResult().getType();

    auto* typeConverter = getTypeConverter&lt;FunLangTypeConverter&gt;();

    // 1. Convert input to LLVM struct
    // input: !funlang.list&lt;T&gt; → !llvm.struct&lt;(i32, ptr)&gt;
    Type structType = typeConverter-&gt;convertType(input.getType());
    Value structVal = rewriter.create&lt;UnrealizedConversionCastOp&gt;(
        loc, structType, input).getResult(0);

    // 2. Extract tag field
    Value tag = rewriter.create&lt;LLVM::ExtractValueOp&gt;(loc, structVal, 0);

    // 3. Cast tag to index (for scf.index_switch)
    Value tagIndex = rewriter.create&lt;arith::IndexCastOp&gt;(
        loc, rewriter.getIndexType(), tag);

    // 4. Extract data pointer (needed for cons case)
    Value dataPtr = rewriter.create&lt;LLVM::ExtractValueOp&gt;(loc, structVal, 1);

    // 5. Create scf.index_switch
    auto indexSwitchOp = rewriter.create&lt;scf::IndexSwitchOp&gt;(
        loc, resultType, tagIndex, matchOp.getCases().size());

    // 6. Process each case region
    for (auto [caseIndex, caseRegion] :
         llvm::enumerate(matchOp.getCases())) {

      Block* originalBlock = &amp;caseRegion.front();
      Region&amp; switchCaseRegion = indexSwitchOp.getCaseRegions()[caseIndex];
      Block* caseBlock = rewriter.createBlock(&amp;switchCaseRegion);

      rewriter.setInsertionPointToStart(caseBlock);

      IRMapping mapper;

      // Handle block arguments (pattern variables)
      if (caseIndex == 1) {  // Cons case
        // originalBlock has 2 arguments: %head, %tail

        // Extract head
        Type headFunLangType = originalBlock-&gt;getArgument(0).getType();
        Type headLLVMType = typeConverter-&gt;convertType(headFunLangType);
        Value head = extractHead(rewriter, loc, dataPtr, headLLVMType);

        // Convert head to FunLang type if needed
        Value headFunLang = head;
        if (headFunLangType != headLLVMType) {
          headFunLang = rewriter.create&lt;UnrealizedConversionCastOp&gt;(
              loc, headFunLangType, head).getResult(0);
        }

        // Extract tail
        Type tailFunLangType = originalBlock-&gt;getArgument(1).getType();
        Value tail = extractTail(rewriter, loc, dataPtr,
                                  typeConverter, tailFunLangType);

        // Map block arguments to extracted values
        mapper.map(originalBlock-&gt;getArgument(0), headFunLang);
        mapper.map(originalBlock-&gt;getArgument(1), tail);
      }
      // Nil case (caseIndex == 0): no block arguments, no extraction

      // Clone operations from original region
      for (Operation&amp; op : originalBlock-&gt;getOperations()) {
        if (auto yieldOp = dyn_cast&lt;YieldOp&gt;(&amp;op)) {
          // Convert funlang.yield → scf.yield
          Value yieldValue = mapper.lookupOrDefault(yieldOp.getValue());
          rewriter.create&lt;scf::YieldOp&gt;(loc, yieldValue);
        } else {
          // Clone operation with mapped operands
          rewriter.clone(op, mapper);
        }
      }
    }

    // 7. Add default region (unreachable for complete constructor sets)
    {
      Region&amp; defaultRegion = indexSwitchOp.getDefaultRegion();
      Block* defaultBlock = rewriter.createBlock(&amp;defaultRegion);
      rewriter.setInsertionPointToStart(defaultBlock);

      // Emit error value (this should never execute)
      Value errorVal;
      if (resultType.isIntOrIndex()) {
        errorVal = rewriter.create&lt;arith::ConstantIntOp&gt;(loc, -1, resultType);
      } else {
        // For other types, emit unreachable or null
        errorVal = rewriter.create&lt;LLVM::ZeroOp&gt;(loc, resultType);
      }

      rewriter.create&lt;scf::YieldOp&gt;(loc, errorVal);
    }

    // 8. Replace match operation with index_switch result
    rewriter.replaceOp(matchOp, indexSwitchOp.getResult(0));

    return success();
  }
};

} // namespace

// Pass definition
struct FunLangToSCFPass
    : public PassWrapper&lt;FunLangToSCFPass, OperationPass&lt;ModuleOp&gt;&gt; {

  void getDependentDialects(DialectRegistry&amp; registry) const override {
    registry.insert&lt;arith::ArithDialect,
                    scf::SCFDialect,
                    LLVM::LLVMDialect&gt;();
  }

  void runOnOperation() override {
    auto module = getOperation();
    auto* context = &amp;getContext();

    FunLangTypeConverter typeConverter;
    ConversionTarget target(*context);

    // Mark funlang.match as illegal (must be lowered)
    target.addIllegalOp&lt;MatchOp&gt;();

    // Mark SCF operations as legal
    target.addLegalDialect&lt;scf::SCFDialect&gt;();
    target.addLegalDialect&lt;arith::ArithDialect&gt;();
    target.addLegalDialect&lt;LLVM::LLVMDialect&gt;();
    target.addLegalDialect&lt;func::FuncDialect&gt;();

    // Keep other FunLang ops legal (lowered in FunLangToLLVM pass)
    target.addLegalOp&lt;NilOp, ConsOp, ClosureOp, ApplyOp&gt;();

    RewritePatternSet patterns(context);
    patterns.add&lt;MatchOpLowering&gt;(typeConverter, context);

    if (failed(applyPartialConversion(module, target, std::move(patterns)))) {
      signalPassFailure();
    }
  }
};

std::unique_ptr&lt;Pass&gt; createFunLangToSCFPass() {
  return std::make_unique&lt;FunLangToSCFPass&gt;();
}
</code></pre>
<p><strong>핵심 로직 분석:</strong></p>
<p><strong>1. Type conversion (lines ~95-100)</strong></p>
<pre><code class="language-cpp">Type structType = typeConverter-&gt;convertType(input.getType());
Value structVal = rewriter.create&lt;UnrealizedConversionCastOp&gt;(
    loc, structType, input).getResult(0);
</code></pre>
<p><code>!funlang.list&lt;i32&gt;</code> → <code>!llvm.struct&lt;(i32, ptr)&gt;</code> 변환.</p>
<p><code>UnrealizedConversionCastOp</code>는 type conversion의 placeholder다. 나중에 다른 pass가 이를 실제 operations로 대체하거나 제거한다.</p>
<p><strong>2. Tag extraction (lines ~103-108)</strong></p>
<pre><code class="language-cpp">Value tag = rewriter.create&lt;LLVM::ExtractValueOp&gt;(loc, structVal, 0);
Value tagIndex = rewriter.create&lt;arith::IndexCastOp&gt;(
    loc, rewriter.getIndexType(), tag);
</code></pre>
<p>Struct의 첫 번째 field (tag)를 추출하고 index type으로 cast.</p>
<p><strong>3. scf.index_switch creation (lines ~113-115)</strong></p>
<pre><code class="language-cpp">auto indexSwitchOp = rewriter.create&lt;scf::IndexSwitchOp&gt;(
    loc, resultType, tagIndex, matchOp.getCases().size());
</code></pre>
<p>N개의 cases를 가진 index_switch 생성.</p>
<p><strong>4. Region cloning (lines ~118-160)</strong></p>
<p>각 case region을 iterate하며:</p>
<ul>
<li><strong>Nil case (caseIndex == 0)</strong>: Block arguments 없음, 그냥 clone</li>
<li><strong>Cons case (caseIndex == 1)</strong>: Block arguments 있음, extract + map</li>
</ul>
<p><strong>5. IRMapping for block arguments (lines ~130-148)</strong></p>
<pre><code class="language-cpp">mapper.map(originalBlock-&gt;getArgument(0), headFunLang);
mapper.map(originalBlock-&gt;getArgument(1), tail);
</code></pre>
<p>Original block의 arguments를 extracted values로 mapping.</p>
<p><strong>6. Operation cloning (lines ~152-159)</strong></p>
<pre><code class="language-cpp">for (Operation&amp; op : originalBlock-&gt;getOperations()) {
  if (auto yieldOp = dyn_cast&lt;YieldOp&gt;(&amp;op)) {
    Value yieldValue = mapper.lookupOrDefault(yieldOp.getValue());
    rewriter.create&lt;scf::YieldOp&gt;(loc, yieldValue);
  } else {
    rewriter.clone(op, mapper);
  }
}
</code></pre>
<ul>
<li><code>funlang.yield</code> → <code>scf.yield</code> 변환</li>
<li>다른 operations는 mapper와 함께 clone</li>
</ul>
<p><strong>7. Default region (lines ~163-176)</strong></p>
<p>Unreachable case를 위한 default region 생성.</p>
<h3 id="complete-pipeline-pass-registration"><a class="header" href="#complete-pipeline-pass-registration">Complete Pipeline: Pass Registration</a></h3>
<p><strong>전체 lowering pipeline:</strong></p>
<pre><code>FunLang Dialect (with match, nil, cons, closure, apply)
    ↓
[FunLangToSCFPass]
    ↓
FunLang (without match) + SCF
    ↓
[FunLangToLLVMPass] (lowers nil, cons, closure, apply)
    ↓
LLVM + SCF
    ↓
[SCFToControlFlowPass]
    ↓
LLVM + CF
    ↓
[ConvertControlFlowToLLVMPass]
    ↓
LLVM Dialect only
    ↓
[LLVMToObjectPass]
    ↓
Object file
</code></pre>
<p><strong>Pass manager setup (F# code):</strong></p>
<pre><code class="language-fsharp">// File: FunLang.Compiler/Pipeline.fs

let lowerToLLVM (module_: Module) =
    let pm = PassManager.Create(module_.Context)

    // 1. FunLang → SCF (lower match operation)
    pm.AddPass(FunLangPasses.CreateFunLangToSCFPass())

    // 2. FunLang → LLVM (lower nil, cons, closure, apply)
    pm.AddPass(FunLangPasses.CreateFunLangToLLVMPass())

    // 3. SCF → CF
    pm.AddPass(SCFPasses.CreateSCFToControlFlowPass())

    // 4. CF → LLVM
    pm.AddPass(ConversionPasses.CreateConvertControlFlowToLLVMPass())

    // 5. Func → LLVM
    pm.AddPass(ConversionPasses.CreateConvertFuncToLLVMPass())

    // 6. Arith → LLVM
    pm.AddPass(ConversionPasses.CreateConvertArithToLLVMPass())

    pm.Run(module_) |&gt; ignore
</code></pre>
<p><strong>Pass dependencies:</strong></p>
<ul>
<li>
<p><code>FunLangToSCFPass</code> must run <strong>before</strong> <code>FunLangToLLVMPass</code></p>
<ul>
<li>Reason: MatchOp의 regions에 다른 FunLang ops (nil, cons, etc.) 포함</li>
<li>SCF로 변환 후 남은 FunLang ops를 LLVM으로 변환</li>
</ul>
</li>
<li>
<p><code>SCFToControlFlowPass</code> must run <strong>after</strong> all FunLang lowering</p>
<ul>
<li>Reason: SCF ops는 다른 dialects가 모두 LLVM으로 변환된 후 lower</li>
</ul>
</li>
<li>
<p><code>ConvertFuncToLLVMPass</code> must run <strong>after</strong> SCF/CF conversion</p>
<ul>
<li>Reason: Function signatures에 FunLang types가 남아있으면 안 됨</li>
</ul>
</li>
</ul>
<h3 id="end-to-end-example-sum_list-function"><a class="header" href="#end-to-end-example-sum_list-function">End-to-End Example: sum_list Function</a></h3>
<p><strong>F# source code:</strong></p>
<pre><code class="language-fsharp">// FunLang source
let rec sum_list lst =
    match lst with
    | [] -&gt; 0
    | head :: tail -&gt; head + sum_list tail

let main () =
    let my_list = [1; 2; 3]
    sum_list my_list
</code></pre>
<p><strong>Stage 1: FunLang Dialect (after F# compiler)</strong></p>
<pre><code class="language-mlir">module {
  func.func @sum_list(%lst: !funlang.list&lt;i32&gt;) -&gt; i32 {
    %result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
      ^nil:
        %zero = arith.constant 0 : i32
        funlang.yield %zero : i32
      ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
        %tail_sum = func.call @sum_list(%tail) : (!funlang.list&lt;i32&gt;) -&gt; i32
        %sum = arith.addi %head, %tail_sum : i32
        funlang.yield %sum : i32
    }
    return %result : i32
  }

  func.func @main() -&gt; i32 {
    // Build list [1, 2, 3]
    %nil = funlang.nil : !funlang.list&lt;i32&gt;

    %c3 = arith.constant 3 : i32
    %l3 = funlang.cons %c3, %nil : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;

    %c2 = arith.constant 2 : i32
    %l2 = funlang.cons %c2, %l3 : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;

    %c1 = arith.constant 1 : i32
    %l1 = funlang.cons %c1, %l2 : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;

    // Call sum_list
    %sum = func.call @sum_list(%l1) : (!funlang.list&lt;i32&gt;) -&gt; i32
    return %sum : i32
  }
}
</code></pre>
<p><strong>Stage 2: After FunLangToSCFPass</strong></p>
<pre><code class="language-mlir">module {
  func.func @sum_list(%lst: !funlang.list&lt;i32&gt;) -&gt; i32 {
    // Type conversion
    %struct = builtin.unrealized_conversion_cast %lst
        : !funlang.list&lt;i32&gt; to !llvm.struct&lt;(i32, ptr)&gt;

    // Tag extraction
    %tag = llvm.extractvalue %struct[0] : !llvm.struct&lt;(i32, ptr)&gt;
    %tag_index = arith.index_cast %tag : i32 to index

    // Data pointer
    %data_ptr = llvm.extractvalue %struct[1] : !llvm.struct&lt;(i32, ptr)&gt;

    // Index switch
    %result = scf.index_switch %tag_index : index -&gt; i32
    case 0 {
      %zero = arith.constant 0 : i32
      scf.yield %zero : i32
    }
    case 1 {
      // Extract head
      %head = llvm.load %data_ptr : !llvm.ptr -&gt; i32

      // Extract tail
      %one = arith.constant 1 : i32
      %tail_ptr = llvm.getelementptr %data_ptr[%one] : (!llvm.ptr, i32) -&gt; !llvm.ptr
      %tail_struct_ptr = llvm.load %tail_ptr : !llvm.ptr -&gt; !llvm.ptr
      %tail_struct = llvm.load %tail_struct_ptr : !llvm.ptr -&gt; !llvm.struct&lt;(i32, ptr)&gt;
      %tail = builtin.unrealized_conversion_cast %tail_struct
          : !llvm.struct&lt;(i32, ptr)&gt; to !funlang.list&lt;i32&gt;

      // Recursive call
      %tail_sum = func.call @sum_list(%tail) : (!funlang.list&lt;i32&gt;) -&gt; i32

      // Sum
      %sum = arith.addi %head, %tail_sum : i32
      scf.yield %sum : i32
    }
    default {
      %error = arith.constant -1 : i32
      scf.yield %error : i32
    }

    return %result : i32
  }

  func.func @main() -&gt; i32 {
    // Still has funlang.nil and funlang.cons (not lowered yet)
    %nil = funlang.nil : !funlang.list&lt;i32&gt;
    %c3 = arith.constant 3 : i32
    %l3 = funlang.cons %c3, %nil : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;
    // ...
    %sum = func.call @sum_list(%l1) : (!funlang.list&lt;i32&gt;) -&gt; i32
    return %sum : i32
  }
}
</code></pre>
<p><strong>Stage 3: After FunLangToLLVMPass</strong></p>
<pre><code class="language-mlir">module {
  func.func @sum_list(%lst: !llvm.struct&lt;(i32, ptr)&gt;) -&gt; i32 {
    // ... same as Stage 2 but types converted ...
    %tag = llvm.extractvalue %lst[0] : !llvm.struct&lt;(i32, ptr)&gt;
    %tag_index = arith.index_cast %tag : i32 to index
    %data_ptr = llvm.extractvalue %lst[1] : !llvm.struct&lt;(i32, ptr)&gt;

    %result = scf.index_switch %tag_index : index -&gt; i32
    case 0 { /* ... */ }
    case 1 { /* ... */ }
    default { /* ... */ }

    return %result : i32
  }

  func.func @main() -&gt; i32 {
    // funlang.nil and funlang.cons lowered to LLVM
    %c0 = arith.constant 0 : i32
    %null = llvm.mlir.zero : !llvm.ptr
    %undef_nil = llvm.mlir.undef : !llvm.struct&lt;(i32, ptr)&gt;
    %s1_nil = llvm.insertvalue %c0, %undef_nil[0] : !llvm.struct&lt;(i32, ptr)&gt;
    %nil = llvm.insertvalue %null, %s1_nil[1] : !llvm.struct&lt;(i32, ptr)&gt;

    %c3 = arith.constant 3 : i32
    %c1_tag = arith.constant 1 : i32
    %size = arith.constant 16 : i64  // sizeof(cons cell)
    %ptr = llvm.call @GC_malloc(%size) : (i64) -&gt; !llvm.ptr
    llvm.store %c3, %ptr : i32, !llvm.ptr
    %tail_ptr = llvm.getelementptr %ptr[1] : (!llvm.ptr) -&gt; !llvm.ptr
    // ... store tail ...
    %undef_cons = llvm.mlir.undef : !llvm.struct&lt;(i32, ptr)&gt;
    %s1_cons = llvm.insertvalue %c1_tag, %undef_cons[0] : !llvm.struct&lt;(i32, ptr)&gt;
    %l3 = llvm.insertvalue %ptr, %s1_cons[1] : !llvm.struct&lt;(i32, ptr)&gt;

    // ...
    %sum = func.call @sum_list(%l1) : (!llvm.struct&lt;(i32, ptr)&gt;) -&gt; i32
    return %sum : i32
  }
}
</code></pre>
<p><strong>Stage 4: After SCFToControlFlowPass</strong></p>
<pre><code class="language-mlir">module {
  func.func @sum_list(%lst: !llvm.struct&lt;(i32, ptr)&gt;) -&gt; i32 {
    %tag = llvm.extractvalue %lst[0] : !llvm.struct&lt;(i32, ptr)&gt;
    %tag_index = arith.index_cast %tag : i32 to index
    %data_ptr = llvm.extractvalue %lst[1] : !llvm.struct&lt;(i32, ptr)&gt;

    // scf.index_switch → cf.switch
    cf.switch %tag_index : index, [
      default: ^default,
      0: ^case_0,
      1: ^case_1
    ]

  ^case_0:
    %zero = arith.constant 0 : i32
    cf.br ^merge(%zero : i32)

  ^case_1:
    %head = llvm.load %data_ptr : !llvm.ptr -&gt; i32
    // ... extract tail ...
    %tail_sum = func.call @sum_list(%tail) : (!llvm.struct&lt;(i32, ptr)&gt;) -&gt; i32
    %sum = arith.addi %head, %tail_sum : i32
    cf.br ^merge(%sum : i32)

  ^default:
    %error = arith.constant -1 : i32
    cf.br ^merge(%error : i32)

  ^merge(%result: i32):
    return %result : i32
  }

  func.func @main() -&gt; i32 {
    // ... LLVM code for list construction ...
    %sum = func.call @sum_list(%l1) : (!llvm.struct&lt;(i32, ptr)&gt;) -&gt; i32
    return %sum : i32
  }
}
</code></pre>
<p><strong>Stage 5: After ConvertControlFlowToLLVMPass + ConvertFuncToLLVMPass</strong></p>
<pre><code class="language-mlir">llvm.func @sum_list(%arg0: !llvm.struct&lt;(i32, ptr)&gt;) -&gt; i32 {
  %0 = llvm.extractvalue %arg0[0] : !llvm.struct&lt;(i32, ptr)&gt;
  %1 = llvm.sext %0 : i32 to i64  // index cast
  %2 = llvm.extractvalue %arg0[1] : !llvm.struct&lt;(i32, ptr)&gt;

  llvm.switch %1 : i64, ^default [
    0: ^case_0,
    1: ^case_1
  ]

^case_0:
  %c0 = llvm.mlir.constant(0 : i32) : i32
  llvm.br ^merge(%c0 : i32)

^case_1:
  %head = llvm.load %2 : !llvm.ptr -&gt; i32
  // ... tail extraction ...
  %tail_sum = llvm.call @sum_list(%tail) : (!llvm.struct&lt;(i32, ptr)&gt;) -&gt; i32
  %sum = llvm.add %head, %tail_sum : i32
  llvm.br ^merge(%sum : i32)

^default:
  %error = llvm.mlir.constant(-1 : i32) : i32
  llvm.br ^merge(%error : i32)

^merge(%result: i32):
  llvm.return %result : i32
}

llvm.func @main() -&gt; i32 {
  // ... LLVM code ...
  %sum = llvm.call @sum_list(%l1) : (!llvm.struct&lt;(i32, ptr)&gt;) -&gt; i32
  llvm.return %sum : i32
}
</code></pre>
<p><strong>Stage 6: Native code (after llc + linking)</strong></p>
<pre><code class="language-bash">$ ./funlang_program
6
</code></pre>
<p><strong>Pipeline verification at each stage:</strong></p>
<pre><code class="language-bash"># After each pass, verify IR
$ mlir-opt --funlang-to-scf --verify-diagnostics input.mlir
$ mlir-opt --funlang-to-llvm --verify-diagnostics input.mlir
$ mlir-opt --convert-scf-to-cf --verify-diagnostics input.mlir
</code></pre>
<h3 id="common-errors-and-debugging"><a class="header" href="#common-errors-and-debugging">Common Errors and Debugging</a></h3>
<p><strong>Error 1: Block argument count mismatch</strong></p>
<p><strong>Symptom:</strong></p>
<pre><code>error: 'scf.yield' op result type mismatch
</code></pre>
<p><strong>Cause:</strong></p>
<p>Cons case region의 block arguments 개수가 틀림.</p>
<pre><code class="language-cpp">// Wrong: forgot to map tail argument
mapper.map(originalBlock-&gt;getArgument(0), headFunLang);
// Missing: mapper.map(originalBlock-&gt;getArgument(1), tail);
</code></pre>
<p><strong>Fix:</strong></p>
<p>모든 block arguments를 map해야 함.</p>
<pre><code class="language-cpp">mapper.map(originalBlock-&gt;getArgument(0), headFunLang);
mapper.map(originalBlock-&gt;getArgument(1), tail);  // ✅
</code></pre>
<p><strong>Error 2: Type mismatch after region cloning</strong></p>
<p><strong>Symptom:</strong></p>
<pre><code>error: 'func.call' op operand type mismatch: expected '!llvm.struct&lt;...&gt;', got '!funlang.list&lt;...&gt;'
</code></pre>
<p><strong>Cause:</strong></p>
<p>Region 내부의 operations가 아직 type conversion 안 됨.</p>
<p><strong>Why:</strong></p>
<p><code>FunLangToSCFPass</code>는 partial conversion이다. Match operation만 lower하고 나머지 FunLang ops는 그대로 둔다.</p>
<p><strong>Fix:</strong></p>
<p>Region cloning 후 남은 FunLang operations는 다음 pass (<code>FunLangToLLVMPass</code>)에서 처리됨.</p>
<p>Temporary workaround: <code>UnrealizedConversionCastOp</code> 사용.</p>
<pre><code class="language-cpp">Value tail = extractTail(...);  // Returns LLVM struct
// Cast back to FunLang type for func.call
Value tailFunLang = rewriter.create&lt;UnrealizedConversionCastOp&gt;(
    loc, tailFunLangType, tail).getResult(0);
</code></pre>
<p><strong>Error 3: Missing scf.yield in converted regions</strong></p>
<p><strong>Symptom:</strong></p>
<pre><code>error: block must terminate with scf.yield
</code></pre>
<p><strong>Cause:</strong></p>
<p><code>funlang.yield</code>를 <code>scf.yield</code>로 변환하는 걸 까먹음.</p>
<pre><code class="language-cpp">// Wrong: just clone YieldOp as-is
for (Operation&amp; op : originalBlock-&gt;getOperations()) {
  rewriter.clone(op, mapper);  // funlang.yield gets cloned!
}
</code></pre>
<p><strong>Fix:</strong></p>
<p>YieldOp를 특별히 처리해서 변환.</p>
<pre><code class="language-cpp">for (Operation&amp; op : originalBlock-&gt;getOperations()) {
  if (auto yieldOp = dyn_cast&lt;YieldOp&gt;(&amp;op)) {
    Value yieldValue = mapper.lookupOrDefault(yieldOp.getValue());
    rewriter.create&lt;scf::YieldOp&gt;(loc, yieldValue);  // ✅ Convert
  } else {
    rewriter.clone(op, mapper);
  }
}
</code></pre>
<p><strong>Error 4: Wrong tag values (0 vs 1 confusion)</strong></p>
<p><strong>Symptom:</strong></p>
<p>런타임에 엉뚱한 case가 실행됨. 예: Nil list인데 Cons case 실행.</p>
<p><strong>Cause:</strong></p>
<p>Tag mapping이 틀림.</p>
<pre><code class="language-cpp">// Wrong: reversed mapping
// case 0 → Cons (wrong!)
// case 1 → Nil (wrong!)
</code></pre>
<p><strong>Fix:</strong></p>
<p>Chapter 18의 tag values와 일치시켜야 함:</p>
<pre><code class="language-cpp">// Correct mapping
// case 0 → Nil  (tag = 0)
// case 1 → Cons (tag = 1)
for (auto [caseIndex, caseRegion] : llvm::enumerate(matchOp.getCases())) {
  // caseIndex = 0 → Nil region (first in match)
  // caseIndex = 1 → Cons region (second in match)
}
</code></pre>
<p><strong>F# compiler는 pattern 순서를 보장해야 함:</strong></p>
<pre><code class="language-fsharp">// F# compiler must emit cases in this order:
// Case 0: Nil
// Case 1: Cons
match lst with
| [] -&gt; ...        // Must be first case
| head :: tail -&gt; ... // Must be second case
</code></pre>
<p><strong>Error 5: Incorrect data extraction from cons cell</strong></p>
<p><strong>Symptom:</strong></p>
<p>런타임 segfault or garbage values.</p>
<p><strong>Cause:</strong></p>
<p>GEP indices 틀림.</p>
<pre><code class="language-cpp">// Wrong: GEP from struct pointer
Value tailPtr = builder.create&lt;LLVM::GEPOp&gt;(
    loc, ptrType, structVal, ValueRange{one});  // ❌ structVal is value not pointer
</code></pre>
<p><strong>Fix:</strong></p>
<p>Data pointer는 이미 cons cell array를 가리킴.</p>
<pre><code class="language-cpp">// Correct: dataPtr already points to [head, tail] array
Value headPtr = dataPtr;  // Points to head
Value head = builder.create&lt;LLVM::LoadOp&gt;(loc, headType, headPtr);

Value one = builder.create&lt;arith::ConstantIntOp&gt;(loc, 1, i32Type);
Value tailPtr = builder.create&lt;LLVM::GEPOp&gt;(
    loc, ptrType, dataPtr, ValueRange{one});  // ✅ GEP from array pointer
</code></pre>
<p><strong>Debugging strategies:</strong></p>
<ol>
<li><strong>Print IR after each pass:</strong></li>
</ol>
<pre><code class="language-bash">$ mlir-opt --funlang-to-scf --print-ir-after-all input.mlir
</code></pre>
<ol start="2">
<li><strong>Use verifier:</strong></li>
</ol>
<pre><code class="language-bash">$ mlir-opt --funlang-to-scf --verify-diagnostics input.mlir
</code></pre>
<ol start="3">
<li><strong>Dump operations in lowering code:</strong></li>
</ol>
<pre><code class="language-cpp">matchOp.dump();  // Before lowering
indexSwitchOp.dump();  // After lowering
</code></pre>
<ol start="4">
<li><strong>Check IRMapping:</strong></li>
</ol>
<pre><code class="language-cpp">for (auto [caseIndex, region] : enumerate(matchOp.getCases())) {
  Block* block = &amp;region.front();
  llvm::errs() &lt;&lt; "Case " &lt;&lt; caseIndex &lt;&lt; ":\n";
  for (BlockArgument arg : block-&gt;getArguments()) {
    llvm::errs() &lt;&lt; "  Arg: " &lt;&lt; arg &lt;&lt; " → "
                 &lt;&lt; mapper.lookupOrDefault(arg) &lt;&lt; "\n";
  }
}
</code></pre>
<hr>
<h2 id="리터럴-패턴-로우어링"><a class="header" href="#리터럴-패턴-로우어링">리터럴 패턴 로우어링</a></h2>
<p>지금까지 constructor patterns (Nil, Cons)를 위한 lowering을 설명했다. 이제 <strong>리터럴 패턴</strong>을 위한 lowering 전략을 다룬다.</p>
<h3 id="constructor-vs-literal-dispatch"><a class="header" href="#constructor-vs-literal-dispatch">Constructor vs Literal Dispatch</a></h3>
<p><strong>Constructor 패턴과 리터럴 패턴의 핵심 차이:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>특성</th><th>Constructor</th><th>Literal</th></tr>
</thead>
<tbody>
<tr><td>값의 범위</td><td>유한 (finite)</td><td>무한 (infinite)</td></tr>
<tr><td>테스트</td><td>Tag extraction</td><td>Value comparison</td></tr>
<tr><td>MLIR dispatch</td><td><code>scf.index_switch</code></td><td><code>arith.cmpi</code> + <code>scf.if</code></td></tr>
<tr><td>Complexity</td><td>O(1)</td><td>O(n) sequential</td></tr>
</tbody>
</table>
</div>
<p><strong>Constructor patterns use <code>scf.index_switch</code>:</strong></p>
<p>Tag는 유한한 범위 (예: 0 = Nil, 1 = Cons)이므로 jump table이 가능하다.</p>
<pre><code class="language-mlir">// Constructor dispatch: O(1)
%tag = llvm.extractvalue %list[0] : !llvm.struct&lt;(i32, ptr)&gt;
%tag_index = arith.index_cast %tag : i32 to index

%result = scf.index_switch %tag_index : index -&gt; i32
case 0 { /* Nil case */ scf.yield ... }
case 1 { /* Cons case */ scf.yield ... }
default { scf.yield %unreachable : i32 }
</code></pre>
<p><strong>Literal patterns use <code>arith.cmpi</code> + <code>scf.if</code> chain:</strong></p>
<p>정수 리터럴은 무한하므로 순차적 비교가 필요하다.</p>
<pre><code class="language-mlir">// Literal dispatch: O(n)
%is_zero = arith.cmpi eq, %x, %c0 : i32
%result = scf.if %is_zero -&gt; i32 {
    scf.yield %zero_result : i32
} else {
    %is_one = arith.cmpi eq, %x, %c1 : i32
    %inner = scf.if %is_one -&gt; i32 {
        scf.yield %one_result : i32
    } else {
        scf.yield %default_result : i32
    }
    scf.yield %inner : i32
}
</code></pre>
<h3 id="리터럴-패턴-lowering-구현"><a class="header" href="#리터럴-패턴-lowering-구현">리터럴 패턴 Lowering 구현</a></h3>
<p><strong>리터럴 매칭을 위한 C++ lowering pattern:</strong></p>
<pre><code class="language-cpp">// LiteralMatchLowering.cpp

class LiteralMatchOpLowering : public OpConversionPattern&lt;LiteralMatchOp&gt; {
public:
  using OpConversionPattern&lt;LiteralMatchOp&gt;::OpConversionPattern;

  LogicalResult matchAndRewrite(
      LiteralMatchOp matchOp,
      OpAdaptor adaptor,
      ConversionPatternRewriter&amp; rewriter) const override {

    Location loc = matchOp.getLoc();
    Value scrutinee = adaptor.getScrutinee();
    Type resultType = matchOp.getResult().getType();

    // Collect all cases: (literal_value, region)
    auto cases = matchOp.getCases();
    Region* defaultRegion = matchOp.getDefaultRegion();

    // Build nested scf.if chain from bottom up
    Value result = buildIfChain(rewriter, loc, scrutinee,
                                 cases, defaultRegion, resultType);

    rewriter.replaceOp(matchOp, result);
    return success();
  }

private:
  Value buildIfChain(
      ConversionPatternRewriter&amp; rewriter,
      Location loc,
      Value scrutinee,
      ArrayRef&lt;std::pair&lt;int64_t, Region*&gt;&gt; cases,
      Region* defaultRegion,
      Type resultType) const {

    // Base case: no more cases, use default
    if (cases.empty()) {
      return cloneRegionAndGetResult(rewriter, loc, defaultRegion, resultType);
    }

    // Current case
    auto [literalValue, caseRegion] = cases.front();
    auto remainingCases = cases.drop_front();

    // Create comparison: scrutinee == literal
    Value literalConst = rewriter.create&lt;arith::ConstantIntOp&gt;(
        loc, literalValue, scrutinee.getType());
    Value isMatch = rewriter.create&lt;arith::CmpIOp&gt;(
        loc, arith::CmpIPredicate::eq, scrutinee, literalConst);

    // Create scf.if
    auto ifOp = rewriter.create&lt;scf::IfOp&gt;(
        loc, resultType, isMatch,
        /*thenBuilder=*/[&amp;](OpBuilder&amp; b, Location loc) {
          Value result = cloneRegionAndGetResult(b, loc, caseRegion, resultType);
          b.create&lt;scf::YieldOp&gt;(loc, result);
        },
        /*elseBuilder=*/[&amp;](OpBuilder&amp; b, Location loc) {
          Value result = buildIfChain(
              rewriter, loc, scrutinee, remainingCases, defaultRegion, resultType);
          b.create&lt;scf::YieldOp&gt;(loc, result);
        });

    return ifOp.getResult(0);
  }

  Value cloneRegionAndGetResult(
      OpBuilder&amp; builder,
      Location loc,
      Region* region,
      Type resultType) const {
    // Clone operations from region
    IRMapping mapper;
    for (Operation&amp; op : region-&gt;front()) {
      if (auto yieldOp = dyn_cast&lt;YieldOp&gt;(&amp;op)) {
        return mapper.lookupOrDefault(yieldOp.getValue());
      } else {
        builder.clone(op, mapper);
      }
    }
    llvm_unreachable("Region must end with yield");
  }
};
</code></pre>
<p><strong>생성된 IR 예제:</strong></p>
<pre><code class="language-fsharp">// FunLang source
match x with
| 0 -&gt; "zero"
| 1 -&gt; "one"
| _ -&gt; "other"
</code></pre>
<pre><code class="language-mlir">// After lowering: nested scf.if chain
%c0 = arith.constant 0 : i32
%c1 = arith.constant 1 : i32

%is_zero = arith.cmpi eq, %x, %c0 : i32
%result = scf.if %is_zero -&gt; !llvm.ptr&lt;i8&gt; {
    scf.yield %zero_str : !llvm.ptr&lt;i8&gt;
} else {
    %is_one = arith.cmpi eq, %x, %c1 : i32
    %inner = scf.if %is_one -&gt; !llvm.ptr&lt;i8&gt; {
        scf.yield %one_str : !llvm.ptr&lt;i8&gt;
    } else {
        // Default case: no comparison
        scf.yield %other_str : !llvm.ptr&lt;i8&gt;
    }
    scf.yield %inner : !llvm.ptr&lt;i8&gt;
}
</code></pre>
<h3 id="최적화-기회-optimization-opportunities"><a class="header" href="#최적화-기회-optimization-opportunities">최적화 기회 (Optimization Opportunities)</a></h3>
<p><strong>1. Dense Range Detection</strong></p>
<p>리터럴이 0, 1, 2, … 연속일 때 <code>scf.index_switch</code>로 변환 가능:</p>
<pre><code class="language-mlir">// Before: sequential comparisons
%is_0 = arith.cmpi eq, %x, %c0
scf.if %is_0 { ... } else {
    %is_1 = arith.cmpi eq, %x, %c1
    scf.if %is_1 { ... } else {
        %is_2 = arith.cmpi eq, %x, %c2
        // ...
    }
}

// After: range check + index_switch
%in_range = arith.cmpi ult, %x, %c3 : i32
scf.if %in_range {
    %idx = arith.index_cast %x : i32 to index
    scf.index_switch %idx : index -&gt; i32
    case 0 { /* case 0 */ }
    case 1 { /* case 1 */ }
    case 2 { /* case 2 */ }
} else {
    // default
}
</code></pre>
<p><strong>Dense range detection algorithm:</strong></p>
<pre><code class="language-cpp">bool isDenseRange(ArrayRef&lt;int64_t&gt; literals) {
  if (literals.empty()) return false;

  // Sort literals
  SmallVector&lt;int64_t&gt; sorted(literals.begin(), literals.end());
  llvm::sort(sorted);

  // Check if consecutive
  for (size_t i = 1; i &lt; sorted.size(); ++i) {
    if (sorted[i] != sorted[i-1] + 1)
      return false;
  }

  // Starts from 0 or 1 (common case)
  return sorted[0] == 0 || sorted[0] == 1;
}
</code></pre>
<p><strong>2. Sparse Set Optimization</strong></p>
<p>리터럴이 sparse할 때 (예: 0, 10, 100) binary search 가능:</p>
<pre><code class="language-mlir">// O(log n) with binary search
%mid = arith.constant 10 : i32
%less_than_mid = arith.cmpi slt, %x, %mid : i32
scf.if %less_than_mid {
    // Check 0
    %is_0 = arith.cmpi eq, %x, %c0
    scf.if %is_0 { ... } else { /* default */ }
} else {
    // Check 10, 100
    %is_10 = arith.cmpi eq, %x, %c10
    scf.if %is_10 { ... } else {
        %is_100 = arith.cmpi eq, %x, %c100
        scf.if %is_100 { ... } else { /* default */ }
    }
}
</code></pre>
<p>이 최적화는 MLIR transformation pass로 구현 가능 (Phase 7).</p>
<p><strong>3. LLVM Backend Optimization</strong></p>
<p>SCF → CF → LLVM pipeline 후 LLVM backend가 추가 최적화:</p>
<pre><code class="language-llvm">; LLVM will recognize this pattern
%cmp0 = icmp eq i32 %x, 0
br i1 %cmp0, label %case0, label %check1
check1:
%cmp1 = icmp eq i32 %x, 1
br i1 %cmp1, label %case1, label %default

; And optimize to switch:
switch i32 %x, label %default [
    i32 0, label %case0
    i32 1, label %case1
]
</code></pre>
<p><strong>LLVM switch lowering:</strong></p>
<ul>
<li>Dense: jump table (O(1))</li>
<li>Sparse: binary search tree (O(log n))</li>
<li>Very sparse: linear search (O(n))</li>
</ul>
<h3 id="mixed-patterns-constructor--literal"><a class="header" href="#mixed-patterns-constructor--literal">Mixed Patterns: Constructor + Literal</a></h3>
<p><strong>실제 코드는 constructor와 literal을 섞어 쓴다:</strong></p>
<pre><code class="language-fsharp">match (list, n) with
| (Nil, _) -&gt; 0
| (Cons(x, _), 0) -&gt; x
| (Cons(x, xs), n) -&gt; x + process xs (n - 1)
</code></pre>
<p><strong>Lowering 전략:</strong></p>
<ol>
<li><strong>First column (list)</strong>: Constructor pattern → <code>scf.index_switch</code></li>
<li><strong>Second column (n)</strong>: Literal pattern → <code>arith.cmpi</code> + <code>scf.if</code></li>
</ol>
<pre><code class="language-mlir">// Step 1: Constructor dispatch on list
%list_tag = llvm.extractvalue %list[0] : !llvm.struct&lt;(i32, ptr)&gt;
%tag_index = arith.index_cast %list_tag : i32 to index

%result = scf.index_switch %tag_index : index -&gt; i32
case 0 {
    // Nil case: wildcard on n (no test)
    %zero = arith.constant 0 : i32
    scf.yield %zero : i32
}
case 1 {
    // Cons case: extract data
    %data = llvm.extractvalue %list[1] : !llvm.struct&lt;(i32, ptr)&gt;
    %x = llvm.load %data : !llvm.ptr -&gt; i32

    // Step 2: Literal dispatch on n
    %is_zero = arith.cmpi eq, %n, %c0 : i32
    %inner = scf.if %is_zero -&gt; i32 {
        // Case: Cons(x, _), 0 → x
        scf.yield %x : i32
    } else {
        // Case: Cons(x, xs), n → x + process xs (n-1)
        %tail_ptr = llvm.getelementptr %data[1] : (!llvm.ptr) -&gt; !llvm.ptr
        %xs = llvm.load %tail_ptr : !llvm.ptr -&gt; !llvm.struct&lt;(i32, ptr)&gt;
        %n_minus_1 = arith.subi %n, %c1 : i32
        %rest = func.call @process(%xs, %n_minus_1) : (...) -&gt; i32
        %sum = arith.addi %x, %rest : i32
        scf.yield %sum : i32
    }
    scf.yield %inner : i32
}
</code></pre>
<p><strong>핵심 원칙:</strong></p>
<ul>
<li>Constructor column: <code>scf.index_switch</code>로 O(1) dispatch</li>
<li>Literal column: <code>scf.if</code> chain으로 O(n) dispatch</li>
<li>Wildcard: test 없음 (fallthrough 또는 skip)</li>
</ul>
<h3 id="와일드카드-default-case-처리"><a class="header" href="#와일드카드-default-case-처리">와일드카드 Default Case 처리</a></h3>
<p><strong>Wildcard (<code>_</code>) pattern의 lowering:</strong></p>
<p>Wildcard는 <strong>어떤 테스트도 생성하지 않는다.</strong></p>
<pre><code class="language-fsharp">match x with
| 0 -&gt; "zero"
| 1 -&gt; "one"
| _ -&gt; "other"  // Wildcard: no test
</code></pre>
<pre><code class="language-mlir">%is_zero = arith.cmpi eq, %x, %c0 : i32
scf.if %is_zero {
    scf.yield %zero_str : !llvm.ptr&lt;i8&gt;
} else {
    %is_one = arith.cmpi eq, %x, %c1 : i32
    scf.if %is_one {
        scf.yield %one_str : !llvm.ptr&lt;i8&gt;
    } else {
        // _ case: NO comparison, just yield
        scf.yield %other_str : !llvm.ptr&lt;i8&gt;
    }
}
</code></pre>
<p><strong>Wildcard optimization in subpatterns:</strong></p>
<pre><code class="language-fsharp">match list with
| Cons(_, tail) -&gt; length tail + 1  // Don't extract head
| Nil -&gt; 0
</code></pre>
<pre><code class="language-mlir">case 1 {  // Cons
    // Wildcard _: Skip head extraction
    // %head = llvm.load %data  -- NOT generated!

    %tail_ptr = llvm.getelementptr %data[1] : (!llvm.ptr) -&gt; !llvm.ptr
    %tail = llvm.load %tail_ptr : !llvm.ptr -&gt; !llvm.struct&lt;(i32, ptr)&gt;
    // ...
}
</code></pre>
<p><strong>Wildcard 최적화의 효과:</strong></p>
<ol>
<li><strong>메모리 접근 감소</strong>: 불필요한 load 제거</li>
<li><strong>레지스터 절약</strong>: unused 값을 저장 안 함</li>
<li><strong>DCE 촉진</strong>: Dead code elimination이 더 쉬워짐</li>
</ol>
<h3 id="type-dispatch-pattern"><a class="header" href="#type-dispatch-pattern">Type Dispatch Pattern</a></h3>
<p><strong>타입 기반 dispatch (future extension):</strong></p>
<p>일부 언어는 runtime type으로 dispatch한다:</p>
<pre><code class="language-fsharp">// Hypothetical type dispatch
match value with
| :? int as n -&gt; n + 1
| :? string as s -&gt; String.length s
| _ -&gt; 0
</code></pre>
<p>이는 다음으로 lowering 가능:</p>
<pre><code class="language-mlir">// Type tag dispatch (similar to ADT constructor)
%type_tag = llvm.extractvalue %boxed_value[0] : !llvm.struct&lt;(i32, ptr)&gt;
%tag_index = arith.index_cast %type_tag : i32 to index

scf.index_switch %tag_index : index -&gt; i32
case 0 { /* int case */ }
case 1 { /* string case */ }
default { scf.yield %zero : i32 }
</code></pre>
<p>현재 FunLang은 ADT constructor만 지원하지만, 동일한 패턴이 적용된다.</p>
<hr>
<h2 id="summary-and-chapter-20-preview"><a class="header" href="#summary-and-chapter-20-preview">Summary and Chapter 20 Preview</a></h2>
<h3 id="chapter-19-recap"><a class="header" href="#chapter-19-recap">Chapter 19 Recap</a></h3>
<p><strong>이 장에서 배운 것:</strong></p>
<p>✅ <strong>Part 1: Match Operation Definition</strong></p>
<ol>
<li>
<p><strong>Region-based operations</strong></p>
<ul>
<li>Regions vs basic blocks: encapsulation, verification 장점</li>
<li><code>funlang.match</code>는 multiple regions (variadic, each with 1 block)</li>
</ul>
</li>
<li>
<p><strong>Match operation semantics</strong></p>
<ul>
<li>Runtime execution: tag extraction → case selection → variable binding → yield</li>
<li>Block arguments for pattern variables</li>
</ul>
</li>
<li>
<p><strong>TableGen definition</strong></p>
<ul>
<li>Traits: <code>RecursiveSideEffect</code>, <code>SingleBlockImplicitTerminator&lt;"YieldOp"&gt;</code></li>
<li><code>VariadicRegion&lt;SizedRegion&lt;1&gt;&gt;</code> for flexible case count</li>
<li>Custom assembly format, verifier</li>
</ul>
</li>
<li>
<p><strong>YieldOp terminator</strong></p>
<ul>
<li>Terminator trait, HasParent&lt;“MatchOp”&gt; constraint</li>
<li>Dedicated operation (not reusing scf.yield)</li>
</ul>
</li>
<li>
<p><strong>C API and F# integration</strong></p>
<ul>
<li>Builder callback pattern for region construction</li>
<li>High-level wrapper: <code>CreateMatchOp(scrutinee, resultType, buildCases)</code></li>
<li>Block arguments added in F# callback, mapped in lowering pass</li>
</ul>
</li>
</ol>
<p>✅ <strong>Part 2: SCF Lowering and Pipeline</strong></p>
<ol>
<li>
<p><strong>SCF dialect overview</strong></p>
<ul>
<li>Structured control flow (regions, not goto)</li>
<li><code>scf.index_switch</code> for multi-way branching</li>
<li>Why SCF before LLVM: structure preservation, optimization, debugging</li>
</ul>
</li>
<li>
<p><strong>MatchOpLowering pattern</strong></p>
<ul>
<li>Tag extraction and index casting</li>
<li>Data extraction for pattern variables</li>
<li>IRMapping for block argument remapping</li>
<li>Region cloning with mapped values</li>
<li><code>funlang.yield</code> → <code>scf.yield</code> conversion</li>
</ul>
</li>
<li>
<p><strong>Complete pipeline</strong></p>
<ul>
<li>FunLangToSCFPass → FunLangToLLVMPass → SCFToControlFlowPass → …</li>
<li>Pass dependencies and ordering</li>
<li>End-to-end example: sum_list</li>
</ul>
</li>
<li>
<p><strong>Common errors</strong></p>
<ul>
<li>Block argument count mismatch</li>
<li>Type mismatch in regions</li>
<li>Missing scf.yield</li>
<li>Wrong tag values</li>
<li>Incorrect data extraction</li>
</ul>
</li>
</ol>
<h3 id="pattern-matching-pipeline-complete"><a class="header" href="#pattern-matching-pipeline-complete">Pattern Matching Pipeline: Complete</a></h3>
<p><strong>Phase 6 journey:</strong></p>
<pre><code>Chapter 17: Theory
  ↓
  Decision tree algorithm
  Pattern matrix, specialization/defaulting
  Exhaustiveness checking

Chapter 18: Data Structures
  ↓
  !funlang.list&lt;T&gt; type
  funlang.nil, funlang.cons operations
  TypeConverter, lowering patterns

Chapter 19: Match Compilation (현재)
  ↓
  funlang.match operation
  Region-based structure
  MatchOpLowering to scf.index_switch
  Complete pipeline

Chapter 20: Functional Programs (next)
  ↓
  Realistic examples: map, filter, fold
  Performance analysis
  Debugging functional code
</code></pre>
<p><strong>지금까지의 성과:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Chapters</th><th>Operations</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>Arithmetic</td><td>5-6</td><td>arith.*</td><td>✅ Phase 2</td></tr>
<tr><td>Let bindings</td><td>7</td><td>SSA values</td><td>✅ Phase 2</td></tr>
<tr><td>Control flow</td><td>8</td><td>scf.if</td><td>✅ Phase 2</td></tr>
<tr><td>Functions</td><td>10</td><td>func.func, func.call</td><td>✅ Phase 3</td></tr>
<tr><td>Recursion</td><td>11</td><td>func.call @self</td><td>✅ Phase 3</td></tr>
<tr><td>Closures</td><td>12</td><td>funlang.closure</td><td>✅ Phase 5</td></tr>
<tr><td>Higher-order</td><td>13</td><td>funlang.apply</td><td>✅ Phase 5</td></tr>
<tr><td>Custom dialect</td><td>14-16</td><td>Lowering passes</td><td>✅ Phase 5</td></tr>
<tr><td>Pattern matching</td><td>17-19</td><td>funlang.match</td><td>✅ Phase 6 (현재)</td></tr>
<tr><td>Data structures</td><td>17-19</td><td>funlang.nil, funlang.cons</td><td>✅ Phase 6 (현재)</td></tr>
</tbody>
</table>
</div>
<p><strong>다음: Realistic functional programs</strong></p>
<h3 id="chapter-20-preview-functional-programs"><a class="header" href="#chapter-20-preview-functional-programs">Chapter 20 Preview: Functional Programs</a></h3>
<p><strong>Chapter 20에서 할 것:</strong></p>
<ol>
<li>
<p><strong>Classic list functions</strong></p>
<ul>
<li><code>length</code>, <code>map</code>, <code>filter</code>, <code>fold_left</code>, <code>fold_right</code></li>
<li>Pattern matching + recursion 결합</li>
</ul>
</li>
<li>
<p><strong>Composed functions</strong></p>
<ul>
<li><code>sum = fold_left (+) 0</code></li>
<li><code>product = fold_left (*) 1</code></li>
<li>Higher-order functions로 추상화</li>
</ul>
</li>
<li>
<p><strong>Performance analysis</strong></p>
<ul>
<li>Tail recursion vs non-tail recursion</li>
<li>Closure allocation overhead</li>
<li>GC pressure measurement</li>
</ul>
</li>
<li>
<p><strong>Debugging techniques</strong></p>
<ul>
<li>IR dumping at each stage</li>
<li>printf debugging in functional code</li>
<li>Stack trace interpretation</li>
</ul>
</li>
<li>
<p><strong>Complete FunLang compiler</strong></p>
<ul>
<li>All features integrated</li>
<li>End-to-end compilation</li>
<li>Real-world program examples</li>
</ul>
</li>
</ol>
<p><strong>Chapter 20 목표:</strong></p>
<p>지금까지 배운 모든 기능을 종합하여 <strong>실용적인 함수형 프로그램</strong>을 작성하고 컴파일한다.</p>
<p><strong>Example program (Chapter 20):</strong></p>
<pre><code class="language-fsharp">// Functional list library
let rec map f lst =
    match lst with
    | [] -&gt; []
    | head :: tail -&gt; f head :: map f tail

let rec filter pred lst =
    match lst with
    | [] -&gt; []
    | head :: tail -&gt;
        if pred head then
            head :: filter pred tail
        else
            filter pred tail

let rec fold_left f acc lst =
    match lst with
    | [] -&gt; acc
    | head :: tail -&gt; fold_left f (f acc head) tail

// Usage
let double x = x * 2
let is_even x = x % 2 = 0

let main () =
    let numbers = [1; 2; 3; 4; 5; 6]
    let doubled = map double numbers         // [2; 4; 6; 8; 10; 12]
    let evens = filter is_even doubled       // [2; 4; 6; 8; 10; 12]
    let sum = fold_left (+) 0 evens          // 42
    sum
</code></pre>
<p><strong>Generated MLIR (high-level view):</strong></p>
<pre><code class="language-mlir">module {
  func.func @map(%f: !funlang.closure, %lst: !funlang.list&lt;i32&gt;)
      -&gt; !funlang.list&lt;i32&gt; {
    %result = funlang.match %lst {
      ^nil: ...
      ^cons(%h, %t): ...
    }
    return %result
  }

  func.func @filter(%pred: !funlang.closure, %lst: !funlang.list&lt;i32&gt;)
      -&gt; !funlang.list&lt;i32&gt; { ... }

  func.func @fold_left(%f: !funlang.closure, %acc: i32, %lst: !funlang.list&lt;i32&gt;)
      -&gt; i32 { ... }

  func.func @main() -&gt; i32 {
    // Build list [1; 2; 3; 4; 5; 6]
    %numbers = ...

    // map double numbers
    %double = funlang.closure @double, () : !funlang.closure
    %doubled = func.call @map(%double, %numbers) : ...

    // filter is_even doubled
    %is_even = funlang.closure @is_even, () : !funlang.closure
    %evens = func.call @filter(%is_even, %doubled) : ...

    // fold_left (+) 0 evens
    %plus = funlang.closure @plus, () : !funlang.closure
    %zero = arith.constant 0 : i32
    %sum = func.call @fold_left(%plus, %zero, %evens) : ...

    return %sum : i32
  }
}
</code></pre>
<p><strong>Chapter 20 will show:</strong></p>
<ul>
<li>Complete compilation to native code</li>
<li>Performance benchmarks</li>
<li>Comparison with imperative equivalents</li>
<li>Debugging workflow for functional programs</li>
</ul>
<hr>
<h2 id="튜플-패턴-매칭-tuple-pattern-matching"><a class="header" href="#튜플-패턴-매칭-tuple-pattern-matching">튜플 패턴 매칭 (Tuple Pattern Matching)</a></h2>
<p>Chapter 18에서 우리는 <code>!funlang.tuple&lt;T1, T2, ...&gt;</code> 타입과 <code>funlang.make_tuple</code> 연산을 구현했다. 이제 튜플에 대한 패턴 매칭을 구현하자.</p>
<h3 id="튜플-패턴의-특성-tuple-pattern-characteristics"><a class="header" href="#튜플-패턴의-특성-tuple-pattern-characteristics">튜플 패턴의 특성 (Tuple Pattern Characteristics)</a></h3>
<p><strong>튜플 패턴은 리스트 패턴과 근본적으로 다르다:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>특성</th><th>리스트 패턴</th><th>튜플 패턴</th></tr>
</thead>
<tbody>
<tr><td>태그 검사</td><td>필요 (Nil/Cons 구분)</td><td>불필요</td></tr>
<tr><td>패턴 case 수</td><td>최소 2개 (Nil, Cons)</td><td>항상 1개</td></tr>
<tr><td>매칭 실패 가능성</td><td>있음</td><td>없음 (항상 매칭)</td></tr>
<tr><td>Lowering 대상</td><td>scf.index_switch</td><td>직접 extractvalue</td></tr>
<tr><td>제어 흐름</td><td>조건부 분기</td><td>선형</td></tr>
</tbody>
</table>
</div>
<p><strong>핵심 통찰:</strong></p>
<p>튜플 패턴은 본질적으로 **구조 분해(destructuring)**다. 항상 매칭이 성공하므로 조건 분기가 필요 없다.</p>
<pre><code class="language-fsharp">// 리스트: 두 가지 가능성, 조건 분기 필요
match list with
| [] -&gt; expr1       // Nil case
| x :: xs -&gt; expr2  // Cons case

// 튜플: 한 가지 가능성, 조건 분기 불필요
match pair with
| (x, y) -&gt; x + y   // 항상 이 case로
</code></pre>
<h3 id="funlangmatch-튜플-지원-tuple-support-in-funlangmatch"><a class="header" href="#funlangmatch-튜플-지원-tuple-support-in-funlangmatch">funlang.match 튜플 지원 (Tuple Support in funlang.match)</a></h3>
<p><strong>튜플 패턴 매칭의 MLIR 표현:</strong></p>
<pre><code class="language-mlir">// 소스 코드: let (x, y) = pair in x + y
%pair = funlang.make_tuple(%a, %b) : !funlang.tuple&lt;i32, i32&gt;

%sum = funlang.match %pair : !funlang.tuple&lt;i32, i32&gt; -&gt; i32 {
  ^case(%x: i32, %y: i32):
    %result = arith.addi %x, %y : i32
    funlang.yield %result : i32
}
</code></pre>
<p><strong>리스트 패턴과 비교:</strong></p>
<pre><code class="language-mlir">// 리스트 패턴: 두 case
%result = funlang.match %list : !funlang.list&lt;i32&gt; -&gt; i32 {
  ^nil:
    %zero = arith.constant 0 : i32
    funlang.yield %zero : i32
  ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
    // ...
    funlang.yield %sum : i32
}

// 튜플 패턴: 한 case만
%result = funlang.match %tuple : !funlang.tuple&lt;i32, i32&gt; -&gt; i32 {
  ^case(%x: i32, %y: i32):
    // 항상 이 case 실행
    funlang.yield %result : i32
}
</code></pre>
<p><strong>튜플 패턴의 핵심:</strong></p>
<ol>
<li><strong>단일 case</strong>: 분기 불필요</li>
<li><strong>block arguments = 구조 분해된 원소</strong>: <code>(%x, %y)</code> → <code>^case(%x: i32, %y: i32)</code></li>
<li><strong>원소 개수 = block argument 개수</strong>: 타입의 arity와 일치</li>
</ol>
<h3 id="튜플-로우어링-구현-tuple-lowering-implementation"><a class="header" href="#튜플-로우어링-구현-tuple-lowering-implementation">튜플 로우어링 구현 (Tuple Lowering Implementation)</a></h3>
<p><strong>핵심 차이점:</strong></p>
<p>리스트 패턴 lowering:</p>
<ol>
<li>태그 추출 (extractvalue [0])</li>
<li>scf.index_switch로 분기</li>
<li>각 case에서 데이터 추출</li>
</ol>
<p>튜플 패턴 lowering:</p>
<ol>
<li>각 원소 추출 (extractvalue [i])</li>
<li>원래 block의 operation들을 inline</li>
<li>분기 없음!</li>
</ol>
<p><strong>TupleMatchLowering 패턴:</strong></p>
<pre><code class="language-cpp">// 튜플 패턴 매칭의 lowering은 특별 처리가 필요
// MatchOpLowering 내부에서 튜플 타입 감지 시

LogicalResult matchTuplePattern(MatchOp op, OpAdaptor adaptor,
                                 ConversionPatternRewriter &amp;rewriter) {
  Location loc = op.getLoc();
  Value input = adaptor.getInput();

  // 튜플은 단일 case만 가짐
  assert(op.getCases().size() == 1 &amp;&amp; "Tuple match must have exactly one case");

  Region&amp; caseRegion = op.getCases().front();
  Block&amp; caseBlock = caseRegion.front();

  // 구조체에서 각 원소 추출
  auto structType = input.getType().cast&lt;LLVM::LLVMStructType&gt;();
  IRMapping mapper;

  for (size_t i = 0; i &lt; caseBlock.getNumArguments(); ++i) {
    Value extracted = rewriter.create&lt;LLVM::ExtractValueOp&gt;(
        loc, structType.getBody()[i], input, i);
    mapper.map(caseBlock.getArgument(i), extracted);
  }

  // 원래 block의 operations를 현재 위치에 inline
  for (Operation&amp; op : caseBlock.getOperations()) {
    if (auto yieldOp = dyn_cast&lt;YieldOp&gt;(&amp;op)) {
      // yield의 값으로 match 결과를 대체
      Value yieldValue = mapper.lookupOrDefault(yieldOp.getValue());
      rewriter.replaceOp(op, yieldValue);
    } else {
      rewriter.clone(op, mapper);
    }
  }

  return success();
}
</code></pre>
<p><strong>Lowering 결과 비교:</strong></p>
<pre><code class="language-mlir">// Before lowering (FunLang)
%sum = funlang.match %pair : !funlang.tuple&lt;i32, i32&gt; -&gt; i32 {
  ^case(%x: i32, %y: i32):
    %result = arith.addi %x, %y : i32
    funlang.yield %result : i32
}

// After lowering (LLVM dialect) - 분기 없음!
%x = llvm.extractvalue %pair[0] : !llvm.struct&lt;(i32, i32)&gt;
%y = llvm.extractvalue %pair[1] : !llvm.struct&lt;(i32, i32)&gt;
%sum = arith.addi %x, %y : i32
</code></pre>
<p><strong>리스트 패턴 lowering과 비교:</strong></p>
<pre><code class="language-mlir">// 리스트: scf.index_switch 필요
%tag = llvm.extractvalue %list[0] : !llvm.struct&lt;(i32, ptr)&gt;
%tagIndex = arith.index_cast %tag : i32 to index
%result = scf.index_switch %tagIndex : index -&gt; i32
case 0 {  // Nil
  %zero = arith.constant 0 : i32
  scf.yield %zero : i32
}
case 1 {  // Cons
  %ptr = llvm.extractvalue %list[1] : !llvm.struct&lt;(i32, ptr)&gt;
  %head = llvm.load %ptr : !llvm.ptr -&gt; i32
  // ...
  scf.yield %sum : i32
}
default {
  llvm.unreachable
}

// 튜플: extractvalue만으로 충분
%x = llvm.extractvalue %pair[0] : !llvm.struct&lt;(i32, i32)&gt;
%y = llvm.extractvalue %pair[1] : !llvm.struct&lt;(i32, i32)&gt;
%result = arith.addi %x, %y : i32
</code></pre>
<h3 id="중첩-패턴-nested-patterns"><a class="header" href="#중첩-패턴-nested-patterns">중첩 패턴 (Nested Patterns)</a></h3>
<p><strong>튜플 안에 리스트가 있는 경우:</strong></p>
<pre><code class="language-fsharp">// 두 리스트를 튜플로 묶어서 동시에 패턴 매칭
let rec zip xs ys =
  match (xs, ys) with
  | ([], _) -&gt; []
  | (_, []) -&gt; []
  | (x :: xs', y :: ys') -&gt; (x, y) :: zip xs' ys'
</code></pre>
<p><strong>MLIR 표현:</strong></p>
<pre><code class="language-mlir">// 1단계: 튜플 구조 분해
%tuple = funlang.make_tuple(%xs, %ys) : !funlang.tuple&lt;!funlang.list&lt;i32&gt;, !funlang.list&lt;i32&gt;&gt;

// 2단계: 튜플에서 두 리스트 추출
%xs_extracted = ... extractvalue [0] ...
%ys_extracted = ... extractvalue [1] ...

// 3단계: 첫 번째 리스트에 대해 패턴 매칭
%result = funlang.match %xs_extracted : !funlang.list&lt;i32&gt; -&gt; ... {
  ^nil:
    // 빈 리스트 반환
  ^cons(%x: i32, %xs_tail: !funlang.list&lt;i32&gt;):
    // 4단계: 두 번째 리스트에 대해 중첩 패턴 매칭
    %inner = funlang.match %ys_extracted : !funlang.list&lt;i32&gt; -&gt; ... {
      ^nil:
        // 빈 리스트 반환
      ^cons(%y: i32, %ys_tail: !funlang.list&lt;i32&gt;):
        // (x, y) :: zip xs_tail ys_tail
        %pair = funlang.make_tuple(%x, %y) : !funlang.tuple&lt;i32, i32&gt;
        %rest = func.call @zip(%xs_tail, %ys_tail) : ...
        %result = funlang.cons %pair, %rest : ...
        funlang.yield %result
    }
    funlang.yield %inner
}
</code></pre>
<p><strong>중첩 패턴 lowering 전략:</strong></p>
<ol>
<li><strong>외부에서 내부로</strong>: 가장 바깥 패턴부터 lowering</li>
<li><strong>튜플 먼저</strong>: 튜플 분해는 조건 없이 extractvalue</li>
<li><strong>리스트는 분기</strong>: 각 리스트 패턴은 scf.index_switch 필요</li>
<li><strong>깊이 우선</strong>: 내부 패턴이 완전히 lowering된 후 외부로</li>
</ol>
<h3 id="matchoplowering-확장-튜플-지원"><a class="header" href="#matchoplowering-확장-튜플-지원">MatchOpLowering 확장: 튜플 지원</a></h3>
<p><strong>기존 MatchOpLowering에 튜플 분기 추가:</strong></p>
<pre><code class="language-cpp">class MatchOpLowering : public OpConversionPattern&lt;MatchOp&gt; {
public:
  LogicalResult matchAndRewrite(MatchOp op, OpAdaptor adaptor,
                                 ConversionPatternRewriter &amp;rewriter) const override {
    Location loc = op.getLoc();
    Value input = adaptor.getInput();
    Type inputType = op.getInput().getType();

    // 튜플인지 확인
    if (auto tupleType = inputType.dyn_cast&lt;funlang::TupleType&gt;()) {
      return matchTuplePattern(op, adaptor, rewriter, tupleType);
    }

    // 리스트인 경우 기존 로직 사용
    if (auto listType = inputType.dyn_cast&lt;funlang::ListType&gt;()) {
      return matchListPattern(op, adaptor, rewriter, listType);
    }

    return op.emitError("unsupported match input type");
  }

private:
  LogicalResult matchTuplePattern(MatchOp op, OpAdaptor adaptor,
                                   ConversionPatternRewriter &amp;rewriter,
                                   funlang::TupleType tupleType) const {
    Location loc = op.getLoc();
    Value input = adaptor.getInput();

    // 튜플은 단일 case만 허용
    if (op.getCases().size() != 1) {
      return op.emitError("tuple match must have exactly one case");
    }

    Region&amp; caseRegion = op.getCases().front();
    Block&amp; caseBlock = caseRegion.front();

    // block argument 개수 검증
    if (caseBlock.getNumArguments() != tupleType.getNumElements()) {
      return op.emitError() &lt;&lt; "tuple arity mismatch: type has "
                            &lt;&lt; tupleType.getNumElements() &lt;&lt; " elements but pattern has "
                            &lt;&lt; caseBlock.getNumArguments();
    }

    // 각 원소 추출 및 매핑
    auto structType = getTypeConverter()-&gt;convertType(tupleType);
    IRMapping mapper;

    for (size_t i = 0; i &lt; caseBlock.getNumArguments(); ++i) {
      auto elemType = structType.cast&lt;LLVM::LLVMStructType&gt;().getBody()[i];
      Value extracted = rewriter.create&lt;LLVM::ExtractValueOp&gt;(
          loc, elemType, input, i);
      mapper.map(caseBlock.getArgument(i), extracted);
    }

    // 현재 위치에 operations inline
    Value resultValue;
    for (Operation&amp; caseOp : caseBlock.getOperations()) {
      if (auto yieldOp = dyn_cast&lt;YieldOp&gt;(&amp;caseOp)) {
        resultValue = mapper.lookupOrDefault(yieldOp.getValue());
      } else {
        rewriter.clone(caseOp, mapper);
      }
    }

    rewriter.replaceOp(op, resultValue);
    return success();
  }

  LogicalResult matchListPattern(MatchOp op, OpAdaptor adaptor,
                                  ConversionPatternRewriter &amp;rewriter,
                                  funlang::ListType listType) const {
    // 기존 리스트 패턴 매칭 로직...
    // (scf.index_switch 사용)
  }
};
</code></pre>
<h3 id="리스트-vs-튜플-패턴-매칭-종합-비교"><a class="header" href="#리스트-vs-튜플-패턴-매칭-종합-비교">리스트 vs 튜플 패턴 매칭 종합 비교</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>구분</th><th>리스트 패턴</th><th>튜플 패턴</th></tr>
</thead>
<tbody>
<tr><td><strong>타입</strong></td><td><code>!funlang.list&lt;T&gt;</code></td><td><code>!funlang.tuple&lt;T1, T2, ...&gt;</code></td></tr>
<tr><td><strong>case 수</strong></td><td>2개 이상 (Nil, Cons, …)</td><td>정확히 1개</td></tr>
<tr><td><strong>태그 검사</strong></td><td>필요 (extractvalue [0])</td><td>불필요</td></tr>
<tr><td><strong>분기</strong></td><td>scf.index_switch</td><td>없음</td></tr>
<tr><td><strong>데이터 추출</strong></td><td>ptr load 필요</td><td>extractvalue만</td></tr>
<tr><td><strong>패턴 변수 바인딩</strong></td><td>조건부 (case 안에서)</td><td>무조건</td></tr>
<tr><td><strong>default case</strong></td><td>있음 (unreachable)</td><td>없음</td></tr>
<tr><td><strong>lowering 복잡도</strong></td><td>높음</td><td>낮음</td></tr>
<tr><td><strong>최종 코드 크기</strong></td><td>크다 (분기 포함)</td><td>작다 (선형)</td></tr>
</tbody>
</table>
</div>
<p><strong>생성되는 코드 비교:</strong></p>
<pre><code class="language-mlir">// 리스트 패턴 매칭 결과 (복잡)
%tag = llvm.extractvalue %list[0] : !llvm.struct&lt;(i32, ptr)&gt;
%idx = arith.index_cast %tag : i32 to index
%result = scf.index_switch %idx : index -&gt; i32
case 0 {  // ~10 lines
  ...
  scf.yield %val0 : i32
}
case 1 {  // ~15 lines
  ...
  scf.yield %val1 : i32
}
default {  // ~3 lines
  llvm.unreachable
}

// 튜플 패턴 매칭 결과 (단순)
%x = llvm.extractvalue %pair[0] : !llvm.struct&lt;(i32, i32)&gt;
%y = llvm.extractvalue %pair[1] : !llvm.struct&lt;(i32, i32)&gt;
// ... operations inline ...
</code></pre>
<h3 id="튜플-패턴의-최적화-기회"><a class="header" href="#튜플-패턴의-최적화-기회">튜플 패턴의 최적화 기회</a></h3>
<p><strong>튜플 패턴 매칭은 이미 최적화되어 있다:</strong></p>
<ol>
<li><strong>분기 제거</strong>: 조건문 없이 바로 연산</li>
<li><strong>Inlining 자동</strong>: 별도 함수 호출 없음</li>
<li><strong>레지스터 친화적</strong>: 작은 튜플은 레지스터에 유지</li>
</ol>
<p><strong>추가 최적화 가능:</strong></p>
<pre><code class="language-mlir">// Before: 사용하지 않는 원소도 추출
%pair = funlang.make_tuple(%a, %b) : !funlang.tuple&lt;i32, i32&gt;
%result = funlang.match %pair {
  ^case(%x: i32, %y: i32):  // %y 사용 안 함
    funlang.yield %x : i32
}

// After: Dead code elimination으로 %y 추출 제거
%x = llvm.extractvalue %pair[0] : !llvm.struct&lt;(i32, i32)&gt;
// %y 추출 생략됨
%result = %x
</code></pre>
<h3 id="와일드카드-패턴-wildcard-pattern"><a class="header" href="#와일드카드-패턴-wildcard-pattern">와일드카드 패턴 (Wildcard Pattern)</a></h3>
<p><strong>사용하지 않는 원소는 와일드카드로:</strong></p>
<pre><code class="language-fsharp">// 첫 번째 원소만 사용
let fst pair = match pair with (x, _) -&gt; x

// 두 번째 원소만 사용
let snd pair = match pair with (_, y) -&gt; y
</code></pre>
<p><strong>MLIR에서 와일드카드:</strong></p>
<pre><code class="language-mlir">// 와일드카드는 block argument가 없음
%fst = funlang.match %pair : !funlang.tuple&lt;i32, i32&gt; -&gt; i32 {
  ^case(%x: i32):  // %y 자리에 block argument 없음 (또는 unused)
    funlang.yield %x : i32
}
</code></pre>
<p><strong>Lowering 시 최적화:</strong></p>
<pre><code class="language-cpp">// 와일드카드 패턴 처리
for (size_t i = 0; i &lt; tupleType.getNumElements(); ++i) {
  BlockArgument arg = caseBlock.getArgument(i);
  if (!arg.use_empty()) {  // 사용되는 경우에만 추출
    Value extracted = rewriter.create&lt;LLVM::ExtractValueOp&gt;(...);
    mapper.map(arg, extracted);
  }
  // 와일드카드 (미사용)면 extractvalue 생략
}
</code></pre>
<h3 id="summary-튜플-패턴-매칭"><a class="header" href="#summary-튜플-패턴-매칭">Summary: 튜플 패턴 매칭</a></h3>
<p><strong>구현 완료:</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""> 튜플 패턴의 특성 이해 (단일 case, 분기 없음)</li>
<li><input disabled="" type="checkbox" checked=""> funlang.match에서 튜플 타입 지원</li>
<li><input disabled="" type="checkbox" checked=""> MatchOpLowering에서 튜플/리스트 분기 처리</li>
<li><input disabled="" type="checkbox" checked=""> extractvalue 체인으로 원소 추출</li>
<li><input disabled="" type="checkbox" checked=""> 분기 없이 inline lowering</li>
<li><input disabled="" type="checkbox" checked=""> 중첩 패턴 (튜플 + 리스트) 처리 전략</li>
<li><input disabled="" type="checkbox" checked=""> 와일드카드 패턴과 dead code elimination</li>
</ul>
<p><strong>튜플 패턴 vs 리스트 패턴:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>측면</th><th>리스트</th><th>튜플</th></tr>
</thead>
<tbody>
<tr><td>패턴 case</td><td>다중</td><td>단일</td></tr>
<tr><td>제어 흐름</td><td>scf.index_switch</td><td>선형</td></tr>
<tr><td>태그 검사</td><td>필요</td><td>불필요</td></tr>
<tr><td>Lowering</td><td>복잡</td><td>단순</td></tr>
<tr><td>생성 코드</td><td>분기 포함</td><td>extractvalue만</td></tr>
</tbody>
</table>
</div>
<p><strong>다음:</strong></p>
<ul>
<li>Chapter 20에서 튜플을 활용한 실제 프로그램 (zip, fst/snd)</li>
<li>중첩 튜플과 포인트 예제</li>
</ul>
<hr>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p><strong>Chapter 19 완료!</strong></p>
<p>우리는 <code>funlang.match</code> operation을 정의하고 SCF dialect로 lowering하여 <strong>패턴 매칭 컴파일 파이프라인</strong>을 완성했다.</p>
<p><strong>핵심 개념:</strong></p>
<ol>
<li><strong>Region-based operations</strong>: Encapsulation과 verification을 위한 구조</li>
<li><strong>Multi-stage lowering</strong>: FunLang → SCF → CF → LLVM (progressive refinement)</li>
<li><strong>IRMapping</strong>: Block arguments를 실제 values로 remapping</li>
<li><strong>Builder callback pattern</strong>: F#에서 regions를 구축하는 방법</li>
<li><strong>튜플 패턴 매칭</strong>: 분기 없는 extractvalue 기반 lowering</li>
</ol>
<p><strong>Phase 6 진행 상황:</strong></p>
<ul>
<li>✅ Chapter 17: Pattern matching theory (Decision tree algorithm)</li>
<li>✅ Chapter 18: List operations (funlang.nil, funlang.cons, funlang.tuple, funlang.make_tuple)</li>
<li>✅ Chapter 19: Match compilation (funlang.match, 리스트/튜플 패턴 lowering)</li>
<li>⏭️ Chapter 20: Functional programs (map, filter, fold, zip - realistic examples)</li>
</ul>
<p><strong>다음 장에서 만나요!</strong></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-20-functional-programs-functional-programs"><a class="header" href="#chapter-20-functional-programs-functional-programs">Chapter 20: Functional Programs (Functional Programs)</a></h1>
<h2 id="소개-20"><a class="header" href="#소개-20">소개</a></h2>
<p><strong>Phase 6의 여정을 복습하자:</strong></p>
<p><strong>Chapter 17: Pattern Matching Theory</strong>에서는 패턴 매칭의 이론적 기초를 다뤘다:</p>
<ul>
<li>Decision tree 알고리즘 (Maranget 2008)</li>
<li>Pattern matrix와 specialization/defaulting 연산</li>
<li>Exhaustiveness checking과 unreachable case detection</li>
<li>컴파일 시간에 패턴을 분석하여 최적의 decision tree 생성</li>
</ul>
<p><strong>Chapter 18: List Operations</strong>에서는 패턴 매칭이 작동할 데이터 구조를 구현했다:</p>
<ul>
<li><code>!funlang.list&lt;T&gt;</code> parameterized type으로 타입 안전한 리스트 표현</li>
<li><code>funlang.nil</code>과 <code>funlang.cons</code> operations으로 리스트 생성</li>
<li>TypeConverter로 tagged union <code>!llvm.struct&lt;(i32, ptr)&gt;</code> 변환</li>
<li>NilOpLowering과 ConsOpLowering patterns로 LLVM dialect 생성</li>
</ul>
<p><strong>Chapter 19: Match Compilation</strong>에서는 모든 것을 종합했다:</p>
<ul>
<li><code>funlang.match</code> operation으로 패턴 매칭 표현</li>
<li>Multi-stage lowering: FunLang → SCF → CF → LLVM</li>
<li>IRMapping으로 block argument remapping</li>
<li>실행 가능한 코드 생성</li>
</ul>
<p><strong>Chapter 20에서는 이 모든 것을 사용하여 실제 함수형 프로그램을 작성한다.</strong></p>
<h3 id="phase-6의-최종-목표-완전한-함수형-프로그래밍"><a class="header" href="#phase-6의-최종-목표-완전한-함수형-프로그래밍">Phase 6의 최종 목표: 완전한 함수형 프로그래밍</a></h3>
<p>Phase 4에서 우리는 클로저를 구현했다:</p>
<pre><code class="language-fsharp">// Phase 4: 클로저
let makeAdder n = fun x -&gt; x + n
let add5 = makeAdder 5
let result = add5 10  // 15
</code></pre>
<p>Phase 5에서 우리는 커스텀 FunLang dialect를 만들었다:</p>
<pre><code class="language-mlir">// Phase 5: FunLang operations
%closure = funlang.closure @add_impl(%n) : (i32) -&gt; ((i32) -&gt; i32)
%result = funlang.apply %closure(%x) : ((i32) -&gt; i32, i32) -&gt; i32
</code></pre>
<p>Phase 6에서 우리는 리스트와 패턴 매칭을 구현했다:</p>
<pre><code class="language-mlir">// Phase 6: Lists and pattern matching
%list = funlang.cons %head, %tail : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;
%result = funlang.match %list : !funlang.list&lt;i32&gt; -&gt; i32 {
  ^nil:
    funlang.yield %zero : i32
  ^cons(%h: i32, %t: !funlang.list&lt;i32&gt;):
    funlang.yield %h : i32
}
</code></pre>
<p><strong>이제 이 세 가지를 조합하면 강력한 함수형 프로그래밍이 가능하다:</strong></p>
<pre><code class="language-fsharp">// Phase 6 Complete: 클로저 + 리스트 + 패턴 매칭
let map f lst =
  match lst with
  | [] -&gt; []
  | head :: tail -&gt; (f head) :: (map f tail)

let double x = x * 2
let result = map double [1, 2, 3]  // [2, 4, 6]
</code></pre>
<h3 id="chapter-20의-목표-실전-함수형-프로그램"><a class="header" href="#chapter-20의-목표-실전-함수형-프로그램">Chapter 20의 목표: 실전 함수형 프로그램</a></h3>
<p>이 장을 마치면 다음과 같은 <strong>실제 함수형 프로그램을 컴파일하고 실행</strong>할 수 있다:</p>
<p><strong>1. map: 리스트의 각 원소에 함수를 적용</strong></p>
<pre><code class="language-fsharp">let map f lst =
  match lst with
  | [] -&gt; []
  | head :: tail -&gt; (f head) :: (map f tail)

map (fun x -&gt; x * 2) [1, 2, 3]  // [2, 4, 6]
</code></pre>
<p><strong>2. filter: 조건을 만족하는 원소만 남기기</strong></p>
<pre><code class="language-fsharp">let filter pred lst =
  match lst with
  | [] -&gt; []
  | head :: tail -&gt;
      if pred head then
        head :: filter pred tail
      else
        filter pred tail

filter (fun x -&gt; x &gt; 2) [1, 2, 3, 4]  // [3, 4]
</code></pre>
<p><strong>3. fold: 리스트를 하나의 값으로 축약</strong></p>
<pre><code class="language-fsharp">let fold f acc lst =
  match lst with
  | [] -&gt; acc
  | head :: tail -&gt; fold f (f acc head) tail

fold (+) 0 [1, 2, 3, 4, 5]  // 15
</code></pre>
<p><strong>4. 조합: 복잡한 프로그램</strong></p>
<pre><code class="language-fsharp">// 제곱의 합: [1, 2, 3] -&gt; 14
let sum_of_squares lst =
  fold (+) 0 (map (fun x -&gt; x * x) lst)

sum_of_squares [1, 2, 3]  // 1 + 4 + 9 = 14
</code></pre>
<h3 id="성공-기준-완전한-컴파일-파이프라인"><a class="header" href="#성공-기준-완전한-컴파일-파이프라인">성공 기준: 완전한 컴파일 파이프라인</a></h3>
<p>각 함수형 프로그램에 대해 다음을 보여준다:</p>
<ol>
<li><strong>FunLang 소스 코드</strong>: F# 스타일의 함수형 문법</li>
<li><strong>FunLang dialect MLIR</strong>: 커스텀 operations 사용</li>
<li><strong>SCF dialect MLIR</strong>: 제어 흐름으로 변환</li>
<li><strong>LLVM dialect MLIR</strong>: 최종 lowering</li>
<li><strong>실행 결과</strong>: JIT으로 실행하여 결과 확인</li>
</ol>
<p><strong>이것이 바로 “실전 컴파일러“다:</strong></p>
<ul>
<li>교과서의 toy 예제가 아니라 실제 사용 가능한 프로그램</li>
<li>모든 단계를 추적 가능하고 검증 가능</li>
<li>Phase 7 (최적화)로 이어지는 기반</li>
</ul>
<h3 id="chapter-20의-구성"><a class="header" href="#chapter-20의-구성">Chapter 20의 구성</a></h3>
<p><strong>Part 1: Map and Filter (이번 섹션)</strong></p>
<ol>
<li>FunLang에서 리스트 구축하기</li>
<li>map 함수: 소스, 컴파일, 실행</li>
<li>filter 함수: 중첩 제어 흐름</li>
<li>Helper 함수: length, append</li>
</ol>
<p><strong>Part 2: Fold and Complete Pipeline</strong></p>
<ol>
<li>fold 함수: 일반적인 리스트 combinator</li>
<li>완전한 예제: sum_of_squares</li>
<li>성능 고려사항</li>
<li>완전한 컴파일러 통합</li>
<li>Phase 6 요약과 Phase 7 미리보기</li>
</ol>
<p>이 장을 마치면 <strong>Phase 6가 완료</strong>되며, Phase 7 (최적화)로 넘어갈 준비가 된다.</p>
<h2 id="funlang에서-리스트-구축하기"><a class="header" href="#funlang에서-리스트-구축하기">FunLang에서 리스트 구축하기</a></h2>
<h3 id="funlang-ast-확장-list-expressions"><a class="header" href="#funlang-ast-확장-list-expressions">FunLang AST 확장: List Expressions</a></h3>
<p>지금까지 우리는 MLIR operations로 리스트를 직접 구축했다:</p>
<pre><code class="language-mlir">// 직접 MLIR 작성
%nil = funlang.nil : !funlang.list&lt;i32&gt;
%three = arith.constant 3 : i32
%l1 = funlang.cons %three, %nil : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;
</code></pre>
<p>하지만 사용자는 <strong>FunLang 언어</strong>로 작성하고 싶어한다:</p>
<pre><code class="language-fsharp">// 사용자가 원하는 문법
let empty = []
let list = [1, 2, 3]
let consed = 1 :: [2, 3]
</code></pre>
<p><strong>AST 확장이 필요하다.</strong></p>
<h3 id="funlang-ast-type-definition"><a class="header" href="#funlang-ast-type-definition">FunLang AST Type Definition</a></h3>
<p><code>Ast.fs</code>에 리스트 표현식을 추가한다:</p>
<pre><code class="language-fsharp">// Ast.fs
type Expr =
    | Int of int
    | Var of string
    | Add of Expr * Expr
    | Let of string * Expr * Expr
    | If of Expr * Expr * Expr
    | Fun of string * Expr              // Phase 4: lambda
    | App of Expr * Expr                // Phase 4: application

    // Phase 6: List expressions
    | Nil                                // []
    | Cons of Expr * Expr                // head :: tail
    | List of Expr list                  // [1, 2, 3] - syntactic sugar
    | Match of Expr * (Pattern * Expr) list  // match expr with cases

and Pattern =
    | PVar of string                     // x (bind any value)
    | PNil                               // [] (empty list)
    | PCons of Pattern * Pattern         // head :: tail
    | PWild                              // _ (wildcard)
</code></pre>
<p><strong>설계 결정:</strong></p>
<ol>
<li><strong><code>Nil</code></strong>: Empty list <code>[]</code>는 zero-argument constructor</li>
<li><strong><code>Cons</code></strong>: Binary operator <code>::</code> (head와 tail)</li>
<li><strong><code>List</code></strong>: List literal <code>[1, 2, 3]</code>는 syntactic sugar (연속된 Cons로 desugaring)</li>
<li><strong><code>Match</code></strong>: Pattern matching expression</li>
</ol>
<h3 id="list-literal-desugaring"><a class="header" href="#list-literal-desugaring">List Literal Desugaring</a></h3>
<p>List literal은 syntactic sugar다:</p>
<pre><code class="language-fsharp">// 사용자 작성
[1, 2, 3]

// Desugaring
1 :: (2 :: (3 :: []))

// AST 표현
Cons(Int 1, Cons(Int 2, Cons(Int 3, Nil)))
</code></pre>
<p>Desugaring 함수:</p>
<pre><code class="language-fsharp">// Parser.fs or Desugar.fs
let rec desugarList (exprs: Expr list) : Expr =
    match exprs with
    | [] -&gt; Nil
    | head :: tail -&gt; Cons(head, desugarList tail)

// Usage
let ast = List [Int 1; Int 2; Int 3]
let desugared = desugarList [Int 1; Int 2; Int 3]
// Result: Cons(Int 1, Cons(Int 2, Cons(Int 3, Nil)))
</code></pre>
<p><strong>왜 desugaring인가?</strong></p>
<ol>
<li><strong>간단한 컴파일</strong>: 컴파일러는 <code>Cons</code>와 <code>Nil</code>만 처리하면 된다</li>
<li><strong>중복 제거</strong>: <code>List</code> literal과 <code>Cons</code> operator가 같은 representation을 공유</li>
<li><strong>확장성</strong>: 새로운 syntactic sugar 추가 시 desugaring만 변경</li>
</ol>
<h3 id="컴파일러-통합-compileexpr-확장"><a class="header" href="#컴파일러-통합-compileexpr-확장">컴파일러 통합: compileExpr 확장</a></h3>
<p><code>Compiler.fs</code>의 <code>compileExpr</code> 함수를 확장하여 리스트를 처리한다:</p>
<pre><code class="language-fsharp">// Compiler.fs
let rec compileExpr (builder: OpBuilder) (expr: Expr) (symbolTable: Map&lt;string, Value&gt;) : Value =
    match expr with
    | Int n -&gt;
        let ty = builder.GetI32Type()
        builder.CreateConstantInt(ty, n)

    | Var name -&gt;
        symbolTable.[name]

    | Add (left, right) -&gt;
        let lhs = compileExpr builder left symbolTable
        let rhs = compileExpr builder right symbolTable
        builder.CreateAddI(lhs, rhs)

    // ... (Phase 3-4 cases)

    // Phase 6: Nil case
    | Nil -&gt;
        // funlang.nil : !funlang.list&lt;T&gt;
        // Type inference: 주변 context에서 element type 결정
        let elemTy = inferElementType expr  // e.g., i32
        let listTy = builder.GetListType(elemTy)
        builder.CreateNil(listTy)

    // Phase 6: Cons case
    | Cons (head, tail) -&gt;
        // funlang.cons %head, %tail : (T, !funlang.list&lt;T&gt;) -&gt; !funlang.list&lt;T&gt;
        let headVal = compileExpr builder head symbolTable
        let tailVal = compileExpr builder tail symbolTable
        let headTy = headVal.GetType()
        let listTy = builder.GetListType(headTy)
        builder.CreateCons(headVal, tailVal, listTy)

    // Phase 6: Match case (covered later in this chapter)
    | Match (scrutinee, cases) -&gt;
        compileMatch builder scrutinee cases symbolTable
</code></pre>
<p><strong>Type inference 예제:</strong></p>
<pre><code class="language-fsharp">// FunLang source
let list = 1 :: 2 :: []

// Type inference
// - 1 is i32, so head is i32
// - Cons expects (i32, !funlang.list&lt;i32&gt;)
// - [] must be !funlang.list&lt;i32&gt;

// Compiled MLIR
%c1 = arith.constant 1 : i32
%c2 = arith.constant 2 : i32
%nil = funlang.nil : !funlang.list&lt;i32&gt;
%tail = funlang.cons %c2, %nil : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;
%list = funlang.cons %c1, %tail : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;
</code></pre>
<h3 id="예제-리스트-컴파일"><a class="header" href="#예제-리스트-컴파일">예제: 리스트 컴파일</a></h3>
<p><strong>Example 1: Empty list</strong></p>
<pre><code class="language-fsharp">// FunLang
let empty = []
</code></pre>
<p>Compiled MLIR:</p>
<pre><code class="language-mlir">func.func @example1() -&gt; !funlang.list&lt;i32&gt; {
  %empty = funlang.nil : !funlang.list&lt;i32&gt;
  return %empty : !funlang.list&lt;i32&gt;
}
</code></pre>
<p><strong>Example 2: Single element</strong></p>
<pre><code class="language-fsharp">// FunLang
let single = [42]

// Desugared
let single = 42 :: []
</code></pre>
<p>Compiled MLIR:</p>
<pre><code class="language-mlir">func.func @example2() -&gt; !funlang.list&lt;i32&gt; {
  %c42 = arith.constant 42 : i32
  %nil = funlang.nil : !funlang.list&lt;i32&gt;
  %single = funlang.cons %c42, %nil : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;
  return %single : !funlang.list&lt;i32&gt;
}
</code></pre>
<p><strong>Example 3: Multiple elements</strong></p>
<pre><code class="language-fsharp">// FunLang
let list = [1, 2, 3]

// Desugared
let list = 1 :: (2 :: (3 :: []))
</code></pre>
<p>Compiled MLIR:</p>
<pre><code class="language-mlir">func.func @example3() -&gt; !funlang.list&lt;i32&gt; {
  // Build from inside out: 3 :: []
  %c3 = arith.constant 3 : i32
  %nil = funlang.nil : !funlang.list&lt;i32&gt;
  %l3 = funlang.cons %c3, %nil : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;

  // 2 :: [3]
  %c2 = arith.constant 2 : i32
  %l2 = funlang.cons %c2, %l3 : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;

  // 1 :: [2, 3]
  %c1 = arith.constant 1 : i32
  %l1 = funlang.cons %c1, %l2 : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;

  return %l1 : !funlang.list&lt;i32&gt;
}
</code></pre>
<p><strong>Example 4: Cons operator</strong></p>
<pre><code class="language-fsharp">// FunLang
let list = 1 :: 2 :: 3 :: []
</code></pre>
<p>Compiled MLIR (same as Example 3):</p>
<pre><code class="language-mlir">func.func @example4() -&gt; !funlang.list&lt;i32&gt; {
  %c3 = arith.constant 3 : i32
  %nil = funlang.nil : !funlang.list&lt;i32&gt;
  %l3 = funlang.cons %c3, %nil : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;

  %c2 = arith.constant 2 : i32
  %l2 = funlang.cons %c2, %l3 : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;

  %c1 = arith.constant 1 : i32
  %l1 = funlang.cons %c1, %l2 : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;

  return %l1 : !funlang.list&lt;i32&gt;
}
</code></pre>
<p><strong>Type safety:</strong></p>
<p>FunLang의 타입 시스템은 heterogeneous list를 방지한다:</p>
<pre><code class="language-fsharp">// Type error: element type mismatch
let bad = [1, "hello", 3]
// Error: Expected i32, found string
</code></pre>
<p>MLIR type은 element type을 명시한다:</p>
<ul>
<li><code>!funlang.list&lt;i32&gt;</code>: 32비트 정수 리스트</li>
<li><code>!funlang.list&lt;f64&gt;</code>: 64비트 부동소수점 리스트</li>
<li><code>!funlang.list&lt;!funlang.closure&lt;(i32) -&gt; i32&gt;&gt;</code>: 클로저 리스트 (고차 함수)</li>
</ul>
<p>이제 우리는 리스트를 구축할 수 있다. 다음은 <strong>리스트를 조작하는 함수</strong>를 작성할 차례다.</p>
<h2 id="map-함수-리스트-변환"><a class="header" href="#map-함수-리스트-변환">map 함수: 리스트 변환</a></h2>
<h3 id="map의-개념-1"><a class="header" href="#map의-개념-1">map의 개념</a></h3>
<p><code>map</code>은 함수형 프로그래밍의 가장 기본적인 고차 함수다:</p>
<pre><code class="language-fsharp">// map의 타입
map : (a -&gt; b) -&gt; [a] -&gt; [b]

// map의 의미
map f [x1, x2, ..., xn] = [f x1, f x2, ..., f xn]
</code></pre>
<p><strong>예제:</strong></p>
<pre><code class="language-fsharp">let double x = x * 2
map double [1, 2, 3]  // [2, 4, 6]

let inc x = x + 1
map inc [10, 20, 30]  // [11, 21, 31]

map (fun x -&gt; x * x) [1, 2, 3, 4]  // [1, 4, 9, 16]
</code></pre>
<h3 id="funlang-소스-코드"><a class="header" href="#funlang-소스-코드">FunLang 소스 코드</a></h3>
<p><code>map</code> 함수를 FunLang으로 작성한다:</p>
<pre><code class="language-fsharp">let rec map f lst =
  match lst with
  | [] -&gt; []
  | head :: tail -&gt; (f head) :: (map f tail)
</code></pre>
<p><strong>동작 원리:</strong></p>
<ol>
<li><strong>Base case</strong>: Empty list → return empty list</li>
<li><strong>Recursive case</strong>:
<ul>
<li>Apply <code>f</code> to <code>head</code> → transformed head</li>
<li>Recursively map over <code>tail</code></li>
<li>Cons the results</li>
</ul>
</li>
</ol>
<p><strong>실행 trace:</strong></p>
<pre><code class="language-fsharp">map double [1, 2, 3]
→ double 1 :: map double [2, 3]
→ 2 :: (double 2 :: map double [3])
→ 2 :: (4 :: (double 3 :: map double []))
→ 2 :: (4 :: (6 :: []))
→ [2, 4, 6]
</code></pre>
<h3 id="funlang-ast-표현"><a class="header" href="#funlang-ast-표현">FunLang AST 표현</a></h3>
<p>FunLang AST로 표현하면:</p>
<pre><code class="language-fsharp">// let rec map f lst = ...
Let("map",
    Fun("f",
        Fun("lst",
            Match(Var "lst",
                [ (PNil, Nil)
                ; (PCons(PVar "head", PVar "tail"),
                   Cons(App(Var "f", Var "head"),
                        App(App(Var "map", Var "f"), Var "tail")))
                ]))),
    // ... body that uses map ...
)
</code></pre>
<p><strong>구조 분석:</strong></p>
<ol>
<li><strong>Outer Let</strong>: <code>map</code> 정의를 scope에 바인딩</li>
<li><strong>Curried function</strong>: <code>f</code>와 <code>lst</code> 두 개의 중첩 lambda</li>
<li><strong>Match expression</strong>: <code>lst</code>에 대한 패턴 매칭</li>
<li><strong>Patterns</strong>: <code>[]</code> (PNil)과 <code>head :: tail</code> (PCons)</li>
<li><strong>Recursive call</strong>: <code>map f tail</code>에서 <code>map</code> 자기 자신 호출</li>
</ol>
<h3 id="컴파일된-mlir-funlang-dialect"><a class="header" href="#컴파일된-mlir-funlang-dialect">컴파일된 MLIR: FunLang Dialect</a></h3>
<p><code>compileExpr</code>가 위 AST를 컴파일하면 다음 MLIR이 생성된다:</p>
<pre><code class="language-mlir">// map : (T -&gt; U) -&gt; !funlang.list&lt;T&gt; -&gt; !funlang.list&lt;U&gt;
func.func @map(%f: !funlang.closure&lt;(i32) -&gt; i32&gt;,
               %lst: !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt; {
  // match lst with ...
  %result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; !funlang.list&lt;i32&gt; {
    // Case 1: [] -&gt; []
    ^nil:
      %empty = funlang.nil : !funlang.list&lt;i32&gt;
      funlang.yield %empty : !funlang.list&lt;i32&gt;

    // Case 2: head :: tail -&gt; (f head) :: (map f tail)
    ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
      // f head
      %transformed = funlang.apply %f(%head) : (!funlang.closure&lt;(i32) -&gt; i32&gt;, i32) -&gt; i32

      // map f tail (recursive call)
      %mapped_tail = func.call @map(%f, %tail)
        : (!funlang.closure&lt;(i32) -&gt; i32&gt;, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;

      // transformed :: mapped_tail
      %new_list = funlang.cons %transformed, %mapped_tail
        : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;

      funlang.yield %new_list : !funlang.list&lt;i32&gt;
  }

  return %result : !funlang.list&lt;i32&gt;
}
</code></pre>
<p><strong>핵심 포인트:</strong></p>
<ol>
<li><strong><code>funlang.match</code></strong>: 리스트를 검사하는 control flow</li>
<li><strong><code>funlang.apply</code></strong>: 클로저 간접 호출 (<code>f head</code>)</li>
<li><strong><code>func.call @map</code></strong>: 재귀 호출 (named function)</li>
<li><strong><code>funlang.cons</code></strong>: 결과 리스트 구축</li>
<li><strong>Type safety</strong>: 모든 operations가 타입 정보를 유지</li>
</ol>
<h3 id="lowering-stage-1-funlang--scf"><a class="header" href="#lowering-stage-1-funlang--scf">Lowering Stage 1: FunLang → SCF</a></h3>
<p><code>FunLangToSCFPass</code>가 실행되면 <code>funlang.match</code>가 <code>scf.if</code>로 lowering된다:</p>
<pre><code class="language-mlir">func.func @map(%f: !funlang.closure&lt;(i32) -&gt; i32&gt;,
               %lst: !llvm.struct&lt;(i32, ptr)&gt;) -&gt; !llvm.struct&lt;(i32, ptr)&gt; {
  // Extract tag: lst-&gt;tag
  %tag_ptr = llvm.getelementptr %lst[0, 0] : (!llvm.struct&lt;(i32, ptr)&gt;) -&gt; !llvm.ptr
  %tag = llvm.load %tag_ptr : !llvm.ptr -&gt; i32

  // Check if tag == 0 (Nil)
  %c0 = arith.constant 0 : i32
  %is_nil = arith.cmpi eq, %tag, %c0 : i32

  // if (is_nil) then ... else ...
  %result = scf.if %is_nil -&gt; !llvm.struct&lt;(i32, ptr)&gt; {
    // Nil case: return empty list
    %nil_tag = arith.constant 0 : i32
    %null_ptr = llvm.mlir.null : !llvm.ptr
    %empty = llvm.mlir.undef : !llvm.struct&lt;(i32, ptr)&gt;
    %empty1 = llvm.insertvalue %nil_tag, %empty[0] : !llvm.struct&lt;(i32, ptr)&gt;
    %empty2 = llvm.insertvalue %null_ptr, %empty1[1] : !llvm.struct&lt;(i32, ptr)&gt;
    scf.yield %empty2 : !llvm.struct&lt;(i32, ptr)&gt;
  } else {
    // Cons case: extract head and tail
    %cons_tag = arith.constant 1 : i32
    %payload_ptr = llvm.getelementptr %lst[0, 1] : (!llvm.struct&lt;(i32, ptr)&gt;) -&gt; !llvm.ptr
    %payload = llvm.load %payload_ptr : !llvm.ptr -&gt; !llvm.ptr

    // Cast payload to ConsCell: struct { head: i32, tail: list }
    %head_ptr = llvm.getelementptr %payload[0, 0] : (!llvm.ptr) -&gt; !llvm.ptr
    %head = llvm.load %head_ptr : !llvm.ptr -&gt; i32

    %tail_ptr = llvm.getelementptr %payload[0, 1] : (!llvm.ptr) -&gt; !llvm.ptr
    %tail = llvm.load %tail_ptr : !llvm.ptr -&gt; !llvm.struct&lt;(i32, ptr)&gt;

    // Apply closure: f head
    %transformed = funlang.apply %f(%head) : (!funlang.closure&lt;(i32) -&gt; i32&gt;, i32) -&gt; i32

    // Recursive call: map f tail
    %mapped_tail = func.call @map(%f, %tail)
      : (!funlang.closure&lt;(i32) -&gt; i32&gt;, !llvm.struct&lt;(i32, ptr)&gt;) -&gt; !llvm.struct&lt;(i32, ptr)&gt;

    // Build cons cell: transformed :: mapped_tail
    %cell_size = llvm.mlir.constant(16 : i64) : i64  // sizeof(ConsCell)
    %cell = llvm.call @GC_malloc(%cell_size) : (i64) -&gt; !llvm.ptr

    %cell_head_ptr = llvm.getelementptr %cell[0, 0] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %transformed, %cell_head_ptr : i32, !llvm.ptr

    %cell_tail_ptr = llvm.getelementptr %cell[0, 1] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %mapped_tail, %cell_tail_ptr : !llvm.struct&lt;(i32, ptr)&gt;, !llvm.ptr

    // Build list struct: {tag=1, payload=cell}
    %cons_tag_val = arith.constant 1 : i32
    %new_list = llvm.mlir.undef : !llvm.struct&lt;(i32, ptr)&gt;
    %new_list1 = llvm.insertvalue %cons_tag_val, %new_list[0] : !llvm.struct&lt;(i32, ptr)&gt;
    %new_list2 = llvm.insertvalue %cell, %new_list1[1] : !llvm.struct&lt;(i32, ptr)&gt;

    scf.yield %new_list2 : !llvm.struct&lt;(i32, ptr)&gt;
  }

  return %result : !llvm.struct&lt;(i32, ptr)&gt;
}
</code></pre>
<p><strong>변환 내용:</strong></p>
<ol>
<li><strong><code>funlang.match</code> → <code>scf.if</code></strong>: Binary choice (Nil vs Cons)</li>
<li><strong>Tag extraction</strong>: <code>llvm.getelementptr</code> + <code>llvm.load</code>로 tag field 읽기</li>
<li><strong>Comparison</strong>: <code>arith.cmpi eq</code>로 tag 검사</li>
<li><strong>Block arguments → loads</strong>: Cons case의 <code>%head</code>, <code>%tail</code>을 payload에서 추출</li>
<li><strong>GC allocation</strong>: <code>GC_malloc</code>으로 새 cons cell 할당</li>
</ol>
<h3 id="lowering-stage-2-scf--cf--llvm"><a class="header" href="#lowering-stage-2-scf--cf--llvm">Lowering Stage 2: SCF → CF + LLVM</a></h3>
<p><code>SCFToControlFlowPass</code>가 실행되면 <code>scf.if</code>가 <code>cf.br</code>, <code>cf.cond_br</code>로 lowering된다:</p>
<pre><code class="language-mlir">func.func @map(%f: !funlang.closure&lt;(i32) -&gt; i32&gt;,
               %lst: !llvm.struct&lt;(i32, ptr)&gt;) -&gt; !llvm.struct&lt;(i32, ptr)&gt; {
^entry:
  // Extract tag
  %tag_ptr = llvm.getelementptr %lst[0, 0] : (!llvm.struct&lt;(i32, ptr)&gt;) -&gt; !llvm.ptr
  %tag = llvm.load %tag_ptr : !llvm.ptr -&gt; i32

  %c0 = arith.constant 0 : i32
  %is_nil = arith.cmpi eq, %tag, %c0 : i32

  // Conditional branch
  cf.cond_br %is_nil, ^nil_case, ^cons_case

^nil_case:
  // Return empty list
  %nil_tag = arith.constant 0 : i32
  %null_ptr = llvm.mlir.null : !llvm.ptr
  %empty = llvm.mlir.undef : !llvm.struct&lt;(i32, ptr)&gt;
  %empty1 = llvm.insertvalue %nil_tag, %empty[0] : !llvm.struct&lt;(i32, ptr)&gt;
  %empty2 = llvm.insertvalue %null_ptr, %empty1[1] : !llvm.struct&lt;(i32, ptr)&gt;
  cf.br ^exit(%empty2 : !llvm.struct&lt;(i32, ptr)&gt;)

^cons_case:
  // Extract head and tail
  %payload_ptr = llvm.getelementptr %lst[0, 1] : (!llvm.struct&lt;(i32, ptr)&gt;) -&gt; !llvm.ptr
  %payload = llvm.load %payload_ptr : !llvm.ptr -&gt; !llvm.ptr

  %head_ptr = llvm.getelementptr %payload[0, 0] : (!llvm.ptr) -&gt; !llvm.ptr
  %head = llvm.load %head_ptr : !llvm.ptr -&gt; i32

  %tail_ptr = llvm.getelementptr %payload[0, 1] : (!llvm.ptr) -&gt; !llvm.ptr
  %tail = llvm.load %tail_ptr : !llvm.ptr -&gt; !llvm.struct&lt;(i32, ptr)&gt;

  // Apply closure
  %transformed = funlang.apply %f(%head) : (!funlang.closure&lt;(i32) -&gt; i32&gt;, i32) -&gt; i32

  // Recursive call
  %mapped_tail = func.call @map(%f, %tail)
    : (!funlang.closure&lt;(i32) -&gt; i32&gt;, !llvm.struct&lt;(i32, ptr)&gt;) -&gt; !llvm.struct&lt;(i32, ptr)&gt;

  // Allocate cons cell
  %cell_size = llvm.mlir.constant(16 : i64) : i64
  %cell = llvm.call @GC_malloc(%cell_size) : (i64) -&gt; !llvm.ptr

  %cell_head_ptr = llvm.getelementptr %cell[0, 0] : (!llvm.ptr) -&gt; !llvm.ptr
  llvm.store %transformed, %cell_head_ptr : i32, !llvm.ptr

  %cell_tail_ptr = llvm.getelementptr %cell[0, 1] : (!llvm.ptr) -&gt; !llvm.ptr
  llvm.store %mapped_tail, %cell_tail_ptr : !llvm.struct&lt;(i32, ptr)&gt;, !llvm.ptr

  // Build result
  %cons_tag = arith.constant 1 : i32
  %new_list = llvm.mlir.undef : !llvm.struct&lt;(i32, ptr)&gt;
  %new_list1 = llvm.insertvalue %cons_tag, %new_list[0] : !llvm.struct&lt;(i32, ptr)&gt;
  %new_list2 = llvm.insertvalue %cell, %new_list1[1] : !llvm.struct&lt;(i32, ptr)&gt;

  cf.br ^exit(%new_list2 : !llvm.struct&lt;(i32, ptr)&gt;)

^exit(%result: !llvm.struct&lt;(i32, ptr)&gt;):
  return %result : !llvm.struct&lt;(i32, ptr)&gt;
}
</code></pre>
<p><strong>CFG 구조:</strong></p>
<pre><code>       [entry]
          |
       (is_nil?)
        /    \
    [nil]  [cons]
       \    /
       [exit]
</code></pre>
<h3 id="테스트-프로그램-map-fun-x---x--2-1-2-3"><a class="header" href="#테스트-프로그램-map-fun-x---x--2-1-2-3">테스트 프로그램: map (fun x -&gt; x * 2) [1, 2, 3]</a></h3>
<p>완전한 프로그램을 컴파일하고 실행해보자:</p>
<pre><code class="language-fsharp">// FunLang source
let double = fun x -&gt; x * 2

let rec map f lst =
  match lst with
  | [] -&gt; []
  | head :: tail -&gt; (f head) :: (map f tail)

let result = map double [1, 2, 3]
// Expected: [2, 4, 6]
</code></pre>
<p><strong>Compiled MLIR (simplified):</strong></p>
<pre><code class="language-mlir">module {
  // Helper: double function as closure implementation
  func.func @double_impl(%x: i32) -&gt; i32 {
    %c2 = arith.constant 2 : i32
    %result = arith.muli %x, %c2 : i32
    return %result : i32
  }

  // map function (as defined above)
  func.func @map(%f: !funlang.closure&lt;(i32) -&gt; i32&gt;,
                 %lst: !llvm.struct&lt;(i32, ptr)&gt;) -&gt; !llvm.struct&lt;(i32, ptr)&gt; {
    // ... (as shown in previous section)
  }

  // Main entry point
  func.func @main() -&gt; !llvm.struct&lt;(i32, ptr)&gt; {
    // Create closure: double
    %double_fn = llvm.mlir.addressof @double_impl : !llvm.ptr
    %null_env = llvm.mlir.null : !llvm.ptr  // no captures
    %closure_size = llvm.mlir.constant(16 : i64) : i64
    %closure_mem = llvm.call @GC_malloc(%closure_size) : (i64) -&gt; !llvm.ptr

    %fn_ptr_field = llvm.getelementptr %closure_mem[0, 0] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %double_fn, %fn_ptr_field : !llvm.ptr, !llvm.ptr

    %env_ptr_field = llvm.getelementptr %closure_mem[0, 1] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %null_env, %env_ptr_field : !llvm.ptr, !llvm.ptr

    %double = llvm.load %closure_mem : !llvm.ptr -&gt; !funlang.closure&lt;(i32) -&gt; i32&gt;

    // Create list: [1, 2, 3]
    %c1 = arith.constant 1 : i32
    %c2 = arith.constant 2 : i32
    %c3 = arith.constant 3 : i32

    %nil = funlang.nil : !funlang.list&lt;i32&gt;
    %l3 = funlang.cons %c3, %nil : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;
    %l2 = funlang.cons %c2, %l3 : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;
    %l1 = funlang.cons %c1, %l2 : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;

    // Call map
    %result = func.call @map(%double, %l1)
      : (!funlang.closure&lt;(i32) -&gt; i32&gt;, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;

    return %result : !llvm.struct&lt;(i32, ptr)&gt;
  }
}
</code></pre>
<p><strong>실행 trace:</strong></p>
<pre><code>map double [1, 2, 3]
→ double 1 :: map double [2, 3]
→ 2 :: (double 2 :: map double [3])
→ 2 :: (4 :: (double 3 :: map double []))
→ 2 :: (4 :: (6 :: []))
→ [2, 4, 6]
</code></pre>
<p><strong>Memory layout (heap):</strong></p>
<pre><code>Closure (double):
  +0: fn_ptr    -&gt; @double_impl
  +8: env_ptr   -&gt; NULL

List [2, 4, 6]:
  +0: tag=1, payload -&gt; ConsCell1

  ConsCell1:
    +0: head=2
    +8: tail -&gt; {tag=1, payload -&gt; ConsCell2}

  ConsCell2:
    +0: head=4
    +8: tail -&gt; {tag=1, payload -&gt; ConsCell3}

  ConsCell3:
    +0: head=6
    +8: tail -&gt; {tag=0, payload=NULL}  // Nil
</code></pre>
<h3 id="검증-jit-실행"><a class="header" href="#검증-jit-실행">검증: JIT 실행</a></h3>
<pre><code class="language-fsharp">// Compiler.fs
let testMapDouble() =
    let ctx = MLIRContext.Create()
    let module = compileProgram ctx mapDoubleSource

    // Apply lowering passes
    let pm = PassManager.Create(ctx)
    pm.AddPass("convert-funlang-to-scf")
    pm.AddPass("convert-scf-to-cf")
    pm.AddPass("convert-funlang-to-llvm")
    pm.Run(module)

    // JIT execute
    let engine = ExecutionEngine.Create(module)
    let result = engine.Invoke("main", [||])

    // Verify result: [2, 4, 6]
    let list = result :?&gt; ListValue
    assert (list.Count = 3)
    assert (list.[0] = 2)
    assert (list.[1] = 4)
    assert (list.[2] = 6)

    printfn "map double [1, 2, 3] = [2, 4, 6] ✓"
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>map double [1, 2, 3] = [2, 4, 6] ✓
</code></pre>
<p>성공! <code>map</code> 함수가 완전히 작동한다.</p>
<h2 id="filter-함수-조건부-리스트-필터링"><a class="header" href="#filter-함수-조건부-리스트-필터링">filter 함수: 조건부 리스트 필터링</a></h2>
<h3 id="filter의-개념"><a class="header" href="#filter의-개념">filter의 개념</a></h3>
<p><code>filter</code>는 조건을 만족하는 원소만 남긴다:</p>
<pre><code class="language-fsharp">// filter의 타입
filter : (a -&gt; bool) -&gt; [a] -&gt; [a]

// filter의 의미
filter pred [x1, x2, ..., xn] = [xi | pred xi = true]
</code></pre>
<p><strong>예제:</strong></p>
<pre><code class="language-fsharp">let is_positive x = x &gt; 0
filter is_positive [-2, -1, 0, 1, 2]  // [1, 2]

let is_even x = x % 2 == 0
filter is_even [1, 2, 3, 4, 5, 6]  // [2, 4, 6]

filter (fun x -&gt; x &gt; 2) [1, 2, 3, 4]  // [3, 4]
</code></pre>
<h3 id="funlang-소스-코드-1"><a class="header" href="#funlang-소스-코드-1">FunLang 소스 코드</a></h3>
<p><code>filter</code> 함수를 FunLang으로 작성한다:</p>
<pre><code class="language-fsharp">let rec filter pred lst =
  match lst with
  | [] -&gt; []
  | head :: tail -&gt;
      if pred head then
        head :: filter pred tail
      else
        filter pred tail
</code></pre>
<p><strong>동작 원리:</strong></p>
<ol>
<li><strong>Base case</strong>: Empty list → return empty list</li>
<li><strong>Recursive case</strong>:
<ul>
<li>조건 검사: <code>pred head</code></li>
<li>True이면: <code>head</code>를 결과에 포함</li>
<li>False이면: <code>head</code>를 건너뛰고 tail만 재귀 처리</li>
</ul>
</li>
</ol>
<p><strong>실행 trace:</strong></p>
<pre><code class="language-fsharp">filter (fun x -&gt; x &gt; 2) [1, 2, 3, 4]
→ (1 &gt; 2)? No → filter pred [2, 3, 4]
→ (2 &gt; 2)? No → filter pred [3, 4]
→ (3 &gt; 2)? Yes → 3 :: filter pred [4]
→ (4 &gt; 2)? Yes → 3 :: (4 :: filter pred [])
→ 3 :: (4 :: [])
→ [3, 4]
</code></pre>
<h3 id="map-vs-filter-비교"><a class="header" href="#map-vs-filter-비교">map vs filter 비교</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>특성</th><th>map</th><th>filter</th></tr>
</thead>
<tbody>
<tr><td>타입</td><td><code>(a -&gt; b) -&gt; [a] -&gt; [b]</code></td><td><code>(a -&gt; bool) -&gt; [a] -&gt; [a]</code></td></tr>
<tr><td>결과 크기</td><td>Input과 동일</td><td>Input 이하</td></tr>
<tr><td>조건 분기</td><td>없음 (항상 변환)</td><td>있음 (if-else)</td></tr>
<tr><td>원소 변환</td><td>있음 (<code>f x</code>)</td><td>없음 (원소 그대로)</td></tr>
<tr><td>MLIR 복잡도</td><td>Moderate</td><td>Higher (nested control flow)</td></tr>
</tbody>
</table>
</div>
<h3 id="컴파일된-mlir-funlang-dialect-1"><a class="header" href="#컴파일된-mlir-funlang-dialect-1">컴파일된 MLIR: FunLang Dialect</a></h3>
<pre><code class="language-mlir">// filter : (T -&gt; i1) -&gt; !funlang.list&lt;T&gt; -&gt; !funlang.list&lt;T&gt;
func.func @filter(%pred: !funlang.closure&lt;(i32) -&gt; i1&gt;,
                  %lst: !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt; {
  // match lst with ...
  %result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; !funlang.list&lt;i32&gt; {
    // Case 1: [] -&gt; []
    ^nil:
      %empty = funlang.nil : !funlang.list&lt;i32&gt;
      funlang.yield %empty : !funlang.list&lt;i32&gt;

    // Case 2: head :: tail -&gt; if (pred head) then ... else ...
    ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
      // pred head
      %should_keep = funlang.apply %pred(%head)
        : (!funlang.closure&lt;(i32) -&gt; i1&gt;, i32) -&gt; i1

      // Recursive call (always needed)
      %filtered_tail = func.call @filter(%pred, %tail)
        : (!funlang.closure&lt;(i32) -&gt; i1&gt;, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;

      // if should_keep then head :: filtered_tail else filtered_tail
      %new_list = scf.if %should_keep -&gt; !funlang.list&lt;i32&gt; {
        // Keep head
        %kept = funlang.cons %head, %filtered_tail
          : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;
        scf.yield %kept : !funlang.list&lt;i32&gt;
      } else {
        // Skip head
        scf.yield %filtered_tail : !funlang.list&lt;i32&gt;
      }

      funlang.yield %new_list : !funlang.list&lt;i32&gt;
  }

  return %result : !funlang.list&lt;i32&gt;
}
</code></pre>
<p><strong>핵심 포인트:</strong></p>
<ol>
<li><strong>Nested control flow</strong>: <code>funlang.match</code> 안에 <code>scf.if</code></li>
<li><strong>Predicate 호출</strong>: <code>funlang.apply %pred(%head)</code>는 boolean 반환</li>
<li><strong>Conditional cons</strong>: True일 때만 <code>funlang.cons</code></li>
<li><strong>Recursive call position</strong>: if 밖에서 호출 (항상 필요)</li>
</ol>
<h3 id="nested-control-flow-분석"><a class="header" href="#nested-control-flow-분석">Nested Control Flow 분석</a></h3>
<p><code>filter</code>는 두 단계의 제어 흐름을 가진다:</p>
<p><strong>Level 1: Pattern matching</strong></p>
<pre><code>match lst:
  Nil  → []
  Cons → [Level 2]
</code></pre>
<p><strong>Level 2: Conditional inclusion</strong></p>
<pre><code>if pred head:
  True  → head :: filtered_tail
  False → filtered_tail
</code></pre>
<p><strong>Combined CFG:</strong></p>
<pre><code>        [entry]
           |
       (is_nil?)
        /    \
    [nil]  [cons]
       |      |
       |   (pred head?)
       |    /      \
       | [keep]  [skip]
       |    \      /
       |   [merge]
        \    /
        [exit]
</code></pre>
<h3 id="lowering-stage-1-funlang--scf-1"><a class="header" href="#lowering-stage-1-funlang--scf-1">Lowering Stage 1: FunLang → SCF</a></h3>
<pre><code class="language-mlir">func.func @filter(%pred: !funlang.closure&lt;(i32) -&gt; i1&gt;,
                  %lst: !llvm.struct&lt;(i32, ptr)&gt;) -&gt; !llvm.struct&lt;(i32, ptr)&gt; {
  // Extract tag
  %tag_ptr = llvm.getelementptr %lst[0, 0] : (!llvm.struct&lt;(i32, ptr)&gt;) -&gt; !llvm.ptr
  %tag = llvm.load %tag_ptr : !llvm.ptr -&gt; i32

  %c0 = arith.constant 0 : i32
  %is_nil = arith.cmpi eq, %tag, %c0 : i32

  // Level 1: match
  %result = scf.if %is_nil -&gt; !llvm.struct&lt;(i32, ptr)&gt; {
    // Nil case
    %nil_tag = arith.constant 0 : i32
    %null_ptr = llvm.mlir.null : !llvm.ptr
    %empty = llvm.mlir.undef : !llvm.struct&lt;(i32, ptr)&gt;
    %empty1 = llvm.insertvalue %nil_tag, %empty[0] : !llvm.struct&lt;(i32, ptr)&gt;
    %empty2 = llvm.insertvalue %null_ptr, %empty1[1] : !llvm.struct&lt;(i32, ptr)&gt;
    scf.yield %empty2 : !llvm.struct&lt;(i32, ptr)&gt;
  } else {
    // Cons case: extract head and tail
    %payload_ptr = llvm.getelementptr %lst[0, 1] : (!llvm.struct&lt;(i32, ptr)&gt;) -&gt; !llvm.ptr
    %payload = llvm.load %payload_ptr : !llvm.ptr -&gt; !llvm.ptr

    %head_ptr = llvm.getelementptr %payload[0, 0] : (!llvm.ptr) -&gt; !llvm.ptr
    %head = llvm.load %head_ptr : !llvm.ptr -&gt; i32

    %tail_ptr = llvm.getelementptr %payload[0, 1] : (!llvm.ptr) -&gt; !llvm.ptr
    %tail = llvm.load %tail_ptr : !llvm.ptr -&gt; !llvm.struct&lt;(i32, ptr)&gt;

    // Apply predicate
    %should_keep = funlang.apply %pred(%head)
      : (!funlang.closure&lt;(i32) -&gt; i1&gt;, i32) -&gt; i1

    // Recursive call
    %filtered_tail = func.call @filter(%pred, %tail)
      : (!funlang.closure&lt;(i32) -&gt; i1&gt;, !llvm.struct&lt;(i32, ptr)&gt;) -&gt; !llvm.struct&lt;(i32, ptr)&gt;

    // Level 2: if pred
    %new_list = scf.if %should_keep -&gt; !llvm.struct&lt;(i32, ptr)&gt; {
      // Keep: allocate cons cell
      %cell_size = llvm.mlir.constant(16 : i64) : i64
      %cell = llvm.call @GC_malloc(%cell_size) : (i64) -&gt; !llvm.ptr

      %cell_head_ptr = llvm.getelementptr %cell[0, 0] : (!llvm.ptr) -&gt; !llvm.ptr
      llvm.store %head, %cell_head_ptr : i32, !llvm.ptr

      %cell_tail_ptr = llvm.getelementptr %cell[0, 1] : (!llvm.ptr) -&gt; !llvm.ptr
      llvm.store %filtered_tail, %cell_tail_ptr : !llvm.struct&lt;(i32, ptr)&gt;, !llvm.ptr

      %cons_tag = arith.constant 1 : i32
      %kept = llvm.mlir.undef : !llvm.struct&lt;(i32, ptr)&gt;
      %kept1 = llvm.insertvalue %cons_tag, %kept[0] : !llvm.struct&lt;(i32, ptr)&gt;
      %kept2 = llvm.insertvalue %cell, %kept1[1] : !llvm.struct&lt;(i32, ptr)&gt;

      scf.yield %kept2 : !llvm.struct&lt;(i32, ptr)&gt;
    } else {
      // Skip: return filtered_tail directly
      scf.yield %filtered_tail : !llvm.struct&lt;(i32, ptr)&gt;
    }

    scf.yield %new_list : !llvm.struct&lt;(i32, ptr)&gt;
  }

  return %result : !llvm.struct&lt;(i32, ptr)&gt;
}
</code></pre>
<p><strong>Nested <code>scf.if</code> analysis:</strong></p>
<ol>
<li><strong>Outer if</strong>: 리스트가 empty인지 검사</li>
<li><strong>Inner if</strong>: Head를 keep할지 skip할지 결정</li>
<li><strong>Region nesting</strong>: Inner if는 outer if의 else branch 안에 있다</li>
<li><strong>Type consistency</strong>: 모든 branch가 같은 타입 반환</li>
</ol>
<h3 id="테스트-프로그램-filter-fun-x---x--2-1-2-3-4"><a class="header" href="#테스트-프로그램-filter-fun-x---x--2-1-2-3-4">테스트 프로그램: filter (fun x -&gt; x &gt; 2) [1, 2, 3, 4]</a></h3>
<pre><code class="language-fsharp">// FunLang source
let is_greater_than_2 = fun x -&gt; x &gt; 2

let rec filter pred lst =
  match lst with
  | [] -&gt; []
  | head :: tail -&gt;
      if pred head then
        head :: filter pred tail
      else
        filter pred tail

let result = filter is_greater_than_2 [1, 2, 3, 4]
// Expected: [3, 4]
</code></pre>
<p><strong>Compiled MLIR (main function):</strong></p>
<pre><code class="language-mlir">func.func @main() -&gt; !llvm.struct&lt;(i32, ptr)&gt; {
  // Create predicate closure: fun x -&gt; x &gt; 2
  %pred_fn = llvm.mlir.addressof @is_greater_than_2_impl : !llvm.ptr
  %null_env = llvm.mlir.null : !llvm.ptr
  %closure_size = llvm.mlir.constant(16 : i64) : i64
  %closure_mem = llvm.call @GC_malloc(%closure_size) : (i64) -&gt; !llvm.ptr

  %fn_ptr_field = llvm.getelementptr %closure_mem[0, 0] : (!llvm.ptr) -&gt; !llvm.ptr
  llvm.store %pred_fn, %fn_ptr_field : !llvm.ptr, !llvm.ptr

  %env_ptr_field = llvm.getelementptr %closure_mem[0, 1] : (!llvm.ptr) -&gt; !llvm.ptr
  llvm.store %null_env, %env_ptr_field : !llvm.ptr, !llvm.ptr

  %pred = llvm.load %closure_mem : !llvm.ptr -&gt; !funlang.closure&lt;(i32) -&gt; i1&gt;

  // Create list: [1, 2, 3, 4]
  %c1 = arith.constant 1 : i32
  %c2 = arith.constant 2 : i32
  %c3 = arith.constant 3 : i32
  %c4 = arith.constant 4 : i32

  %nil = funlang.nil : !funlang.list&lt;i32&gt;
  %l4 = funlang.cons %c4, %nil : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;
  %l3 = funlang.cons %c3, %l4 : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;
  %l2 = funlang.cons %c2, %l3 : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;
  %l1 = funlang.cons %c1, %l2 : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;

  // Call filter
  %result = func.call @filter(%pred, %l1)
    : (!funlang.closure&lt;(i32) -&gt; i1&gt;, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;

  return %result : !llvm.struct&lt;(i32, ptr)&gt;
}

// Predicate implementation
func.func @is_greater_than_2_impl(%x: i32) -&gt; i1 {
  %c2 = arith.constant 2 : i32
  %result = arith.cmpi sgt, %x, %c2 : i32
  return %result : i1
}
</code></pre>
<p><strong>실행 trace:</strong></p>
<pre><code>filter pred [1, 2, 3, 4]
→ (1 &gt; 2)? No → filter pred [2, 3, 4]
→ (2 &gt; 2)? No → filter pred [3, 4]
→ (3 &gt; 2)? Yes → 3 :: filter pred [4]
→ (4 &gt; 2)? Yes → 3 :: (4 :: filter pred [])
→ 3 :: (4 :: [])
→ [3, 4]
</code></pre>
<p><strong>검증:</strong></p>
<pre><code class="language-fsharp">let testFilterGreaterThan2() =
    let ctx = MLIRContext.Create()
    let module = compileProgram ctx filterSource

    let pm = PassManager.Create(ctx)
    pm.AddPass("convert-funlang-to-scf")
    pm.AddPass("convert-scf-to-cf")
    pm.AddPass("convert-funlang-to-llvm")
    pm.Run(module)

    let engine = ExecutionEngine.Create(module)
    let result = engine.Invoke("main", [||])

    let list = result :?&gt; ListValue
    assert (list.Count = 2)
    assert (list.[0] = 3)
    assert (list.[1] = 4)

    printfn "filter (fun x -&gt; x &gt; 2) [1, 2, 3, 4] = [3, 4] ✓"
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>filter (fun x -&gt; x &gt; 2) [1, 2, 3, 4] = [3, 4] ✓
</code></pre>
<p>성공! <code>filter</code> 함수도 완전히 작동한다.</p>
<h2 id="helper-함수-length와-append"><a class="header" href="#helper-함수-length와-append">Helper 함수: length와 append</a></h2>
<p><code>map</code>과 <code>filter</code> 외에도 유용한 리스트 함수가 많다. 두 가지 기본 helper를 구현한다.</p>
<h3 id="length-함수"><a class="header" href="#length-함수">length 함수</a></h3>
<p><strong>FunLang 소스:</strong></p>
<pre><code class="language-fsharp">let rec length lst =
  match lst with
  | [] -&gt; 0
  | head :: tail -&gt; 1 + length tail
</code></pre>
<p><strong>타입:</strong> <code>[a] -&gt; int</code></p>
<p><strong>예제:</strong></p>
<pre><code class="language-fsharp">length []           // 0
length [1]          // 1
length [1, 2, 3]    // 3
</code></pre>
<p><strong>Compiled MLIR:</strong></p>
<pre><code class="language-mlir">func.func @length(%lst: !funlang.list&lt;i32&gt;) -&gt; i32 {
  %result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
    ^nil:
      %zero = arith.constant 0 : i32
      funlang.yield %zero : i32

    ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
      %tail_len = func.call @length(%tail) : (!funlang.list&lt;i32&gt;) -&gt; i32
      %one = arith.constant 1 : i32
      %len = arith.addi %one, %tail_len : i32
      funlang.yield %len : i32
  }
  return %result : i32
}
</code></pre>
<p><strong>특징:</strong></p>
<ul>
<li><code>head</code> 값은 무시 (타입만 필요)</li>
<li>재귀 호출로 tail length 계산</li>
<li>결과: <code>1 + tail_length</code></li>
</ul>
<h3 id="append-함수"><a class="header" href="#append-함수">append 함수</a></h3>
<p><strong>FunLang 소스:</strong></p>
<pre><code class="language-fsharp">let rec append xs ys =
  match xs with
  | [] -&gt; ys
  | head :: tail -&gt; head :: (append tail ys)
</code></pre>
<p><strong>타입:</strong> <code>[a] -&gt; [a] -&gt; [a]</code></p>
<p><strong>예제:</strong></p>
<pre><code class="language-fsharp">append [] [1, 2]         // [1, 2]
append [1, 2] []         // [1, 2]
append [1, 2] [3, 4]     // [1, 2, 3, 4]
</code></pre>
<p><strong>Compiled MLIR:</strong></p>
<pre><code class="language-mlir">func.func @append(%xs: !funlang.list&lt;i32&gt;,
                  %ys: !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt; {
  %result = funlang.match %xs : !funlang.list&lt;i32&gt; -&gt; !funlang.list&lt;i32&gt; {
    ^nil:
      // Base case: [] ++ ys = ys
      funlang.yield %ys : !funlang.list&lt;i32&gt;

    ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
      // Recursive case: (h :: t) ++ ys = h :: (t ++ ys)
      %appended = func.call @append(%tail, %ys)
        : (!funlang.list&lt;i32&gt;, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;
      %new_list = funlang.cons %head, %appended
        : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;
      funlang.yield %new_list : !funlang.list&lt;i32&gt;
  }
  return %result : !funlang.list&lt;i32&gt;
}
</code></pre>
<p><strong>특징:</strong></p>
<ul>
<li>Base case: 첫 번째 리스트가 empty이면 두 번째 리스트 반환</li>
<li>Recursive case: 첫 번째 리스트의 head를 보존하고 tail 재귀 처리</li>
<li>시간 복잡도: O(|xs|) - 첫 번째 리스트 길이에 비례</li>
</ul>
<p><strong>실행 trace:</strong></p>
<pre><code class="language-fsharp">append [1, 2] [3, 4]
→ 1 :: append [2] [3, 4]
→ 1 :: (2 :: append [] [3, 4])
→ 1 :: (2 :: [3, 4])
→ [1, 2, 3, 4]
</code></pre>
<h3 id="테스트-helper-함수"><a class="header" href="#테스트-helper-함수">테스트: Helper 함수</a></h3>
<pre><code class="language-fsharp">let testHelpers() =
    // Test length
    let len1 = length []            // 0
    let len2 = length [1]           // 1
    let len3 = length [1, 2, 3]     // 3

    assert (len1 = 0)
    assert (len2 = 1)
    assert (len3 = 3)
    printfn "length tests passed ✓"

    // Test append
    let app1 = append [] [1, 2]         // [1, 2]
    let app2 = append [1, 2] []         // [1, 2]
    let app3 = append [1, 2] [3, 4]     // [1, 2, 3, 4]

    assert (listEqual app1 [1, 2])
    assert (listEqual app2 [1, 2])
    assert (listEqual app3 [1, 2, 3, 4])
    printfn "append tests passed ✓"
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>length tests passed ✓
append tests passed ✓
</code></pre>
<p>이제 우리는 <strong>기본 함수형 프로그래밍 toolkit</strong>을 갖췄다:</p>
<ul>
<li><code>map</code>: 변환</li>
<li><code>filter</code>: 필터링</li>
<li><code>length</code>: 크기 측정</li>
<li><code>append</code>: 결합</li>
</ul>
<p>다음 섹션에서는 가장 강력한 combinator인 **<code>fold</code>**를 구현한다.</p>
<h2 id="fold-함수-일반적인-리스트-combinator"><a class="header" href="#fold-함수-일반적인-리스트-combinator">fold 함수: 일반적인 리스트 Combinator</a></h2>
<h3 id="fold의-개념"><a class="header" href="#fold의-개념">fold의 개념</a></h3>
<p><code>fold</code> (또는 <code>reduce</code>)는 리스트를 하나의 값으로 축약하는 가장 일반적인 combinator다:</p>
<pre><code class="language-fsharp">// fold의 타입
fold : (acc -&gt; a -&gt; acc) -&gt; acc -&gt; [a] -&gt; acc

// fold의 의미
fold f acc [x1, x2, ..., xn] = f (... (f (f acc x1) x2) ...) xn
</code></pre>
<p><strong>fold는 모든 리스트 연산의 기초다:</strong></p>
<pre><code class="language-fsharp">// sum: 모든 원소의 합
let sum lst = fold (+) 0 lst
sum [1, 2, 3, 4, 5]  // 15

// product: 모든 원소의 곱
let product lst = fold (*) 1 lst
product [1, 2, 3, 4]  // 24

// length: map과 filter도 fold로 구현 가능
let length lst = fold (fun acc _ -&gt; acc + 1) 0 lst
length [1, 2, 3]  // 3
</code></pre>
<p><strong>왜 fold가 가장 강력한가?</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>함수</th><th>fold로 구현 가능?</th><th>예제</th></tr>
</thead>
<tbody>
<tr><td><code>sum</code></td><td>✓</td><td><code>fold (+) 0</code></td></tr>
<tr><td><code>product</code></td><td>✓</td><td><code>fold (*) 1</code></td></tr>
<tr><td><code>length</code></td><td>✓</td><td><code>fold (fun acc _ -&gt; acc + 1) 0</code></td></tr>
<tr><td><code>map</code></td><td>✓</td><td><code>fold (fun acc x -&gt; acc ++ [f x]) []</code></td></tr>
<tr><td><code>filter</code></td><td>✓</td><td><code>fold (fun acc x -&gt; if p x then acc ++ [x] else acc) []</code></td></tr>
<tr><td><code>reverse</code></td><td>✓</td><td><code>fold (fun acc x -&gt; x :: acc) []</code></td></tr>
</tbody>
</table>
</div>
<p><strong>fold는 universal list combinator다.</strong> 다른 모든 리스트 함수를 fold로 표현할 수 있다.</p>
<h3 id="funlang-소스-코드-2"><a class="header" href="#funlang-소스-코드-2">FunLang 소스 코드</a></h3>
<p><code>fold</code> 함수를 FunLang으로 작성한다:</p>
<pre><code class="language-fsharp">let rec fold f acc lst =
  match lst with
  | [] -&gt; acc
  | head :: tail -&gt; fold f (f acc head) tail
</code></pre>
<p><strong>동작 원리:</strong></p>
<ol>
<li><strong>Base case</strong>: Empty list → return accumulator (결과)</li>
<li><strong>Recursive case</strong>:
<ul>
<li>Apply <code>f</code> to <code>acc</code> and <code>head</code> → new accumulator</li>
<li>Recursively fold over <code>tail</code> with new accumulator</li>
</ul>
</li>
</ol>
<p><strong>실행 trace:</strong></p>
<pre><code class="language-fsharp">fold (+) 0 [1, 2, 3, 4, 5]
→ fold (+) (0 + 1) [2, 3, 4, 5]
→ fold (+) 1 [2, 3, 4, 5]
→ fold (+) (1 + 2) [3, 4, 5]
→ fold (+) 3 [3, 4, 5]
→ fold (+) (3 + 3) [4, 5]
→ fold (+) 6 [4, 5]
→ fold (+) (6 + 4) [5]
→ fold (+) 10 [5]
→ fold (+) (10 + 5) []
→ fold (+) 15 []
→ 15
</code></pre>
<p><strong>Accumulator 패턴:</strong></p>
<p>Accumulator는 중간 결과를 저장하는 변수다:</p>
<ul>
<li><strong>초기값</strong>: <code>acc = 0</code> (sum의 경우)</li>
<li><strong>갱신</strong>: <code>acc = f acc head</code> (각 원소마다 업데이트)</li>
<li><strong>최종값</strong>: 리스트가 empty일 때 accumulator 반환</li>
</ul>
<h3 id="fold-vs-mapfilter-비교"><a class="header" href="#fold-vs-mapfilter-비교">fold vs map/filter 비교</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>특성</th><th>map</th><th>filter</th><th>fold</th></tr>
</thead>
<tbody>
<tr><td>타입</td><td><code>(a -&gt; b) -&gt; [a] -&gt; [b]</code></td><td><code>(a -&gt; bool) -&gt; [a] -&gt; [a]</code></td><td><code>(acc -&gt; a -&gt; acc) -&gt; acc -&gt; [a] -&gt; acc</code></td></tr>
<tr><td>입력</td><td>리스트</td><td>리스트</td><td>리스트 + 초기값</td></tr>
<tr><td>출력</td><td>리스트</td><td>리스트</td><td>단일 값</td></tr>
<tr><td>함수 인자</td><td>1개 (원소)</td><td>1개 (원소)</td><td>2개 (누적값, 원소)</td></tr>
<tr><td>일반성</td><td>특수</td><td>특수</td><td>일반 (map/filter 구현 가능)</td></tr>
</tbody>
</table>
</div>
<h3 id="컴파일된-mlir-funlang-dialect-2"><a class="header" href="#컴파일된-mlir-funlang-dialect-2">컴파일된 MLIR: FunLang Dialect</a></h3>
<pre><code class="language-mlir">// fold : (acc -&gt; T -&gt; acc) -&gt; acc -&gt; !funlang.list&lt;T&gt; -&gt; acc
func.func @fold(%f: !funlang.closure&lt;(i32, i32) -&gt; i32&gt;,
                %acc: i32,
                %lst: !funlang.list&lt;i32&gt;) -&gt; i32 {
  // match lst with ...
  %result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
    // Case 1: [] -&gt; acc
    ^nil:
      funlang.yield %acc : i32

    // Case 2: head :: tail -&gt; fold f (f acc head) tail
    ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
      // f acc head
      %new_acc = funlang.apply %f(%acc, %head)
        : (!funlang.closure&lt;(i32, i32) -&gt; i32&gt;, i32, i32) -&gt; i32

      // fold f new_acc tail (tail recursion!)
      %final = func.call @fold(%f, %new_acc, %tail)
        : (!funlang.closure&lt;(i32, i32) -&gt; i32&gt;, i32, !funlang.list&lt;i32&gt;) -&gt; i32

      funlang.yield %final : i32
  }

  return %result : i32
}
</code></pre>
<p><strong>핵심 포인트:</strong></p>
<ol>
<li><strong>Three arguments</strong>: 클로저 <code>f</code>, 누적값 <code>acc</code>, 리스트 <code>lst</code></li>
<li><strong>Binary closure</strong>: <code>f</code>는 두 인자 (<code>acc</code>, <code>head</code>)를 받는다</li>
<li><strong>Tail recursion</strong>: 재귀 호출이 함수의 마지막 operation (최적화 가능!)</li>
<li><strong>Accumulator threading</strong>: <code>acc</code> → <code>new_acc</code> → <code>final</code>로 흐름</li>
</ol>
<h3 id="tail-recursion-분석"><a class="header" href="#tail-recursion-분석">Tail Recursion 분석</a></h3>
<p><code>fold</code>는 <strong>tail recursive</strong>다:</p>
<pre><code class="language-fsharp">// Tail recursive (good)
let rec fold f acc lst =
  match lst with
  | [] -&gt; acc
  | head :: tail -&gt; fold f (f acc head) tail
  // ^^^ Recursive call is the LAST operation

// NOT tail recursive (map, filter)
let rec map f lst =
  match lst with
  | [] -&gt; []
  | head :: tail -&gt; (f head) :: (map f tail)
  // ^^^ Recursive call is NOT the last (cons follows)
</code></pre>
<p><strong>Tail recursion의 장점:</strong></p>
<ol>
<li><strong>Stack frame 재사용</strong>: 각 재귀 호출이 새 stack frame을 생성하지 않음</li>
<li><strong>메모리 효율</strong>: O(1) stack space (vs O(n) for non-tail)</li>
<li><strong>컴파일러 최적화</strong>: Loop로 변환 가능</li>
</ol>
<p><strong>LLVM optimization pass가 tail call을 감지하면:</strong></p>
<pre><code class="language-mlir">// Before optimization (recursive)
%result = func.call @fold(%f, %new_acc, %tail) : (...) -&gt; i32

// After optimization (loop)
// Stack frame 재사용, jump로 변환
</code></pre>
<h3 id="common-fold-patterns"><a class="header" href="#common-fold-patterns">Common Fold Patterns</a></h3>
<p><strong>1. Sum (합계)</strong></p>
<pre><code class="language-fsharp">let sum lst = fold (fun acc x -&gt; acc + x) 0 lst
// Or simply: fold (+) 0 lst

sum [1, 2, 3, 4, 5]  // 15
</code></pre>
<p>Compiled MLIR:</p>
<pre><code class="language-mlir">func.func @sum(%lst: !funlang.list&lt;i32&gt;) -&gt; i32 {
  // Create add closure
  %add = funlang.closure @add_impl() : () -&gt; ((i32, i32) -&gt; i32)

  // Initial accumulator
  %zero = arith.constant 0 : i32

  // Call fold
  %result = func.call @fold(%add, %zero, %lst)
    : (!funlang.closure&lt;(i32, i32) -&gt; i32&gt;, i32, !funlang.list&lt;i32&gt;) -&gt; i32

  return %result : i32
}

func.func @add_impl(%acc: i32, %x: i32) -&gt; i32 {
  %result = arith.addi %acc, %x : i32
  return %result : i32
}
</code></pre>
<p><strong>2. Product (곱셈)</strong></p>
<pre><code class="language-fsharp">let product lst = fold (*) 1 lst

product [1, 2, 3, 4]  // 24
</code></pre>
<p><strong>3. Length (길이)</strong></p>
<pre><code class="language-fsharp">let length lst = fold (fun acc _ -&gt; acc + 1) 0 lst

length [1, 2, 3]  // 3
</code></pre>
<p>이전에 재귀로 구현한 <code>length</code>와 같은 결과지만, fold를 사용하면 더 일반적이다.</p>
<p><strong>4. Reverse (역순)</strong></p>
<pre><code class="language-fsharp">let reverse lst = fold (fun acc x -&gt; x :: acc) [] lst

reverse [1, 2, 3]  // [3, 2, 1]
</code></pre>
<p><strong>Trace:</strong></p>
<pre><code>fold cons [] [1, 2, 3]
→ fold cons (1 :: []) [2, 3]
→ fold cons [1] [2, 3]
→ fold cons (2 :: [1]) [3]
→ fold cons [2, 1] [3]
→ fold cons (3 :: [2, 1]) []
→ fold cons [3, 2, 1] []
→ [3, 2, 1]
</code></pre>
<p><strong>5. Maximum (최댓값)</strong></p>
<pre><code class="language-fsharp">let max_list lst =
  match lst with
  | [] -&gt; error "empty list"
  | head :: tail -&gt; fold (fun acc x -&gt; if x &gt; acc then x else acc) head tail

max_list [3, 1, 4, 1, 5, 9, 2]  // 9
</code></pre>
<h3 id="테스트-프로그램-fold--0-1-2-3-4-5"><a class="header" href="#테스트-프로그램-fold--0-1-2-3-4-5">테스트 프로그램: fold (+) 0 [1, 2, 3, 4, 5]</a></h3>
<pre><code class="language-fsharp">// FunLang source
let add = fun acc x -&gt; acc + x

let rec fold f acc lst =
  match lst with
  | [] -&gt; acc
  | head :: tail -&gt; fold f (f acc head) tail

let result = fold add 0 [1, 2, 3, 4, 5]
// Expected: 15
</code></pre>
<p><strong>Compiled MLIR (main function):</strong></p>
<pre><code class="language-mlir">func.func @main() -&gt; i32 {
  // Create add closure
  %add_fn = llvm.mlir.addressof @add_impl : !llvm.ptr
  %null_env = llvm.mlir.null : !llvm.ptr
  %closure_size = llvm.mlir.constant(16 : i64) : i64
  %closure_mem = llvm.call @GC_malloc(%closure_size) : (i64) -&gt; !llvm.ptr

  %fn_ptr_field = llvm.getelementptr %closure_mem[0, 0] : (!llvm.ptr) -&gt; !llvm.ptr
  llvm.store %add_fn, %fn_ptr_field : !llvm.ptr, !llvm.ptr

  %env_ptr_field = llvm.getelementptr %closure_mem[0, 1] : (!llvm.ptr) -&gt; !llvm.ptr
  llvm.store %null_env, %env_ptr_field : !llvm.ptr, !llvm.ptr

  %add = llvm.load %closure_mem : !llvm.ptr -&gt; !funlang.closure&lt;(i32, i32) -&gt; i32&gt;

  // Initial accumulator
  %zero = arith.constant 0 : i32

  // Create list: [1, 2, 3, 4, 5]
  %c1 = arith.constant 1 : i32
  %c2 = arith.constant 2 : i32
  %c3 = arith.constant 3 : i32
  %c4 = arith.constant 4 : i32
  %c5 = arith.constant 5 : i32

  %nil = funlang.nil : !funlang.list&lt;i32&gt;
  %l5 = funlang.cons %c5, %nil : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;
  %l4 = funlang.cons %c4, %l5 : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;
  %l3 = funlang.cons %c3, %l4 : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;
  %l2 = funlang.cons %c2, %l3 : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;
  %l1 = funlang.cons %c1, %l2 : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;

  // Call fold
  %result = func.call @fold(%add, %zero, %l1)
    : (!funlang.closure&lt;(i32, i32) -&gt; i32&gt;, i32, !funlang.list&lt;i32&gt;) -&gt; i32

  return %result : i32
}

func.func @add_impl(%acc: i32, %x: i32) -&gt; i32 {
  %result = arith.addi %acc, %x : i32
  return %result : i32
}
</code></pre>
<p><strong>검증:</strong></p>
<pre><code class="language-fsharp">let testFoldSum() =
    let ctx = MLIRContext.Create()
    let module = compileProgram ctx foldSumSource

    let pm = PassManager.Create(ctx)
    pm.AddPass("convert-funlang-to-scf")
    pm.AddPass("convert-scf-to-cf")
    pm.AddPass("convert-funlang-to-llvm")
    pm.Run(module)

    let engine = ExecutionEngine.Create(module)
    let result = engine.Invoke("main", [||])

    assert (result = 15)
    printfn "fold (+) 0 [1, 2, 3, 4, 5] = 15 ✓"
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>fold (+) 0 [1, 2, 3, 4, 5] = 15 ✓
</code></pre>
<p>성공! <code>fold</code> 함수도 완전히 작동한다.</p>
<h2 id="완전한-예제-sum-of-squares"><a class="header" href="#완전한-예제-sum-of-squares">완전한 예제: Sum of Squares</a></h2>
<p>이제 모든 것을 조합하여 <strong>실전 함수형 프로그램</strong>을 작성한다.</p>
<h3 id="문제-정의"><a class="header" href="#문제-정의">문제 정의</a></h3>
<p>주어진 숫자 리스트의 <strong>제곱의 합</strong>을 계산한다:</p>
<pre><code>sum_of_squares [1, 2, 3] = 1² + 2² + 3² = 1 + 4 + 9 = 14
</code></pre>
<h3 id="funlang-소스-코드-3"><a class="header" href="#funlang-소스-코드-3">FunLang 소스 코드</a></h3>
<pre><code class="language-fsharp">// Helper: square function
let square = fun x -&gt; x * x

// Helper: add function
let add = fun acc x -&gt; acc + x

// map: transform each element
let rec map f lst =
  match lst with
  | [] -&gt; []
  | head :: tail -&gt; (f head) :: (map f tail)

// fold: reduce to single value
let rec fold f acc lst =
  match lst with
  | [] -&gt; acc
  | head :: tail -&gt; fold f (f acc head) tail

// Composition: sum of squares
let sum_of_squares lst =
  fold add 0 (map square lst)

// Test
let result = sum_of_squares [1, 2, 3]
// Expected: 14
</code></pre>
<p><strong>함수 조합 분석:</strong></p>
<pre><code>[1, 2, 3]
  ↓ map square
[1, 4, 9]
  ↓ fold add 0
14
</code></pre>
<p><strong>이것이 바로 함수형 프로그래밍의 핵심이다:</strong></p>
<ul>
<li>작은 함수들 (<code>square</code>, <code>add</code>, <code>map</code>, <code>fold</code>)</li>
<li>조합하여 복잡한 동작 (<code>sum_of_squares</code>)</li>
<li>선언적 스타일: “무엇을” 계산할지 명확</li>
</ul>
<h3 id="전체-컴파일-파이프라인-9-단계"><a class="header" href="#전체-컴파일-파이프라인-9-단계">전체 컴파일 파이프라인 (9 단계)</a></h3>
<p>이 프로그램을 end-to-end로 컴파일하는 과정을 모두 추적한다.</p>
<p><strong>Stage 1: FunLang Source (사용자 작성)</strong></p>
<pre><code class="language-fsharp">let sum_of_squares lst =
  fold add 0 (map square lst)
</code></pre>
<p><strong>Stage 2: FunLang AST (Parser 출력)</strong></p>
<pre><code class="language-fsharp">Let("sum_of_squares",
    Fun("lst",
        App(App(App(Var "fold", Var "add"),
                Int 0),
            App(App(Var "map", Var "square"),
                Var "lst"))),
    ...)
</code></pre>
<p><strong>Stage 3: FunLang MLIR (Compiler.fs 출력)</strong></p>
<pre><code class="language-mlir">func.func @sum_of_squares(%lst: !funlang.list&lt;i32&gt;) -&gt; i32 {
  // square closure (defined elsewhere)
  %square = ... : !funlang.closure&lt;(i32) -&gt; i32&gt;

  // add closure (defined elsewhere)
  %add = ... : !funlang.closure&lt;(i32, i32) -&gt; i32&gt;

  // map square lst
  %squared_list = func.call @map(%square, %lst)
    : (!funlang.closure&lt;(i32) -&gt; i32&gt;, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;

  // fold add 0 squared_list
  %zero = arith.constant 0 : i32
  %result = func.call @fold(%add, %zero, %squared_list)
    : (!funlang.closure&lt;(i32, i32) -&gt; i32&gt;, i32, !funlang.list&lt;i32&gt;) -&gt; i32

  return %result : i32
}
</code></pre>
<p><strong>Stage 4: FunLang → SCF Lowering (FunLangToSCFPass)</strong></p>
<p><code>funlang.match</code> operations이 <code>scf.if</code>로 변환된다:</p>
<pre><code class="language-mlir">// @map function (simplified)
func.func @map(...) -&gt; ... {
  %is_nil = ... : i1
  %result = scf.if %is_nil -&gt; ... {
    // Nil case
    scf.yield %empty : ...
  } else {
    // Cons case
    %transformed = funlang.apply %f(%head) : ...
    %mapped_tail = func.call @map(...) : ...
    %new_list = funlang.cons %transformed, %mapped_tail : ...
    scf.yield %new_list : ...
  }
  return %result : ...
}
</code></pre>
<p><strong>Stage 5: FunLang Ops → LLVM (FunLangToLLVMPass)</strong></p>
<p><code>funlang.cons</code>, <code>funlang.nil</code>, <code>funlang.apply</code> 등이 LLVM operations로 변환:</p>
<pre><code class="language-mlir">// funlang.cons lowering
%cell_size = llvm.mlir.constant(16 : i64) : i64
%cell = llvm.call @GC_malloc(%cell_size) : (i64) -&gt; !llvm.ptr
%head_ptr = llvm.getelementptr %cell[0, 0] : (!llvm.ptr) -&gt; !llvm.ptr
llvm.store %head, %head_ptr : i32, !llvm.ptr
%tail_ptr = llvm.getelementptr %cell[0, 1] : (!llvm.ptr) -&gt; !llvm.ptr
llvm.store %tail, %tail_ptr : !llvm.struct&lt;(i32, ptr)&gt;, !llvm.ptr

%cons_tag = arith.constant 1 : i32
%list = llvm.mlir.undef : !llvm.struct&lt;(i32, ptr)&gt;
%list1 = llvm.insertvalue %cons_tag, %list[0] : !llvm.struct&lt;(i32, ptr)&gt;
%list2 = llvm.insertvalue %cell, %list1[1] : !llvm.struct&lt;(i32, ptr)&gt;
</code></pre>
<p><strong>Stage 6: SCF → CF Lowering (SCFToControlFlowPass)</strong></p>
<p><code>scf.if</code> → <code>cf.cond_br</code>, <code>cf.br</code>:</p>
<pre><code class="language-mlir">func.func @map(...) -&gt; ... {
^entry:
  %is_nil = ... : i1
  cf.cond_br %is_nil, ^nil_case, ^cons_case

^nil_case:
  %empty = ...
  cf.br ^exit(%empty : ...)

^cons_case:
  %transformed = ...
  %mapped_tail = func.call @map(...) : ...
  %new_list = ...
  cf.br ^exit(%new_list : ...)

^exit(%result: ...):
  return %result : ...
}
</code></pre>
<p><strong>Stage 7: Func → LLVM (ConvertFuncToLLVMPass)</strong></p>
<p><code>func.func</code> → <code>llvm.func</code>, <code>func.call</code> → <code>llvm.call</code>:</p>
<pre><code class="language-mlir">llvm.func @map(%f: !llvm.ptr, %lst: !llvm.struct&lt;(i32, ptr)&gt;) -&gt; !llvm.struct&lt;(i32, ptr)&gt; {
  ...
  %result = llvm.call @map(%f, %tail) : (!llvm.ptr, !llvm.struct&lt;(i32, ptr)&gt;) -&gt; !llvm.struct&lt;(i32, ptr)&gt;
  ...
}
</code></pre>
<p><strong>Stage 8: LLVM Dialect → LLVM IR (Translate to LLVM IR)</strong></p>
<p>MLIR LLVM dialect를 실제 LLVM IR로 변환:</p>
<pre><code class="language-llvm">define { i32, i8* } @map({ i8*, i8* }* %f, { i32, i8* } %lst) {
entry:
  %0 = extractvalue { i32, i8* } %lst, 0
  %1 = icmp eq i32 %0, 0
  br i1 %1, label %nil_case, label %cons_case

nil_case:
  %2 = insertvalue { i32, i8* } undef, i32 0, 0
  %3 = insertvalue { i32, i8* } %2, i8* null, 1
  br label %exit

cons_case:
  %4 = extractvalue { i32, i8* } %lst, 1
  %5 = bitcast i8* %4 to { i32, { i32, i8* } }*
  %6 = getelementptr { i32, { i32, i8* } }, { i32, { i32, i8* } }* %5, i32 0, i32 0
  %7 = load i32, i32* %6
  %8 = getelementptr { i32, { i32, i8* } }, { i32, { i32, i8* } }* %5, i32 0, i32 1
  %9 = load { i32, i8* }, { i32, i8* }* %8
  ; ... (apply closure, recursive call, cons)
  br label %exit

exit:
  %result = phi { i32, i8* } [ %3, %nil_case ], [ %new_list, %cons_case ]
  ret { i32, i8* } %result
}
</code></pre>
<p><strong>Stage 9: LLVM IR → Machine Code (JIT 또는 AOT)</strong></p>
<p>LLVM backend가 target architecture의 machine code 생성:</p>
<pre><code class="language-asm">; x86-64 assembly (simplified)
map:
    push    rbp
    mov     rbp, rsp
    ; Extract tag
    mov     eax, dword ptr [rsi]
    test    eax, eax
    je      .LBB0_1        ; Nil case
    ; Cons case
    mov     rdi, qword ptr [rsi + 8]
    mov     ecx, dword ptr [rdi]     ; head
    mov     rsi, qword ptr [rdi + 8]  ; tail
    ; ... (apply f, recursive call)
    jmp     .LBB0_2
.LBB0_1:
    ; Return empty list
    xor     eax, eax
    xor     edx, edx
.LBB0_2:
    pop     rbp
    ret
</code></pre>
<h3 id="실행-및-검증"><a class="header" href="#실행-및-검증">실행 및 검증</a></h3>
<pre><code class="language-fsharp">let testSumOfSquares() =
    let ctx = MLIRContext.Create()
    let module = compileProgram ctx sumOfSquaresSource

    // Apply all passes
    let pm = PassManager.Create(ctx)
    pm.AddPass("convert-funlang-to-scf")
    pm.AddPass("convert-scf-to-cf")
    pm.AddPass("convert-funlang-to-llvm")
    pm.AddPass("convert-func-to-llvm")
    pm.Run(module)

    // JIT compile and execute
    let engine = ExecutionEngine.Create(module)
    let result = engine.Invoke("main", [||])

    // Verify
    assert (result = 14)
    printfn "sum_of_squares [1, 2, 3] = 14 ✓"

    // Detailed trace
    printfn "Pipeline trace:"
    printfn "  [1, 2, 3]"
    printfn "  → map square"
    printfn "  [1, 4, 9]"
    printfn "  → fold add 0"
    printfn "  14 ✓"
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>sum_of_squares [1, 2, 3] = 14 ✓
Pipeline trace:
  [1, 2, 3]
  → map square
  [1, 4, 9]
  → fold add 0
  14 ✓
</code></pre>
<p><strong>완전한 컴파일러가 작동한다!</strong></p>
<p>9단계의 변환을 거쳐 FunLang 소스 코드가 실행 가능한 machine code가 되었다.</p>
<h2 id="성능-고려사항-1"><a class="header" href="#성능-고려사항-1">성능 고려사항</a></h2>
<h3 id="stack-usage-in-recursive-list-functions"><a class="header" href="#stack-usage-in-recursive-list-functions">Stack Usage in Recursive List Functions</a></h3>
<p>리스트 함수는 재귀적이므로 stack 사용량이 중요하다.</p>
<p><strong>Stack depth by function:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>함수</th><th>Stack depth</th><th>이유</th></tr>
</thead>
<tbody>
<tr><td><code>map</code></td><td>O(n)</td><td>Non-tail recursive (cons 후에 return)</td></tr>
<tr><td><code>filter</code></td><td>O(n)</td><td>Non-tail recursive (cons 후에 return)</td></tr>
<tr><td><code>fold</code></td><td><strong>O(1)</strong></td><td><strong>Tail recursive (최적화 가능)</strong></td></tr>
<tr><td><code>length</code></td><td>O(n)</td><td>Non-tail recursive</td></tr>
<tr><td><code>append</code></td><td>O(n)</td><td>Non-tail recursive</td></tr>
</tbody>
</table>
</div>
<p><strong>Non-tail recursion example (map):</strong></p>
<pre><code class="language-fsharp">let rec map f lst =
  match lst with
  | [] -&gt; []
  | head :: tail -&gt; (f head) :: (map f tail)
  // ^^^ Cons operation AFTER recursive call
  // Stack frame must be preserved until map returns
</code></pre>
<p>Call stack for <code>map square [1, 2, 3]</code>:</p>
<pre><code>map [1, 2, 3]
  map [2, 3]
    map [3]
      map []
      return []
    cons 9 []
    return [9]
  cons 4 [9]
  return [4, 9]
cons 1 [4, 9]
return [1, 4, 9]
</code></pre>
<p><strong>각 frame은 다음을 저장해야 한다:</strong></p>
<ul>
<li>Return address</li>
<li><code>head</code> value (cons를 위해)</li>
<li><code>tail</code> pointer</li>
</ul>
<p><strong>Tail recursion example (fold):</strong></p>
<pre><code class="language-fsharp">let rec fold f acc lst =
  match lst with
  | [] -&gt; acc
  | head :: tail -&gt; fold f (f acc head) tail
  // ^^^ Recursive call is LAST operation
  // Stack frame can be REUSED
</code></pre>
<p>Call stack for <code>fold add 0 [1, 2, 3]</code>:</p>
<pre><code>fold 0 [1, 2, 3]
fold 1 [2, 3]      // Same stack frame, acc updated
fold 3 [3]         // Same stack frame, acc updated
fold 6 []          // Same stack frame, acc updated
return 6
</code></pre>
<p><strong>Only ONE stack frame!</strong></p>
<h3 id="tail-call-optimization-tco"><a class="header" href="#tail-call-optimization-tco">Tail Call Optimization (TCO)</a></h3>
<p>LLVM은 tail call을 감지하여 최적화할 수 있다.</p>
<p><strong>Before TCO:</strong></p>
<pre><code class="language-llvm">define i32 @fold(...) {
  ; ...
  %new_acc = add i32 %acc, %head
  %result = call i32 @fold(..., %new_acc, %tail)
  ret i32 %result
}
</code></pre>
<p><strong>After TCO:</strong></p>
<pre><code class="language-llvm">define i32 @fold(...) {
entry:
  br label %loop

loop:
  ; ...
  %new_acc = add i32 %acc, %head
  ; Update arguments and jump (no new stack frame)
  br label %loop
}
</code></pre>
<p><strong>TCO 활성화:</strong></p>
<pre><code class="language-fsharp">// PassManager.fs
let pm = PassManager.Create(ctx)

// Add standard LLVM optimization passes
pm.AddPass("inline")              // Inline small functions
pm.AddPass("simplifycfg")         // Simplify control flow
pm.AddPass("tailcallelim")        // Tail call elimination
pm.AddPass("mem2reg")             // Promote memory to registers
pm.Run(module)
</code></pre>
<p><strong>결과:</strong></p>
<ul>
<li><code>fold</code>는 loop로 변환되어 O(1) stack 사용</li>
<li>큰 리스트 (100,000+ elements)도 stack overflow 없이 처리 가능</li>
</ul>
<h3 id="gc-pressure"><a class="header" href="#gc-pressure">GC Pressure</a></h3>
<p>리스트 연산은 많은 메모리를 할당한다.</p>
<p><strong>Allocation counts:</strong></p>
<pre><code class="language-fsharp">// Create list [1, 2, 3]
// - 3 cons cells = 3 * 16 bytes = 48 bytes

// map square [1, 2, 3]
// - Input: 3 cells (48 bytes)
// - Output: 3 NEW cells (48 bytes)
// - Total alive: 96 bytes (both lists live)

// fold add 0 (map square [1, 2, 3])
// - Input: 3 cells (48 bytes) from map
// - Output: i32 (4 bytes) - no new list!
// - GC can collect input list after fold
</code></pre>
<p><strong>Allocation pattern by function:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>함수</th><th>할당량</th><th>설명</th></tr>
</thead>
<tbody>
<tr><td><code>map</code></td><td>O(n) cons cells</td><td>새 리스트 생성</td></tr>
<tr><td><code>filter</code></td><td>O(k) cons cells (k ≤ n)</td><td>조건 만족하는 원소만</td></tr>
<tr><td><code>fold</code></td><td><strong>O(1)</strong></td><td>단일 값만 반환</td></tr>
<tr><td><code>append</code></td><td>O(n) cons cells</td><td>첫 번째 리스트 복사</td></tr>
</tbody>
</table>
</div>
<p><strong>GC optimization:</strong></p>
<pre><code class="language-fsharp">// BAD: 중간 리스트가 메모리에 남는다
let result1 = map f1 lst
let result2 = map f2 result1
let result3 = map f3 result2
// result1, result2, result3 모두 메모리에 존재

// GOOD: Fusion으로 중간 리스트 제거 (Phase 7에서 다룸)
let result = map (f3 &lt;&lt; f2 &lt;&lt; f1) lst
// 단일 pass, 중간 리스트 없음
</code></pre>
<h3 id="phase-7-preview-optimization-opportunities"><a class="header" href="#phase-7-preview-optimization-opportunities">Phase 7 Preview: Optimization Opportunities</a></h3>
<p>Phase 7에서 다룰 최적화:</p>
<p><strong>1. List Fusion</strong></p>
<pre><code class="language-fsharp">// Before: 두 번 순회
map f (map g lst)

// After fusion: 한 번만 순회
map (f &lt;&lt; g) lst
</code></pre>
<p><strong>2. Deforestation</strong></p>
<pre><code class="language-fsharp">// Before: 중간 리스트 생성
fold h z (map f lst)

// After deforestation: 직접 계산
fold (fun acc x -&gt; h acc (f x)) z lst
</code></pre>
<p><strong>3. Tail Recursion Modulo Cons</strong></p>
<pre><code class="language-fsharp">// map을 tail recursive로 변환
let map f lst =
  let rec loop acc lst =
    match lst with
    | [] -&gt; reverse acc
    | head :: tail -&gt; loop ((f head) :: acc) tail
  loop [] lst
</code></pre>
<p><strong>4. Parallel Map</strong></p>
<p>큰 리스트에 대해 map을 병렬화:</p>
<pre><code class="language-mlir">// Sequential
%result = scf.for %i = 0 to %n step 1 iter_args(%acc = %init) -&gt; ... {
  %elem = load %lst[%i]
  %transformed = apply %f(%elem)
  ...
}

// Parallel (MLIR scf.parallel)
scf.parallel (%i) = (0) to (%n) step (1) {
  %elem = load %lst[%i]
  %transformed = apply %f(%elem)
  store %transformed, %result[%i]
}
</code></pre>
<p>이러한 최적화는 Phase 7에서 MLIR transformation passes로 구현할 것이다.</p>
<h2 id="완전한-컴파일러-통합"><a class="header" href="#완전한-컴파일러-통합">완전한 컴파일러 통합</a></h2>
<p>이제 모든 것을 통합하여 <strong>완전한 FunLang 컴파일러</strong>를 구축한다.</p>
<h3 id="funlang-ast-type-extensions"><a class="header" href="#funlang-ast-type-extensions">FunLang AST Type Extensions</a></h3>
<p>최종 AST 정의:</p>
<pre><code class="language-fsharp">// Ast.fs
module Ast

type Expr =
    // Phase 1-2: Basics
    | Int of int
    | Float of float
    | Bool of bool
    | Var of string
    | Add of Expr * Expr
    | Sub of Expr * Expr
    | Mul of Expr * Expr
    | Div of Expr * Expr
    | Lt of Expr * Expr
    | Gt of Expr * Expr
    | Eq of Expr * Expr

    // Phase 3: Control flow and functions
    | Let of string * Expr * Expr
    | If of Expr * Expr * Expr
    | LetRec of string * Expr * Expr

    // Phase 4: Closures and higher-order functions
    | Fun of string * Expr              // lambda
    | App of Expr * Expr                // application

    // Phase 6: Lists and pattern matching
    | Nil                                // []
    | Cons of Expr * Expr                // head :: tail
    | List of Expr list                  // [1, 2, 3] (syntactic sugar)
    | Match of Expr * (Pattern * Expr) list

and Pattern =
    | PVar of string                     // x (variable binding)
    | PNil                               // [] (empty list)
    | PCons of Pattern * Pattern         // head :: tail (cons pattern)
    | PWild                              // _ (wildcard)
    | PInt of int                        // 42 (literal match)
    | PBool of bool                      // true/false

type Program = Expr
</code></pre>
<h3 id="compilerfs-compileexpr-complete-implementation"><a class="header" href="#compilerfs-compileexpr-complete-implementation">Compiler.fs: compileExpr Complete Implementation</a></h3>
<pre><code class="language-fsharp">// Compiler.fs
module Compiler

open MLIR
open Ast

let rec compileExpr (builder: OpBuilder) (expr: Expr) (symbolTable: Map&lt;string, Value&gt;) : Value =
    match expr with
    // Phase 1-2: Arithmetic
    | Int n -&gt;
        let ty = builder.GetI32Type()
        builder.CreateConstantInt(ty, n)

    | Float f -&gt;
        let ty = builder.GetF64Type()
        builder.CreateConstantFloat(ty, f)

    | Bool b -&gt;
        let ty = builder.GetI1Type()
        builder.CreateConstantBool(ty, b)

    | Var name -&gt;
        symbolTable.[name]

    | Add (left, right) -&gt;
        let lhs = compileExpr builder left symbolTable
        let rhs = compileExpr builder right symbolTable
        builder.CreateAddI(lhs, rhs)

    | Mul (left, right) -&gt;
        let lhs = compileExpr builder left symbolTable
        let rhs = compileExpr builder right symbolTable
        builder.CreateMulI(lhs, rhs)

    // ... (other arithmetic ops)

    // Phase 3: Let and If
    | Let (name, value, body) -&gt;
        let val_result = compileExpr builder value symbolTable
        let newSymbolTable = symbolTable.Add(name, val_result)
        compileExpr builder body newSymbolTable

    | If (cond, thenExpr, elseExpr) -&gt;
        let condVal = compileExpr builder cond symbolTable
        let resultTy = inferType thenExpr symbolTable
        builder.CreateScfIf(condVal, resultTy, fun thenBuilder -&gt;
            let thenResult = compileExpr thenBuilder thenExpr symbolTable
            thenBuilder.CreateScfYield(thenResult)
        , fun elseBuilder -&gt;
            let elseResult = compileExpr elseBuilder elseExpr symbolTable
            elseBuilder.CreateScfYield(elseResult)
        )

    | LetRec (name, func, body) -&gt;
        // Create named function for recursion
        let funcName = sprintf "_%s" name
        let funcOp = compileFunctionDefinition builder funcName func symbolTable
        let funcRef = builder.CreateFuncRef(funcOp)
        let newSymbolTable = symbolTable.Add(name, funcRef)
        compileExpr builder body newSymbolTable

    // Phase 4: Closures
    | Fun (param, body) -&gt;
        // Analyze free variables
        let freeVars = analyzeFreeVars (Fun(param, body)) symbolTable

        // Create closure implementation function
        let implName = sprintf "_lambda_%d" (freshId())
        let implFunc = createClosureImpl builder implName param body freeVars symbolTable

        // Capture environment
        let captures = freeVars |&gt; List.map (fun v -&gt; symbolTable.[v])

        // Create closure object
        builder.CreateClosure(implFunc, captures)

    | App (func, arg) -&gt;
        let funcVal = compileExpr builder func symbolTable
        let argVal = compileExpr builder arg symbolTable
        builder.CreateApply(funcVal, argVal)

    // Phase 6: Lists
    | Nil -&gt;
        let elemTy = inferElementType expr symbolTable
        let listTy = builder.GetListType(elemTy)
        builder.CreateNil(listTy)

    | Cons (head, tail) -&gt;
        let headVal = compileExpr builder head symbolTable
        let tailVal = compileExpr builder tail symbolTable
        let headTy = headVal.GetType()
        let listTy = builder.GetListType(headTy)
        builder.CreateCons(headVal, tailVal, listTy)

    | List exprs -&gt;
        // Desugar to nested Cons
        let desugared = desugarList exprs
        compileExpr builder desugared symbolTable

    | Match (scrutinee, cases) -&gt;
        compileMatch builder scrutinee cases symbolTable

and compileMatch (builder: OpBuilder) (scrutinee: Expr) (cases: (Pattern * Expr) list) (symbolTable: Map&lt;string, Value&gt;) : Value =
    let scrutineeVal = compileExpr builder scrutinee symbolTable
    let resultTy = inferType (snd cases.[0]) symbolTable

    // Create funlang.match operation
    builder.CreateMatch(scrutineeVal, resultTy, fun matchBuilder -&gt;
        cases |&gt; List.map (fun (pattern, body) -&gt;
            match pattern with
            | PNil -&gt;
                // Nil case: no block arguments
                matchBuilder.CreateNilCase(fun caseBuilder -&gt;
                    let result = compileExpr caseBuilder body symbolTable
                    caseBuilder.CreateYield(result)
                )

            | PCons (PVar headName, PVar tailName) -&gt;
                // Cons case: bind head and tail
                let headTy = inferPatternType pattern symbolTable
                let listTy = builder.GetListType(headTy)
                matchBuilder.CreateConsCase(headTy, listTy, fun caseBuilder headArg tailArg -&gt;
                    let newSymbolTable =
                        symbolTable
                            .Add(headName, headArg)
                            .Add(tailName, tailArg)
                    let result = compileExpr caseBuilder body newSymbolTable
                    caseBuilder.CreateYield(result)
                )

            | _ -&gt; failwith "Unsupported pattern"
        )
    )

and desugarList (exprs: Expr list) : Expr =
    match exprs with
    | [] -&gt; Nil
    | head :: tail -&gt; Cons(head, desugarList tail)
</code></pre>
<h3 id="type-inference-for-list-types"><a class="header" href="#type-inference-for-list-types">Type Inference for List Types</a></h3>
<p>리스트 타입 추론:</p>
<pre><code class="language-fsharp">// TypeInfer.fs
let rec inferType (expr: Expr) (symbolTable: Map&lt;string, Value&gt;) : MLIRType =
    match expr with
    | Int _ -&gt; builder.GetI32Type()
    | Float _ -&gt; builder.GetF64Type()
    | Bool _ -&gt; builder.GetI1Type()

    | Var name -&gt;
        let value = symbolTable.[name]
        value.GetType()

    | Nil -&gt;
        // Need context to infer element type
        // If context is unavailable, default to i32
        builder.GetListType(builder.GetI32Type())

    | Cons (head, tail) -&gt;
        let headTy = inferType head symbolTable
        builder.GetListType(headTy)

    | List (head :: _) -&gt;
        let headTy = inferType head symbolTable
        builder.GetListType(headTy)

    | Match (scrutinee, cases) -&gt;
        // Result type is the type of first case body
        inferType (snd cases.[0]) symbolTable

    | Fun (param, body) -&gt;
        // Function type: paramTy -&gt; returnTy
        // Need type annotation or inference
        let paramTy = inferParamType param
        let returnTy = inferType body symbolTable
        builder.GetFunctionType(paramTy, returnTy)

    | _ -&gt; failwith "Type inference not implemented"
</code></pre>
<h3 id="end-to-end-compilation-function"><a class="header" href="#end-to-end-compilation-function">End-to-End Compilation Function</a></h3>
<pre><code class="language-fsharp">// Pipeline.fs
let compileProgram (source: string) : MLIRModule =
    // 1. Parse
    let ast = Parser.parse source

    // 2. Desugar
    let desugared = Desugar.desugar ast

    // 3. Type check
    TypeChecker.check desugared

    // 4. Compile to MLIR
    let ctx = MLIRContext.Create()
    let module = MLIRModule.Create(ctx)
    let builder = OpBuilder.Create(ctx)

    let mainFunc = builder.CreateFunc("main", [], inferType desugared Map.empty, fun funcBuilder -&gt;
        let result = Compiler.compileExpr funcBuilder desugared Map.empty
        funcBuilder.CreateReturn(result)
    )

    module.AddFunction(mainFunc)

    // 5. Apply lowering passes
    let pm = PassManager.Create(ctx)
    pm.AddPass("convert-funlang-to-scf")
    pm.AddPass("convert-scf-to-cf")
    pm.AddPass("convert-funlang-to-llvm")
    pm.AddPass("convert-func-to-llvm")
    pm.Run(module)

    module

// Execute
let execute (module: MLIRModule) : obj =
    let engine = ExecutionEngine.Create(module)
    engine.Invoke("main", [||])

// Complete pipeline
let run (source: string) : obj =
    let module = compileProgram source
    execute module
</code></pre>
<h3 id="example-usage"><a class="header" href="#example-usage">Example Usage</a></h3>
<pre><code class="language-fsharp">// Main.fs
[&lt;EntryPoint&gt;]
let main argv =
    let source = """
        let square = fun x -&gt; x * x
        let add = fun acc x -&gt; acc + x

        let rec map f lst =
          match lst with
          | [] -&gt; []
          | head :: tail -&gt; (f head) :: (map f tail)

        let rec fold f acc lst =
          match lst with
          | [] -&gt; acc
          | head :: tail -&gt; fold f (f acc head) tail

        let sum_of_squares lst =
          fold add 0 (map square lst)

        sum_of_squares [1, 2, 3]
    """

    let result = Pipeline.run source
    printfn "Result: %A" result  // Result: 14

    0
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Result: 14
</code></pre>
<p><strong>완전한 컴파일러가 작동한다!</strong></p>
<h2 id="common-errors-and-debugging-1"><a class="header" href="#common-errors-and-debugging-1">Common Errors and Debugging</a></h2>
<p>함수형 프로그램 작성 시 자주 발생하는 오류와 해결 방법.</p>
<h3 id="1-infinite-recursion"><a class="header" href="#1-infinite-recursion">1. Infinite Recursion</a></h3>
<p><strong>오류:</strong></p>
<pre><code class="language-fsharp">let rec bad_map f lst =
  match lst with
  | [] -&gt; []
  | head :: tail -&gt; (f head) :: (bad_map f lst)  // BUG: lst instead of tail
</code></pre>
<p><strong>증상:</strong></p>
<pre><code>Stack overflow
Segmentation fault
Infinite loop
</code></pre>
<p><strong>해결:</strong></p>
<ul>
<li>재귀 호출이 “smaller” input을 사용하는지 확인</li>
<li>Base case가 반드시 도달 가능한지 확인</li>
</ul>
<pre><code class="language-fsharp">// Correct
| head :: tail -&gt; (f head) :: (map f tail)  // ✓ tail is smaller
</code></pre>
<h3 id="2-type-mismatch"><a class="header" href="#2-type-mismatch">2. Type Mismatch</a></h3>
<p><strong>오류:</strong></p>
<pre><code class="language-fsharp">let bad_fold f acc lst =
  match lst with
  | [] -&gt; 0  // BUG: should return acc, not 0
  | head :: tail -&gt; fold f (f acc head) tail
</code></pre>
<p><strong>증상:</strong></p>
<pre><code>Type error: Expected i32, found i64
Type mismatch in match branches
</code></pre>
<p><strong>해결:</strong></p>
<ul>
<li>모든 match branch가 같은 타입 반환하는지 확인</li>
<li>Accumulator 타입이 일관되는지 확인</li>
</ul>
<pre><code class="language-fsharp">// Correct
| [] -&gt; acc  // ✓ Same type as recursive case
</code></pre>
<h3 id="3-wrong-accumulator-type"><a class="header" href="#3-wrong-accumulator-type">3. Wrong Accumulator Type</a></h3>
<p><strong>오류:</strong></p>
<pre><code class="language-fsharp">// Want to reverse a list
let reverse lst = fold (fun acc x -&gt; acc :: x) [] lst  // BUG: wrong cons order
</code></pre>
<p><strong>증상:</strong></p>
<pre><code>Type error: Cannot cons list to element
Expected: element :: list
Found: list :: element
</code></pre>
<p><strong>해결:</strong></p>
<ul>
<li>Cons operator는 <code>element :: list</code> 순서</li>
<li>Accumulator 타입 확인</li>
</ul>
<pre><code class="language-fsharp">// Correct
let reverse lst = fold (fun acc x -&gt; x :: acc) [] lst  // ✓ x :: acc
</code></pre>
<h3 id="4-stack-overflow"><a class="header" href="#4-stack-overflow">4. Stack Overflow</a></h3>
<p><strong>오류:</strong></p>
<pre><code class="language-fsharp">// Large list
let big_list = [1..100000]
let result = map square big_list  // Stack overflow!
</code></pre>
<p><strong>증상:</strong></p>
<pre><code>Segmentation fault (core dumped)
Stack overflow at recursion depth 100000
</code></pre>
<p><strong>해결:</strong></p>
<ul>
<li>Tail recursive 버전 사용</li>
<li>TCO 활성화</li>
<li>Iteration으로 변환 (Phase 7)</li>
</ul>
<pre><code class="language-fsharp">// Tail recursive version
let map_tailrec f lst =
  let rec loop acc lst =
    match lst with
    | [] -&gt; reverse acc
    | head :: tail -&gt; loop ((f head) :: acc) tail
  loop [] lst
</code></pre>
<h3 id="5-debugging-strategies"><a class="header" href="#5-debugging-strategies">5. Debugging Strategies</a></h3>
<p><strong>전략 1: Trace execution</strong></p>
<pre><code class="language-fsharp">let rec map f lst =
  printfn "map called with list of length %d" (length lst)
  match lst with
  | [] -&gt;
      printfn "  -&gt; returning []"
      []
  | head :: tail -&gt;
      printfn "  -&gt; transforming %A" head
      let transformed = f head
      printfn "  -&gt; recursing on tail"
      let mapped_tail = map f tail
      printfn "  -&gt; cons %A onto result" transformed
      transformed :: mapped_tail
</code></pre>
<p><strong>전략 2: Unit tests</strong></p>
<pre><code class="language-fsharp">let test_map() =
    assert (map square [] = [])
    assert (map square [1] = [1])
    assert (map square [1, 2] = [1, 4])
    assert (map square [1, 2, 3] = [1, 4, 9])
    printfn "map tests passed ✓"
</code></pre>
<p><strong>전략 3: MLIR inspection</strong></p>
<pre><code class="language-fsharp">let module = compileProgram source
printfn "%s" (module.ToString())  // Print MLIR before lowering

let pm = PassManager.Create(ctx)
pm.EnableIRPrinting()  // Print after each pass
pm.AddPass("convert-funlang-to-scf")
pm.Run(module)
</code></pre>
<p><strong>전략 4: GDB debugging</strong></p>
<pre><code class="language-bash"># Compile with debug info
mlir-opt --debug-only=funlang-to-scf input.mlir

# Run under GDB
gdb --args mlir-opt ...
(gdb) break FunLangToSCFPass::runOnOperation
(gdb) run
</code></pre>
<h2 id="리터럴-패턴-예제-fizzbuzz"><a class="header" href="#리터럴-패턴-예제-fizzbuzz">리터럴 패턴 예제: fizzbuzz</a></h2>
<p>지금까지 리스트에 대한 constructor pattern (Nil, Cons)을 다뤘다. 이제 <strong>리터럴 패턴</strong>을 사용하는 실전 예제를 살펴본다.</p>
<h3 id="fizzbuzz-문제"><a class="header" href="#fizzbuzz-문제">FizzBuzz 문제</a></h3>
<p><strong>FizzBuzz 규칙:</strong></p>
<ul>
<li>3의 배수: “Fizz”</li>
<li>5의 배수: “Buzz”</li>
<li>15의 배수: “FizzBuzz”</li>
<li>그 외: 숫자 그대로</li>
</ul>
<p><strong>FunLang 구현:</strong></p>
<pre><code class="language-fsharp">let fizzbuzz n =
    match (n % 3, n % 5) with
    | (0, 0) -&gt; "FizzBuzz"
    | (0, _) -&gt; "Fizz"
    | (_, 0) -&gt; "Buzz"
    | (_, _) -&gt; string_of_int n
</code></pre>
<p><strong>패턴 분석:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Row</th><th>n % 3</th><th>n % 5</th><th>Result</th></tr>
</thead>
<tbody>
<tr><td>1</td><td>0</td><td>0</td><td>“FizzBuzz”</td></tr>
<tr><td>2</td><td>0</td><td>_</td><td>“Fizz”</td></tr>
<tr><td>3</td><td>_</td><td>0</td><td>“Buzz”</td></tr>
<tr><td>4</td><td>_</td><td>_</td><td>n</td></tr>
</tbody>
</table>
</div>
<h3 id="컴파일된-mlir-리터럴-패턴"><a class="header" href="#컴파일된-mlir-리터럴-패턴">컴파일된 MLIR: 리터럴 패턴</a></h3>
<pre><code class="language-mlir">func.func @fizzbuzz(%n: i32) -&gt; !llvm.ptr&lt;i8&gt; {
  // Compute remainders
  %c3 = arith.constant 3 : i32
  %c5 = arith.constant 5 : i32
  %c0 = arith.constant 0 : i32

  %mod3 = arith.remsi %n, %c3 : i32
  %mod5 = arith.remsi %n, %c5 : i32

  // Pattern matching: sequential arith.cmpi chain
  %is_div3 = arith.cmpi eq, %mod3, %c0 : i32
  %result = scf.if %is_div3 -&gt; !llvm.ptr&lt;i8&gt; {
    // First column is 0 (n % 3 == 0)
    %is_div5 = arith.cmpi eq, %mod5, %c0 : i32
    %inner = scf.if %is_div5 -&gt; !llvm.ptr&lt;i8&gt; {
      // Case (0, 0): FizzBuzz
      scf.yield %fizzbuzz_str : !llvm.ptr&lt;i8&gt;
    } else {
      // Case (0, _): Fizz
      scf.yield %fizz_str : !llvm.ptr&lt;i8&gt;
    }
    scf.yield %inner : !llvm.ptr&lt;i8&gt;
  } else {
    // First column is not 0 (n % 3 != 0)
    %is_div5_2 = arith.cmpi eq, %mod5, %c0 : i32
    %inner2 = scf.if %is_div5_2 -&gt; !llvm.ptr&lt;i8&gt; {
      // Case (_, 0): Buzz
      scf.yield %buzz_str : !llvm.ptr&lt;i8&gt;
    } else {
      // Case (_, _): n as string
      %str = func.call @int_to_string(%n) : (i32) -&gt; !llvm.ptr&lt;i8&gt;
      scf.yield %str : !llvm.ptr&lt;i8&gt;
    }
    scf.yield %inner2 : !llvm.ptr&lt;i8&gt;
  }

  return %result : !llvm.ptr&lt;i8&gt;
}
</code></pre>
<p><strong>핵심 관찰:</strong></p>
<ol>
<li><strong><code>arith.cmpi eq</code></strong>: 리터럴 0과의 비교</li>
<li><strong>Nested <code>scf.if</code></strong>: Decision tree 구조</li>
<li><strong>Wildcard <code>_</code></strong>: else branch로 fallthrough (테스트 없음)</li>
</ol>
<h3 id="classify-함수-숫자-분류"><a class="header" href="#classify-함수-숫자-분류">classify 함수: 숫자 분류</a></h3>
<p><strong>숫자를 여러 카테고리로 분류하는 예제:</strong></p>
<pre><code class="language-fsharp">let classify n =
    match n with
    | 0 -&gt; "zero"
    | 1 -&gt; "one"
    | 2 -&gt; "two"
    | _ -&gt; if n &lt; 0 then "negative" else "many"
</code></pre>
<p><strong>컴파일된 MLIR:</strong></p>
<pre><code class="language-mlir">func.func @classify(%n: i32) -&gt; !llvm.ptr&lt;i8&gt; {
  %c0 = arith.constant 0 : i32
  %c1 = arith.constant 1 : i32
  %c2 = arith.constant 2 : i32

  // Sequential literal comparisons
  %is_zero = arith.cmpi eq, %n, %c0 : i32
  %result = scf.if %is_zero -&gt; !llvm.ptr&lt;i8&gt; {
    scf.yield %zero_str : !llvm.ptr&lt;i8&gt;
  } else {
    %is_one = arith.cmpi eq, %n, %c1 : i32
    %r1 = scf.if %is_one -&gt; !llvm.ptr&lt;i8&gt; {
      scf.yield %one_str : !llvm.ptr&lt;i8&gt;
    } else {
      %is_two = arith.cmpi eq, %n, %c2 : i32
      %r2 = scf.if %is_two -&gt; !llvm.ptr&lt;i8&gt; {
        scf.yield %two_str : !llvm.ptr&lt;i8&gt;
      } else {
        // Default case with guard
        %is_neg = arith.cmpi slt, %n, %c0 : i32
        %r3 = scf.if %is_neg -&gt; !llvm.ptr&lt;i8&gt; {
          scf.yield %negative_str : !llvm.ptr&lt;i8&gt;
        } else {
          scf.yield %many_str : !llvm.ptr&lt;i8&gt;
        }
        scf.yield %r3 : !llvm.ptr&lt;i8&gt;
      }
      scf.yield %r2 : !llvm.ptr&lt;i8&gt;
    }
    scf.yield %r1 : !llvm.ptr&lt;i8&gt;
  }

  return %result : !llvm.ptr&lt;i8&gt;
}
</code></pre>
<h3 id="최적화-dense-range-switch"><a class="header" href="#최적화-dense-range-switch">최적화: Dense Range Switch</a></h3>
<p>리터럴이 0, 1, 2 연속일 때 <code>scf.index_switch</code> 최적화 가능:</p>
<pre><code class="language-mlir">// Optimized: range check + index_switch
%in_range = arith.cmpi ult, %n, %c3 : i32
%result = scf.if %in_range -&gt; !llvm.ptr&lt;i8&gt; {
  %idx = arith.index_cast %n : i32 to index
  %r = scf.index_switch %idx : index -&gt; !llvm.ptr&lt;i8&gt;
  case 0 { scf.yield %zero_str : !llvm.ptr&lt;i8&gt; }
  case 1 { scf.yield %one_str : !llvm.ptr&lt;i8&gt; }
  case 2 { scf.yield %two_str : !llvm.ptr&lt;i8&gt; }
  default { scf.yield %unreachable : !llvm.ptr&lt;i8&gt; }
  scf.yield %r : !llvm.ptr&lt;i8&gt;
} else {
  // n &gt;= 3: check if negative
  %is_neg = arith.cmpi slt, %n, %c0 : i32
  %r2 = scf.if %is_neg -&gt; !llvm.ptr&lt;i8&gt; {
    scf.yield %negative_str : !llvm.ptr&lt;i8&gt;
  } else {
    scf.yield %many_str : !llvm.ptr&lt;i8&gt;
  }
  scf.yield %r2 : !llvm.ptr&lt;i8&gt;
}
</code></pre>
<p><strong>최적화 효과:</strong></p>
<ul>
<li><strong>Before:</strong> O(n) sequential comparisons</li>
<li><strong>After:</strong> O(1) jump table for dense range</li>
</ul>
<h3 id="wildcard-default-case-최적화"><a class="header" href="#wildcard-default-case-최적화">Wildcard Default Case 최적화</a></h3>
<p><strong>Wildcard <code>_</code>는 테스트를 생성하지 않는다:</strong></p>
<pre><code class="language-fsharp">match x with
| 0 -&gt; handle_zero()
| 1 -&gt; handle_one()
| _ -&gt; handle_default()  // No comparison needed!
</code></pre>
<pre><code class="language-mlir">%is_zero = arith.cmpi eq, %x, %c0 : i32
scf.if %is_zero {
  // case 0
} else {
  %is_one = arith.cmpi eq, %x, %c1 : i32
  scf.if %is_one {
    // case 1
  } else {
    // _ case: NO arith.cmpi, just fallthrough
    // All other cases exhausted, this is the default
  }
}
</code></pre>
<p><strong>핵심 원칙:</strong></p>
<ul>
<li>마지막 else branch는 이전 모든 테스트가 실패한 경우</li>
<li>추가 비교 없이 바로 default 코드 실행</li>
<li>이것이 wildcard의 <strong>zero-cost abstraction</strong></li>
</ul>
<h3 id="리터럴--constructor-혼합-예제"><a class="header" href="#리터럴--constructor-혼합-예제">리터럴 + Constructor 혼합 예제</a></h3>
<p><strong>리스트와 숫자를 함께 매칭:</strong></p>
<pre><code class="language-fsharp">let take_first_n lst n =
    match (lst, n) with
    | (_, 0) -&gt; []
    | ([], _) -&gt; []
    | (head :: tail, n) -&gt; head :: take_first_n tail (n - 1)
</code></pre>
<p><strong>컴파일된 MLIR:</strong></p>
<pre><code class="language-mlir">func.func @take_first_n(%lst: !funlang.list&lt;i32&gt;, %n: i32) -&gt; !funlang.list&lt;i32&gt; {
  %c0 = arith.constant 0 : i32
  %c1 = arith.constant 1 : i32

  // Check n == 0 first (literal pattern)
  %is_n_zero = arith.cmpi eq, %n, %c0 : i32
  %result = scf.if %is_n_zero -&gt; !funlang.list&lt;i32&gt; {
    // Case (_, 0): return empty
    %empty = funlang.nil : !funlang.list&lt;i32&gt;
    scf.yield %empty : !funlang.list&lt;i32&gt;
  } else {
    // Check list constructor (constructor pattern)
    %struct = builtin.unrealized_conversion_cast %lst : ... to !llvm.struct&lt;(i32, ptr)&gt;
    %tag = llvm.extractvalue %struct[0] : !llvm.struct&lt;(i32, ptr)&gt;
    %tag_index = arith.index_cast %tag : i32 to index

    %inner = scf.index_switch %tag_index : index -&gt; !funlang.list&lt;i32&gt;
    case 0 {
      // Case ([], _): return empty
      %empty = funlang.nil : !funlang.list&lt;i32&gt;
      scf.yield %empty : !funlang.list&lt;i32&gt;
    }
    case 1 {
      // Case (head :: tail, n): recursive
      %data = llvm.extractvalue %struct[1] : !llvm.struct&lt;(i32, ptr)&gt;
      %head = llvm.load %data : !llvm.ptr -&gt; i32
      %tail_ptr = llvm.getelementptr %data[1] : (!llvm.ptr) -&gt; !llvm.ptr
      %tail = llvm.load %tail_ptr : !llvm.ptr -&gt; !funlang.list&lt;i32&gt;

      %n_minus_1 = arith.subi %n, %c1 : i32
      %rest = func.call @take_first_n(%tail, %n_minus_1) : (...) -&gt; !funlang.list&lt;i32&gt;
      %new_list = funlang.cons %head, %rest : ...
      scf.yield %new_list : !funlang.list&lt;i32&gt;
    }
    default { scf.yield %unreachable : !funlang.list&lt;i32&gt; }

    scf.yield %inner : !funlang.list&lt;i32&gt;
  }

  return %result : !funlang.list&lt;i32&gt;
}
</code></pre>
<p><strong>혼합 패턴 lowering 전략:</strong></p>
<ol>
<li><strong>Literal column first</strong>: <code>arith.cmpi</code> + <code>scf.if</code></li>
<li><strong>Constructor column inside</strong>: <code>scf.index_switch</code></li>
<li><strong>Wildcard</strong>: test 없이 fallthrough</li>
</ol>
<h3 id="검증-및-테스트"><a class="header" href="#검증-및-테스트">검증 및 테스트</a></h3>
<pre><code class="language-fsharp">let testFizzBuzz() =
    // Test fizzbuzz
    assert (fizzbuzz 3 = "Fizz")
    assert (fizzbuzz 5 = "Buzz")
    assert (fizzbuzz 15 = "FizzBuzz")
    assert (fizzbuzz 7 = "7")
    printfn "fizzbuzz tests passed"

    // Test classify
    assert (classify 0 = "zero")
    assert (classify 1 = "one")
    assert (classify 2 = "two")
    assert (classify 42 = "many")
    assert (classify (-5) = "negative")
    printfn "classify tests passed"

    // Test take_first_n
    assert (take_first_n [1, 2, 3, 4, 5] 3 = [1, 2, 3])
    assert (take_first_n [1, 2, 3] 0 = [])
    assert (take_first_n [] 5 = [])
    printfn "take_first_n tests passed"
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>fizzbuzz tests passed
classify tests passed
take_first_n tests passed
</code></pre>
<h3 id="key-takeaways-1"><a class="header" href="#key-takeaways-1">Key Takeaways</a></h3>
<ol>
<li><strong>리터럴 패턴</strong>: <code>arith.cmpi eq</code> + <code>scf.if</code> chain</li>
<li><strong>Constructor 패턴</strong>: <code>scf.index_switch</code>로 O(1) dispatch</li>
<li><strong>Wildcard</strong>: else branch로 fallthrough (테스트 없음)</li>
<li><strong>Dense range</strong>: <code>scf.index_switch</code>로 최적화 가능</li>
<li><strong>혼합 패턴</strong>: 각 column의 패턴 타입에 맞는 dispatch 사용</li>
</ol>
<hr>
<h2 id="튜플-예제-zip과-unzip-tuple-examples-zip-and-unzip"><a class="header" href="#튜플-예제-zip과-unzip-tuple-examples-zip-and-unzip">튜플 예제: zip과 unzip (Tuple Examples: zip and unzip)</a></h2>
<p>Chapter 18에서 <code>!funlang.tuple&lt;T1, T2, ...&gt;</code> 타입과 <code>funlang.make_tuple</code> 연산을, Chapter 19에서 튜플 패턴 매칭을 구현했다. 이제 튜플을 활용하는 실제 프로그램을 작성하고 컴파일해보자.</p>
<h3 id="zip-함수-두-리스트를-쌍의-리스트로"><a class="header" href="#zip-함수-두-리스트를-쌍의-리스트로">zip 함수: 두 리스트를 쌍의 리스트로</a></h3>
<p><strong>zip의 개념:</strong></p>
<p>두 리스트를 받아 각 위치의 원소들을 튜플로 묶은 리스트를 반환한다.</p>
<pre><code class="language-fsharp">// zip의 타입
zip : [a] -&gt; [b] -&gt; [(a, b)]

// zip의 동작
zip [1, 2, 3] ["a", "b", "c"] = [(1, "a"), (2, "b"), (3, "c")]

// 길이가 다르면 짧은 쪽에 맞춤
zip [1, 2] ["a", "b", "c"] = [(1, "a"), (2, "b")]
</code></pre>
<p><strong>FunLang 구현:</strong></p>
<pre><code class="language-fsharp">let rec zip xs ys =
  match xs with
  | [] -&gt; []
  | x :: xs' -&gt;
      match ys with
      | [] -&gt; []
      | y :: ys' -&gt; make_tuple(x, y) :: zip xs' ys'
</code></pre>
<p><strong>동작 원리:</strong></p>
<ol>
<li>첫 번째 리스트가 비어있으면 빈 리스트 반환</li>
<li>두 번째 리스트가 비어있으면 빈 리스트 반환</li>
<li>둘 다 원소가 있으면:
<ul>
<li>각 head로 튜플 생성: <code>make_tuple(x, y)</code></li>
<li>tail들로 재귀 호출: <code>zip xs' ys'</code></li>
<li>결과를 cons: <code>pair :: rest</code></li>
</ul>
</li>
</ol>
<h3 id="zip-함수-컴파일-funlang-mlir"><a class="header" href="#zip-함수-컴파일-funlang-mlir">zip 함수 컴파일: FunLang MLIR</a></h3>
<pre><code class="language-mlir">// zip : !funlang.list&lt;i32&gt; -&gt; !funlang.list&lt;f64&gt; -&gt; !funlang.list&lt;!funlang.tuple&lt;i32, f64&gt;&gt;
func.func @zip(%xs: !funlang.list&lt;i32&gt;, %ys: !funlang.list&lt;f64&gt;)
    -&gt; !funlang.list&lt;!funlang.tuple&lt;i32, f64&gt;&gt; {

  // 첫 번째 리스트 패턴 매칭
  %result = funlang.match %xs : !funlang.list&lt;i32&gt;
      -&gt; !funlang.list&lt;!funlang.tuple&lt;i32, f64&gt;&gt; {

    ^nil:
      // xs가 비어있으면 빈 리스트 반환
      %empty = funlang.nil : !funlang.list&lt;!funlang.tuple&lt;i32, f64&gt;&gt;
      funlang.yield %empty : !funlang.list&lt;!funlang.tuple&lt;i32, f64&gt;&gt;

    ^cons(%x: i32, %xs_tail: !funlang.list&lt;i32&gt;):
      // xs = x :: xs_tail, 이제 ys 패턴 매칭
      %inner = funlang.match %ys : !funlang.list&lt;f64&gt;
          -&gt; !funlang.list&lt;!funlang.tuple&lt;i32, f64&gt;&gt; {

        ^nil:
          // ys가 비어있으면 빈 리스트 반환
          %empty2 = funlang.nil : !funlang.list&lt;!funlang.tuple&lt;i32, f64&gt;&gt;
          funlang.yield %empty2 : !funlang.list&lt;!funlang.tuple&lt;i32, f64&gt;&gt;

        ^cons(%y: f64, %ys_tail: !funlang.list&lt;f64&gt;):
          // ys = y :: ys_tail
          // 튜플 생성: (x, y)
          %pair = funlang.make_tuple(%x, %y) : !funlang.tuple&lt;i32, f64&gt;

          // 재귀 호출: zip xs_tail ys_tail
          %rest = func.call @zip(%xs_tail, %ys_tail)
              : (!funlang.list&lt;i32&gt;, !funlang.list&lt;f64&gt;)
              -&gt; !funlang.list&lt;!funlang.tuple&lt;i32, f64&gt;&gt;

          // cons: pair :: rest
          %cons_result = funlang.cons %pair, %rest
              : !funlang.list&lt;!funlang.tuple&lt;i32, f64&gt;&gt;

          funlang.yield %cons_result : !funlang.list&lt;!funlang.tuple&lt;i32, f64&gt;&gt;
      }
      funlang.yield %inner : !funlang.list&lt;!funlang.tuple&lt;i32, f64&gt;&gt;
  }

  return %result : !funlang.list&lt;!funlang.tuple&lt;i32, f64&gt;&gt;
}
</code></pre>
<p><strong>핵심 포인트:</strong></p>
<ol>
<li><strong>중첩 패턴 매칭</strong>: 먼저 xs를 매칭하고, Cons case 안에서 ys를 매칭</li>
<li><strong>make_tuple 사용</strong>: <code>funlang.make_tuple(%x, %y)</code> 로 쌍 생성</li>
<li><strong>결과 타입</strong>: <code>!funlang.list&lt;!funlang.tuple&lt;i32, f64&gt;&gt;</code> - 튜플의 리스트</li>
</ol>
<h3 id="fst와-snd-함수-튜플-원소-추출"><a class="header" href="#fst와-snd-함수-튜플-원소-추출">fst와 snd 함수: 튜플 원소 추출</a></h3>
<p><strong>fst와 snd의 정의:</strong></p>
<pre><code class="language-fsharp">// 첫 번째 원소 추출
let fst pair = match pair with (x, _) -&gt; x

// 두 번째 원소 추출
let snd pair = match pair with (_, y) -&gt; y
</code></pre>
<p><strong>MLIR 구현:</strong></p>
<pre><code class="language-mlir">// fst : !funlang.tuple&lt;i32, f64&gt; -&gt; i32
func.func @fst(%pair: !funlang.tuple&lt;i32, f64&gt;) -&gt; i32 {
  %result = funlang.match %pair : !funlang.tuple&lt;i32, f64&gt; -&gt; i32 {
    ^case(%x: i32, %y: f64):
      funlang.yield %x : i32
  }
  return %result : i32
}

// snd : !funlang.tuple&lt;i32, f64&gt; -&gt; f64
func.func @snd(%pair: !funlang.tuple&lt;i32, f64&gt;) -&gt; f64 {
  %result = funlang.match %pair : !funlang.tuple&lt;i32, f64&gt; -&gt; f64 {
    ^case(%x: i32, %y: f64):
      funlang.yield %y : f64
  }
  return %result : f64
}
</code></pre>
<p><strong>Lowering 결과:</strong></p>
<pre><code class="language-mlir">// fst after lowering - 분기 없이 직접 추출
func.func @fst(%pair: !llvm.struct&lt;(i32, f64)&gt;) -&gt; i32 {
  %x = llvm.extractvalue %pair[0] : !llvm.struct&lt;(i32, f64)&gt;
  return %x : i32
}

// snd after lowering
func.func @snd(%pair: !llvm.struct&lt;(i32, f64)&gt;) -&gt; f64 {
  %y = llvm.extractvalue %pair[1] : !llvm.struct&lt;(i32, f64)&gt;
  return %y : f64
}
</code></pre>
<p><strong>핵심:</strong></p>
<ul>
<li>튜플 패턴 매칭은 <strong>scf.index_switch 없이</strong> 바로 extractvalue로 lowering</li>
<li>와일드카드 <code>_</code>는 해당 위치의 extractvalue를 생략 (dead code elimination)</li>
</ul>
<h3 id="unzip-함수-쌍의-리스트를-두-리스트로"><a class="header" href="#unzip-함수-쌍의-리스트를-두-리스트로">unzip 함수: 쌍의 리스트를 두 리스트로</a></h3>
<p><strong>unzip의 개념:</strong></p>
<p>zip의 역연산. 튜플 리스트를 두 개의 리스트로 분리한다.</p>
<pre><code class="language-fsharp">// unzip의 타입
unzip : [(a, b)] -&gt; ([a], [b])

// unzip의 동작
unzip [(1, "a"), (2, "b")] = ([1, 2], ["a", "b"])
</code></pre>
<p><strong>FunLang 구현:</strong></p>
<pre><code class="language-fsharp">let rec unzip pairs =
  match pairs with
  | [] -&gt; ([], [])
  | p :: ps -&gt;
      let (x, y) = p in
      let (xs, ys) = unzip ps in
      (x :: xs, y :: ys)
</code></pre>
<p><strong>MLIR 구현:</strong></p>
<pre><code class="language-mlir">// unzip : !funlang.list&lt;!funlang.tuple&lt;i32, f64&gt;&gt;
//       -&gt; !funlang.tuple&lt;!funlang.list&lt;i32&gt;, !funlang.list&lt;f64&gt;&gt;
func.func @unzip(%pairs: !funlang.list&lt;!funlang.tuple&lt;i32, f64&gt;&gt;)
    -&gt; !funlang.tuple&lt;!funlang.list&lt;i32&gt;, !funlang.list&lt;f64&gt;&gt; {

  %result = funlang.match %pairs
      : !funlang.list&lt;!funlang.tuple&lt;i32, f64&gt;&gt;
      -&gt; !funlang.tuple&lt;!funlang.list&lt;i32&gt;, !funlang.list&lt;f64&gt;&gt; {

    ^nil:
      // 빈 리스트 → ([], [])
      %empty_ints = funlang.nil : !funlang.list&lt;i32&gt;
      %empty_floats = funlang.nil : !funlang.list&lt;f64&gt;
      %empty_pair = funlang.make_tuple(%empty_ints, %empty_floats)
          : !funlang.tuple&lt;!funlang.list&lt;i32&gt;, !funlang.list&lt;f64&gt;&gt;
      funlang.yield %empty_pair
          : !funlang.tuple&lt;!funlang.list&lt;i32&gt;, !funlang.list&lt;f64&gt;&gt;

    ^cons(%p: !funlang.tuple&lt;i32, f64&gt;, %ps: !funlang.list&lt;!funlang.tuple&lt;i32, f64&gt;&gt;):
      // p = (x, y), 튜플 분해
      %xy = funlang.match %p : !funlang.tuple&lt;i32, f64&gt;
          -&gt; !funlang.tuple&lt;i32, f64&gt; {
        ^case(%x: i32, %y: f64):
          funlang.yield %p : !funlang.tuple&lt;i32, f64&gt;
      }
      // 실제로는 직접 extractvalue 사용
      %x = ... extractvalue [0] ...
      %y = ... extractvalue [1] ...

      // 재귀: unzip ps
      %rest = func.call @unzip(%ps) : ...
      %xs = ... fst rest ...
      %ys = ... snd rest ...

      // 결과: (x :: xs, y :: ys)
      %new_xs = funlang.cons %x, %xs : !funlang.list&lt;i32&gt;
      %new_ys = funlang.cons %y, %ys : !funlang.list&lt;f64&gt;
      %result_pair = funlang.make_tuple(%new_xs, %new_ys)
          : !funlang.tuple&lt;!funlang.list&lt;i32&gt;, !funlang.list&lt;f64&gt;&gt;
      funlang.yield %result_pair
          : !funlang.tuple&lt;!funlang.list&lt;i32&gt;, !funlang.list&lt;f64&gt;&gt;
  }

  return %result : !funlang.tuple&lt;!funlang.list&lt;i32&gt;, !funlang.list&lt;f64&gt;&gt;
}
</code></pre>
<h3 id="point-조작-예제-2d-좌표"><a class="header" href="#point-조작-예제-2d-좌표">Point 조작 예제: 2D 좌표</a></h3>
<p><strong>Point 타입:</strong></p>
<pre><code class="language-fsharp">// Point = (int, int) 튜플
type point = int * int

let origin = (0, 0)
let p1 = (3, 4)
</code></pre>
<p><strong>기본 연산들:</strong></p>
<pre><code class="language-fsharp">// 오른쪽으로 이동
let move_right pt =
  match pt with (x, y) -&gt; (x + 1, y)

// 위로 이동
let move_up pt =
  match pt with (x, y) -&gt; (x, y + 1)

// 두 점 사이의 거리 (맨해튼)
let manhattan_distance p1 p2 =
  match (p1, p2) with ((x1, y1), (x2, y2)) -&gt;
    abs(x2 - x1) + abs(y2 - y1)

// 점 리스트의 중심점
let centroid points =
  let sum_pts = fold (fun (sx, sy) (x, y) -&gt; (sx + x, sy + y)) (0, 0) points
  let n = length points
  match sum_pts with (sx, sy) -&gt; (sx / n, sy / n)
</code></pre>
<p><strong>MLIR 구현 - move_right:</strong></p>
<pre><code class="language-mlir">// move_right : !funlang.tuple&lt;i32, i32&gt; -&gt; !funlang.tuple&lt;i32, i32&gt;
func.func @move_right(%pt: !funlang.tuple&lt;i32, i32&gt;) -&gt; !funlang.tuple&lt;i32, i32&gt; {
  %result = funlang.match %pt : !funlang.tuple&lt;i32, i32&gt; -&gt; !funlang.tuple&lt;i32, i32&gt; {
    ^case(%x: i32, %y: i32):
      %c1 = arith.constant 1 : i32
      %new_x = arith.addi %x, %c1 : i32
      %new_pt = funlang.make_tuple(%new_x, %y) : !funlang.tuple&lt;i32, i32&gt;
      funlang.yield %new_pt : !funlang.tuple&lt;i32, i32&gt;
  }
  return %result : !funlang.tuple&lt;i32, i32&gt;
}
</code></pre>
<p><strong>Lowering 결과:</strong></p>
<pre><code class="language-mlir">func.func @move_right(%pt: !llvm.struct&lt;(i32, i32)&gt;) -&gt; !llvm.struct&lt;(i32, i32)&gt; {
  %x = llvm.extractvalue %pt[0] : !llvm.struct&lt;(i32, i32)&gt;
  %y = llvm.extractvalue %pt[1] : !llvm.struct&lt;(i32, i32)&gt;
  %c1 = arith.constant 1 : i32
  %new_x = arith.addi %x, %c1 : i32
  %0 = llvm.mlir.undef : !llvm.struct&lt;(i32, i32)&gt;
  %1 = llvm.insertvalue %new_x, %0[0] : !llvm.struct&lt;(i32, i32)&gt;
  %result = llvm.insertvalue %y, %1[1] : !llvm.struct&lt;(i32, i32)&gt;
  return %result : !llvm.struct&lt;(i32, i32)&gt;
}
</code></pre>
<p><strong>중첩 튜플 - manhattan_distance:</strong></p>
<pre><code class="language-mlir">// manhattan_distance : !funlang.tuple&lt;i32, i32&gt; -&gt; !funlang.tuple&lt;i32, i32&gt; -&gt; i32
func.func @manhattan_distance(%p1: !funlang.tuple&lt;i32, i32&gt;, %p2: !funlang.tuple&lt;i32, i32&gt;) -&gt; i32 {
  // 두 점을 하나의 튜플로 묶어서 패턴 매칭
  %combined = funlang.make_tuple(%p1, %p2)
      : !funlang.tuple&lt;!funlang.tuple&lt;i32, i32&gt;, !funlang.tuple&lt;i32, i32&gt;&gt;

  // 중첩 튜플 분해
  %result = funlang.match %combined
      : !funlang.tuple&lt;!funlang.tuple&lt;i32, i32&gt;, !funlang.tuple&lt;i32, i32&gt;&gt; -&gt; i32 {

    ^case(%pt1: !funlang.tuple&lt;i32, i32&gt;, %pt2: !funlang.tuple&lt;i32, i32&gt;):
      // 첫 번째 점 분해
      %xy1 = funlang.match %pt1 : !funlang.tuple&lt;i32, i32&gt; -&gt; !funlang.tuple&lt;i32, i32&gt; {
        ^case(%x1: i32, %y1: i32):
          funlang.yield %pt1 : !funlang.tuple&lt;i32, i32&gt;
      }
      // 실제로는 extractvalue 연쇄
      // %x1 = extractvalue %pt1[0]
      // %y1 = extractvalue %pt1[1]
      // %x2 = extractvalue %pt2[0]
      // %y2 = extractvalue %pt2[1]

      // 거리 계산
      // %dx = abs(x2 - x1)
      // %dy = abs(y2 - y1)
      // %result = dx + dy
      ...
      funlang.yield %distance : i32
  }

  return %result : i32
}
</code></pre>
<h3 id="튜플--고차-함수-결합"><a class="header" href="#튜플--고차-함수-결합">튜플 + 고차 함수 결합</a></h3>
<p><strong>튜플을 사용한 map_with_index:</strong></p>
<pre><code class="language-fsharp">// 리스트의 각 원소에 인덱스와 함께 함수 적용
let map_with_index f lst =
  let indexed = zip [0..length lst - 1] lst
  map (fun (i, x) -&gt; f i x) indexed
</code></pre>
<p><strong>enumerate 함수:</strong></p>
<pre><code class="language-fsharp">// 리스트에 인덱스를 붙여서 튜플 리스트로
let rec enumerate_from n lst =
  match lst with
  | [] -&gt; []
  | x :: xs -&gt; (n, x) :: enumerate_from (n + 1) xs

let enumerate = enumerate_from 0

// 사용 예
enumerate ["a", "b", "c"]  // [(0, "a"), (1, "b"), (2, "c")]
</code></pre>
<p><strong>partition 함수 (튜플 반환):</strong></p>
<pre><code class="language-fsharp">// 리스트를 조건에 따라 두 리스트로 분리
let rec partition pred lst =
  match lst with
  | [] -&gt; ([], [])
  | x :: xs -&gt;
      let (yes, no) = partition pred xs
      if pred x then
        (x :: yes, no)
      else
        (yes, x :: no)

// 사용 예
partition (fun x -&gt; x &gt; 0) [-1, 2, -3, 4]  // ([2, 4], [-1, -3])
</code></pre>
<p><strong>MLIR 구현 - partition:</strong></p>
<pre><code class="language-mlir">func.func @partition(%pred: !funlang.closure&lt;(i32) -&gt; i1&gt;,
                      %lst: !funlang.list&lt;i32&gt;)
    -&gt; !funlang.tuple&lt;!funlang.list&lt;i32&gt;, !funlang.list&lt;i32&gt;&gt; {

  %result = funlang.match %lst : !funlang.list&lt;i32&gt;
      -&gt; !funlang.tuple&lt;!funlang.list&lt;i32&gt;, !funlang.list&lt;i32&gt;&gt; {

    ^nil:
      %empty1 = funlang.nil : !funlang.list&lt;i32&gt;
      %empty2 = funlang.nil : !funlang.list&lt;i32&gt;
      %pair = funlang.make_tuple(%empty1, %empty2)
          : !funlang.tuple&lt;!funlang.list&lt;i32&gt;, !funlang.list&lt;i32&gt;&gt;
      funlang.yield %pair : !funlang.tuple&lt;!funlang.list&lt;i32&gt;, !funlang.list&lt;i32&gt;&gt;

    ^cons(%x: i32, %xs: !funlang.list&lt;i32&gt;):
      // 재귀: partition pred xs
      %rest = func.call @partition(%pred, %xs) : ...
      %yes = ... fst rest ...
      %no = ... snd rest ...

      // pred x 평가
      %test = funlang.apply %pred(%x) : (i32) -&gt; i1

      // 조건부 cons
      %new_pair = scf.if %test -&gt; !funlang.tuple&lt;!funlang.list&lt;i32&gt;, !funlang.list&lt;i32&gt;&gt; {
        %new_yes = funlang.cons %x, %yes : !funlang.list&lt;i32&gt;
        %pair = funlang.make_tuple(%new_yes, %no)
            : !funlang.tuple&lt;!funlang.list&lt;i32&gt;, !funlang.list&lt;i32&gt;&gt;
        scf.yield %pair : !funlang.tuple&lt;!funlang.list&lt;i32&gt;, !funlang.list&lt;i32&gt;&gt;
      } else {
        %new_no = funlang.cons %x, %no : !funlang.list&lt;i32&gt;
        %pair = funlang.make_tuple(%yes, %new_no)
            : !funlang.tuple&lt;!funlang.list&lt;i32&gt;, !funlang.list&lt;i32&gt;&gt;
        scf.yield %pair : !funlang.tuple&lt;!funlang.list&lt;i32&gt;, !funlang.list&lt;i32&gt;&gt;
      }

      funlang.yield %new_pair : !funlang.tuple&lt;!funlang.list&lt;i32&gt;, !funlang.list&lt;i32&gt;&gt;
  }

  return %result : !funlang.tuple&lt;!funlang.list&lt;i32&gt;, !funlang.list&lt;i32&gt;&gt;
}
</code></pre>
<h3 id="summary-튜플-예제"><a class="header" href="#summary-튜플-예제">Summary: 튜플 예제</a></h3>
<p><strong>구현한 함수들:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>함수</th><th>타입</th><th>설명</th></tr>
</thead>
<tbody>
<tr><td>zip</td><td><code>[a] -&gt; [b] -&gt; [(a,b)]</code></td><td>두 리스트를 쌍으로 묶기</td></tr>
<tr><td>fst</td><td><code>(a,b) -&gt; a</code></td><td>첫 번째 원소 추출</td></tr>
<tr><td>snd</td><td><code>(a,b) -&gt; b</code></td><td>두 번째 원소 추출</td></tr>
<tr><td>unzip</td><td><code>[(a,b)] -&gt; ([a], [b])</code></td><td>쌍 리스트를 두 리스트로 분리</td></tr>
<tr><td>move_right</td><td><code>point -&gt; point</code></td><td>좌표 변환</td></tr>
<tr><td>manhattan_distance</td><td><code>point -&gt; point -&gt; int</code></td><td>두 점 사이 거리</td></tr>
<tr><td>enumerate</td><td><code>[a] -&gt; [(int, a)]</code></td><td>인덱스 붙이기</td></tr>
<tr><td>partition</td><td><code>(a -&gt; bool) -&gt; [a] -&gt; ([a], [a])</code></td><td>조건에 따라 분리</td></tr>
</tbody>
</table>
</div>
<p><strong>핵심 패턴:</strong></p>
<ol>
<li><strong>make_tuple로 튜플 생성</strong>: <code>funlang.make_tuple(%a, %b)</code></li>
<li><strong>패턴 매칭으로 분해</strong>: <code>^case(%x, %y):</code> 또는 extractvalue 직접 사용</li>
<li><strong>중첩 가능</strong>: 튜플 안에 리스트, 리스트 안에 튜플</li>
<li><strong>다중 반환값</strong>: 함수에서 튜플 반환하여 여러 값 리턴</li>
<li><strong>고차 함수와 결합</strong>: map, fold 등과 함께 사용</li>
</ol>
<p><strong>Lowering 특성:</strong></p>
<ul>
<li>튜플 패턴: <strong>분기 없이</strong> extractvalue 체인</li>
<li>리스트 패턴: scf.index_switch 사용</li>
<li>중첩: 외부에서 내부로 순차 처리</li>
</ul>
<hr>
<h2 id="phase-6-complete-summary"><a class="header" href="#phase-6-complete-summary">Phase 6 Complete Summary</a></h2>
<p><strong>축하한다! Phase 6를 완료했다.</strong></p>
<h3 id="chapter-17-20-복습"><a class="header" href="#chapter-17-20-복습">Chapter 17-20 복습</a></h3>
<p><strong>Chapter 17: Pattern Matching Theory</strong></p>
<ul>
<li>Decision tree 알고리즘으로 패턴 매칭을 효율적으로 컴파일</li>
<li>Exhaustiveness checking으로 빠진 case 감지</li>
<li>Unreachable case detection으로 중복 제거</li>
</ul>
<p><strong>Chapter 18: List Operations</strong></p>
<ul>
<li><code>!funlang.list&lt;T&gt;</code> parameterized type</li>
<li>Tagged union representation: <code>!llvm.struct&lt;(i32, ptr)&gt;</code></li>
<li><code>funlang.nil</code>과 <code>funlang.cons</code> operations</li>
<li>TypeConverter와 lowering patterns</li>
</ul>
<p><strong>Chapter 19: Match Compilation</strong></p>
<ul>
<li><code>funlang.match</code> operation 정의</li>
<li>Multi-stage lowering: FunLang → SCF → CF → LLVM</li>
<li>IRMapping으로 block argument remapping</li>
<li>Region-based IR structure</li>
</ul>
<p><strong>Chapter 20: Functional Programs (this chapter)</strong></p>
<ul>
<li>FunLang AST extensions for lists</li>
<li>Compiler integration (compileExpr, type inference)</li>
<li>Core list functions: map, filter, fold, length, append</li>
<li>Complete example: sum_of_squares</li>
<li>End-to-end compilation pipeline (9 stages)</li>
<li>Performance analysis and optimization preview</li>
</ul>
<h3 id="what-you-can-now-compile"><a class="header" href="#what-you-can-now-compile">What You Can Now Compile</a></h3>
<p><strong>Phase 6 종료 시점에 컴파일 가능한 프로그램:</strong></p>
<pre><code class="language-fsharp">// 1. List construction
let list = [1, 2, 3, 4, 5]

// 2. Pattern matching
let rec sum lst =
  match lst with
  | [] -&gt; 0
  | head :: tail -&gt; head + sum tail

// 3. Higher-order functions
let map f lst = ...
let filter pred lst = ...
let fold combiner acc lst = ...

// 4. Function composition
let sum_of_squares lst =
  fold (+) 0 (map (fun x -&gt; x * x) lst)

// 5. Complex functional programs
let process data =
  data
  |&gt; filter is_valid
  |&gt; map transform
  |&gt; fold aggregate initial

// 6. Nested data structures
let nested = [[1, 2], [3, 4], [5, 6]]
let flattened = fold append [] nested
</code></pre>
<p><strong>이것은 실제 함수형 언어와 동등한 표현력이다!</strong></p>
<h3 id="technical-achievements"><a class="header" href="#technical-achievements">Technical Achievements</a></h3>
<p><strong>Phase 6에서 구현한 기술:</strong></p>
<ol>
<li><strong>Parameterized types</strong>: <code>!funlang.list&lt;T&gt;</code> with element type parameter</li>
<li><strong>Tagged unions</strong>: Efficient runtime representation of ADTs</li>
<li><strong>Pattern matching</strong>: Decision tree compilation for performance</li>
<li><strong>Multi-stage lowering</strong>: Progressive refinement through dialects</li>
<li><strong>Type conversion</strong>: Consistent type mapping across lowering stages</li>
<li><strong>Region-based IR</strong>: Structured control flow with scoped bindings</li>
<li><strong>Tail recursion</strong>: Optimization opportunity for fold</li>
<li><strong>GC integration</strong>: Automatic memory management for lists</li>
<li><strong>Complete pipeline</strong>: Source → AST → MLIR → LLVM IR → Machine code</li>
</ol>
<h3 id="phase-7-preview-optimization"><a class="header" href="#phase-7-preview-optimization">Phase 7 Preview: Optimization</a></h3>
<p>Phase 7에서 다룰 내용:</p>
<p><strong>1. List Fusion</strong></p>
<p>중간 리스트 제거:</p>
<pre><code class="language-fsharp">// Before
map f (map g lst)  // Two passes, intermediate list

// After fusion
map (f &lt;&lt; g) lst   // One pass, no intermediate
</code></pre>
<p><strong>2. Deforestation</strong></p>
<p>Tree 구조 중간 생성 제거:</p>
<pre><code class="language-fsharp">// Before
fold h z (map f lst)  // Creates intermediate list

// After deforestation
fold (fun acc x -&gt; h acc (f x)) z lst  // Direct
</code></pre>
<p><strong>3. Inlining</strong></p>
<p>Small 함수 inline:</p>
<pre><code class="language-mlir">// Before
%result = func.call @square(%x) : (i32) -&gt; i32

// After inlining
%result = arith.muli %x, %x : i32
</code></pre>
<p><strong>4. Loop Unrolling</strong></p>
<p>재귀를 explicit loop로 변환:</p>
<pre><code class="language-mlir">// Before (recursive)
func.func @map(...) {
  %result = funlang.match %lst : ... {
    ^nil: ...
    ^cons(...): %mapped = func.call @map(...) ...
  }
}

// After (loop)
func.func @map(...) {
  scf.for %i = 0 to %n step 1 iter_args(%acc = %init) -&gt; ... {
    %elem = load %lst[%i]
    %transformed = apply %f(%elem)
    ...
  }
}
</code></pre>
<p><strong>5. Parallel Map</strong></p>
<p>데이터 병렬성 활용:</p>
<pre><code class="language-mlir">scf.parallel (%i) = (0) to (%n) step (1) {
  %elem = load %lst[%i]
  %result = apply %f(%elem)
  store %result, %output[%i]
}
</code></pre>
<p><strong>6. Constant Folding</strong></p>
<p>컴파일 시간에 계산:</p>
<pre><code class="language-fsharp">// Before
let result = sum [1, 2, 3, 4, 5]

// After constant folding
let result = 15  // Computed at compile time
</code></pre>
<p>이러한 최적화는 MLIR의 <strong>transformation passes</strong>로 구현되며, Phase 7에서 자세히 다룬다.</p>
<h3 id="congratulations"><a class="header" href="#congratulations">Congratulations!</a></h3>
<p><strong>Phase 6 완료를 축하한다!</strong></p>
<p>이제 여러분은:</p>
<ul>
<li>✓ 완전한 함수형 프로그래밍 언어를 컴파일할 수 있다</li>
<li>✓ 리스트, 패턴 매칭, 고차 함수를 지원한다</li>
<li>✓ Multi-stage lowering pipeline을 이해한다</li>
<li>✓ End-to-end 컴파일 (source to machine code)을 할 수 있다</li>
<li>✓ 성능 특성과 최적화 기회를 안다</li>
</ul>
<p><strong>다음 단계:</strong> Phase 7 (Optimization)에서 더 빠르고 효율적인 코드 생성을 배운다.</p>
<p>Happy functional programming! 🎉</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="appendix-커스텀-mlir-dialect-등록"><a class="header" href="#appendix-커스텀-mlir-dialect-등록">Appendix: 커스텀 MLIR Dialect 등록</a></h1>
<h2 id="소개-21"><a class="header" href="#소개-21">소개</a></h2>
<p>Chapter 01-05에서는 MLIR의 빌트인 dialect를 사용했다:</p>
<ul>
<li><code>arith</code>: 산술 연산</li>
<li><code>func</code>: 함수 정의와 호출</li>
<li><code>scf</code>: 구조적 제어 흐름 (if/while)</li>
<li><code>llvm</code>: LLVM IR 타입과 operation</li>
</ul>
<p>이 dialect들은 강력하지만 범용적이다. FunLang과 같은 도메인별 언어의 경우 언어의 의미를 직접 표현하는 <strong>커스텀 dialect</strong>가 유용하다.</p>
<p>예를 들어 FunLang 클로저를 고려해 본다:</p>
<pre><code class="language-fsharp">let make_adder x =
    fun y -&gt; x + y
</code></pre>
<p>빌트인 dialect만 사용하면 클로저를 즉시 struct, 함수 포인터, 환경 캡처로 낮춰야 한다. 하지만 커스텀 dialect를 사용하면 이렇게 표현할 수 있다:</p>
<pre><code class="language-mlir">%closure = funlang.make_closure @lambda_body, %x : (!funlang.closure)
%result = funlang.apply %closure, %y : (i32)
</code></pre>
<p>높은 수준에서 의미가 명확하다. 그런 다음 낮추기 pass에서 구현 세부사항 (struct 레이아웃, malloc 호출 등)으로 점진적으로 변환한다.</p>
<p>이 appendix는 다음을 다룬다:</p>
<ol>
<li>커스텀 dialect를 C++에서 정의하는 방법</li>
<li>C API shim으로 F#에 노출하는 방법</li>
<li>Phase 5에서 사용할 아키텍처</li>
</ol>
<blockquote>
<p><strong>아키텍처 노트:</strong> 커스텀 dialect 등록은 Phase 5의 주제다. 이 appendix는 미리 보기와 기술적 기초를 제공한다.</p>
</blockquote>
<h2 id="c-api가-커스텀-dialect를-등록할-수-없는-이유"><a class="header" href="#c-api가-커스텀-dialect를-등록할-수-없는-이유">C API가 커스텀 Dialect를 등록할 수 없는 이유</a></h2>
<p>MLIR C API (<code>mlir-c/IR.h</code>)는 빌트인 dialect를 <strong>로드</strong>하는 함수를 제공한다:</p>
<pre><code class="language-c">// C API에 있음 - 빌트인 dialect 로드
MlirDialectHandle mlirGetDialectHandle__arith__();
void mlirDialectHandleRegisterDialect(MlirDialectHandle handle, MlirContext ctx);
</code></pre>
<p>하지만 <strong>새</strong> dialect를 <strong>정의</strong>하는 함수는 없다. 커스텀 dialect 정의는 C++ 코드를 요구한다:</p>
<pre><code class="language-cpp">// C++만 가능 - 새 dialect 정의
class FunLangDialect : public mlir::Dialect {
public:
  FunLangDialect(mlir::MLIRContext *context);
  static constexpr llvm::StringLiteral getDialectNamespace() {
    return llvm::StringLiteral("funlang");
  }
  // ... operation, type, attribute 정의 ...
};
</code></pre>
<p><strong>왜 C API에 없나?</strong></p>
<p>Dialect 정의는 C++ 클래스 상속, 템플릿, TableGen 생성 코드를 사용한다. 이것들은 C FFI 경계를 넘을 수 없다. C API는 <strong>이미 정의된</strong> dialect의 핸들만 다룰 수 있다.</p>
<p><strong>해결책:</strong> C++에서 dialect를 정의하고 등록을 위한 <strong>C API shim</strong>을 작성한다. F#은 이 shim을 P/Invoke로 호출한다.</p>
<h2 id="c-래퍼-접근법"><a class="header" href="#c-래퍼-접근법">C++ 래퍼 접근법</a></h2>
<p>아키텍처:</p>
<pre><code>┌─────────────────────────────────────────┐
│ F# Compiler (Compiler.fs)              │
│                                         │
│ ctx.LoadCustomDialect("funlang")        │
└────────────────┬────────────────────────┘
                 │ P/Invoke
                 ▼
┌─────────────────────────────────────────┐
│ C API Shim (funlang_dialect.c)         │
│                                         │
│ void funlangRegisterDialect(MlirContext)│
└────────────────┬────────────────────────┘
                 │ Call C++ API
                 ▼
┌─────────────────────────────────────────┐
│ C++ Dialect (FunLangDialect.cpp)       │
│                                         │
│ class FunLangDialect : public Dialect { │
│   // operation, type 정의               │
│ }                                       │
└─────────────────────────────────────────┘
</code></pre>
<p>C++ dialect을 공유 라이브러리 (<code>libFunLangDialect.so</code>)로 컴파일하고 F#이 로드한다.</p>
<h2 id="최소-커스텀-dialect-in-c"><a class="header" href="#최소-커스텀-dialect-in-c">최소 커스텀 Dialect in C++</a></h2>
<p>C++ 파일 <code>funlang_dialect.cpp</code>를 만든다:</p>
<pre><code class="language-cpp">// funlang_dialect.cpp - 최소 FunLang MLIR Dialect
#include "mlir/IR/Dialect.h"
#include "mlir/IR/MLIRContext.h"
#include "mlir/IR/Builders.h"
#include "mlir/IR/DialectRegistry.h"
#include "mlir-c/IR.h"

namespace mlir {
namespace funlang {

/// FunLang Dialect 정의
class FunLangDialect : public Dialect {
public:
  /// Context에 FunLang dialect 등록
  explicit FunLangDialect(MLIRContext *context)
      : Dialect(getDialectNamespace(), context,
                mlir::TypeID::get&lt;FunLangDialect&gt;()) {
    // 여기서 operation, type, attribute를 등록할 것
    // Phase 5에서 구현
  }

  /// Dialect 네임스페이스 반환 ("funlang")
  static constexpr llvm::StringLiteral getDialectNamespace() {
    return llvm::StringLiteral("funlang");
  }
};

} // namespace funlang
} // namespace mlir

// C API shim - F#에서 호출 가능
extern "C" {

/// FunLang dialect를 MLIR context에 등록
void funlangRegisterDialect(MlirContext ctx) {
  mlir::MLIRContext *context = unwrap(ctx);
  mlir::DialectRegistry registry;
  registry.insert&lt;mlir::funlang::FunLangDialect&gt;();
  context-&gt;appendDialectRegistry(registry);
  context-&gt;loadDialect&lt;mlir::funlang::FunLangDialect&gt;();
}

} // extern "C"
</code></pre>
<p><strong>Line-by-line 설명:</strong></p>
<ol>
<li><strong><code>#include "mlir/IR/Dialect.h"</code></strong>: MLIR dialect 기본 클래스</li>
<li><strong><code>namespace mlir::funlang</code></strong>: 네임스페이스 충돌 방지</li>
<li><strong><code>class FunLangDialect : public Dialect</code></strong>: 커스텀 dialect 정의. <code>Dialect</code>는 MLIR 기본 클래스</li>
<li><strong><code>explicit FunLangDialect(MLIRContext *context)</code></strong>: 생성자. Context에 dialect 등록</li>
<li><strong><code>getDialectNamespace()</code></strong>: Dialect 이름 반환. MLIR IR에서 <code>funlang.operation_name</code>으로 사용됨</li>
<li><strong><code>extern "C" { ... }</code></strong>: C linkage - name mangling 방지, F# P/Invoke 가능</li>
<li><strong><code>void funlangRegisterDialect(MlirContext ctx)</code></strong>: C API shim. F#이 호출할 함수</li>
<li><strong><code>unwrap(ctx)</code></strong>: MLIR C API 유틸리티 - <code>MlirContext</code> (불투명 핸들)을 C++ <code>MLIRContext*</code>로 변환</li>
<li><strong><code>registry.insert&lt;FunLangDialect&gt;()</code></strong>: Registry에 dialect 추가</li>
<li><strong><code>context-&gt;appendDialectRegistry(registry)</code></strong>: Context에 registry 추가</li>
<li><strong><code>context-&gt;loadDialect&lt;FunLangDialect&gt;()</code></strong>: Dialect 즉시 로드 (lazy loading 아님)</li>
</ol>
<blockquote>
<p><strong>설계 결정:</strong> 이 dialect는 아직 operation이나 type을 정의하지 않는다. Phase 5에서 <code>funlang.closure</code>, <code>funlang.apply</code> 같은 operation을 추가할 것이다.</p>
</blockquote>
<h2 id="c-라이브러리-빌드"><a class="header" href="#c-라이브러리-빌드">C++ 라이브러리 빌드</a></h2>
<p><code>CMakeLists.txt</code>를 작성한다:</p>
<pre><code class="language-cmake"># CMakeLists.txt - FunLang Dialect 빌드
cmake_minimum_required(VERSION 3.20)
project(FunLangDialect)

# LLVM/MLIR 찾기
find_package(MLIR REQUIRED CONFIG)
list(APPEND CMAKE_MODULE_PATH "${MLIR_CMAKE_DIR}")
include(AddLLVM)
include(AddMLIR)

# Include 디렉토리
include_directories(${MLIR_INCLUDE_DIRS})

# FunLangDialect 공유 라이브러리
add_library(FunLangDialect SHARED
  funlang_dialect.cpp
)

# MLIR 라이브러리 링크
target_link_libraries(FunLangDialect
  PRIVATE
    MLIRIR
    MLIRDialect
)

# 설치
install(TARGETS FunLangDialect
  LIBRARY DESTINATION lib
)
</code></pre>
<p><strong>빌드:</strong></p>
<pre><code class="language-bash"># CMake 설정
cmake -S . -B build \
  -DMLIR_DIR=$HOME/mlir-install/lib/cmake/mlir \
  -DCMAKE_BUILD_TYPE=Release

# 빌드
cmake --build build

# 설치
cmake --build build --target install
</code></pre>
<p>이렇게 하면 <code>libFunLangDialect.so</code> (Linux), <code>libFunLangDialect.dylib</code> (macOS), 또는 <code>FunLangDialect.dll</code> (Windows)가 생성된다.</p>
<h2 id="f에서-사용"><a class="header" href="#f에서-사용">F#에서 사용</a></h2>
<p><code>MlirBindings.fs</code>에 P/Invoke 선언 추가:</p>
<pre><code class="language-fsharp">// MlirBindings.fs에 추가

module MlirNative =
    // ... 기존 바인딩 ...

    /// FunLang 커스텀 dialect 등록 (C++ shim 호출)
    [&lt;DllImport("FunLangDialect", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void funlangRegisterDialect(MlirContext ctx)
</code></pre>
<p><code>MlirWrapper.fs</code>의 <code>Context</code> 클래스에 메서드 추가:</p>
<pre><code class="language-fsharp">type Context() =
    let mutable handle = MlirNative.mlirContextCreate()
    let mutable disposed = false

    member _.Handle = handle

    /// 빌트인 dialect 로드
    member _.LoadDialect(dialect: string) =
        if disposed then
            raise (ObjectDisposedException("Context"))

        MlirStringRef.WithString dialect (fun nameRef -&gt;
            MlirNative.mlirContextGetOrLoadDialect(handle, nameRef)
            |&gt; ignore)

    /// 커스텀 FunLang dialect 로드
    member _.LoadFunLangDialect() =
        if disposed then
            raise (ObjectDisposedException("Context"))

        MlirNative.funlangRegisterDialect(handle)

    // ... IDisposable 구현 ...
</code></pre>
<p><strong>사용:</strong></p>
<pre><code class="language-fsharp">use ctx = new Context()
ctx.LoadDialect("arith")
ctx.LoadDialect("func")
ctx.LoadFunLangDialect()  // 커스텀 dialect 로드

// 이제 funlang.* operation 사용 가능 (Phase 5에서 정의)
</code></pre>
<h2 id="커스텀-operation-추가-미리-보기"><a class="header" href="#커스텀-operation-추가-미리-보기">커스텀 Operation 추가 (미리 보기)</a></h2>
<p>Phase 5에서 FunLang dialect에 operation을 추가한다. 미리 보기:</p>
<p><strong>TableGen 정의 (FunLangOps.td):</strong></p>
<pre><code class="language-tablegen">// FunLangOps.td - FunLang operation 정의 (TableGen)
include "mlir/IR/OpBase.td"

def FunLang_Dialect : Dialect {
  let name = "funlang";
  let cppNamespace = "::mlir::funlang";
}

class FunLang_Op&lt;string mnemonic, list&lt;Trait&gt; traits = []&gt;
    : Op&lt;FunLang_Dialect, mnemonic, traits&gt;;

// funlang.make_closure operation
def FunLang_MakeClosureOp : FunLang_Op&lt;"make_closure"&gt; {
  let summary = "Create a closure capturing environment";
  let arguments = (ins
    FlatSymbolRefAttr:$callee,
    Variadic&lt;AnyType&gt;:$captured
  );
  let results = (outs AnyType:$result);
}

// funlang.apply operation
def FunLang_ApplyOp : FunLang_Op&lt;"apply"&gt; {
  let summary = "Apply a closure to arguments";
  let arguments = (ins
    AnyType:$closure,
    Variadic&lt;AnyType&gt;:$args
  );
  let results = (outs AnyType:$result);
}
</code></pre>
<p><strong>생성된 C++ 코드:</strong></p>
<p>TableGen은 위 정의에서 C++ 클래스를 생성한다:</p>
<pre><code class="language-cpp">// 생성됨: FunLangOps.h.inc
class MakeClosureOp : public Op&lt;MakeClosureOp, /* traits */&gt; {
public:
  static StringRef getOperationName() { return "funlang.make_closure"; }
  // ... getter/setter, verifier ...
};

class ApplyOp : public Op&lt;ApplyOp, /* traits */&gt; {
public:
  static StringRef getOperationName() { return "funlang.apply"; }
  // ... getter/setter, verifier ...
};
</code></pre>
<p><strong>Dialect에 등록:</strong></p>
<pre><code class="language-cpp">// funlang_dialect.cpp 업데이트
FunLangDialect::FunLangDialect(MLIRContext *context)
    : Dialect(/*...*/) {
  // Operation 등록
  addOperations&lt;
    MakeClosureOp,
    ApplyOp
  &gt;();
}
</code></pre>
<p><strong>F#에서 사용:</strong></p>
<pre><code class="language-fsharp">// 커스텀 operation 생성 (Phase 5에서 OpBuilder 확장)
let closureOp = builder.CreateMakeClosure("lambda_body", [| xValue |], loc)
let resultOp = builder.CreateApply(closureOp, [| yValue |], loc)
</code></pre>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">%closure = funlang.make_closure @lambda_body, %x : (!funlang.closure)
%result = funlang.apply %closure, %y : (i32)
</code></pre>
<p>Phase 5에서 이 operation들을 <code>scf</code>, <code>memref</code>, <code>llvm</code> dialect로 낮추는 pass를 작성할 것이다.</p>
<h2 id="커스텀-dialect를-사용할-때-vs-빌트인-사용"><a class="header" href="#커스텀-dialect를-사용할-때-vs-빌트인-사용">커스텀 Dialect를 사용할 때 vs. 빌트인 사용</a></h2>
<p><strong>커스텀 dialect를 사용해야 하는 경우:</strong></p>
<ol>
<li><strong>도메인별 의미</strong>: FunLang 클로저, 패턴 매칭, 리스트 cons는 커스텀 operation으로 더 명확하다</li>
<li><strong>점진적 낮추기</strong>: 높은 수준에서 시작하여 여러 pass를 통해 낮춘다</li>
<li><strong>최적화 기회</strong>: 커스텀 operation의 패턴 매칭 최적화 작성 가능</li>
<li><strong>가독성</strong>: <code>funlang.make_closure</code>가 15줄의 <code>llvm.call</code>, <code>memref.alloc</code>, <code>memref.store</code>보다 이해하기 쉽다</li>
</ol>
<p><strong>빌트인 dialect를 사용해야 하는 경우:</strong></p>
<ol>
<li><strong>단순한 언어</strong>: 산술과 함수만 있으면 <code>arith</code> + <code>func</code>로 충분하다</li>
<li><strong>빠른 프로토타이핑</strong>: 커스텀 dialect는 C++ 빌드 시스템이 필요하다</li>
<li><strong>MLIR 학습</strong>: 빌트인 dialect로 시작하면 개념을 빠르게 배울 수 있다</li>
</ol>
<p><strong>FunLang의 경우:</strong> Phase 1-4는 빌트인 dialect를 사용한다. Phase 5는 클로저와 고급 기능을 위해 커스텀 dialect를 도입한다.</p>
<h2 id="요약-2"><a class="header" href="#요약-2">요약</a></h2>
<p>이 appendix에서 다음을 배웠다:</p>
<ol>
<li><strong>C API 제한</strong>: MLIR C API는 커스텀 dialect 정의를 지원하지 않는다 - C++ 필요</li>
<li><strong>C++ 래퍼 패턴</strong>: C++에서 dialect를 정의하고 <code>extern "C"</code> shim으로 노출</li>
<li><strong>F# 통합</strong>: P/Invoke로 shim 호출, 빌트인 dialect처럼 사용</li>
<li><strong>TableGen</strong>: Operation 정의를 위한 MLIR의 코드 생성 도구</li>
<li><strong>점진적 낮추기</strong>: 커스텀 operation → 표준 dialect → LLVM</li>
</ol>
<p><strong>Phase 5 미리 보기:</strong></p>
<ul>
<li>FunLang dialect 정의 (<code>funlang.closure</code>, <code>funlang.apply</code>, <code>funlang.match</code>)</li>
<li>TableGen으로 operation 생성</li>
<li>낮추기 pass 작성 (pattern rewrite 사용)</li>
<li>이전 chapter들을 커스텀 dialect 사용으로 리팩터링</li>
</ul>
<p><strong>리소스:</strong></p>
<ul>
<li><a href="https://mlir.llvm.org/docs/DefiningDialects/">MLIR Dialect 정의 가이드</a></li>
<li><a href="https://mlir.llvm.org/docs/OpDefinitions/">MLIR TableGen 참조</a></li>
<li><a href="https://mlir.llvm.org/docs/CAPI/">MLIR C API 문서</a></li>
</ul>
<hr>
<p><strong>이것으로 Phase 1이 완료되었다!</strong> Chapter 00-05와 이 appendix를 통해 MLIR 기반 컴파일러 구축을 위한 완전한 기초를 갖추었다. Phase 2에서 FunLang의 더 많은 기능을 컴파일하기 시작할 것이다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
