<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>LangBackend Tutorial</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="MLIR 기반 FunLang 컴파일러 백엔드 튜토리얼">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-d8498b13.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-1fa1ad07.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">LangBackend Tutorial</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/ohama/LangBackend" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="langbackend-tutorial"><a class="header" href="#langbackend-tutorial">LangBackend Tutorial</a></h1>
<p>MLIR 기반 FunLang 컴파일러 백엔드 튜토리얼입니다.</p>
<p>FunLang의 Typed AST를 MLIR을 거쳐 네이티브 바이너리로 컴파일하는 과정을 단계별로 다룹니다. 각 챕터마다 그때까지 다룬 기능이 모두 동작하는 컴파일러를 만들 수 있습니다.</p>
<h2 id="시작하기"><a class="header" href="#시작하기">시작하기</a></h2>
<p><a href="#chapter-00-사전-준비">Chapter 00: 사전 준비</a>부터 시작하세요.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-00-사전-준비"><a class="header" href="#chapter-00-사전-준비">Chapter 00: 사전 준비</a></h1>
<h2 id="소개"><a class="header" href="#소개">소개</a></h2>
<p>LangBackend 튜토리얼 시리즈에 오신 것을 환영한다. 여러분은 LangTutorial을 완료하고 완전히 동작하는 FunLang 인터프리터를 구축했기 때문에 이 튜토리얼을 시작하게 되었을 것이다. 이미 파서, Hindley-Milner 타입 추론을 갖춘 타입 체커, 그리고 트리 워킹 평가기를 갖추고 있다. 이제 FunLang을 다음 단계로 끌어올릴 차례다: 네이티브 머신 코드로 컴파일하는 것이다.</p>
<p>이 튜토리얼 시리즈에서는 타입이 지정된 FunLang AST를 실행 가능한 바이너리로 변환하는 MLIR 기반 컴파일러 백엔드를 구축하는 방법을 배운다. MLIR(Multi-Level Intermediate Representation)은 LLVM 프로젝트에서 제공하는 현대적인 컴파일러 프레임워크로, 구조화된 IR 연산, 타입 안전성, 플러그인 가능한 dialect, 그리고 고수준 의미론에서 머신 코드까지의 점진적 lowering 등 필요한 인프라를 제공한다.</p>
<p>이 장에서는 필수 사전 준비 설정을 다룬다: C API를 활성화하여 LLVM/MLIR을 소스에서 빌드하고, F# 개발을 위한 .NET SDK를 설치하며, 두 시스템이 통신할 수 있도록 환경을 구성하는 것이다. 이러한 기초가 없으면 나머지 튜토리얼을 진행할 수 없다.</p>
<h2 id="시스템-요구-사항"><a class="header" href="#시스템-요구-사항">시스템 요구 사항</a></h2>
<p>시작하기 전에 시스템이 다음 요구 사항을 충족하는지 확인한다:</p>
<ul>
<li><strong>디스크 공간:</strong> ~30 GB (LLVM 소스 + 빌드 산출물 + 설치)</li>
<li><strong>RAM:</strong> 16 GB 권장 (빌드 병렬 처리를 줄이면 최소 8 GB)</li>
<li><strong>빌드 시간:</strong> 최신 하드웨어 기준 30-60분 (4코어 이상, SSD)</li>
<li><strong>지원 플랫폼:</strong>
<ul>
<li>Linux (Ubuntu 22.04+, Fedora 38+ 또는 이에 상응하는 배포판)</li>
<li>macOS (13 Ventura 이상, Intel 및 Apple Silicon 모두 지원)</li>
<li>Windows (Ubuntu 22.04+가 설치된 WSL2 권장; 네이티브 MSVC 빌드도 가능하지만 이 튜토리얼에서는 다루지 않는다)</li>
</ul>
</li>
</ul>
<h2 id="c-api를-포함한-llvmmlir-빌드"><a class="header" href="#c-api를-포함한-llvmmlir-빌드">C API를 포함한 LLVM/MLIR 빌드</a></h2>
<p>MLIR은 LLVM 프로젝트의 일부이다. MLIR 팀은 F#과 같은 비-C++ 언어가 MLIR 인프라와 상호작용할 수 있도록 안정적인 C API를 제공한다. 이 C API는 기본적으로 빌드되지 않으므로 CMake 구성 단계에서 명시적으로 활성화해야 한다.</p>
<h3 id="빌드-의존성-설치"><a class="header" href="#빌드-의존성-설치">빌드 의존성 설치</a></h3>
<h4 id="linux-ubuntudebian"><a class="header" href="#linux-ubuntudebian">Linux (Ubuntu/Debian)</a></h4>
<pre><code class="language-bash">sudo apt update
sudo apt install -y \
  build-essential \
  cmake \
  ninja-build \
  clang \
  lld \
  python3 \
  git
</code></pre>
<h4 id="macos"><a class="header" href="#macos">macOS</a></h4>
<p>먼저 Xcode Command Line Tools가 설치되어 있지 않다면 설치한다:</p>
<pre><code class="language-bash">xcode-select --install
</code></pre>
<p>그런 다음 Homebrew를 통해 CMake와 Ninja를 설치한다:</p>
<pre><code class="language-bash">brew install cmake ninja
</code></pre>
<p>macOS에는 이미 Clang이 포함되어 있으므로 빌드할 준비가 된 것이다.</p>
<h4 id="windows-wsl2"><a class="header" href="#windows-wsl2">Windows (WSL2)</a></h4>
<p>Ubuntu 22.04가 설치된 Windows Subsystem for Linux 2 (WSL2)를 사용하는 것을 권장한다. <a href="https://learn.microsoft.com/en-us/windows/wsl/install">WSL2 설치 가이드</a>를 따른 후, 위의 Linux (Ubuntu) 의존성 설치 단계를 사용한다.</p>
<blockquote>
<p><strong>참고:</strong> MSVC를 사용한 네이티브 Windows 빌드도 가능하지만 다른 CMake 구성이 필요하며 이 튜토리얼의 범위를 벗어난다. WSL2는 Windows에서 일관된 Linux 환경을 제공한다.</p>
</blockquote>
<h3 id="llvm-클론"><a class="header" href="#llvm-클론">LLVM 클론</a></h3>
<p>LLVM monorepo를 LLVM 19.x 안정 릴리스 브랜치에서 클론한다. <code>--depth 1</code>을 사용하면 최신 커밋만 가져와 디스크 공간과 다운로드 시간을 절약할 수 있다:</p>
<pre><code class="language-bash">cd $HOME
git clone --depth 1 --branch release/19.x https://github.com/llvm/llvm-project.git
cd llvm-project
</code></pre>
<p>shallow clone 후 저장소 크기는 약 2 GB이다.</p>
<h3 id="빌드-구성"><a class="header" href="#빌드-구성">빌드 구성</a></h3>
<p>CMake 구성 단계는 매우 중요하다. 각 플래그는 특정 목적을 가지고 있다:</p>
<pre><code class="language-bash">cmake -S llvm -B build -G Ninja \
  -DCMAKE_BUILD_TYPE=Release \
  -DLLVM_ENABLE_PROJECTS=mlir \
  -DMLIR_BUILD_MLIR_C_DYLIB=ON \
  -DLLVM_TARGETS_TO_BUILD="X86;AArch64" \
  -DCMAKE_INSTALL_PREFIX=$HOME/mlir-install
</code></pre>
<p><strong>플래그 설명:</strong></p>
<ul>
<li><code>-S llvm</code>: 소스 디렉터리 (저장소 내의 <code>llvm</code> 하위 디렉터리)</li>
<li><code>-B build</code>: 빌드 디렉터리 (out-of-tree 빌드 권장)</li>
<li><code>-G Ninja</code>: Ninja 빌드 시스템 사용 (Make보다 빠름)</li>
<li><code>-DCMAKE_BUILD_TYPE=Release</code>: 디버그 심볼 없이 최적화된 빌드 (크기가 훨씬 작고 빠름)</li>
<li><code>-DLLVM_ENABLE_PROJECTS=mlir</code>: LLVM과 함께 MLIR 빌드 (MLIR은 LLVM에 의존)</li>
<li><strong><code>-DMLIR_BUILD_MLIR_C_DYLIB=ON</code></strong>: <strong>핵심 플래그</strong> — MLIR C API를 노출하는 <code>libMLIR-C</code> 공유 라이브러리를 빌드한다</li>
<li><code>-DLLVM_TARGETS_TO_BUILD="X86;AArch64"</code>: x86-64 및 ARM64 백엔드만 빌드 (빌드 시간 단축; 필요시 다른 타겟 추가)</li>
<li><code>-DCMAKE_INSTALL_PREFIX=$HOME/mlir-install</code>: 설치 위치 (쓰기 가능한 디렉터리 사용)</li>
</ul>
<p>CMake 구성은 1-2분 내에 완료된다. 다음과 같은 출력이 표시된다:</p>
<pre><code>-- The C compiler identification is GNU 11.4.0
-- The CXX compiler identification is GNU 11.4.0
...
-- Build files have been written to: /home/user/llvm-project/build
</code></pre>
<h3 id="빌드-및-설치"><a class="header" href="#빌드-및-설치">빌드 및 설치</a></h3>
<p>사용 가능한 모든 CPU 코어를 활용하여 MLIR을 빌드한다 (Ninja는 자동으로 병렬 처리를 사용한다):</p>
<pre><code class="language-bash">cmake --build build --target install
</code></pre>
<p>이 단계는 하드웨어에 따라 30-60분이 소요된다. 수천 줄의 컴파일 로그가 스크롤된다. 빌드 중 메모리가 부족해지면 (시스템이 응답하지 않는 경우), 빌드를 중지하고 (Ctrl+C) 병렬 처리를 줄여 다시 시작한다:</p>
<pre><code class="language-bash">cmake --build build --target install -- -j2
</code></pre>
<p><code>-j2</code> 플래그는 Ninja의 병렬 컴파일 작업을 2개로 제한하여, 빌드 시간이 느려지는 대신 최대 메모리 사용량을 줄인다.</p>
<p>빌드가 완료되면 다음과 같이 표시된다:</p>
<pre><code>[100%] Built target install
</code></pre>
<h3 id="설치-확인"><a class="header" href="#설치-확인">설치 확인</a></h3>
<p>MLIR C API 공유 라이브러리가 설치되었는지 확인한다:</p>
<pre><code class="language-bash">ls -lh $HOME/mlir-install/lib/libMLIR-C*
</code></pre>
<p><strong>예상 출력:</strong></p>
<ul>
<li><strong>Linux:</strong> <code>libMLIR-C.so</code> 및 <code>libMLIR-C.so.19</code> (버전이 지정된 라이브러리에 대한 심볼릭 링크)</li>
<li><strong>macOS:</strong> <code>libMLIR-C.19.dylib</code> 및 <code>libMLIR-C.dylib</code> (심볼릭 링크)</li>
<li><strong>Windows (WSL):</strong> Linux와 동일</li>
</ul>
<p><code>No such file or directory</code>가 표시되면 CMake 구성에 <code>-DMLIR_BUILD_MLIR_C_DYLIB=ON</code>이 포함되어 있는지 확인하고 빌드 단계를 다시 실행한다.</p>
<p><code>mlir-opt</code> 도구도 설치되어 있어야 한다:</p>
<pre><code class="language-bash">$HOME/mlir-install/bin/mlir-opt --version
</code></pre>
<p>예상 출력: <code>MLIR (http://mlir.llvm.org) version 19.1.x</code></p>
<h2 id="net-sdk-설치"><a class="header" href="#net-sdk-설치">.NET SDK 설치</a></h2>
<p>FunLang의 컴파일러 백엔드는 F#으로 구현된다. F# 프로그램을 컴파일하고 실행하려면 .NET SDK가 필요하다.</p>
<h3 id="linux-ubuntudebian-1"><a class="header" href="#linux-ubuntudebian-1">Linux (Ubuntu/Debian)</a></h3>
<p>.NET 8.0 SDK (2026년 11월까지 지원되는 LTS 릴리스)를 설치한다:</p>
<pre><code class="language-bash">wget https://dot.net/v1/dotnet-install.sh -O dotnet-install.sh
chmod +x dotnet-install.sh
./dotnet-install.sh --channel 8.0
</code></pre>
<p>스크립트는 .NET을 <code>$HOME/.dotnet</code>에 설치한다. PATH에 추가한다:</p>
<pre><code class="language-bash">echo 'export PATH="$HOME/.dotnet:$PATH"' &gt;&gt; ~/.bashrc
source ~/.bashrc
</code></pre>
<h3 id="macos-1"><a class="header" href="#macos-1">macOS</a></h3>
<p><a href="https://dotnet.microsoft.com/download/dotnet/8.0">https://dotnet.microsoft.com/download/dotnet/8.0</a>에서 .NET 8.0 SDK 설치 프로그램을 다운로드하여 설치하거나, Homebrew를 사용한다:</p>
<pre><code class="language-bash">brew install --cask dotnet-sdk
</code></pre>
<h3 id="windows-wsl2-1"><a class="header" href="#windows-wsl2-1">Windows (WSL2)</a></h3>
<p>WSL2 Ubuntu 환경에서 위의 Linux 설치 단계를 따른다.</p>
<h3 id="net-설치-확인"><a class="header" href="#net-설치-확인">.NET 설치 확인</a></h3>
<p>.NET 버전을 확인한다:</p>
<pre><code class="language-bash">dotnet --version
</code></pre>
<p>예상 출력: <code>8.0.x</code></p>
<p>F# 컴파일러가 사용 가능한지 확인한다:</p>
<pre><code class="language-bash">dotnet fsi --version
</code></pre>
<p>예상 출력: <code>Microsoft (R) F# Interactive version 12.8.x.0</code></p>
<p>모든 것이 정상적으로 작동하는지 확인하기 위해 테스트 F# 프로젝트를 생성한다:</p>
<pre><code class="language-bash">dotnet new console -lang F# -o test-fsharp
cd test-fsharp
dotnet run
</code></pre>
<p>다음과 같이 출력되어야 한다:</p>
<pre><code>Hello from F#
</code></pre>
<h2 id="라이브러리-검색-경로-설정"><a class="header" href="#라이브러리-검색-경로-설정">라이브러리 검색 경로 설정</a></h2>
<p>F# 프로그램이 P/Invoke를 통해 MLIR C API 함수를 호출할 때, .NET 런타임은 런타임에 <code>libMLIR-C</code> 공유 라이브러리를 찾을 수 있어야 한다. 표준적인 방법은 MLIR 설치 라이브러리 디렉터리를 시스템의 라이브러리 검색 경로에 추가하는 것이다.</p>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<p>MLIR 라이브러리 디렉터리를 <code>LD_LIBRARY_PATH</code>에 추가한다:</p>
<pre><code class="language-bash">echo 'export LD_LIBRARY_PATH="$HOME/mlir-install/lib:$LD_LIBRARY_PATH"' &gt;&gt; ~/.bashrc
source ~/.bashrc
</code></pre>
<p>라이브러리가 검색 가능한지 확인한다:</p>
<pre><code class="language-bash">ldconfig -p | grep MLIR
</code></pre>
<p><code>libMLIR-C.so</code>에 대한 항목이 표시되어야 한다.</p>
<h3 id="macos-2"><a class="header" href="#macos-2">macOS</a></h3>
<p>MLIR 라이브러리 디렉터리를 <code>DYLD_LIBRARY_PATH</code>에 추가한다:</p>
<pre><code class="language-bash">echo 'export DYLD_LIBRARY_PATH="$HOME/mlir-install/lib:$DYLD_LIBRARY_PATH"' &gt;&gt; ~/.zshrc
source ~/.zshrc
</code></pre>
<blockquote>
<p><strong>참고:</strong> macOS Catalina 이후 macOS는 기본적으로 zsh를 사용한다. bash를 사용하고 있다면 <code>~/.bashrc</code>를 수정한다.</p>
</blockquote>
<p>라이브러리가 존재하는지 확인한다:</p>
<pre><code class="language-bash">ls -l $HOME/mlir-install/lib/libMLIR-C.dylib
</code></pre>
<h3 id="windows-wsl2-2"><a class="header" href="#windows-wsl2-2">Windows (WSL2)</a></h3>
<p>WSL2에서 위의 Linux 지침을 따른다.</p>
<h3 id="대안-프로젝트별-구성"><a class="header" href="#대안-프로젝트별-구성">대안: 프로젝트별 구성</a></h3>
<p>전역 환경 변수를 설정하는 대신, F# 애플리케이션을 실행할 때 라이브러리 경로를 지정할 수 있다:</p>
<pre><code class="language-bash">LD_LIBRARY_PATH=$HOME/mlir-install/lib dotnet run
</code></pre>
<p>이 방법은 셸 프로파일을 수정하지 않고 테스트할 때 유용하다.</p>
<h2 id="자주-발생하는-문제-해결"><a class="header" href="#자주-발생하는-문제-해결">자주 발생하는 문제 해결</a></h2>
<h3 id="빌드-중-메모리-부족"><a class="header" href="#빌드-중-메모리-부족">빌드 중 메모리 부족</a></h3>
<p><strong>증상:</strong> MLIR 빌드 중 시스템이 응답하지 않음; 스왑 사용량이 100%.</p>
<p><strong>해결 방법:</strong> 빌드 병렬 처리를 줄인다:</p>
<pre><code class="language-bash">cmake --build build --target install -- -j2
</code></pre>
<p>RAM이 8 GB인 시스템에서는 <code>-j1</code>이 필요할 수 있다.</p>
<h3 id="mlir-c-library-not-found-런타임-오류"><a class="header" href="#mlir-c-library-not-found-런타임-오류">“MLIR-C library not found” 런타임 오류</a></h3>
<p><strong>증상:</strong> F# 프로그램이 <code>DllNotFoundException: Unable to load shared library 'MLIR-C'</code>로 실패한다.</p>
<p><strong>해결 방법:</strong> 라이브러리 검색 경로가 구성되어 있는지 확인한다:</p>
<pre><code class="language-bash"># Linux
echo $LD_LIBRARY_PATH
# $HOME/mlir-install/lib이 포함되어 있어야 합니다

# macOS
echo $DYLD_LIBRARY_PATH
</code></pre>
<p>라이브러리 파일이 존재하는지 확인한다:</p>
<pre><code class="language-bash">ls $HOME/mlir-install/lib/libMLIR-C*
</code></pre>
<p>파일이 없다면 <code>-DMLIR_BUILD_MLIR_C_DYLIB=ON</code>으로 다시 빌드한다.</p>
<h3 id="cmake-버전이-너무-오래됨"><a class="header" href="#cmake-버전이-너무-오래됨">CMake 버전이 너무 오래됨</a></h3>
<p><strong>증상:</strong> CMake 구성이 <code>CMake 3.20 or higher is required</code>로 실패한다.</p>
<p><strong>해결 방법:</strong> 최신 CMake를 설치한다:</p>
<pre><code class="language-bash"># Linux: 최신 CMake 바이너리 다운로드
wget https://github.com/Kitware/CMake/releases/download/v3.28.0/cmake-3.28.0-linux-x86_64.sh
sudo sh cmake-3.28.0-linux-x86_64.sh --prefix=/usr/local --skip-license

# macOS
brew upgrade cmake
</code></pre>
<h3 id="ninja-빌드-시스템-누락"><a class="header" href="#ninja-빌드-시스템-누락">Ninja 빌드 시스템 누락</a></h3>
<p><strong>증상:</strong> CMake 구성이 <code>Could not find Ninja</code>로 실패한다.</p>
<p><strong>해결 방법:</strong> Ninja를 설치하거나 (위의 “빌드 의존성 설치” 참조), 대신 Unix Makefiles를 사용한다 (더 느림):</p>
<pre><code class="language-bash">cmake -S llvm -B build -G "Unix Makefiles" \
  -DCMAKE_BUILD_TYPE=Release \
  -DLLVM_ENABLE_PROJECTS=mlir \
  -DMLIR_BUILD_MLIR_C_DYLIB=ON \
  -DLLVM_TARGETS_TO_BUILD="X86;AArch64" \
  -DCMAKE_INSTALL_PREFIX=$HOME/mlir-install

make -C build install -j$(nproc)
</code></pre>
<h3 id="디스크-공간-부족"><a class="header" href="#디스크-공간-부족">디스크 공간 부족</a></h3>
<p><strong>증상:</strong> 빌드가 <code>No space left on device</code>로 실패한다.</p>
<p><strong>해결 방법:</strong> LLVM 빌드에는 ~30 GB가 필요하다. 공간을 확보하거나 다른 파티션에서 빌드한다. 설치 후 <code>build</code> 디렉터리를 삭제하면 ~20 GB를 회수할 수 있다:</p>
<pre><code class="language-bash">rm -rf $HOME/llvm-project/build
</code></pre>
<h2 id="이-장에서-완료한-것"><a class="header" href="#이-장에서-완료한-것">이 장에서 완료한 것</a></h2>
<p>이 시점에서 다음 항목이 준비되어 있다:</p>
<ol>
<li><strong>LLVM/MLIR 설치 완료</strong> — <code>$HOME/mlir-install</code>에 C API 공유 라이브러리(<code>libMLIR-C.so</code>, <code>libMLIR-C.dylib</code>, 또는 <code>MLIR-C.dll</code>) 포함</li>
<li><strong>.NET 8.0 SDK</strong> — F# 컴파일러 및 런타임과 함께 설치 완료</li>
<li><strong>라이브러리 검색 경로 구성 완료</strong> — .NET이 런타임에 MLIR을 찾을 수 있도록 설정</li>
<li><strong>빌드 도구 검증 완료</strong> — 개발 준비 완료 (<code>mlir-opt</code>, <code>dotnet</code>)</li>
</ol>
<p>이제 MLIR과 상호작용하는 F# 코드를 작성할 준비가 되었다. 다음 장에서는 코드를 작성하기 전에 이해해야 할 핵심 MLIR 개념들을 살펴본다: dialect, operation, region, block, 그리고 SSA 형식이다.</p>
<h2 id="다음-장"><a class="header" href="#다음-장">다음 장</a></h2>
<p><a href="#chapter-01-mlir-입문">Chapter 01: MLIR 입문</a>으로 이동하여 MLIR IR의 기본 개념을 학습한다.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-01-mlir-입문"><a class="header" href="#chapter-01-mlir-입문">Chapter 01: MLIR 입문</a></h1>
<h2 id="소개-1"><a class="header" href="#소개-1">소개</a></h2>
<p>이전 챕터에서 LLVM/MLIR을 소스에서 빌드하고 .NET SDK를 설정했다. 필요한 도구는 모두 설치되었다. 하지만 MLIR을 생성하는 F# 코드를 작성하기 전에, MLIR이 무엇이고 프로그램을 어떻게 표현하는지 이해해야 한다.</p>
<p>MLIR은 전통적인 중간 표현(intermediate representation)과 다르다. 단순히 “하나의 IR“이 아니라, 서로 상호 운용할 수 있는 여러 IR(dialect이라고 부른다)을 구축하기 위한 프레임워크이다. 이 다단계(multi-level) 철학이 MLIR을 컴파일러 개발에 강력하게 만드는 핵심이다. 고수준 함수형 언어를 매우 저수준인 LLVM IR로 직접 변환하도록 강제하는 대신, MLIR은 언어의 의미론(semantics)을 필요한 만큼 보존하는 중간 표현을 정의한 다음, 단계적으로 점진적 하강(progressive lowering)할 수 있게 해준다.</p>
<p>FunLang의 컴파일 파이프라인은 다음과 같다:</p>
<pre><code>FunLang Typed AST
    ↓
High-Level MLIR (arith, func, scf dialects)
    ↓
Low-Level MLIR (LLVM dialect)
    ↓
LLVM IR
    ↓
Native Machine Code
</code></pre>
<p>이 챕터에서는 MLIR IR을 이해하기 위한 멘탈 모델을 제공한다. 다섯 가지 핵심 개념 — <strong>dialect</strong>, <strong>operation</strong>, <strong>region</strong>, <strong>block</strong>, 그리고 <strong>SSA form</strong> — 을 구체적인 예제를 통해 배운다. 챕터를 마치면 MLIR 텍스트 IR을 읽고, FunLang 프로그램이 MLIR 구조에 어떻게 매핑되는지 이해할 수 있을 것이다.</p>
<h2 id="mlir-ir-구조"><a class="header" href="#mlir-ir-구조">MLIR IR 구조</a></h2>
<p>완전한 MLIR 프로그램을 보면서 각 부분을 분석해 본다. 다음은 두 개의 32비트 정수를 더하는 간단한 함수이다:</p>
<pre><code class="language-mlir">module {
  func.func @add(%arg0: i32, %arg1: i32) -&gt; i32 {
    %result = arith.addi %arg0, %arg1 : i32
    return %result : i32
  }
}
</code></pre>
<p>한 줄씩 분석해 본다:</p>
<ul>
<li>
<p><strong><code>module { ... }</code></strong>: 모든 MLIR 프로그램은 module에 포함된다. module은 모든 코드를 담는 최상위 컨테이너로, C의 컴파일 단위(compilation unit)나 .NET의 어셈블리와 유사하다.</p>
</li>
<li>
<p><strong><code>func.func @add(...) -&gt; i32 { ... }</code></strong>: <code>func</code> dialect의 operation으로, <code>@add</code>라는 이름의 함수를 정의한다. <code>@</code> 접두사는 심볼(함수 이름)을 나타낸다. 이 함수는 두 개의 인자를 받아 <code>i32</code>(32비트 정수)를 반환한다.</p>
</li>
<li>
<p><strong><code>%arg0: i32, %arg1: i32</code></strong>: 함수 매개변수이다. 각 매개변수는 타입 어노테이션(<code>: i32</code>)을 가진 SSA 값(<code>%</code>로 시작)이다. 이것이 함수의 입력이다.</p>
</li>
<li>
<p><strong><code>%result = arith.addi %arg0, %arg1 : i32</code></strong>: <code>arith</code> dialect의 산술 덧셈 operation이다. 두 피연산자(<code>%arg0</code>과 <code>%arg1</code>)를 받아 더한 후, 새로운 SSA 값 <code>%result</code>를 생성한다. <code>: i32</code> 접미사는 결과 타입을 지정한다.</p>
</li>
<li>
<p><strong><code>return %result : i32</code></strong>: 함수의 return operation이다. <code>%result</code> 값을 호출자에게 반환한다. <code>: i32</code> 타입 어노테이션은 타입 안전성을 보장한다.</p>
</li>
</ul>
<p>MLIR의 모든 요소에는 목적과 타입이 있다. 암시적 변환이나 정의되지 않은 동작(undefined behavior)은 없다. 이러한 엄격함이 MLIR이 공격적인 최적화와 검증을 수행할 수 있게 해주는 것이다.</p>
<h2 id="dialect"><a class="header" href="#dialect">Dialect</a></h2>
<p><strong>Dialect</strong>은 관련된 operation, 타입, attribute를 그룹화하는 네임스페이스이다. Dialect은 MLIR의 확장성 메커니즘이다 — 모든 가능한 operation을 하나의 거대한 IR에 넣는 대신, MLIR은 도메인에 맞는 커스텀 dialect을 정의할 수 있게 해준다.</p>
<h3 id="사용할-내장-dialect"><a class="header" href="#사용할-내장-dialect">사용할 내장 Dialect</a></h3>
<p>FunLang 컴파일러에서는 주로 다음 표준 dialect들을 사용한다:</p>
<ol>
<li>
<p><strong><code>arith</code></strong> — 산술 연산</p>
<ul>
<li><code>arith.addi</code>, <code>arith.subi</code>, <code>arith.muli</code>, <code>arith.divsi</code> (부호 있는 정수 산술)</li>
<li><code>arith.cmpi</code> (정수 비교: <code>&lt;</code>, <code>&gt;</code>, <code>==</code> 등)</li>
<li><code>arith.constant</code> (정수 및 부동소수점 상수)</li>
</ul>
</li>
<li>
<p><strong><code>func</code></strong> — 함수 정의 및 호출</p>
<ul>
<li><code>func.func</code> (함수 정의)</li>
<li><code>func.call</code> (함수 호출)</li>
<li><code>func.return</code> (함수에서 반환)</li>
</ul>
</li>
<li>
<p><strong><code>scf</code></strong> — 구조적 제어 흐름(Structured Control Flow)</p>
<ul>
<li><code>scf.if</code> (조건부 실행)</li>
<li><code>scf.for</code> (카운트 루프)</li>
<li><code>scf.while</code> (조건 루프)</li>
</ul>
</li>
<li>
<p><strong><code>llvm</code></strong> — LLVM dialect (lowering 대상)</p>
<ul>
<li><code>llvm.func</code>, <code>llvm.call</code>, <code>llvm.add</code> 등</li>
<li>이 dialect은 LLVM IR 구성 요소와 1:1로 매핑된다</li>
</ul>
</li>
</ol>
<h3 id="커스텀-dialect"><a class="header" href="#커스텀-dialect">커스텀 Dialect</a></h3>
<p>이 튜토리얼 시리즈의 후반부(Chapter 10-11)에서는 다음과 같은 operation을 가진 <strong>FunLang dialect</strong>을 정의하게 된다:</p>
<ul>
<li><code>funlang.closure</code> (클로저 생성)</li>
<li><code>funlang.apply</code> (클로저에 인자를 적용)</li>
<li><code>funlang.match</code> (패턴 매칭)</li>
</ul>
<p>커스텀 dialect을 사용하면 컴파일 과정에서 고수준 의미론을 보존할 수 있다. FunLang 클로저를 즉시 저수준 구조체 할당과 함수 포인터로 변환하는 대신, 고수준 <code>funlang.closure</code> operation으로 표현한다. 이렇게 하면 최적화를 작성하고 이해하기가 더 쉬워진다.</p>
<h3 id="dialect-명명-규칙"><a class="header" href="#dialect-명명-규칙">Dialect 명명 규칙</a></h3>
<p>Operation은 항상 자신이 속한 dialect 이름을 접두사로 가지며, 점(.)으로 구분된다:</p>
<pre><code class="language-mlir">arith.addi   // "arith" dialect의 "addi" operation
func.call    // "func" dialect의 "call" operation
llvm.load    // "llvm" dialect의 "load" operation
</code></pre>
<p>이를 통해 이름 충돌을 방지한다. <code>arith</code> dialect의 <code>addi</code>는 가상의 <code>mydialect.addi</code>와 구별된다.</p>
<h2 id="operation"><a class="header" href="#operation">Operation</a></h2>
<p><strong>Operation</strong>은 MLIR IR의 기본 단위이다. MLIR에서는 함수 정의, 산술 명령어, 제어 흐름 등 모든 것이 operation으로 표현된다. 심지어 타입과 attribute도 operation에 첨부된다.</p>
<h3 id="operation의-구조"><a class="header" href="#operation의-구조">Operation의 구조</a></h3>
<p>텍스트 형식에서 operation은 다음과 같은 구조를 가진다:</p>
<pre><code class="language-mlir">%results = dialect.opname(%operands) {attributes} : (types) -&gt; result_type
</code></pre>
<p>덧셈 예제에서 각 구성 요소를 살펴본다:</p>
<pre><code class="language-mlir">%result = arith.addi %arg0, %arg1 : i32
</code></pre>
<ul>
<li>
<p><strong><code>%result</code></strong>: 이 operation이 생성하는 SSA 값이다. 이 값은 이후 operation에서 사용할 수 있다. <code>%</code> 접두사는 SSA 값을 심볼(<code>@function_name</code>)과 구별한다.</p>
</li>
<li>
<p><strong><code>arith.addi</code></strong>: operation 이름(dialect + opname)이다.</p>
</li>
<li>
<p><strong><code>%arg0, %arg1</code></strong>: 피연산자(operation의 입력)이다. 이전에 정의된 SSA 값(이 경우 함수 인자)이다.</p>
</li>
<li>
<p><strong><code>: i32</code></strong>: 타입 제약 조건이다. 이 operation은 32비트 정수에 대해 동작한다.</p>
</li>
</ul>
<p>모든 operation이 결과를 생성하는 것은 아니다. 예를 들어, <code>return</code>은 함수를 종료하는 operation이지만 이후에 사용할 값을 생성하지는 않는다:</p>
<pre><code class="language-mlir">return %result : i32
</code></pre>
<h3 id="복수-결과를-가진-operation"><a class="header" href="#복수-결과를-가진-operation">복수 결과를 가진 Operation</a></h3>
<p>일부 operation은 여러 값을 생성한다. 예를 들어, 몫과 나머지를 모두 반환하는 나눗셈 operation이 있다:</p>
<pre><code class="language-mlir">%quot, %rem = arith.divrem %dividend, %divisor : i32
</code></pre>
<p>이제 <code>%quot</code>과 <code>%rem</code> 모두 사용 가능한 SSA 값이다.</p>
<h3 id="attribute를-가진-operation"><a class="header" href="#attribute를-가진-operation">Attribute를 가진 Operation</a></h3>
<p>Attribute는 컴파일 타임 상수 메타데이터를 제공한다. 예를 들어, 정수 상수는 다음과 같다:</p>
<pre><code class="language-mlir">%zero = arith.constant 0 : i32
</code></pre>
<p><code>0</code>은 attribute(상수 값)이고, <code>i32</code>는 타입이다. Attribute는 런타임 값이 아니라 컴파일 타임에 IR에 내장되는 것이다.</p>
<h2 id="region과-block"><a class="header" href="#region과-block">Region과 Block</a></h2>
<p>MLIR operation은 <strong>region</strong>을 포함할 수 있고, region은 <strong>block</strong>을 포함한다. 이것이 MLIR이 중첩된 스코프와 제어 흐름을 표현하는 방식이다.</p>
<h3 id="region"><a class="header" href="#region">Region</a></h3>
<p><strong>Region</strong>은 block의 목록이다. 함수 본문은 region이다. <code>scf.if</code>와 같은 제어 흐름 operation에는 “then“과 “else” 분기를 위한 region이 있다.</p>
<p>다음은 하나의 region에 하나의 block을 포함하는 함수이다:</p>
<pre><code class="language-mlir">func.func @example() -&gt; i32 {
  %one = arith.constant 1 : i32
  return %one : i32
}
</code></pre>
<p>중괄호 <code>{ ... }</code>가 함수의 region을 구분한다. region 내부에는 두 개의 operation(상수와 return)을 가진 하나의 block이 있다.</p>
<h3 id="block"><a class="header" href="#block">Block</a></h3>
<p><strong>Block</strong>은 선형적으로 실행되는 operation의 시퀀스이다. 모든 block은 <strong>terminator</strong> operation — 제어를 다른 곳으로 이전하는 operation(return, branch 등) — 으로 끝나야 한다. Block을 “통과(fall through)“할 수 없다.</p>
<p>제어 흐름이 있을 때 block이 필수적이 된다. 다음은 두 개의 block을 가진 함수이다:</p>
<pre><code class="language-mlir">func.func @conditional(%cond: i1, %a: i32, %b: i32) -&gt; i32 {
  cf.cond_br %cond, ^then_block, ^else_block

^then_block:
  return %a : i32

^else_block:
  return %b : i32
}
</code></pre>
<p>분석해 본다:</p>
<ul>
<li>
<p><strong><code>cf.cond_br %cond, ^then_block, ^else_block</code></strong>: 조건 분기 operation(<code>cf</code> control-flow dialect)이다. <code>%cond</code>가 참이면 <code>^then_block</code>으로, 그렇지 않으면 <code>^else_block</code>으로 점프한다. 이것이 entry block의 terminator이다.</p>
</li>
<li>
<p><strong><code>^then_block:</code></strong>: block 레이블이다. <code>^</code> 접두사는 block을 나타낸다. block 이름은 함수 내에서 로컬이다.</p>
</li>
<li>
<p><strong><code>return %a : i32</code></strong>: <code>^then_block</code>의 terminator이다. <code>%a</code>를 호출자에게 반환한다.</p>
</li>
<li>
<p><strong><code>^else_block:</code></strong>: 또 다른 block 레이블이다.</p>
</li>
<li>
<p><strong><code>return %b : i32</code></strong>: <code>^else_block</code>의 terminator이다. <code>%b</code>를 반환한다.</p>
</li>
</ul>
<h3 id="block-인자-mlir의-phi-node-처리-방식"><a class="header" href="#block-인자-mlir의-phi-node-처리-방식">Block 인자 (MLIR의 Phi Node 처리 방식)</a></h3>
<p>MLIR은 LLVM의 phi node 대신 <strong>block 인자</strong>를 사용한다. LLVM IR에서는 여러 선행 block의 값을 병합하기 위해 phi node를 사용한다. MLIR에서는 block으로 분기할 때 값을 인자로 전달한다.</p>
<p>다음은 두 값을 병합하는 예제이다:</p>
<pre><code class="language-mlir">func.func @merge_example(%cond: i1, %a: i32, %b: i32) -&gt; i32 {
  cf.cond_br %cond, ^merge(%a : i32), ^merge(%b : i32)

^merge(%result: i32):
  return %result : i32
}
</code></pre>
<p>무슨 일이 일어나는지 살펴본다:</p>
<ul>
<li>
<p><strong><code>cf.cond_br %cond, ^merge(%a : i32), ^merge(%b : i32)</code></strong>: <code>^merge</code> block으로 분기하되, 조건이 참이면 <code>%a</code>를, 거짓이면 <code>%b</code>를 전달한다.</p>
</li>
<li>
<p><strong><code>^merge(%result: i32):</code></strong>: <code>^merge</code> block은 <code>i32</code> 타입의 인자 하나를 기대한다고 선언한다. 어느 분기가 선택되든, 전달된 값이 이 block 내에서 <code>%result</code>가 된다.</p>
</li>
</ul>
<p>이 방식은 LLVM의 phi node보다 깔끔하다. 데이터 흐름이 분기 지점에서 명시적으로 표현되며, 사후에 재구성할 필요가 없기 때문이다.</p>
<h2 id="ssa-form-static-single-assignment"><a class="header" href="#ssa-form-static-single-assignment">SSA Form (Static Single Assignment)</a></h2>
<p>MLIR은 <strong>SSA form</strong>을 사용한다. 즉, 모든 값은 정확히 한 번만 정의되고 절대 변경되지 않는다. <code>%x</code>를 정의하면 다시 할당할 수 없다. 이 속성 덕분에 “지금 어떤 버전의 변수를 보고 있는 것인가?“를 추적할 필요가 없어 최적화가 단순해진다.</p>
<h3 id="ssa-동작-예시"><a class="header" href="#ssa-동작-예시">SSA 동작 예시</a></h3>
<p>다음 FunLang 코드를 살펴본다:</p>
<pre><code class="language-fsharp">let x = 5
let y = x + 3
let z = y * 2
z
</code></pre>
<p>MLIR SSA form에서 각 let 바인딩은 새로운 SSA 값이 된다:</p>
<pre><code class="language-mlir">func.func @example() -&gt; i32 {
  %x = arith.constant 5 : i32
  %three = arith.constant 3 : i32
  %y = arith.addi %x, %three : i32
  %two = arith.constant 2 : i32
  %z = arith.muli %y, %two : i32
  return %z : i32
}
</code></pre>
<p>주목할 점:</p>
<ul>
<li>각 <code>let</code> 바인딩은 새로운 SSA 값(<code>%x</code>, <code>%y</code>, <code>%z</code>)이 된다.</li>
<li>상수는 값을 생성하는 operation(<code>arith.constant</code>)이다.</li>
<li>어떤 값도 재할당되지 않는다.</li>
</ul>
<h3 id="ssa와-가변성mutability"><a class="header" href="#ssa와-가변성mutability">SSA와 가변성(Mutability)</a></h3>
<p>FunLang은 불변(immutable)이므로 SSA와 자연스럽게 매핑된다. 하지만 변이(mutation)가 있는 명령형 코드는 어떨까? 다음을 살펴본다:</p>
<pre><code class="language-c">int x = 1;
x = x + 1;
return x;
</code></pre>
<p>SSA에서는 <code>x</code>를 변경할 수 없다. 대신, 새로운 버전을 생성한다:</p>
<pre><code class="language-mlir">%x0 = arith.constant 1 : i32
%one = arith.constant 1 : i32
%x1 = arith.addi %x0, %one : i32
return %x1 : i32
</code></pre>
<p>각 “변이“는 새로운 SSA 값(<code>%x0</code>, <code>%x1</code> 등)을 생성한다. 이 변환을 <strong>SSA conversion</strong>이라고 하며, 명령형 언어의 컴파일러에서 자동으로 처리된다.</p>
<p>FunLang은 함수형이므로 이 작업은 필요하지 않다 — 모든 <code>let</code> 바인딩이 이미 새로운 이름을 도입하기 때문이다.</p>
<h3 id="핵심-통찰-ssa는-최적화를-가능하게-한다"><a class="header" href="#핵심-통찰-ssa는-최적화를-가능하게-한다">핵심 통찰: SSA는 최적화를 가능하게 한다</a></h3>
<p>SSA form은 많은 컴파일러 최적화를 간단하게 만들어 준다. 예를 들어:</p>
<ul>
<li><strong>Dead code elimination(죽은 코드 제거):</strong> SSA 값이 정의되었지만 사용되지 않으면, 해당 값을 정의하는 operation을 삭제한다.</li>
<li><strong>Constant propagation(상수 전파):</strong> <code>%x</code>가 <code>arith.constant 5</code>로 정의되었다면, <code>%x</code>의 모든 사용을 <code>5</code>로 대체한다.</li>
<li><strong>Common subexpression elimination(공통 하위 표현식 제거):</strong> 두 operation이 같은 값을 계산하면, 하나를 재사용하고 다른 하나를 삭제한다.</li>
</ul>
<p>이 모든 최적화는 값이 정의 후 절대 변경되지 않는다는 보장에 의존한다.</p>
<h2 id="mlir의-타입"><a class="header" href="#mlir의-타입">MLIR의 타입</a></h2>
<p>MLIR은 강타입(strongly typed)이다. 모든 SSA 값, operation, 함수에는 타입이 있다. 타입 시스템은 확장 가능하며(dialect이 커스텀 타입을 정의할 수 있음), 다음은 사용하게 될 내장 타입이다:</p>
<h3 id="정수-타입"><a class="header" href="#정수-타입">정수 타입</a></h3>
<ul>
<li><code>i1</code> — 1비트 정수 (boolean)</li>
<li><code>i32</code> — 32비트 부호 있는 정수</li>
<li><code>i64</code> — 64비트 부호 있는 정수</li>
<li><code>i8</code>, <code>i16</code>, <code>i128</code> 등 — 임의 비트 너비 정수</li>
</ul>
<h3 id="부동소수점-타입"><a class="header" href="#부동소수점-타입">부동소수점 타입</a></h3>
<ul>
<li><code>f32</code> — 32비트 IEEE 754 float</li>
<li><code>f64</code> — 64비트 IEEE 754 double</li>
</ul>
<h3 id="index-타입"><a class="header" href="#index-타입">Index 타입</a></h3>
<ul>
<li><code>index</code> — 배열 인덱싱을 위한 플랫폼 의존 정수 (대상 아키텍처에 따라 일반적으로 32비트 또는 64비트)</li>
</ul>
<h3 id="메모리-타입"><a class="header" href="#메모리-타입">메모리 타입</a></h3>
<ul>
<li><code>memref&lt;4xi32&gt;</code> — 메모리상의 4개 <code>i32</code> 값 배열에 대한 참조</li>
<li><code>memref&lt;*xf64&gt;</code> — <code>f64</code> 값에 대한 unranked(동적) 메모리 참조</li>
</ul>
<h3 id="함수-타입"><a class="header" href="#함수-타입">함수 타입</a></h3>
<ul>
<li><code>(i32, i32) -&gt; i32</code> — 두 개의 <code>i32</code> 인자를 받아 <code>i32</code>를 반환하는 함수</li>
</ul>
<h3 id="funlang-타입-매핑"><a class="header" href="#funlang-타입-매핑">FunLang 타입 매핑</a></h3>
<p>FunLang 타입이 MLIR 타입에 어떻게 매핑되는지 정리하면 다음과 같다:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>FunLang 타입</th><th>MLIR 타입</th><th>비고</th></tr>
</thead>
<tbody>
<tr><td><code>Int</code></td><td><code>i64</code></td><td>FunLang 정수는 인터프리터에서 임의 정밀도이지만, 64비트로 컴파일한다</td></tr>
<tr><td><code>Bool</code></td><td><code>i1</code></td><td>True = 1, False = 0</td></tr>
<tr><td><code>String</code></td><td><code>!llvm.ptr</code> (LLVM dialect 포인터)</td><td>문자열은 힙에 할당된 null 종료 C 문자열이다</td></tr>
<tr><td><code>Float</code></td><td><code>f64</code></td><td>배정밀도 부동소수점</td></tr>
<tr><td><code>List&lt;'a&gt;</code></td><td><code>!llvm.ptr</code></td><td>리스트는 힙에 할당된 연결 구조이다</td></tr>
<tr><td><code>Tuple&lt;'a, 'b, ...&gt;</code></td><td><code>!llvm.struct&lt;...&gt;</code></td><td>튜플은 LLVM struct로 컴파일된다</td></tr>
</tbody>
</table>
</div>
<p><code>!</code> 접두사는 dialect에서 정의된 타입을 나타낸다 (예: <code>!llvm.ptr</code>는 LLVM dialect의 포인터 타입).</p>
<h2 id="progressive-lowering"><a class="header" href="#progressive-lowering">Progressive Lowering</a></h2>
<p>MLIR의 강력함은 <strong>progressive lowering</strong>에 있다: 한 번에 크게 변환하는 대신, 고수준 operation을 여러 단계에 걸쳐 저수준 operation으로 변환하는 방식이다.</p>
<h3 id="funlang-컴파일-파이프라인"><a class="header" href="#funlang-컴파일-파이프라인">FunLang 컴파일 파이프라인</a></h3>
<p>이 튜토리얼에서 구축할 파이프라인은 다음과 같다:</p>
<pre><code>Stage 1: AST → High-Level MLIR
    FunLang AST (타입 검사기에서 전달)
    ↓
    arith, func, scf dialect을 사용하여 MLIR로 변환
    예: `let x = 1 + 2`는 `%x = arith.addi ...`가 됩니다

Stage 2: High-Level MLIR → LLVM Dialect
    `arith.addi` 같은 operation이 `llvm.add`로 lowering됩니다
    구조적 제어 흐름(`scf.if`)은 basic block과 branch로 lowering됩니다

Stage 3: LLVM Dialect → LLVM IR
    MLIR의 LLVM dialect이 텍스트 LLVM IR로 변환됩니다

Stage 4: LLVM IR → Native Code
    LLVM 백엔드(llc)가 대상 플랫폼의 머신 코드로 컴파일합니다
</code></pre>
<p>각 lowering 단계는 <strong>pass</strong> — IR을 재작성하는 변환 — 이다. MLIR은 pass 정의, 패턴 기반 재작성, 각 단계 후 검증을 위한 인프라를 제공한다.</p>
<h3 id="progressive-lowering이-중요한-이유"><a class="header" href="#progressive-lowering이-중요한-이유">Progressive Lowering이 중요한 이유</a></h3>
<p>FunLang의 패턴 매칭을 컴파일하는 경우를 생각해 보자. LLVM IR로 직접 lowering해야 한다면, 즉시 basic block, phi node, 메모리 로드로 이루어진 복잡한 결정 트리로 확장해야 한다. 하지만 progressive lowering을 사용하면:</p>
<ol>
<li><strong>고수준:</strong> 패턴 매칭을 구조를 보존하는 <code>funlang.match</code> operation으로 표현한다.</li>
<li><strong>중간 수준:</strong> <code>funlang.match</code>를 <code>scf.if</code>와 <code>scf.while</code>(구조적 제어 흐름)로 lowering한다.</li>
<li><strong>저수준:</strong> <code>scf.if</code>를 LLVM basic block과 branch로 lowering한다.</li>
</ol>
<p>각 단계에서 해당 추상화 수준에 맞는 최적화를 수행할 수 있다. 패턴 매칭 최적화(중복 검사 제거)는 고수준에서 이루어지고, LLVM 수준 최적화(레지스터 할당, 명령어 스케줄링)는 저수준에서 이루어진다.</p>
<h2 id="종합-예제"><a class="header" href="#종합-예제">종합 예제</a></h2>
<p>여러 개념을 함께 사용하는 좀 더 현실적인 MLIR 예제를 살펴본다:</p>
<pre><code class="language-mlir">module {
  func.func @factorial(%n: i64) -&gt; i64 {
    %c0 = arith.constant 0 : i64
    %c1 = arith.constant 1 : i64
    %is_zero = arith.cmpi eq, %n, %c0 : i64
    cf.cond_br %is_zero, ^base_case, ^recursive_case

  ^base_case:
    return %c1 : i64

  ^recursive_case:
    %n_minus_1 = arith.subi %n, %c1 : i64
    %rec_result = func.call @factorial(%n_minus_1) : (i64) -&gt; i64
    %result = arith.muli %n, %rec_result : i64
    return %result : i64
  }
}
</code></pre>
<p>이 코드를 추적해 본다:</p>
<ol>
<li>
<p><strong><code>func.func @factorial(%n: i64) -&gt; i64</code></strong>: 하나의 64비트 정수를 받아 64비트 정수를 반환하는 <code>@factorial</code> 함수를 정의한다.</p>
</li>
<li>
<p><strong><code>%c0 = arith.constant 0 : i64</code></strong>: 상수 <code>0</code>을 생성한다.</p>
</li>
<li>
<p><strong><code>%c1 = arith.constant 1 : i64</code></strong>: 상수 <code>1</code>을 생성한다.</p>
</li>
<li>
<p><strong><code>%is_zero = arith.cmpi eq, %n, %c0 : i64</code></strong>: <code>%n</code>과 <code>0</code>을 동등성 비교한다. 결과는 <code>i1</code>(boolean)이다.</p>
</li>
<li>
<p><strong><code>cf.cond_br %is_zero, ^base_case, ^recursive_case</code></strong>: 참이면 <code>^base_case</code>로, 아니면 <code>^recursive_case</code>로 분기한다.</p>
</li>
<li>
<p><strong><code>^base_case:</code></strong>: n == 0이면 1을 반환한다.</p>
</li>
<li>
<p><strong><code>^recursive_case:</code></strong>: n &gt; 0이면 <code>n * factorial(n - 1)</code>을 계산한다:</p>
<ul>
<li><code>%n_minus_1 = arith.subi %n, %c1</code>: <code>n - 1</code>을 계산한다.</li>
<li><code>%rec_result = func.call @factorial(%n_minus_1)</code>: 재귀 호출이다.</li>
<li><code>%result = arith.muli %n, %rec_result</code>: <code>n</code>과 재귀 결과를 곱한다.</li>
<li><code>return %result</code>: 결과를 반환한다.</li>
</ul>
</li>
</ol>
<p>이 예제는 다음을 보여준다:</p>
<ul>
<li><strong>SSA form:</strong> 모든 값(<code>%c0</code>, <code>%n_minus_1</code> 등)이 한 번만 정의된다.</li>
<li><strong>Operation:</strong> 상수, 비교, 산술, 함수 호출.</li>
<li><strong>Region과 block:</strong> 함수 본문은 세 개의 block(entry, <code>^base_case</code>, <code>^recursive_case</code>)을 가진 region이다.</li>
<li><strong>Terminator:</strong> 모든 block이 terminator(<code>cf.cond_br</code> 또는 <code>return</code>)로 끝난다.</li>
<li><strong>Dialect:</strong> <code>arith</code>, <code>func</code>, <code>cf</code> dialect을 사용한다.</li>
</ul>
<h2 id="학습-내용-정리"><a class="header" href="#학습-내용-정리">학습 내용 정리</a></h2>
<p>이제 MLIR의 다섯 가지 핵심 개념을 이해하게 되었다:</p>
<ol>
<li><strong>Dialect:</strong> operation, 타입, attribute의 네임스페이스 (예: <code>arith</code>, <code>func</code>, <code>llvm</code>).</li>
<li><strong>Operation:</strong> MLIR IR의 기본 단위 (예: <code>arith.addi</code>, <code>func.call</code>).</li>
<li><strong>Region:</strong> block의 목록 (예: 함수 본문).</li>
<li><strong>Block:</strong> terminator로 끝나는 operation 시퀀스 (예: 제어 흐름의 basic block).</li>
<li><strong>SSA form:</strong> 모든 값이 정확히 한 번만 정의되며 불변.</li>
</ol>
<p>구체적인 예제(산술, 제어 흐름, 재귀)를 통해 이 개념들이 어떻게 함께 작동하는지 살펴보았다. 또한 progressive lowering — IR을 한 번에 큰 점프가 아닌 단계적으로 변환하는 철학 — 을 이해하게 되었다.</p>
<h2 id="다음-단계"><a class="header" href="#다음-단계">다음 단계</a></h2>
<p>다음 챕터에서는 MLIR IR을 생성하는 첫 번째 F# 프로그램을 작성한다. P/Invoke를 사용하여 MLIR의 C API를 호출하고, 컴파일러의 “Hello, World“인 상수 정수를 반환하는 프로그램을 생성할 것이다.</p>
<p>**Chapter 02: Hello MLIR from F#**로 계속된다 (작성 예정).</p>
<h2 id="참고-자료"><a class="header" href="#참고-자료">참고 자료</a></h2>
<ul>
<li><a href="https://mlir.llvm.org/docs/LangRef/">MLIR Language Reference</a> — MLIR의 텍스트 형식, dialect, 의미론에 대한 공식 사양.</li>
<li><a href="https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/">Understanding MLIR IR Structure</a> — operation, region, block에 대한 심층 분석.</li>
<li><a href="https://mlir.llvm.org/docs/Tutorials/Toy/">MLIR Toy Tutorial</a> — MLIR을 사용하여 “Toy” 언어의 컴파일러를 구축하는 완전한 튜토리얼.</li>
<li><a href="https://mlir.llvm.org/docs/Dialects/">Dialects Documentation</a> — 내장 dialect(arith, func, scf, llvm 등)에 대한 참조 문서.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="챕터-02-f에서-hello-mlir"><a class="header" href="#챕터-02-f에서-hello-mlir">챕터 02: F#에서 Hello MLIR</a></h1>
<h2 id="소개-2"><a class="header" href="#소개-2">소개</a></h2>
<p>챕터 00에서는 MLIR을 소스에서 빌드하고 .NET SDK를 설치했다. 챕터 01에서는 MLIR의 핵심 개념인 dialect, operation, region, block, SSA 형태에 대해 배웠다. 이제 코드를 작성할 차례다.</p>
<p>이 챕터는 처음으로 “동작한다!“를 경험하는 순간이다. F# 스크립트를 작성하여 P/Invoke를 통해 MLIR C API를 호출하고, MLIR context와 module을 생성하며, 산술 연산이 포함된 간단한 함수를 구성한 뒤, 결과 IR을 콘솔에 출력할 것이다. 이 챕터를 마치면 F#이 MLIR과 상호운용될 수 있다는 것을 증명하는 동작하는 프로토타입을 갖게 된다.</p>
<p>이 챕터의 코드는 의도적으로 즉흥적이고 탐색적이다. P/Invoke 바인딩을 인라인으로 정의하고 우선 동작하는 것에 집중한다. 챕터 03에서 이 바인딩들을 적절한 재사용 가능한 모듈로 구성할 것이다.</p>
<h2 id="만들어-볼-것"><a class="header" href="#만들어-볼-것">만들어 볼 것</a></h2>
<p>첫 번째 MLIR 프로그램은 상수 정수를 반환하는 함수다. MLIR 텍스트 형식으로는 다음과 같다:</p>
<pre><code class="language-mlir">module {
  func.func @return_forty_two() -&gt; i32 {
    %c42 = arith.constant 42 : i32
    return %c42 : i32
  }
}
</code></pre>
<p>이것은 가장 간단한 MLIR 프로그램이다:</p>
<ul>
<li><code>@return_forty_two</code>라는 이름의 함수 하나</li>
<li>매개변수 없음</li>
<li><code>i32</code> (32비트 정수) 반환</li>
<li>본문에서 상수 <code>42</code>를 생성하고 반환</li>
</ul>
<p>이것을 MLIR의 C API를 사용하여 F#에서 프로그래밍 방식으로 구성할 것이다.</p>
<h2 id="pinvoke-이해하기"><a class="header" href="#pinvoke-이해하기">P/Invoke 이해하기</a></h2>
<p>P/Invoke (Platform Invoke)는 .NET의 외부 함수 인터페이스(FFI) 메커니즘이다. 관리 코드(F#, C# 등)에서 공유 라이브러리(Linux의 <code>.so</code>, macOS의 <code>.dylib</code>, Windows의 <code>.dll</code>)에 있는 비관리 네이티브 함수를 호출할 수 있게 해준다.</p>
<h3 id="dllimport-속성"><a class="header" href="#dllimport-속성">DllImport 속성</a></h3>
<p>네이티브 함수를 호출하려면 <code>[&lt;DllImport&gt;]</code> 속성을 사용하여 함수 시그니처를 선언한다. 패턴은 다음과 같다:</p>
<pre><code class="language-fsharp">[&lt;DllImport("library-name", CallingConvention = CallingConvention.Cdecl)&gt;]
extern ReturnType functionName(ParamType1 param1, ParamType2 param2)
</code></pre>
<p>하나씩 살펴본다:</p>
<ul>
<li>
<p><strong><code>[&lt;DllImport("library-name")&gt;]</code></strong>: 함수가 포함된 공유 라이브러리를 지정한다. MLIR의 경우 <code>"MLIR-C"</code>이다(파일 확장자 없이 – .NET이 플랫폼에 따라 자동으로 <code>.so</code>, <code>.dylib</code>, <code>.dll</code>을 추가한다).</p>
</li>
<li>
<p><strong><code>CallingConvention = CallingConvention.Cdecl</code></strong>: 인수 전달 및 스택 관리 방식을 지정한다. MLIR C API는 C 라이브러리의 표준인 C 호출 규약(<code>Cdecl</code>)을 사용한다.</p>
</li>
<li>
<p><strong><code>extern</code></strong>: 네이티브 코드에 정의된 외부 함수임을 표시한다.</p>
</li>
<li>
<p><strong>반환 타입과 매개변수</strong>: C 함수 시그니처와 정확히 일치해야 한다. MLIR은 불투명 구조체 핸들(내부 데이터 구조에 대한 포인터)을 사용하며, F#에서는 이를 <code>nativeint</code>로 표현한다.</p>
</li>
</ul>
<h3 id="mlir-핸들-타입"><a class="header" href="#mlir-핸들-타입">MLIR 핸들 타입</a></h3>
<p>MLIR C API는 모든 IR 엔티티에 불투명 구조체 타입을 사용한다:</p>
<pre><code class="language-c">// MLIR-C API (C header)
typedef struct MlirContext { void *ptr; } MlirContext;
typedef struct MlirModule { void *ptr; } MlirModule;
typedef struct MlirOperation { void *ptr; } MlirOperation;
// ... and many more
</code></pre>
<p>각 구조체는 포인터를 감싸는 래퍼다. F#의 관점에서는 내부 구조에 관심이 없고, MLIR 함수 간에 이 핸들들을 전달하기만 하면 된다. 단일 <code>nativeint</code> 필드를 가진 F# 구조체로 표현한다:</p>
<pre><code class="language-fsharp">[&lt;Struct&gt;]
type MlirContext =
    val Handle: nativeint
    new(handle) = { Handle = handle }
</code></pre>
<p>이는 C 메모리 레이아웃(단일 포인터)과 일치하며, P/Invoke 경계를 넘어 안전하게 전달할 수 있다.</p>
<h2 id="f-스크립트-생성"><a class="header" href="#f-스크립트-생성">F# 스크립트 생성</a></h2>
<p>코드를 작성해 본다. 작업 디렉터리에 <code>HelloMlir.fsx</code>라는 새 파일을 생성한다:</p>
<pre><code class="language-bash">cd $HOME
mkdir -p mlir-fsharp-tutorial
cd mlir-fsharp-tutorial
touch HelloMlir.fsx
</code></pre>
<p>텍스트 편집기에서 <code>HelloMlir.fsx</code>를 열고 필요한 import부터 시작한다:</p>
<pre><code class="language-fsharp">open System
open System.Runtime.InteropServices
</code></pre>
<ul>
<li><code>System</code>: .NET 핵심 타입</li>
<li><code>System.Runtime.InteropServices</code>: <code>DllImport</code>, <code>CallingConvention</code>, 마샬링 속성 포함</li>
</ul>
<h2 id="핸들-타입-정의"><a class="header" href="#핸들-타입-정의">핸들 타입 정의</a></h2>
<p>먼저 필요한 MLIR 핸들 타입을 정의한다. 이 간단한 예제에서는 다음이 필요하다:</p>
<ul>
<li><code>MlirContext</code>: MLIR 루트 context (메모리, dialect 등을 관리)</li>
<li><code>MlirModule</code>: module (함수의 최상위 컨테이너)</li>
<li><code>MlirLocation</code>: 소스 위치 정보 (operation 생성에 필요)</li>
<li><code>MlirType</code>: 타입 시스템 (<code>i32</code> 사용 예정)</li>
<li><code>MlirBlock</code>: 기본 블록</li>
<li><code>MlirRegion</code>: 블록을 포함하는 region</li>
<li><code>MlirOperation</code>: operation (함수나 산술 연산 생성 결과)</li>
<li><code>MlirValue</code>: SSA 값 (operation의 결과)</li>
</ul>
<p>스크립트에 다음 타입 정의를 추가한다:</p>
<pre><code class="language-fsharp">[&lt;Struct&gt;]
type MlirContext =
    val Handle: nativeint
    new(handle) = { Handle = handle }

[&lt;Struct&gt;]
type MlirModule =
    val Handle: nativeint
    new(handle) = { Handle = handle }

[&lt;Struct&gt;]
type MlirLocation =
    val Handle: nativeint
    new(handle) = { Handle = handle }

[&lt;Struct&gt;]
type MlirType =
    val Handle: nativeint
    new(handle) = { Handle = handle }

[&lt;Struct&gt;]
type MlirBlock =
    val Handle: nativeint
    new(handle) = { Handle = handle }

[&lt;Struct&gt;]
type MlirRegion =
    val Handle: nativeint
    new(handle) = { Handle = handle }

[&lt;Struct&gt;]
type MlirOperation =
    val Handle: nativeint
    new(handle) = { Handle = handle }

[&lt;Struct&gt;]
type MlirValue =
    val Handle: nativeint
    new(handle) = { Handle = handle }
</code></pre>
<p>각 핸들은 네이티브 포인터를 감싸는 얇은 래퍼다. <code>[&lt;Struct&gt;]</code> 속성은 이들이 힙에 할당되는 클래스가 아닌 스택에 할당되는 값 타입임을 보장하며, 작은 래퍼에 대해 더 효율적이다.</p>
<h2 id="문자열-마샬링-mlirstringref"><a class="header" href="#문자열-마샬링-mlirstringref">문자열 마샬링: MlirStringRef</a></h2>
<p>MLIR의 C API는 소유권 문제 없이 문자열을 전달하기 위해 <code>MlirStringRef</code>라는 사용자 정의 문자열 구조체를 사용한다. C에서는 다음과 같이 정의되어 있다:</p>
<pre><code class="language-c">typedef struct MlirStringRef {
    const char *data;
    size_t length;
} MlirStringRef;
</code></pre>
<p>이 레이아웃을 F#에서 맞춰야 한다:</p>
<pre><code class="language-fsharp">[&lt;Struct; StructLayout(LayoutKind.Sequential)&gt;]
type MlirStringRef =
    val Data: nativeint  // const char*
    val Length: nativeint  // size_t

    new(data, length) = { Data = data; Length = length }

    static member FromString(s: string) =
        let bytes = System.Text.Encoding.UTF8.GetBytes(s)
        let ptr = Marshal.AllocHGlobal(bytes.Length)
        Marshal.Copy(bytes, 0, ptr, bytes.Length)
        MlirStringRef(ptr, nativeint bytes.Length)

    member this.Free() =
        if this.Data &lt;&gt; nativeint 0 then
            Marshal.FreeHGlobal(this.Data)
</code></pre>
<p>세부 사항을 살펴본다:</p>
<ul>
<li>
<p><strong><code>[&lt;StructLayout(LayoutKind.Sequential)&gt;]</code></strong>: 필드가 선언된 순서대로 메모리에 배치되도록 보장한다 (C 구조체와 일치).</p>
</li>
<li>
<p><strong><code>FromString(s: string)</code></strong>: F# 문자열을 <code>MlirStringRef</code>로 변환하는 헬퍼다. 비관리 메모리를 할당하고, UTF-8 바이트를 복사한 후, 해당 메모리를 가리키는 <code>MlirStringRef</code>를 반환한다.</p>
</li>
<li>
<p><strong><code>Free()</code></strong>: 비관리 메모리를 해제한다. 문자열을 MLIR에 전달한 후 반드시 호출해야 하며, 그렇지 않으면 메모리 누수가 발생한다.</p>
</li>
</ul>
<h2 id="pinvoke-함수-선언"><a class="header" href="#pinvoke-함수-선언">P/Invoke 함수 선언</a></h2>
<p>이제 P/Invoke 선언을 작성한다. 이 예제에 필요한 함수만 선언한다. 스크립트에 다음을 추가한다:</p>
<pre><code class="language-fsharp">module MlirNative =
    // Context management
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirContext mlirContextCreate()

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirContextDestroy(MlirContext ctx)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirDialectHandle mlirGetDialectHandle__func__()

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirDialectHandle mlirGetDialectHandle__arith__()

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirDialectHandleRegisterDialect(MlirDialectHandle handle, MlirContext ctx)

    // Module management
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirModule mlirModuleCreateEmpty(MlirLocation loc)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirModuleGetOperation(MlirModule m)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirModuleDestroy(MlirModule m)

    // Location
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirLocation mlirLocationUnknownGet(MlirContext ctx)

    // Types
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirIntegerTypeGet(MlirContext ctx, uint32 bitwidth)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirFunctionTypeGet(MlirContext ctx, nativeint numInputs, MlirType&amp; inputs, nativeint numResults, MlirType&amp; results)

    // Operation building
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirOperationCreate(MlirOperationState&amp; state)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirRegion mlirOperationGetRegion(MlirOperation op, nativeint pos)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirRegionAppendOwnedBlock(MlirRegion region, MlirBlock block)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirBlock mlirBlockCreate(nativeint numArgs, MlirType&amp; argTypes, MlirLocation&amp; argLocs)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirBlockInsertOwnedOperation(MlirBlock block, nativeint pos, MlirOperation op)

    // Printing
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirOperationPrint(MlirOperation op, MlirStringCallback callback, nativeint userData)
</code></pre>
<p>함수 시그니처에 등장한 추가 핸들 타입도 필요하다:</p>
<pre><code class="language-fsharp">[&lt;Struct&gt;]
type MlirDialectHandle =
    val Handle: nativeint
    new(handle) = { Handle = handle }

[&lt;Struct&gt;]
type MlirOperationState =
    val Name: MlirStringRef
    val Location: MlirLocation
    val NumResults: nativeint
    val Results: nativeint  // Pointer to MlirType array
    val NumOperands: nativeint
    val Operands: nativeint  // Pointer to MlirValue array
    val NumRegions: nativeint
    val Regions: nativeint  // Pointer to MlirRegion array
    val NumSuccessors: nativeint
    val Successors: nativeint  // Pointer to MlirBlock array
    val NumAttributes: nativeint
    val Attributes: nativeint  // Pointer to MlirNamedAttribute array
    val EnableResultTypeInference: bool
</code></pre>
<p>그리고 출력을 위한 콜백 delegate도 필요하다:</p>
<pre><code class="language-fsharp">[&lt;UnmanagedFunctionPointer(CallingConvention.Cdecl)&gt;]
type MlirStringCallback = delegate of MlirStringRef * nativeint -&gt; unit
</code></pre>
<p>이 delegate는 IR 출력 시 MLIR이 F# 코드를 콜백할 수 있게 해준다. MLIR은 출력의 각 청크마다 콜백을 호출한다.</p>
<h2 id="mlir-module-구성하기"><a class="header" href="#mlir-module-구성하기">MLIR Module 구성하기</a></h2>
<p>이제 MLIR module을 생성하는 로직을 작성한다. 스크립트에 다음 함수를 추가한다:</p>
<pre><code class="language-fsharp">let buildHelloMlir() =
    // Step 1: Create MLIR context
    let ctx = MlirNative.mlirContextCreate()
    printfn "Created MLIR context"

    // Step 2: Load required dialects (func and arith)
    let funcDialect = MlirNative.mlirGetDialectHandle__func__()
    MlirNative.mlirDialectHandleRegisterDialect(funcDialect, ctx)
    let arithDialect = MlirNative.mlirGetDialectHandle__arith__()
    MlirNative.mlirDialectHandleRegisterDialect(arithDialect, ctx)
    printfn "Registered func and arith dialects"

    // Step 3: Create an empty module
    let loc = MlirNative.mlirLocationUnknownGet(ctx)
    let mlirModule = MlirNative.mlirModuleCreateEmpty(loc)
    printfn "Created empty module"

    // Step 4: Create the function type () -&gt; i32
    let i32Type = MlirNative.mlirIntegerTypeGet(ctx, 32u)
    let mutable resultType = i32Type
    let funcType = MlirNative.mlirFunctionTypeGet(ctx, nativeint 0, &amp;i32Type, nativeint 1, &amp;resultType)
    printfn "Created function type () -&gt; i32"

    // Step 5: Create func.func operation
    let funcName = MlirStringRef.FromString("func.func")
    let mutable funcState =
        { MlirOperationState.Name = funcName
          Location = loc
          NumResults = nativeint 0
          Results = nativeint 0
          NumOperands = nativeint 0
          Operands = nativeint 0
          NumRegions = nativeint 1  // Function body is a region
          Regions = nativeint 0
          NumSuccessors = nativeint 0
          Successors = nativeint 0
          NumAttributes = nativeint 0
          Attributes = nativeint 0
          EnableResultTypeInference = false }

    let funcOp = MlirNative.mlirOperationCreate(&amp;funcState)
    funcName.Free()
    printfn "Created func.func operation"

    // Step 6: Create a block for the function body
    let funcRegion = MlirNative.mlirOperationGetRegion(funcOp, nativeint 0)
    let block = MlirNative.mlirBlockCreate(nativeint 0, &amp;i32Type, &amp;loc)
    MlirNative.mlirRegionAppendOwnedBlock(funcRegion, block)
    printfn "Created function body block"

    // Step 7: Create arith.constant 42 : i32
    let constantName = MlirStringRef.FromString("arith.constant")
    let mutable constantState =
        { MlirOperationState.Name = constantName
          Location = loc
          NumResults = nativeint 1
          Results = Marshal.AllocHGlobal(sizeof&lt;nativeint&gt;)
          NumOperands = nativeint 0
          Operands = nativeint 0
          NumRegions = nativeint 0
          Regions = nativeint 0
          NumSuccessors = nativeint 0
          Successors = nativeint 0
          NumAttributes = nativeint 0
          Attributes = nativeint 0
          EnableResultTypeInference = false }
    Marshal.StructureToPtr(i32Type, constantState.Results, false)

    let constantOp = MlirNative.mlirOperationCreate(&amp;constantState)
    constantName.Free()
    Marshal.FreeHGlobal(constantState.Results)
    printfn "Created arith.constant operation"

    // Step 8: Create return operation
    let returnName = MlirStringRef.FromString("func.return")
    let mutable returnState =
        { MlirOperationState.Name = returnName
          Location = loc
          NumResults = nativeint 0
          Results = nativeint 0
          NumOperands = nativeint 1
          Operands = nativeint 0  // Should point to constant's result
          NumRegions = nativeint 0
          Regions = nativeint 0
          NumSuccessors = nativeint 0
          Successors = nativeint 0
          NumAttributes = nativeint 0
          Attributes = nativeint 0
          EnableResultTypeInference = false }

    let returnOp = MlirNative.mlirOperationCreate(&amp;returnState)
    returnName.Free()
    printfn "Created func.return operation"

    // Step 9: Insert operations into the block
    MlirNative.mlirBlockInsertOwnedOperation(block, nativeint 0, constantOp)
    MlirNative.mlirBlockInsertOwnedOperation(block, nativeint 1, returnOp)
    printfn "Inserted operations into block"

    // Step 10: Get module operation and print
    let moduleOp = MlirNative.mlirModuleGetOperation(mlirModule)
    printfn "\n--- Generated MLIR IR ---"

    let mutable output = ""
    let callback = MlirStringCallback(fun strRef _ -&gt;
        let length = int strRef.Length
        let bytes = Array.zeroCreate&lt;byte&gt; length
        Marshal.Copy(strRef.Data, bytes, 0, length)
        let text = System.Text.Encoding.UTF8.GetString(bytes)
        output &lt;- output + text
    )

    MlirNative.mlirOperationPrint(moduleOp, callback, nativeint 0)
    printfn "%s" output
    printfn "--- End of IR ---\n"

    // Cleanup
    MlirNative.mlirModuleDestroy(mlirModule)
    MlirNative.mlirContextDestroy(ctx)
    printfn "Cleaned up MLIR context and module"
</code></pre>
<p>이 함수에는 많은 내용이 있으므로 단계별로 살펴본다.</p>
<h2 id="단계별-분석"><a class="header" href="#단계별-분석">단계별 분석</a></h2>
<h3 id="1단계-mlir-context-생성"><a class="header" href="#1단계-mlir-context-생성">1단계: MLIR Context 생성</a></h3>
<pre><code class="language-fsharp">let ctx = MlirNative.mlirContextCreate()
</code></pre>
<p>MLIR context는 등록된 dialect, 타입 고유화, 메모리 관리 등 모든 MLIR 상태를 관리하는 루트 객체다. 다른 작업을 하기 전에 반드시 context를 생성해야 한다.</p>
<h3 id="2단계-dialect-로드"><a class="header" href="#2단계-dialect-로드">2단계: Dialect 로드</a></h3>
<pre><code class="language-fsharp">let funcDialect = MlirNative.mlirGetDialectHandle__func__()
MlirNative.mlirDialectHandleRegisterDialect(funcDialect, ctx)
let arithDialect = MlirNative.mlirGetDialectHandle__arith__()
MlirNative.mlirDialectHandleRegisterDialect(arithDialect, ctx)
</code></pre>
<p>MLIR dialect은 요청 시 로드된다. 함수 정의를 위한 <code>func</code> dialect과 상수 및 산술 연산을 위한 <code>arith</code> dialect이 필요하다. 각 dialect에는 getter 함수(<code>mlirGetDialectHandle__&lt;dialect&gt;__</code>)가 있으며, 이를 context에 등록한다.</p>
<h3 id="3단계-빈-module-생성"><a class="header" href="#3단계-빈-module-생성">3단계: 빈 Module 생성</a></h3>
<pre><code class="language-fsharp">let loc = MlirNative.mlirLocationUnknownGet(ctx)
let mlirModule = MlirNative.mlirModuleCreateEmpty(loc)
</code></pre>
<p>모든 MLIR operation에는 소스 위치가 필요하다. 생성된 코드의 경우 “unknown” 위치를 사용한다. 그런 다음 빈 module을 생성한다.</p>
<h3 id="4단계-함수-타입-생성"><a class="header" href="#4단계-함수-타입-생성">4단계: 함수 타입 생성</a></h3>
<pre><code class="language-fsharp">let i32Type = MlirNative.mlirIntegerTypeGet(ctx, 32u)
let mutable resultType = i32Type
let funcType = MlirNative.mlirFunctionTypeGet(ctx, nativeint 0, &amp;i32Type, nativeint 1, &amp;resultType)
</code></pre>
<p>함수 시그니처를 정의한다: 입력 없음(<code>nativeint 0</code>), 출력 하나(<code>i32</code>). <code>mlirFunctionTypeGet</code> 함수는 타입 배열에 대한 포인터를 받으므로 <code>&amp;</code>를 사용하여 참조로 전달한다.</p>
<h3 id="5-6단계-함수-operation-및-본문-block-생성"><a class="header" href="#5-6단계-함수-operation-및-본문-block-생성">5-6단계: 함수 Operation 및 본문 Block 생성</a></h3>
<p>MLIR에서 operation을 생성하려면 <code>MlirOperationState</code>를 구성하고 <code>mlirOperationCreate</code>를 호출해야 한다. 이것이 모든 operation 생성의 일반적인 패턴이다:</p>
<ol>
<li>operation 이름, 위치, 피연산자, 결과, region 등을 포함하는 <code>MlirOperationState</code> 생성</li>
<li><code>mlirOperationCreate(&amp;state)</code> 호출</li>
<li>할당된 메모리(operation 이름 문자열 등) 해제</li>
</ol>
<p>함수의 경우 region(함수 본문)과 그 안의 block도 생성한다.</p>
<h3 id="7-8단계-함수-내부-operation-생성"><a class="header" href="#7-8단계-함수-내부-operation-생성">7-8단계: 함수 내부 Operation 생성</a></h3>
<p>두 개의 operation을 생성한다:</p>
<ol>
<li><strong><code>arith.constant 42 : i32</code></strong>: 상수 operation이다. 하나의 결과(값 42)를 가진다.</li>
<li><strong><code>func.return %result</code></strong>: 반환 operation이다. 하나의 피연산자(상수의 결과)를 가진다.</li>
</ol>
<p>각 operation은 동일한 패턴을 따른다: <code>MlirOperationState</code> 생성, <code>mlirOperationCreate</code> 호출, 정리.</p>
<h3 id="9단계-operation을-block에-삽입"><a class="header" href="#9단계-operation을-block에-삽입">9단계: Operation을 Block에 삽입</a></h3>
<pre><code class="language-fsharp">MlirNative.mlirBlockInsertOwnedOperation(block, nativeint 0, constantOp)
MlirNative.mlirBlockInsertOwnedOperation(block, nativeint 1, returnOp)
</code></pre>
<p>Operation은 실행 순서대로 block에 삽입해야 한다. 상수가 먼저(위치 0), 그다음 반환(위치 1)이다.</p>
<h3 id="10단계-ir-출력"><a class="header" href="#10단계-ir-출력">10단계: IR 출력</a></h3>
<pre><code class="language-fsharp">let callback = MlirStringCallback(fun strRef _ -&gt;
    // MlirStringRef를 F# 문자열로 변환
    // output 변수에 누적
)
MlirNative.mlirOperationPrint(moduleOp, callback, nativeint 0)
</code></pre>
<p>MLIR의 출력 함수는 콜백을 사용한다. 콜백은 출력의 청크마다 여러 번 호출된다. 이 청크들을 하나의 문자열로 누적하여 출력한다.</p>
<h3 id="정리"><a class="header" href="#정리">정리</a></h3>
<pre><code class="language-fsharp">MlirNative.mlirModuleDestroy(mlirModule)
MlirNative.mlirContextDestroy(ctx)
</code></pre>
<p>메모리 누수를 방지하기 위해 항상 module과 context를 파괴해야 한다.</p>
<h2 id="스크립트-실행"><a class="header" href="#스크립트-실행">스크립트 실행</a></h2>
<p><code>HelloMlir.fsx</code> 파일 끝에 다음을 추가한다:</p>
<pre><code class="language-fsharp">[&lt;EntryPoint&gt;]
let main argv =
    buildHelloMlir()
    0
</code></pre>
<p>이제 F# Interactive로 스크립트를 실행한다:</p>
<pre><code class="language-bash">LD_LIBRARY_PATH=$HOME/mlir-install/lib dotnet fsi HelloMlir.fsx
</code></pre>
<p><strong>예상 출력:</strong></p>
<pre><code>Created MLIR context
Registered func and arith dialects
Created empty module
Created function type () -&gt; i32
Created func.func operation
Created function body block
Created arith.constant operation
Created func.return operation
Inserted operations into block

--- Generated MLIR IR ---
module {
  func.func @return_forty_two() -&gt; i32 {
    %c42 = arith.constant 42 : i32
    return %c42 : i32
  }
}
--- End of IR ---

Cleaned up MLIR context and module
</code></pre>
<p>이 출력이 보인다면 성공이다! F#에서 MLIR을 호출하고 프로그래밍 방식으로 IR을 생성하는 데 성공한 것이다.</p>
<h2 id="문제-해결"><a class="header" href="#문제-해결">문제 해결</a></h2>
<h3 id="dllnotfoundexception-unable-to-load-shared-library-mlir-c"><a class="header" href="#dllnotfoundexception-unable-to-load-shared-library-mlir-c">DllNotFoundException: Unable to load shared library ‘MLIR-C’</a></h3>
<p><strong>원인:</strong> .NET 런타임이 MLIR-C 공유 라이브러리를 찾을 수 없다.</p>
<p><strong>해결 방법:</strong> <code>LD_LIBRARY_PATH</code> (Linux) 또는 <code>DYLD_LIBRARY_PATH</code> (macOS)에 <code>$HOME/mlir-install/lib</code>이 포함되어 있는지 확인한다:</p>
<pre><code class="language-bash">export LD_LIBRARY_PATH=$HOME/mlir-install/lib:$LD_LIBRARY_PATH
dotnet fsi HelloMlir.fsx
</code></pre>
<p>또는 환경 변수를 인라인으로 지정하여 실행한다:</p>
<pre><code class="language-bash">LD_LIBRARY_PATH=$HOME/mlir-install/lib dotnet fsi HelloMlir.fsx
</code></pre>
<h3 id="accessviolationexception-또는-segmentation-fault"><a class="header" href="#accessviolationexception-또는-segmentation-fault">AccessViolationException 또는 Segmentation Fault</a></h3>
<p><strong>원인:</strong> 잘못된 P/Invoke 시그니처 (잘못된 매개변수 타입, byref 매개변수에 <code>&amp;</code> 누락 등).</p>
<p><strong>해결 방법:</strong> <code>DllImport</code> 선언이 MLIR-C API 헤더 파일과 정확히 일치하는지 확인한다. <a href="https://mlir.llvm.org/docs/CAPI/">MLIR-C API 문서</a>와 <code>$HOME/mlir-install/include/mlir-c/</code>의 헤더 파일을 참고한다.</p>
<h3 id="비어있거나-잘못된-형식의-ir-출력"><a class="header" href="#비어있거나-잘못된-형식의-ir-출력">비어있거나 잘못된 형식의 IR 출력</a></h3>
<p><strong>원인:</strong> Operation이 block에 제대로 삽입되지 않았거나, region이 operation에 제대로 연결되지 않았다.</p>
<p><strong>해결 방법:</strong> 연산 순서를 확인한다: operation 생성 -&gt; region 가져오기 -&gt; block 생성 -&gt; block에 operation 삽입.</p>
<h2 id="배운-내용"><a class="header" href="#배운-내용">배운 내용</a></h2>
<p>이 챕터에서 다음을 배웠다:</p>
<ol>
<li><strong>MLIR 핸들 타입 정의</strong> - 네이티브 포인터를 감싸는 F# 구조체로 정의했다.</li>
<li><strong><code>[&lt;DllImport&gt;]</code> 사용</strong> - 외부 MLIR-C API 함수를 선언했다.</li>
<li><strong>문자열 마샬링</strong> - <code>MlirStringRef</code>와 수동 메모리 관리를 사용했다.</li>
<li><strong>MLIR context와 module 생성</strong> - 처음부터 생성했다.</li>
<li><strong>프로그래밍 방식으로 operation 구성</strong> - <code>MlirOperationState</code>를 사용했다.</li>
<li><strong>MLIR IR 출력</strong> - 콜백을 사용했다.</li>
<li><strong>메모리 관리</strong> - 완료 후 context와 module을 파괴했다.</li>
</ol>
<p>이제 F#이 MLIR과 상호운용될 수 있다는 것이 증명되었다. 하지만 이 코드는 정돈되지 않았다 – 타입과 P/Invoke 함수를 스크립트에 인라인으로 정의하고 있다. 실제 컴파일러에서는 이 바인딩들이 재사용 가능한 모듈로 구성되어야 한다.</p>
<h2 id="다음-챕터"><a class="header" href="#다음-챕터">다음 챕터</a></h2>
<p><a href="#chapter-03-pinvoke-바인딩">챕터 03: P/Invoke 바인딩</a>으로 이어서 이 바인딩들을 깔끔한 API와 MLIR-C API의 포괄적인 커버리지를 갖춘 적절한 F# 모듈로 구성하는 방법을 배운다.</p>
<h2 id="추가-참고-자료"><a class="header" href="#추가-참고-자료">추가 참고 자료</a></h2>
<ul>
<li><a href="https://mlir.llvm.org/docs/CAPI/">MLIR C API Documentation</a> – MLIR C API 설계 및 사용 패턴에 대한 공식 가이드.</li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke">.NET P/Invoke Documentation</a> – .NET에서의 Platform Invoke 종합 가이드.</li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/standard/native-interop/type-marshalling">Marshalling in .NET</a> – .NET이 관리 타입과 비관리 타입 간에 변환하는 방법.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-03-pinvoke-바인딩"><a class="header" href="#chapter-03-pinvoke-바인딩">Chapter 03: P/Invoke 바인딩</a></h1>
<h2 id="소개-3"><a class="header" href="#소개-3">소개</a></h2>
<p>Chapter 02에서는 MLIR IR을 생성하는 첫 번째 F# 프로그램을 작성했다. 핸들 타입을 정의하고, <code>DllImport</code> 선언을 작성하며, MLIR C API를 성공적으로 호출하여 간단한 함수를 만들었다. 하지만 그 코드는 탐색적이고 임시방편적이었다 – 모든 바인딩이 스크립트 내에 인라인으로 정의되어 있었다.</p>
<p>실제 컴파일러에는 체계적이고 재사용 가능한 바인딩이 필요하다. 이 장에서는 Chapter 02에서 배운 모든 것을 가져와 적절한 F# 모듈인 <code>MlirBindings.fs</code>로 체계화한다. 이 모듈은 이후 모든 장의 기반이 된다. 이 장에서 배울 내용은 다음과 같다:</p>
<ul>
<li>기능 영역별(context, module, type, operation 등)로 MLIR C API 바인딩을 구성하는 방법</li>
<li>문자열 마샬링을 올바르고 안전하게 처리하는 방법</li>
<li>IR 출력을 위한 콜백 처리 방법</li>
<li>크로스 플랫폼 고려 사항 (Linux, macOS, Windows)</li>
</ul>
<p>이 장을 마치면 MLIR C API에 대한 완전하고 프로덕션에 사용할 수 있는 바인딩 레이어를 갖추게 된다.</p>
<h2 id="설계-철학"><a class="header" href="#설계-철학">설계 철학</a></h2>
<p>바인딩 레이어는 다음 원칙을 따른다:</p>
<ol>
<li><strong>얇은 래퍼:</strong> C API 위에 최소한의 추상화만 적용한다. 각 F# 함수는 C 함수에 직접 대응된다.</li>
<li><strong>타입 안전성:</strong> MLIR 핸들에 F# struct 타입을 사용하여 컴파일 시점에 타입 오류를 잡는다.</li>
<li><strong>메모리 안전성:</strong> 안전한 문자열 마샬링과 정리를 위한 유틸리티를 제공하되, destroy 함수를 호출해야 하는 필요성을 숨기지 않는다.</li>
<li><strong>완전성:</strong> 컴파일러에 필요한 모든 MLIR C API 함수를 다룬다 (context, module, type, operation, region, block, location, attribute, value).</li>
<li><strong>문서화:</strong> 모든 함수에 목적과 MLIR C API 대응 관계를 설명하는 주석이 있다.</li>
</ol>
<h2 id="프로젝트-구조"><a class="header" href="#프로젝트-구조">프로젝트 구조</a></h2>
<p>코드를 작성하기 전에 적절한 F# 프로젝트를 설정한다. Chapter 02에서는 스크립트(<code>.fsx</code>)를 사용했지만, 이제 라이브러리 프로젝트를 만든다:</p>
<pre><code class="language-bash">cd $HOME/mlir-fsharp-tutorial
dotnet new classlib -lang F# -o MlirBindings
cd MlirBindings
</code></pre>
<p>이렇게 하면 다음과 같은 구조의 새 F# 라이브러리 프로젝트가 생성된다:</p>
<pre><code>MlirBindings/
├── MlirBindings.fsproj
└── Library.fs
</code></pre>
<p>기본 <code>Library.fs</code>를 삭제한다:</p>
<pre><code class="language-bash">rm Library.fs
</code></pre>
<p><code>MlirBindings.fs</code>를 처음부터 새로 만든다.</p>
<h2 id="모듈-구성"><a class="header" href="#모듈-구성">모듈 구성</a></h2>
<p>바인딩 모듈은 다음과 같은 논리적 섹션으로 구성된다:</p>
<ol>
<li><strong>핸들 타입:</strong> MLIR 불투명 타입을 나타내는 F# struct</li>
<li><strong>문자열 마샬링:</strong> <code>MlirStringRef</code>와 헬퍼 함수</li>
<li><strong>콜백 델리게이트:</strong> MLIR 콜백을 위한 함수 포인터 타입</li>
<li><strong>Context 관리:</strong> Context 생성, 소멸, dialect 로딩</li>
<li><strong>Module 관리:</strong> Module 생성, 연산, 출력</li>
<li><strong>Location:</strong> 소스 위치 유틸리티</li>
<li><strong>타입 시스템:</strong> 정수 타입, 함수 타입, LLVM 타입</li>
<li><strong>Operation 빌딩:</strong> Operation state 생성 및 조립</li>
<li><strong>Region과 Block:</strong> Region 및 Block 생성과 관리</li>
<li><strong>Value와 Attribute:</strong> SSA value 및 attribute 처리</li>
</ol>
<p>단계별로 구축해 본다.</p>
<h2 id="핸들-타입"><a class="header" href="#핸들-타입">핸들 타입</a></h2>
<p><code>MlirBindings</code> 디렉토리에 새 파일 <code>MlirBindings.fs</code>를 생성한다:</p>
<pre><code class="language-bash">touch MlirBindings.fs
</code></pre>
<p>프로젝트 파일 <code>MlirBindings.fsproj</code>를 편집하여 파일을 추가한다. 내용을 다음으로 교체한다:</p>
<pre><code class="language-xml">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;

  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;
    &lt;GenerateDocumentationFile&gt;true&lt;/GenerateDocumentationFile&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemGroup&gt;
    &lt;Compile Include="MlirBindings.fs" /&gt;
  &lt;/ItemGroup&gt;

&lt;/Project&gt;
</code></pre>
<p>이제 <code>MlirBindings.fs</code>를 열고 namespace와 import부터 시작한다:</p>
<pre><code class="language-fsharp">namespace MlirBindings

open System
open System.Runtime.InteropServices
</code></pre>
<p>필요한 모든 핸들 타입을 정의한다. 이것들은 MLIR 내부 구조체에 대한 불투명 포인터이다:</p>
<pre><code class="language-fsharp">/// MLIR context - manages dialects, types, and global state
[&lt;Struct&gt;]
type MlirContext =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR module - top-level container for functions and global data
[&lt;Struct&gt;]
type MlirModule =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR operation - fundamental IR unit (instructions, functions, etc.)
[&lt;Struct&gt;]
type MlirOperation =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR type - represents value types (i32, f64, pointers, etc.)
[&lt;Struct&gt;]
type MlirType =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR location - source code location for diagnostics
[&lt;Struct&gt;]
type MlirLocation =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR region - contains a list of blocks
[&lt;Struct&gt;]
type MlirRegion =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR block - basic block containing a sequence of operations
[&lt;Struct&gt;]
type MlirBlock =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR value - SSA value produced by an operation
[&lt;Struct&gt;]
type MlirValue =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR attribute - compile-time constant metadata
[&lt;Struct&gt;]
type MlirAttribute =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR named attribute - key-value pair (name: attribute)
[&lt;Struct; StructLayout(LayoutKind.Sequential)&gt;]
type MlirNamedAttribute =
    val Name: MlirStringRef
    val Attribute: MlirAttribute

/// MLIR dialect handle - opaque handle to a registered dialect
[&lt;Struct&gt;]
type MlirDialectHandle =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR identifier - interned string for operation names, attribute keys, etc.
[&lt;Struct&gt;]
type MlirIdentifier =
    val Handle: nativeint
    new(handle) = { Handle = handle }
</code></pre>
<p>각 핸들 타입에는 목적을 설명하는 문서 주석이 포함되어 있다. <code>[&lt;Struct&gt;]</code> 어트리뷰트는 이들이 스택에 할당되는 값 타입임을 보장한다.</p>
<h2 id="문자열-마샬링"><a class="header" href="#문자열-마샬링">문자열 마샬링</a></h2>
<p>MLIR은 소유권 의미 없이 문자열을 전달하기 위해 <code>MlirStringRef</code>를 사용한다. 헬퍼 유틸리티와 함께 정의한다:</p>
<pre><code class="language-fsharp">/// MLIR string reference - non-owning pointer to string data
[&lt;Struct; StructLayout(LayoutKind.Sequential)&gt;]
type MlirStringRef =
    val Data: nativeint  // const char*
    val Length: nativeint  // size_t

    new(data, length) = { Data = data; Length = length }

    /// Convert F# string to MlirStringRef (allocates unmanaged memory)
    static member FromString(s: string) =
        if String.IsNullOrEmpty(s) then
            MlirStringRef(nativeint 0, nativeint 0)
        else
            let bytes = System.Text.Encoding.UTF8.GetBytes(s)
            let ptr = Marshal.AllocHGlobal(bytes.Length)
            Marshal.Copy(bytes, 0, ptr, bytes.Length)
            MlirStringRef(ptr, nativeint bytes.Length)

    /// Convert MlirStringRef to F# string
    member this.ToString() =
        if this.Data = nativeint 0 || this.Length = nativeint 0 then
            String.Empty
        else
            let length = int this.Length
            let bytes = Array.zeroCreate&lt;byte&gt; length
            Marshal.Copy(this.Data, bytes, 0, length)
            System.Text.Encoding.UTF8.GetString(bytes)

    /// Free unmanaged memory (call after passing to MLIR)
    member this.Free() =
        if this.Data &lt;&gt; nativeint 0 then
            Marshal.FreeHGlobal(this.Data)

    /// Create from string, use it, and automatically free
    static member WithString(s: string, f: MlirStringRef -&gt; 'a) =
        let strRef = MlirStringRef.FromString(s)
        try
            f strRef
        finally
            strRef.Free()
</code></pre>
<p><code>WithString</code> 헬퍼는 특히 유용하다 – 할당과 정리를 자동으로 처리한다:</p>
<pre><code class="language-fsharp">// 이렇게 하는 대신:
let strRef = MlirStringRef.FromString("func.func")
let op = createOp strRef
strRef.Free()

// 다음과 같이 작성할 수 있습니다:
MlirStringRef.WithString "func.func" (fun strRef -&gt;
    createOp strRef
)
</code></pre>
<h2 id="콜백-델리게이트"><a class="header" href="#콜백-델리게이트">콜백 델리게이트</a></h2>
<p>MLIR은 출력과 문자열 처리를 위해 콜백을 사용한다. 델리게이트 타입을 정의한다:</p>
<pre><code class="language-fsharp">/// Callback for MLIR IR printing (invoked with chunks of output)
[&lt;UnmanagedFunctionPointer(CallingConvention.Cdecl)&gt;]
type MlirStringCallback = delegate of MlirStringRef * nativeint -&gt; unit

/// Callback for diagnostic handlers
[&lt;UnmanagedFunctionPointer(CallingConvention.Cdecl)&gt;]
type MlirDiagnosticCallback = delegate of MlirDiagnostic * nativeint -&gt; MlirLogicalResult

/// MLIR diagnostic handle
[&lt;Struct&gt;]
type MlirDiagnostic =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR logical result (success/failure)
[&lt;Struct&gt;]
type MlirLogicalResult =
    val Value: int8
    new(value) = { Value = value }
    member this.IsSuccess = this.Value &lt;&gt; 0y
    member this.IsFailure = this.Value = 0y
</code></pre>
<h2 id="operation-state"><a class="header" href="#operation-state">Operation State</a></h2>
<p><code>MlirOperationState</code> struct는 operation을 빌드하는 데 사용된다. 배열에 대한 포인터를 포함하기 때문에 복잡하다:</p>
<pre><code class="language-fsharp">/// MLIR operation state - used to construct operations
[&lt;Struct; StructLayout(LayoutKind.Sequential)&gt;]
type MlirOperationState =
    val mutable Name: MlirStringRef
    val mutable Location: MlirLocation
    val mutable NumResults: nativeint
    val mutable Results: nativeint  // Pointer to MlirType array
    val mutable NumOperands: nativeint
    val mutable Operands: nativeint  // Pointer to MlirValue array
    val mutable NumRegions: nativeint
    val mutable Regions: nativeint  // Pointer to MlirRegion array
    val mutable NumSuccessors: nativeint
    val mutable Successors: nativeint  // Pointer to MlirBlock array
    val mutable NumAttributes: nativeint
    val mutable Attributes: nativeint  // Pointer to MlirNamedAttribute array
    val mutable EnableResultTypeInference: bool
</code></pre>
<p>참고: <code>mlirOperationCreate</code>에 전달하기 전에 수정해야 하므로 모든 필드가 mutable이다.</p>
<h2 id="pinvoke-선언"><a class="header" href="#pinvoke-선언">P/Invoke 선언</a></h2>
<p>이제 핵심 부분이다: MLIR C API에 대한 P/Invoke 선언이다. 모듈로 구성한다:</p>
<pre><code class="language-fsharp">module MlirNative =

    //==========================================================================
    // Context 관리
    //==========================================================================

    /// Create an MLIR context
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirContext mlirContextCreate()

    /// Destroy an MLIR context (frees all owned IR)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirContextDestroy(MlirContext ctx)

    /// Check if two contexts are equal
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern bool mlirContextEqual(MlirContext ctx1, MlirContext ctx2)

    /// Get dialect handle for the 'func' dialect
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirDialectHandle mlirGetDialectHandle__func__()

    /// Get dialect handle for the 'arith' dialect
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirDialectHandle mlirGetDialectHandle__arith__()

    /// Get dialect handle for the 'scf' (structured control flow) dialect
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirDialectHandle mlirGetDialectHandle__scf__()

    /// Get dialect handle for the 'cf' (control flow) dialect
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirDialectHandle mlirGetDialectHandle__cf__()

    /// Get dialect handle for the 'llvm' dialect
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirDialectHandle mlirGetDialectHandle__llvm__()

    /// Register a dialect with a context
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirDialectHandleRegisterDialect(MlirDialectHandle handle, MlirContext ctx)

    //==========================================================================
    // Module 관리
    //==========================================================================

    /// Create an empty MLIR module
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirModule mlirModuleCreateEmpty(MlirLocation loc)

    /// Create an MLIR module from parsing a string
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirModule mlirModuleCreateParse(MlirContext ctx, MlirStringRef mlir)

    /// Get the top-level operation of a module
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirModuleGetOperation(MlirModule m)

    /// Get the body (region) of a module
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirRegion mlirModuleGetBody(MlirModule m)

    /// Destroy a module (frees all owned IR)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirModuleDestroy(MlirModule m)

    //==========================================================================
    // Location
    //==========================================================================

    /// Create an unknown location (for generated code)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirLocation mlirLocationUnknownGet(MlirContext ctx)

    /// Create a file-line-column location
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirLocation mlirLocationFileLineColGet(MlirContext ctx, MlirStringRef filename, uint32 line, uint32 col)

    /// Create a fused location (combination of multiple locations)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirLocation mlirLocationFusedGet(MlirContext ctx, nativeint numLocs, MlirLocation&amp; locs, MlirAttribute metadata)

    //==========================================================================
    // 타입 시스템
    //==========================================================================

    /// Create an integer type with specified bit width
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirIntegerTypeGet(MlirContext ctx, uint32 bitwidth)

    /// Create a signed integer type
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirIntegerTypeSignedGet(MlirContext ctx, uint32 bitwidth)

    /// Create an unsigned integer type
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirIntegerTypeUnsignedGet(MlirContext ctx, uint32 bitwidth)

    /// Create a floating-point type (f32, f64, etc.)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirF32TypeGet(MlirContext ctx)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirF64TypeGet(MlirContext ctx)

    /// Create the index type (platform-dependent integer for indexing)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirIndexTypeGet(MlirContext ctx)

    /// Create a function type
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirFunctionTypeGet(MlirContext ctx, nativeint numInputs, MlirType&amp; inputs, nativeint numResults, MlirType&amp; results)

    /// Get the number of inputs for a function type
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern nativeint mlirFunctionTypeGetNumInputs(MlirType funcType)

    /// Get the number of results for a function type
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern nativeint mlirFunctionTypeGetNumResults(MlirType funcType)

    /// Create an LLVM pointer type
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirLLVMPointerTypeGet(MlirContext ctx, uint32 addressSpace)

    /// Create an LLVM void type
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirLLVMVoidTypeGet(MlirContext ctx)

    /// Create an LLVM struct type
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirLLVMStructTypeLiteralGet(MlirContext ctx, nativeint numFieldTypes, MlirType&amp; fieldTypes, bool isPacked)

    //==========================================================================
    // Attribute 시스템
    //==========================================================================

    /// Create an integer attribute
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirAttribute mlirIntegerAttrGet(MlirType typ, int64 value)

    /// Create a float attribute
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirAttribute mlirFloatAttrDoubleGet(MlirContext ctx, MlirType typ, float64 value)

    /// Create a string attribute
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirAttribute mlirStringAttrGet(MlirContext ctx, MlirStringRef str)

    /// Create a type attribute
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirAttribute mlirTypeAttrGet(MlirType typ)

    /// Create a symbol reference attribute
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirAttribute mlirFlatSymbolRefAttrGet(MlirContext ctx, MlirStringRef symbol)

    /// Create an array attribute
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirAttribute mlirArrayAttrGet(MlirContext ctx, nativeint numElements, MlirAttribute&amp; elements)

    /// Get an identifier from a string
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirIdentifier mlirIdentifierGet(MlirContext ctx, MlirStringRef str)

    /// Create a named attribute
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirNamedAttribute mlirNamedAttributeGet(MlirIdentifier name, MlirAttribute attr)

    //==========================================================================
    // Operation 빌딩
    //==========================================================================

    /// Create an operation state
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperationState mlirOperationStateGet(MlirStringRef name, MlirLocation loc)

    /// Create an operation from an operation state
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirOperationCreate(MlirOperationState&amp; state)

    /// Destroy an operation (if not owned by a block)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirOperationDestroy(MlirOperation op)

    /// Get the name of an operation
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirIdentifier mlirOperationGetName(MlirOperation op)

    /// Get the number of regions in an operation
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern nativeint mlirOperationGetNumRegions(MlirOperation op)

    /// Get a region from an operation by index
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirRegion mlirOperationGetRegion(MlirOperation op, nativeint pos)

    /// Get the number of results an operation produces
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern nativeint mlirOperationGetNumResults(MlirOperation op)

    /// Get a result value from an operation by index
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirValue mlirOperationGetResult(MlirOperation op, nativeint pos)

    /// Get the number of operands an operation takes
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern nativeint mlirOperationGetNumOperands(MlirOperation op)

    /// Get an operand value from an operation by index
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirValue mlirOperationGetOperand(MlirOperation op, nativeint pos)

    /// Set an operand of an operation
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirOperationSetOperand(MlirOperation op, nativeint pos, MlirValue value)

    /// Print an operation to a callback
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirOperationPrint(MlirOperation op, MlirStringCallback callback, nativeint userData)

    /// Verify an operation (check IR well-formedness)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern bool mlirOperationVerify(MlirOperation op)

    //==========================================================================
    // Region 관리
    //==========================================================================

    /// Create a new region
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirRegion mlirRegionCreate()

    /// Destroy a region (if not owned by an operation)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirRegionDestroy(MlirRegion region)

    /// Append a block to a region (region takes ownership)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirRegionAppendOwnedBlock(MlirRegion region, MlirBlock block)

    /// Insert a block into a region at position (region takes ownership)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirRegionInsertOwnedBlock(MlirRegion region, nativeint pos, MlirBlock block)

    /// Get the first block in a region
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirBlock mlirRegionGetFirstBlock(MlirRegion region)

    //==========================================================================
    // Block 관리
    //==========================================================================

    /// Create a new block with arguments
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirBlock mlirBlockCreate(nativeint numArgs, MlirType&amp; argTypes, MlirLocation&amp; argLocs)

    /// Destroy a block (if not owned by a region)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirBlockDestroy(MlirBlock block)

    /// Get the number of arguments a block has
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern nativeint mlirBlockGetNumArguments(MlirBlock block)

    /// Get a block argument by index
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirValue mlirBlockGetArgument(MlirBlock block, nativeint pos)

    /// Append an operation to a block (block takes ownership)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirBlockAppendOwnedOperation(MlirBlock block, MlirOperation op)

    /// Insert an operation into a block at position (block takes ownership)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirBlockInsertOwnedOperation(MlirBlock block, nativeint pos, MlirOperation op)

    /// Get the first operation in a block
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirBlockGetFirstOperation(MlirBlock block)

    //==========================================================================
    // Value
    //==========================================================================

    /// Get the type of a value
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirValueGetType(MlirValue value)

    /// Print a value
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirValuePrint(MlirValue value, MlirStringCallback callback, nativeint userData)
</code></pre>
<p>이것은 컴파일러 구축에 필요한 모든 MLIR C API 함수를 다루는 포괄적인 바인딩 레이어이다. 각 함수에는 목적을 설명하는 문서가 포함되어 있다.</p>
<h2 id="크로스-플랫폼-라이브러리-로딩"><a class="header" href="#크로스-플랫폼-라이브러리-로딩">크로스 플랫폼 라이브러리 로딩</a></h2>
<p>중요한 세부 사항이 하나 있다: 라이브러리 이름 <code>"MLIR-C"</code>는 .NET이 자동으로 올바른 확장자를 추가하기 때문에 플랫폼 간에 동작한다:</p>
<ul>
<li><strong>Linux:</strong> <code>libMLIR-C.so</code></li>
<li><strong>macOS:</strong> <code>libMLIR-C.dylib</code></li>
<li><strong>Windows:</strong> <code>MLIR-C.dll</code></li>
</ul>
<p>그러나 .NET은 런타임에 라이브러리를 어디서 찾을 수 있는지 알아야 한다. 이 내용은 Chapter 00에서 다루었다 (<code>LD_LIBRARY_PATH</code> 또는 <code>DYLD_LIBRARY_PATH</code> 설정). 프로덕션 애플리케이션의 경우 여러 가지 옵션이 있다:</p>
<h3 id="옵션-1-환경-변수-개발-시"><a class="header" href="#옵션-1-환경-변수-개발-시">옵션 1: 환경 변수 (개발 시)</a></h3>
<p>실행 전에 라이브러리 경로를 설정한다:</p>
<pre><code class="language-bash">LD_LIBRARY_PATH=$HOME/mlir-install/lib dotnet run
</code></pre>
<h3 id="옵션-2-nativelibrarysetdllimportresolver-런타임"><a class="header" href="#옵션-2-nativelibrarysetdllimportresolver-런타임">옵션 2: NativeLibrary.SetDllImportResolver (런타임)</a></h3>
<p>.NET의 <code>NativeLibrary</code> API를 사용하여 커스텀 검색 경로를 지정한다:</p>
<pre><code class="language-fsharp">open System.Runtime.InteropServices

module LibraryLoader =
    let initialize() =
        NativeLibrary.SetDllImportResolver(
            typeof&lt;MlirContext&gt;.Assembly,
            fun libraryName assemblyPath searchPath -&gt;
                if libraryName = "MLIR-C" then
                    let customPath = Environment.GetEnvironmentVariable("MLIR_INSTALL_PATH")
                    if not (String.IsNullOrEmpty(customPath)) then
                        let libPath =
                            if RuntimeInformation.IsOSPlatform(OSPlatform.Linux) then
                                System.IO.Path.Combine(customPath, "lib", "libMLIR-C.so")
                            elif RuntimeInformation.IsOSPlatform(OSPlatform.OSX) then
                                System.IO.Path.Combine(customPath, "lib", "libMLIR-C.dylib")
                            else
                                System.IO.Path.Combine(customPath, "bin", "MLIR-C.dll")
                        NativeLibrary.Load(libPath)
                    else
                        nativeint 0
                else
                    nativeint 0
        )
</code></pre>
<p>MLIR 함수를 호출하기 전에 <code>LibraryLoader.initialize()</code>를 호출한다.</p>
<h3 id="옵션-3-rpath-linuxmacos-바이너리"><a class="header" href="#옵션-3-rpath-linuxmacos-바이너리">옵션 3: rpath (Linux/macOS 바이너리)</a></h3>
<p>컴파일된 바이너리의 경우, rpath를 사용하여 실행 파일에 라이브러리 검색 경로를 내장한다. 이 방법은 이 튜토리얼의 범위를 벗어나지만, 배포 애플리케이션의 표준 솔루션이다.</p>
<h2 id="헬퍼-유틸리티"><a class="header" href="#헬퍼-유틸리티">헬퍼 유틸리티</a></h2>
<p>자주 사용되는 패턴을 위한 고수준 헬퍼 함수를 추가한다:</p>
<pre><code class="language-fsharp">module MlirHelpers =
    /// Print an operation to a string
    let operationToString (op: MlirOperation) : string =
        let mutable output = ""
        let callback = MlirStringCallback(fun strRef _ -&gt;
            output &lt;- output + strRef.ToString()
        )
        MlirNative.mlirOperationPrint(op, callback, nativeint 0)
        output

    /// Print a module to a string
    let moduleToString (m: MlirModule) : string =
        let op = MlirNative.mlirModuleGetOperation(m)
        operationToString op

    /// Print a value to a string
    let valueToString (v: MlirValue) : string =
        let mutable output = ""
        let callback = MlirStringCallback(fun strRef _ -&gt;
            output &lt;- output + strRef.ToString()
        )
        MlirNative.mlirValuePrint(v, callback, nativeint 0)
        output

    /// Create a context with common dialects registered
    let createContextWithDialects() : MlirContext =
        let ctx = MlirNative.mlirContextCreate()
        MlirNative.mlirDialectHandleRegisterDialect(MlirNative.mlirGetDialectHandle__func__(), ctx)
        MlirNative.mlirDialectHandleRegisterDialect(MlirNative.mlirGetDialectHandle__arith__(), ctx)
        MlirNative.mlirDialectHandleRegisterDialect(MlirNative.mlirGetDialectHandle__scf__(), ctx)
        MlirNative.mlirDialectHandleRegisterDialect(MlirNative.mlirGetDialectHandle__cf__(), ctx)
        MlirNative.mlirDialectHandleRegisterDialect(MlirNative.mlirGetDialectHandle__llvm__(), ctx)
        ctx

    /// Create a block with no arguments
    let createEmptyBlock(ctx: MlirContext) : MlirBlock =
        let loc = MlirNative.mlirLocationUnknownGet(ctx)
        let mutable dummyType = MlirType()
        let mutable dummyLoc = loc
        MlirNative.mlirBlockCreate(nativeint 0, &amp;dummyType, &amp;dummyLoc)
</code></pre>
<p>이 유틸리티들은 일반적인 작업을 래핑하여 사용자 코드에서 보일러플레이트를 줄여 준다.</p>
<h2 id="전체-mlirbindingsfs-목록"><a class="header" href="#전체-mlirbindingsfs-목록">전체 MlirBindings.fs 목록</a></h2>
<p>다음은 모든 섹션이 통합된 완전한 <code>MlirBindings.fs</code> 파일이다:</p>
<pre><code class="language-fsharp">namespace MlirBindings

open System
open System.Runtime.InteropServices

//=============================================================================
// Handle Types
//=============================================================================

/// MLIR context - manages dialects, types, and global state
[&lt;Struct&gt;]
type MlirContext =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR module - top-level container for functions and global data
[&lt;Struct&gt;]
type MlirModule =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR operation - fundamental IR unit (instructions, functions, etc.)
[&lt;Struct&gt;]
type MlirOperation =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR type - represents value types (i32, f64, pointers, etc.)
[&lt;Struct&gt;]
type MlirType =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR location - source code location for diagnostics
[&lt;Struct&gt;]
type MlirLocation =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR region - contains a list of blocks
[&lt;Struct&gt;]
type MlirRegion =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR block - basic block containing a sequence of operations
[&lt;Struct&gt;]
type MlirBlock =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR value - SSA value produced by an operation
[&lt;Struct&gt;]
type MlirValue =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR attribute - compile-time constant metadata
[&lt;Struct&gt;]
type MlirAttribute =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR dialect handle - opaque handle to a registered dialect
[&lt;Struct&gt;]
type MlirDialectHandle =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR identifier - interned string for operation names, attribute keys, etc.
[&lt;Struct&gt;]
type MlirIdentifier =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR diagnostic handle
[&lt;Struct&gt;]
type MlirDiagnostic =
    val Handle: nativeint
    new(handle) = { Handle = handle }

/// MLIR logical result (success/failure)
[&lt;Struct&gt;]
type MlirLogicalResult =
    val Value: int8
    new(value) = { Value = value }
    member this.IsSuccess = this.Value &lt;&gt; 0y
    member this.IsFailure = this.Value = 0y

//=============================================================================
// String Marshalling
//=============================================================================

/// MLIR string reference - non-owning pointer to string data
[&lt;Struct; StructLayout(LayoutKind.Sequential)&gt;]
type MlirStringRef =
    val Data: nativeint
    val Length: nativeint

    new(data, length) = { Data = data; Length = length }

    static member FromString(s: string) =
        if String.IsNullOrEmpty(s) then
            MlirStringRef(nativeint 0, nativeint 0)
        else
            let bytes = System.Text.Encoding.UTF8.GetBytes(s)
            let ptr = Marshal.AllocHGlobal(bytes.Length)
            Marshal.Copy(bytes, 0, ptr, bytes.Length)
            MlirStringRef(ptr, nativeint bytes.Length)

    member this.ToString() =
        if this.Data = nativeint 0 || this.Length = nativeint 0 then
            String.Empty
        else
            let length = int this.Length
            let bytes = Array.zeroCreate&lt;byte&gt; length
            Marshal.Copy(this.Data, bytes, 0, length)
            System.Text.Encoding.UTF8.GetString(bytes)

    member this.Free() =
        if this.Data &lt;&gt; nativeint 0 then
            Marshal.FreeHGlobal(this.Data)

    static member WithString(s: string, f: MlirStringRef -&gt; 'a) =
        let strRef = MlirStringRef.FromString(s)
        try
            f strRef
        finally
            strRef.Free()

/// MLIR named attribute - key-value pair
[&lt;Struct; StructLayout(LayoutKind.Sequential)&gt;]
type MlirNamedAttribute =
    val Name: MlirStringRef
    val Attribute: MlirAttribute

//=============================================================================
// Callback Delegates
//=============================================================================

/// Callback for MLIR IR printing
[&lt;UnmanagedFunctionPointer(CallingConvention.Cdecl)&gt;]
type MlirStringCallback = delegate of MlirStringRef * nativeint -&gt; unit

/// Callback for diagnostic handlers
[&lt;UnmanagedFunctionPointer(CallingConvention.Cdecl)&gt;]
type MlirDiagnosticCallback = delegate of MlirDiagnostic * nativeint -&gt; MlirLogicalResult

//=============================================================================
// Operation State
//=============================================================================

/// MLIR operation state - used to construct operations
[&lt;Struct; StructLayout(LayoutKind.Sequential)&gt;]
type MlirOperationState =
    val mutable Name: MlirStringRef
    val mutable Location: MlirLocation
    val mutable NumResults: nativeint
    val mutable Results: nativeint
    val mutable NumOperands: nativeint
    val mutable Operands: nativeint
    val mutable NumRegions: nativeint
    val mutable Regions: nativeint
    val mutable NumSuccessors: nativeint
    val mutable Successors: nativeint
    val mutable NumAttributes: nativeint
    val mutable Attributes: nativeint
    val mutable EnableResultTypeInference: bool

//=============================================================================
// P/Invoke Declarations
//=============================================================================

module MlirNative =

    // Context Management
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirContext mlirContextCreate()

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirContextDestroy(MlirContext ctx)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirDialectHandle mlirGetDialectHandle__func__()

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirDialectHandle mlirGetDialectHandle__arith__()

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirDialectHandle mlirGetDialectHandle__scf__()

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirDialectHandle mlirGetDialectHandle__cf__()

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirDialectHandle mlirGetDialectHandle__llvm__()

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirDialectHandleRegisterDialect(MlirDialectHandle handle, MlirContext ctx)

    // Module Management
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirModule mlirModuleCreateEmpty(MlirLocation loc)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirModule mlirModuleCreateParse(MlirContext ctx, MlirStringRef mlir)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirModuleGetOperation(MlirModule m)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirRegion mlirModuleGetBody(MlirModule m)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirModuleDestroy(MlirModule m)

    // Location
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirLocation mlirLocationUnknownGet(MlirContext ctx)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirLocation mlirLocationFileLineColGet(MlirContext ctx, MlirStringRef filename, uint32 line, uint32 col)

    // Type System
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirIntegerTypeGet(MlirContext ctx, uint32 bitwidth)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirF32TypeGet(MlirContext ctx)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirF64TypeGet(MlirContext ctx)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirIndexTypeGet(MlirContext ctx)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirFunctionTypeGet(MlirContext ctx, nativeint numInputs, MlirType&amp; inputs, nativeint numResults, MlirType&amp; results)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirLLVMPointerTypeGet(MlirContext ctx, uint32 addressSpace)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirLLVMVoidTypeGet(MlirContext ctx)

    // Attributes
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirAttribute mlirIntegerAttrGet(MlirType typ, int64 value)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirAttribute mlirStringAttrGet(MlirContext ctx, MlirStringRef str)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirAttribute mlirTypeAttrGet(MlirType typ)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirIdentifier mlirIdentifierGet(MlirContext ctx, MlirStringRef str)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirNamedAttribute mlirNamedAttributeGet(MlirIdentifier name, MlirAttribute attr)

    // Operation Building
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperationState mlirOperationStateGet(MlirStringRef name, MlirLocation loc)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirOperationCreate(MlirOperationState&amp; state)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirOperationDestroy(MlirOperation op)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirRegion mlirOperationGetRegion(MlirOperation op, nativeint pos)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern nativeint mlirOperationGetNumResults(MlirOperation op)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirValue mlirOperationGetResult(MlirOperation op, nativeint pos)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirOperationSetOperand(MlirOperation op, nativeint pos, MlirValue value)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirOperationPrint(MlirOperation op, MlirStringCallback callback, nativeint userData)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern bool mlirOperationVerify(MlirOperation op)

    // Region Management
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirRegion mlirRegionCreate()

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirRegionAppendOwnedBlock(MlirRegion region, MlirBlock block)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirBlock mlirRegionGetFirstBlock(MlirRegion region)

    // Block Management
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirBlock mlirBlockCreate(nativeint numArgs, MlirType&amp; argTypes, MlirLocation&amp; argLocs)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern nativeint mlirBlockGetNumArguments(MlirBlock block)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirValue mlirBlockGetArgument(MlirBlock block, nativeint pos)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirBlockAppendOwnedOperation(MlirBlock block, MlirOperation op)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirBlockInsertOwnedOperation(MlirBlock block, nativeint pos, MlirOperation op)

    // Value
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirType mlirValueGetType(MlirValue value)

    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirValuePrint(MlirValue value, MlirStringCallback callback, nativeint userData)

//=============================================================================
// Helper Utilities
//=============================================================================

module MlirHelpers =
    let operationToString (op: MlirOperation) : string =
        let mutable output = ""
        let callback = MlirStringCallback(fun strRef _ -&gt;
            output &lt;- output + strRef.ToString()
        )
        MlirNative.mlirOperationPrint(op, callback, nativeint 0)
        output

    let moduleToString (m: MlirModule) : string =
        let op = MlirNative.mlirModuleGetOperation(m)
        operationToString op

    let valueToString (v: MlirValue) : string =
        let mutable output = ""
        let callback = MlirStringCallback(fun strRef _ -&gt;
            output &lt;- output + strRef.ToString()
        )
        MlirNative.mlirValuePrint(v, callback, nativeint 0)
        output

    let createContextWithDialects() : MlirContext =
        let ctx = MlirNative.mlirContextCreate()
        MlirNative.mlirDialectHandleRegisterDialect(MlirNative.mlirGetDialectHandle__func__(), ctx)
        MlirNative.mlirDialectHandleRegisterDialect(MlirNative.mlirGetDialectHandle__arith__(), ctx)
        MlirNative.mlirDialectHandleRegisterDialect(MlirNative.mlirGetDialectHandle__scf__(), ctx)
        MlirNative.mlirDialectHandleRegisterDialect(MlirNative.mlirGetDialectHandle__cf__(), ctx)
        MlirNative.mlirDialectHandleRegisterDialect(MlirNative.mlirGetDialectHandle__llvm__(), ctx)
        ctx
</code></pre>
<p>이것이 완전하고 프로덕션에 사용할 수 있는 MLIR 바인딩 레이어이다.</p>
<h2 id="라이브러리-빌드"><a class="header" href="#라이브러리-빌드">라이브러리 빌드</a></h2>
<p>라이브러리 프로젝트를 빌드한다:</p>
<pre><code class="language-bash">cd $HOME/mlir-fsharp-tutorial/MlirBindings
dotnet build
</code></pre>
<p>예상 출력:</p>
<pre><code>Build succeeded.
    0 Warning(s)
    0 Error(s)
</code></pre>
<p>컴파일된 라이브러리는 <code>bin/Debug/net8.0/MlirBindings.dll</code>에 위치한다.</p>
<h2 id="바인딩-사용하기"><a class="header" href="#바인딩-사용하기">바인딩 사용하기</a></h2>
<p>새 바인딩을 사용하여 Chapter 02의 hello-world 예제를 다시 작성해 본다. 새 콘솔 프로젝트를 생성한다:</p>
<pre><code class="language-bash">cd $HOME/mlir-fsharp-tutorial
dotnet new console -lang F# -o HelloMlirWithBindings
cd HelloMlirWithBindings
dotnet add reference ../MlirBindings/MlirBindings.fsproj
</code></pre>
<p><code>Program.fs</code>의 내용을 다음으로 교체한다:</p>
<pre><code class="language-fsharp">open System
open MlirBindings

[&lt;EntryPoint&gt;]
let main argv =
    // Create context with dialects
    let ctx = MlirHelpers.createContextWithDialects()
    printfn "Created MLIR context with dialects loaded"

    // Create empty module
    let loc = MlirNative.mlirLocationUnknownGet(ctx)
    let mlirModule = MlirNative.mlirModuleCreateEmpty(loc)
    printfn "Created empty module"

    // Print the module
    printfn "\nGenerated MLIR IR:"
    printfn "%s" (MlirHelpers.moduleToString mlirModule)

    // Cleanup
    MlirNative.mlirModuleDestroy(mlirModule)
    MlirNative.mlirContextDestroy(ctx)
    printfn "\nCleaned up"

    0
</code></pre>
<p>실행한다:</p>
<pre><code class="language-bash">LD_LIBRARY_PATH=$HOME/mlir-install/lib dotnet run
</code></pre>
<p>예상 출력:</p>
<pre><code>Created MLIR context with dialects loaded
Created empty module

Generated MLIR IR:
module {
}

Cleaned up
</code></pre>
<p>Chapter 02보다 훨씬 깔끔하다! 바인딩 모듈이 모든 마샬링과 보일러플레이트를 처리한다.</p>
<h2 id="이-장에서-배운-내용"><a class="header" href="#이-장에서-배운-내용">이 장에서 배운 내용</a></h2>
<p>이 장에서는 다음을 수행했다:</p>
<ol>
<li><strong>MLIR 바인딩을 구성하여</strong> 논리적 섹션으로 나뉜 재사용 가능한 F# 라이브러리 모듈을 만들었다.</li>
<li><strong>포괄적인 핸들 타입을 정의하여</strong> 모든 MLIR 엔티티(context, module, operation, type, region, block, value, attribute)를 다루었다.</li>
<li><strong>안전한 문자열 마샬링을 구현하여</strong> <code>MlirStringRef</code>와 헬퍼 유틸리티를 만들었다.</li>
<li><strong>P/Invoke 바인딩을 선언하여</strong> 컴파일에 필요한 MLIR C API의 전체 표면적을 다루었다.</li>
<li><strong>헬퍼 유틸리티를 생성하여</strong> 보일러플레이트를 줄였다 (출력, context 생성).</li>
<li><strong>크로스 플랫폼 고려 사항을</strong> 이해하여 라이브러리 로딩을 다루었다.</li>
<li><strong>바인딩 라이브러리를 빌드하고 사용하여</strong> 별도의 프로젝트에서 활용했다.</li>
</ol>
<p>이제 MLIR에 대한 완전하고 프로덕션에 사용할 수 있는 바인딩 레이어를 갖추었다. 이 <code>MlirBindings</code> 모듈은 FunLang 컴파일러를 구축하는 이후 모든 장의 기반이 된다.</p>
<h2 id="다음-장-1"><a class="header" href="#다음-장-1">다음 장</a></h2>
<p>다음 장에서는 FunLang 컴파일러 백엔드 구축을 시작한다. 타입이 지정된 FunLang AST를 F#에서 표현하기 위한 데이터 구조를 정의하고, 여기서 만든 바인딩을 사용하여 FunLang 표현식을 MLIR operation으로 변환하는 코드 생성 로직을 작성하기 시작한다.</p>
<p><strong>Chapter 04: FunLang AST에서 MLIR로</strong> (작성 예정)로 이어진다.</p>
<h2 id="참고-자료-1"><a class="header" href="#참고-자료-1">참고 자료</a></h2>
<ul>
<li><a href="https://mlir.llvm.org/docs/CAPI/">MLIR C API Documentation</a> – 공식 C API 가이드</li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/standard/native-interop/best-practices">P/Invoke Best Practices</a> – 안전하고 고성능의 interop을 위한 Microsoft의 가이드라인</li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/standard/native-interop/tutorial-custom-marshaller">Memory Management in P/Invoke</a> – 관리/비관리 메모리 경계 이해</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-04-f-래퍼-레이어"><a class="header" href="#chapter-04-f-래퍼-레이어">Chapter 04: F# 래퍼 레이어</a></h1>
<h2 id="소개-4"><a class="header" href="#소개-4">소개</a></h2>
<p>Chapter 03에서는 MLIR C API에 대한 완전한 P/Invoke 바인딩 모듈인 <code>MlirBindings.fs</code>를 구축했다. 이제 Context를 생성하고, Module을 만들며, Operation을 구성하는 등 MLIR C API의 모든 기능을 F#에서 호출할 수 있다.</p>
<p>하지만 Chapter 02와 03의 코드를 살펴보면 몇 가지 문제점이 드러난다:</p>
<p><strong>문제 1: 리소스 누수 위험</strong></p>
<pre><code class="language-fsharp">let ctx = MlirNative.mlirContextCreate()
let loc = MlirNative.mlirLocationUnknownGet(ctx)
let mlirMod = MlirNative.mlirModuleCreateEmpty(loc)

// ... IR 구축 ...

// 정리를 잊어버리면 메모리 누수 발생
MlirNative.mlirModuleDestroy(mlirMod)
MlirNative.mlirContextDestroy(ctx)
</code></pre>
<p>수동으로 <code>Destroy</code> 함수를 호출해야 한다. 예외가 발생하거나 조기 반환이 있으면 리소스가 누수된다.</p>
<p><strong>문제 2: 장황함</strong></p>
<pre><code class="language-fsharp">let state = MlirNative.mlirOperationStateGet(
    MlirStringRef.FromString("arith.constant"),
    location)
MlirNative.mlirOperationStateAddResults(&amp;state, 1, &amp;intType)
// ... 더 많은 state 조작 ...
let op = MlirNative.mlirOperationCreate(&amp;state)
</code></pre>
<p>Operation 하나를 만드는데 5-10줄의 코드가 필요하다. 반복적이고 오류가 발생하기 쉽다.</p>
<p><strong>문제 3: 타입 안전성 부족</strong></p>
<pre><code class="language-fsharp">let ctx = MlirNative.mlirContextCreate()
MlirNative.mlirContextDestroy(ctx)
// ctx는 이제 무효하지만, 타입 시스템이 이를 막지 못한다
let loc = MlirNative.mlirLocationUnknownGet(ctx) // 버그!
</code></pre>
<p>핸들을 해제한 후에도 여전히 사용할 수 있다. C API는 이를 막지 못한다.</p>
<p>이 장에서는 이러한 문제들을 해결하는 <strong>래퍼 레이어</strong>를 구축한다. 이 레이어는 원시 P/Invoke 바인딩을 관용적인 F# API로 감싸서 다음을 제공한다:</p>
<ul>
<li><strong>자동 리소스 관리</strong>: <code>IDisposable</code>과 <code>use</code> 키워드</li>
<li><strong>간결한 API</strong>: <code>OpBuilder.CreateConstant(42)</code> 같은 유창한 빌더</li>
<li><strong>생명주기 안전성</strong>: 부모 객체가 자식보다 먼저 파괴되는 것을 방지</li>
</ul>
<p>이 장을 마치면 튜토리얼의 나머지 부분에서 사용할 깔끔하고 안전한 MLIR API를 갖게 된다.</p>
<h2 id="소유권-문제"><a class="header" href="#소유권-문제">소유권 문제</a></h2>
<p>MLIR은 엄격한 소유권 계층 구조를 갖는다:</p>
<pre><code>Context (root)
  └─ Module
       └─ Operation
            └─ Region
                 └─ Block
                      └─ Operation
</code></pre>
<p>각 객체는 부모에 속한다:</p>
<ul>
<li><strong>Module</strong>은 <strong>Context</strong>가 소유한다</li>
<li><strong>Operation</strong>은 <strong>Block</strong>이 소유한다</li>
<li><strong>Block</strong>은 <strong>Region</strong>이 소유한다</li>
<li><strong>Region</strong>은 <strong>Operation</strong>이 소유한다</li>
</ul>
<p>C++에서는 이 소유권이 자동으로 관리된다 (RAII와 unique_ptr). 부모가 파괴되면 자식도 자동으로 파괴된다.</p>
<p>P/Invoke에서는 이 소유권을 수동으로 관리해야 한다. 문제는 부모를 먼저 파괴하면 자식 핸들이 무효가 된다는 것이다:</p>
<pre><code class="language-fsharp">// 버그가 있는 코드
let ctx = MlirNative.mlirContextCreate()
let loc = MlirNative.mlirLocationUnknownGet(ctx)
let mlirMod = MlirNative.mlirModuleCreateEmpty(loc)

// Context를 먼저 파괴
MlirNative.mlirContextDestroy(ctx)

// Module 핸들이 이제 무효 - 위험한 포인터!
MlirNative.mlirModuleGetOperation(mlirMod) // 세그멘테이션 폴트
</code></pre>
<p>F#의 가비지 컬렉터는 MLIR의 소유권 규칙을 알지 못한다. 따라서 우리가 강제해야 한다.</p>
<p><strong>해결책:</strong> F# 래퍼는 부모 객체에 대한 참조를 저장한다. 자식이 살아있는 한 부모는 가비지 컬렉트되지 않는다.</p>
<pre><code class="language-fsharp">type Module(context: Context, location: Location) =
    let handle = MlirNative.mlirModuleCreateEmpty(location.Handle)
    let contextRef = context  // 부모 참조 유지 - Context가 먼저 GC되는 것을 방지

    member _.Handle = handle

    interface IDisposable with
        member _.Dispose() =
            MlirNative.mlirModuleDestroy(handle)
</code></pre>
<h2 id="context-래퍼"><a class="header" href="#context-래퍼">Context 래퍼</a></h2>
<p>MLIR의 최상위 객체인 Context부터 시작한다. 새 파일 <code>MlirWrapper.fs</code>를 만든다:</p>
<pre><code class="language-fsharp">namespace MlirWrapper

open System
open MlirBindings

/// MLIR Context를 나타낸다. 모든 MLIR 객체의 소유자이며 메모리 관리를 담당한다.
/// Context는 dialect와 type을 등록하고 IR 구성을 위한 전역 환경을 제공한다.
type Context() =
    let mutable handle = MlirNative.mlirContextCreate()
    let mutable disposed = false

    /// 기본 MLIR context 핸들
    member _.Handle = handle

    /// 이 context에 dialect를 로드한다.
    /// dialect: 로드할 dialect의 이름 (예: "arith", "func", "llvm")
    member _.LoadDialect(dialect: string) =
        if disposed then
            raise (ObjectDisposedException("Context"))

        MlirStringRef.WithString dialect (fun nameRef -&gt;
            MlirNative.mlirContextGetOrLoadDialect(handle, nameRef)
            |&gt; ignore)

    interface IDisposable with
        member this.Dispose() =
            this.Dispose(true)
            GC.SuppressFinalize(this)

    member private _.Dispose(disposing: bool) =
        if not disposed then
            if disposing then
                // 관리 리소스 정리 (이 경우 없음)
                ()

            // 비관리 리소스 정리
            MlirNative.mlirContextDestroy(handle)
            handle &lt;- Unchecked.defaultof&lt;_&gt;
            disposed &lt;- true
</code></pre>
<blockquote>
<p><strong>설계 결정:</strong> <code>disposed</code> 플래그는 이중 해제를 방지한다. 동일한 Context에서 <code>Dispose()</code>를 두 번 호출하는 것은 안전하다 (두 번째 호출은 아무 작업도 하지 않는다).</p>
</blockquote>
<p><strong>사용 예:</strong></p>
<pre><code class="language-fsharp">let example () =
    use ctx = new Context()          // Context 생성
    ctx.LoadDialect("arith")         // Arithmetic dialect 로드
    ctx.LoadDialect("func")          // Function dialect 로드

    // ctx 사용...
    printfn "Context created: %A" ctx.Handle

    // 스코프가 끝나면 자동으로 Dispose 호출됨 - mlirContextDestroy 호출
</code></pre>
<p>F#의 <code>use</code> 키워드는 C#의 <code>using</code>과 동일하다. 스코프가 끝나면 자동으로 <code>Dispose()</code>를 호출한다. 예외가 발생해도 정리가 보장된다.</p>
<h2 id="location-래퍼"><a class="header" href="#location-래퍼">Location 래퍼</a></h2>
<p>Location은 MLIR의 가벼운 값 타입이다. 리소스를 소유하지 않으므로 <code>IDisposable</code>이 필요하지 않다:</p>
<pre><code class="language-fsharp">/// MLIR IR에서 소스 위치를 나타낸다. 컴파일 오류 보고에 사용된다.
type Location =
    | Unknown of Context
    | FileLineCol of Context * filename: string * line: int * col: int

    /// 기본 MLIR location 핸들을 반환한다
    member this.Handle =
        match this with
        | Unknown ctx -&gt;
            MlirNative.mlirLocationUnknownGet(ctx.Handle)

        | FileLineCol (ctx, filename, line, col) -&gt;
            MlirStringRef.WithString filename (fun filenameRef -&gt;
                MlirNative.mlirLocationFileLineColGet(
                    ctx.Handle,
                    filenameRef,
                    uint32 line,
                    uint32 col))
</code></pre>
<blockquote>
<p><strong>설계 결정:</strong> 모든 MLIR 타입이 <code>IDisposable</code>을 필요로 하는 것은 아니다. Location, Type, Attribute는 값 타입이며 Context가 소유한다. 명시적 정리가 필요 없다.</p>
</blockquote>
<p><strong>사용 예:</strong></p>
<pre><code class="language-fsharp">use ctx = new Context()

let loc1 = Location.Unknown(ctx)
let loc2 = Location.FileLineCol(ctx, "example.fun", 10, 5)

printfn "Unknown location: %A" loc1.Handle
printfn "File location: %A" loc2.Handle
</code></pre>
<h2 id="module-래퍼"><a class="header" href="#module-래퍼">Module 래퍼</a></h2>
<p>Module은 MLIR IR의 최상위 컨테이너다. 여러 함수와 전역 선언을 포함한다:</p>
<pre><code class="language-fsharp">/// MLIR Module - 최상위 IR 컨테이너. 함수와 전역 선언을 포함한다.
type Module(context: Context, location: Location) =
    let handle = MlirNative.mlirModuleCreateEmpty(location.Handle)
    let contextRef = context  // Context 참조 유지 - 조기 GC 방지
    let mutable disposed = false

    /// 기본 MLIR module 핸들
    member _.Handle = handle

    /// 이 module이 속한 context
    member _.Context = contextRef

    /// 이 module의 body block을 반환한다 (최상위 operation들을 포함)
    member _.Body =
        let op = MlirNative.mlirModuleGetOperation(handle)
        let region = MlirNative.mlirOperationGetRegion(op, 0n)
        MlirNative.mlirRegionGetFirstBlock(region)

    /// MLIR IR을 검증한다. 모든 operation이 올바른 형식인지 확인한다.
    member _.Verify() =
        let op = MlirNative.mlirModuleGetOperation(handle)
        MlirNative.mlirOperationVerify(op)

    /// MLIR IR을 문자열로 출력한다
    member _.Print() =
        let op = MlirNative.mlirModuleGetOperation(handle)
        MlirHelpers.operationToString(op)

    interface IDisposable with
        member this.Dispose() =
            this.Dispose(true)
            GC.SuppressFinalize(this)

    member private _.Dispose(disposing: bool) =
        if not disposed then
            if disposing then
                ()

            MlirNative.mlirModuleDestroy(handle)
            disposed &lt;- true
</code></pre>
<blockquote>
<p><strong>설계 결정:</strong> <code>contextRef</code> 필드는 Module이 존재하는 한 Context가 가비지 컬렉트되지 않도록 보장한다. 이는 소유권 안전성의 핵심이다.</p>
</blockquote>
<p><strong>사용 예:</strong></p>
<pre><code class="language-fsharp">use ctx = new Context()
ctx.LoadDialect("func")

let loc = Location.Unknown(ctx)
use mlirMod = new Module(ctx, loc)

// IR 구축...

if mlirMod.Verify() then
    printfn "Module IR:\n%s" (mlirMod.Print())
else
    failwith "IR verification failed"
</code></pre>
<h2 id="opbuilder-ir-구축을-위한-유창한-api"><a class="header" href="#opbuilder-ir-구축을-위한-유창한-api">OpBuilder: IR 구축을 위한 유창한 API</a></h2>
<p>Operation을 만드는 것은 MLIR에서 가장 복잡한 작업이다. 원시 C API는 다음과 같다:</p>
<pre><code class="language-fsharp">// 원시 P/Invoke - 15줄
let mutable state = MlirNative.mlirOperationStateGet(
    MlirStringRef.FromString("arith.constant"), location)

let mutable intType = MlirNative.mlirIntegerTypeGet(ctx, 32u)
MlirNative.mlirOperationStateAddResults(&amp;state, 1, &amp;intType)

let value = 42
let mutable attr = MlirNative.mlirIntegerAttrGet(intType, int64 value)
let mutable attrName = MlirStringRef.FromString("value")
MlirNative.mlirOperationStateAddAttributes(&amp;state, 1, &amp;attrName, &amp;attr)

let op = MlirNative.mlirOperationCreate(&amp;state)
</code></pre>
<p>이것을 한 줄로 줄이고 싶다:</p>
<pre><code class="language-fsharp">let op = builder.CreateConstant(42, intType, location)
</code></pre>
<p><code>OpBuilder</code> 클래스가 이를 가능하게 한다:</p>
<pre><code class="language-fsharp">/// MLIR operation을 구축하기 위한 유창한 빌더 API.
/// 원시 operation state 조작을 숨기고 일반적인 operation에 대한 고수준 메서드를 제공한다.
type OpBuilder(context: Context) =
    let contextRef = context

    /// i32 타입을 반환한다
    member _.I32Type() =
        MlirNative.mlirIntegerTypeGet(contextRef.Handle, 32u)

    /// i64 타입을 반환한다
    member _.I64Type() =
        MlirNative.mlirIntegerTypeGet(contextRef.Handle, 64u)

    /// 함수 타입을 생성한다 (inputs -&gt; results)
    member _.FunctionType(inputs: MlirType[], results: MlirType[]) =
        let mutable inputsArray = inputs
        let mutable resultsArray = results
        MlirNative.mlirFunctionTypeGet(
            contextRef.Handle,
            unativeint inputs.Length,
            &amp;&amp;inputsArray.[0],
            unativeint results.Length,
            &amp;&amp;resultsArray.[0])

    /// 정수 상수 operation을 생성한다: arith.constant
    member _.CreateConstant(value: int, typ: MlirType, location: Location) =
        let mutable state = MlirNative.mlirOperationStateGet(
            MlirStringRef.FromString("arith.constant"),
            location.Handle)

        // 결과 타입 추가
        let mutable resultType = typ
        MlirNative.mlirOperationStateAddResults(&amp;state, 1n, &amp;&amp;resultType)

        // value attribute 추가
        let mutable attr = MlirNative.mlirIntegerAttrGet(typ, int64 value)
        let mutable attrName = MlirStringRef.FromString("value")
        MlirNative.mlirOperationStateAddAttributes(&amp;state, 1n, &amp;&amp;attrName, &amp;&amp;attr)

        MlirNative.mlirOperationCreate(&amp;state)

    /// 함수 operation을 생성한다: func.func
    member _.CreateFunction(name: string, funcType: MlirType, location: Location) =
        let mutable state = MlirNative.mlirOperationStateGet(
            MlirStringRef.FromString("func.func"),
            location.Handle)

        // sym_name attribute 추가 (함수 이름)
        MlirStringRef.WithString name (fun nameRef -&gt;
            let mutable attr = MlirNative.mlirStringAttrGet(contextRef.Handle, nameRef)
            let mutable attrName = MlirStringRef.FromString("sym_name")
            MlirNative.mlirOperationStateAddAttributes(&amp;state, 1n, &amp;&amp;attrName, &amp;&amp;attr))

        // function_type attribute 추가
        let mutable funcTypeAttr = MlirNative.mlirTypeAttrGet(funcType)
        let mutable funcTypeAttrName = MlirStringRef.FromString("function_type")
        MlirNative.mlirOperationStateAddAttributes(&amp;state, 1n, &amp;&amp;funcTypeAttrName, &amp;&amp;funcTypeAttr)

        // body region 추가
        let mutable numRegions = 1n
        MlirNative.mlirOperationStateAddOwnedRegions(&amp;state, numRegions)

        MlirNative.mlirOperationCreate(&amp;state)

    /// return operation을 생성한다: func.return
    member _.CreateReturn(values: MlirValue[], location: Location) =
        let mutable state = MlirNative.mlirOperationStateGet(
            MlirStringRef.FromString("func.return"),
            location.Handle)

        // operand 추가
        if values.Length &gt; 0 then
            let mutable operands = values
            MlirNative.mlirOperationStateAddOperands(&amp;state, unativeint values.Length, &amp;&amp;operands.[0])

        MlirNative.mlirOperationCreate(&amp;state)

    /// Block에서 operation의 결과 value를 가져온다
    member _.GetResult(op: MlirOperation, index: int) =
        MlirNative.mlirOperationGetResult(op, unativeint index)
</code></pre>
<blockquote>
<p><strong>설계 결정:</strong> <code>OpBuilder</code>는 MLIR의 복잡성 대부분을 숨긴다. 일반적인 operation (constant, function, return)에 대해 고수준 메서드를 제공한다. 드물게 사용되는 operation은 직접 원시 API를 사용할 수 있다.</p>
</blockquote>
<h2 id="타입-헬퍼"><a class="header" href="#타입-헬퍼">타입 헬퍼</a></h2>
<p>타입 생성을 더 편리하게 만드는 모듈:</p>
<pre><code class="language-fsharp">/// MLIR 타입 생성을 위한 헬퍼 함수들
module MLIRType =
    /// i32 타입을 반환한다
    let i32 (ctx: Context) =
        MlirNative.mlirIntegerTypeGet(ctx.Handle, 32u)

    /// i64 타입을 반환한다
    let i64 (ctx: Context) =
        MlirNative.mlirIntegerTypeGet(ctx.Handle, 64u)

    /// 함수 타입을 생성한다
    let func (ctx: Context) (inputs: MlirType[]) (results: MlirType[]) =
        let mutable inputsArray = inputs
        let mutable resultsArray = results
        MlirNative.mlirFunctionTypeGet(
            ctx.Handle,
            unativeint inputs.Length,
            (if inputs.Length &gt; 0 then &amp;&amp;inputsArray.[0] else nativeint 0),
            unativeint results.Length,
            (if results.Length &gt; 0 then &amp;&amp;resultsArray.[0] else nativeint 0))
</code></pre>
<h2 id="모두-함께-사용하기"><a class="header" href="#모두-함께-사용하기">모두 함께 사용하기</a></h2>
<p>이제 래퍼를 사용하여 Chapter 02의 “hello-mlir” 예제를 다시 작성해 본다. 비교를 위해 두 버전을 나란히 보자:</p>
<p><strong>원시 P/Invoke 버전 (Chapter 02):</strong></p>
<pre><code class="language-fsharp">// 35+ 줄, 수동 정리, 장황함
let ctx = MlirNative.mlirContextCreate()

MlirStringRef.WithString "arith" (fun dialectName -&gt;
    MlirNative.mlirContextGetOrLoadDialect(ctx, dialectName) |&gt; ignore)

MlirStringRef.WithString "func" (fun dialectName -&gt;
    MlirNative.mlirContextGetOrLoadDialect(ctx, dialectName) |&gt; ignore)

let loc = MlirNative.mlirLocationUnknownGet(ctx)
let mlirMod = MlirNative.mlirModuleCreateEmpty(loc)

// ... 더 많은 장황한 코드 ...

MlirNative.mlirModuleDestroy(mlirMod)
MlirNative.mlirContextDestroy(ctx)
</code></pre>
<p><strong>래퍼 버전 (Chapter 04):</strong></p>
<pre><code class="language-fsharp">// 20줄, 자동 정리, 간결함
open MlirWrapper

let buildHelloMlir () =
    use ctx = new Context()
    ctx.LoadDialect("arith")
    ctx.LoadDialect("func")

    let loc = Location.Unknown(ctx)
    use mlirMod = new Module(ctx, loc)

    let builder = OpBuilder(ctx)
    let i32Type = builder.I32Type()

    // 함수 타입 생성: () -&gt; i32
    let funcType = builder.FunctionType([||], [| i32Type |])

    // 함수 operation 생성
    let funcOp = builder.CreateFunction("return_forty_two", funcType, loc)

    // 함수 body의 첫 번째 region과 block 가져오기
    let bodyRegion = MlirNative.mlirOperationGetRegion(funcOp, 0n)
    let entryBlock = MlirNative.mlirRegionGetFirstBlock(bodyRegion)

    // entry block이 비어있는지 확인하고, 비어있으면 새로 생성
    let block =
        if MlirNative.mlirBlockIsNull(entryBlock) then
            let newBlock = MlirNative.mlirBlockCreate(0n, nativeint 0, nativeint 0)
            MlirNative.mlirRegionAppendOwnedBlock(bodyRegion, newBlock)
            newBlock
        else
            entryBlock

    // 상수 operation 생성: %c42 = arith.constant 42 : i32
    let constOp = builder.CreateConstant(42, i32Type, loc)
    MlirNative.mlirBlockAppendOwnedOperation(block, constOp)

    // 상수의 결과 value 가져오기
    let constValue = builder.GetResult(constOp, 0)

    // return operation 생성: return %c42 : i32
    let returnOp = builder.CreateReturn([| constValue |], loc)
    MlirNative.mlirBlockAppendOwnedOperation(block, returnOp)

    // 함수를 module에 추가
    MlirNative.mlirBlockAppendOwnedOperation(mlirMod.Body, funcOp)

    // 검증 및 출력
    if mlirMod.Verify() then
        printfn "Generated MLIR:\n%s" (mlirMod.Print())
    else
        failwith "Module verification failed"

    // use가 자동으로 정리 처리
</code></pre>
<p><strong>개선 사항:</strong></p>
<ol>
<li><strong>자동 정리</strong>: <code>use</code> 키워드가 <code>Dispose()</code>를 자동으로 호출한다</li>
<li><strong>간결성</strong>: <code>builder.CreateConstant(42, i32Type, loc)</code> vs. 15줄의 state 조작</li>
<li><strong>타입 안전성</strong>: Context 참조가 Module이 살아있는 동안 유지됨을 보장</li>
<li><strong>가독성</strong>: 의도가 명확하고 보일러플레이트가 적음</li>
</ol>
<h2 id="완전한-래퍼-모듈-리스팅"><a class="header" href="#완전한-래퍼-모듈-리스팅">완전한 래퍼 모듈 리스팅</a></h2>
<p>다음은 완전한 <code>MlirWrapper.fs</code> 파일이다:</p>
<pre><code class="language-fsharp">namespace MlirWrapper

open System
open MlirBindings

/// MLIR Context - 모든 MLIR 객체의 소유자
type Context() =
    let mutable handle = MlirNative.mlirContextCreate()
    let mutable disposed = false

    member _.Handle = handle

    member _.LoadDialect(dialect: string) =
        if disposed then
            raise (ObjectDisposedException("Context"))

        MlirStringRef.WithString dialect (fun nameRef -&gt;
            MlirNative.mlirContextGetOrLoadDialect(handle, nameRef)
            |&gt; ignore)

    interface IDisposable with
        member this.Dispose() =
            this.Dispose(true)
            GC.SuppressFinalize(this)

    member private _.Dispose(disposing: bool) =
        if not disposed then
            if disposing then
                ()
            MlirNative.mlirContextDestroy(handle)
            handle &lt;- Unchecked.defaultof&lt;_&gt;
            disposed &lt;- true

/// MLIR Location - 소스 위치 정보
type Location =
    | Unknown of Context
    | FileLineCol of Context * filename: string * line: int * col: int

    member this.Handle =
        match this with
        | Unknown ctx -&gt;
            MlirNative.mlirLocationUnknownGet(ctx.Handle)
        | FileLineCol (ctx, filename, line, col) -&gt;
            MlirStringRef.WithString filename (fun filenameRef -&gt;
                MlirNative.mlirLocationFileLineColGet(
                    ctx.Handle, filenameRef, uint32 line, uint32 col))

/// MLIR Module - 최상위 IR 컨테이너
type Module(context: Context, location: Location) =
    let handle = MlirNative.mlirModuleCreateEmpty(location.Handle)
    let contextRef = context
    let mutable disposed = false

    member _.Handle = handle
    member _.Context = contextRef

    member _.Body =
        let op = MlirNative.mlirModuleGetOperation(handle)
        let region = MlirNative.mlirOperationGetRegion(op, 0n)
        MlirNative.mlirRegionGetFirstBlock(region)

    member _.Verify() =
        let op = MlirNative.mlirModuleGetOperation(handle)
        MlirNative.mlirOperationVerify(op)

    member _.Print() =
        let op = MlirNative.mlirModuleGetOperation(handle)
        MlirHelpers.operationToString(op)

    interface IDisposable with
        member this.Dispose() =
            this.Dispose(true)
            GC.SuppressFinalize(this)

    member private _.Dispose(disposing: bool) =
        if not disposed then
            if disposing then
                ()
            MlirNative.mlirModuleDestroy(handle)
            disposed &lt;- true

/// Operation 빌더 - 유창한 IR 구축 API
type OpBuilder(context: Context) =
    let contextRef = context

    member _.I32Type() =
        MlirNative.mlirIntegerTypeGet(contextRef.Handle, 32u)

    member _.I64Type() =
        MlirNative.mlirIntegerTypeGet(contextRef.Handle, 64u)

    member _.FunctionType(inputs: MlirType[], results: MlirType[]) =
        let mutable inputsArray = inputs
        let mutable resultsArray = results
        MlirNative.mlirFunctionTypeGet(
            contextRef.Handle,
            unativeint inputs.Length,
            (if inputs.Length &gt; 0 then &amp;&amp;inputsArray.[0] else nativeint 0),
            unativeint results.Length,
            (if results.Length &gt; 0 then &amp;&amp;resultsArray.[0] else nativeint 0))

    member _.CreateConstant(value: int, typ: MlirType, location: Location) =
        let mutable state = MlirNative.mlirOperationStateGet(
            MlirStringRef.FromString("arith.constant"), location.Handle)

        let mutable resultType = typ
        MlirNative.mlirOperationStateAddResults(&amp;state, 1n, &amp;&amp;resultType)

        let mutable attr = MlirNative.mlirIntegerAttrGet(typ, int64 value)
        let mutable attrName = MlirStringRef.FromString("value")
        MlirNative.mlirOperationStateAddAttributes(&amp;state, 1n, &amp;&amp;attrName, &amp;&amp;attr)

        MlirNative.mlirOperationCreate(&amp;state)

    member _.CreateFunction(name: string, funcType: MlirType, location: Location) =
        let mutable state = MlirNative.mlirOperationStateGet(
            MlirStringRef.FromString("func.func"), location.Handle)

        MlirStringRef.WithString name (fun nameRef -&gt;
            let mutable attr = MlirNative.mlirStringAttrGet(contextRef.Handle, nameRef)
            let mutable attrName = MlirStringRef.FromString("sym_name")
            MlirNative.mlirOperationStateAddAttributes(&amp;state, 1n, &amp;&amp;attrName, &amp;&amp;attr))

        let mutable funcTypeAttr = MlirNative.mlirTypeAttrGet(funcType)
        let mutable funcTypeAttrName = MlirStringRef.FromString("function_type")
        MlirNative.mlirOperationStateAddAttributes(&amp;state, 1n, &amp;&amp;funcTypeAttrName, &amp;&amp;funcTypeAttr)

        let mutable numRegions = 1n
        MlirNative.mlirOperationStateAddOwnedRegions(&amp;state, numRegions)

        MlirNative.mlirOperationCreate(&amp;state)

    member _.CreateReturn(values: MlirValue[], location: Location) =
        let mutable state = MlirNative.mlirOperationStateGet(
            MlirStringRef.FromString("func.return"), location.Handle)

        if values.Length &gt; 0 then
            let mutable operands = values
            MlirNative.mlirOperationStateAddOperands(&amp;state, unativeint values.Length, &amp;&amp;operands.[0])

        MlirNative.mlirOperationCreate(&amp;state)

    member _.GetResult(op: MlirOperation, index: int) =
        MlirNative.mlirOperationGetResult(op, unativeint index)

/// 타입 생성 헬퍼
module MLIRType =
    let i32 (ctx: Context) =
        MlirNative.mlirIntegerTypeGet(ctx.Handle, 32u)

    let i64 (ctx: Context) =
        MlirNative.mlirIntegerTypeGet(ctx.Handle, 64u)

    let func (ctx: Context) (inputs: MlirType[]) (results: MlirType[]) =
        let mutable inputsArray = inputs
        let mutable resultsArray = results
        MlirNative.mlirFunctionTypeGet(
            ctx.Handle,
            unativeint inputs.Length,
            (if inputs.Length &gt; 0 then &amp;&amp;inputsArray.[0] else nativeint 0),
            unativeint results.Length,
            (if results.Length &gt; 0 then &amp;&amp;resultsArray.[0] else nativeint 0))
</code></pre>
<h2 id="배운-것"><a class="header" href="#배운-것">배운 것</a></h2>
<p>이 장에서 다음을 배웠다:</p>
<ol>
<li><strong>소유권 관리</strong>: MLIR의 계층적 소유권과 F#에서 부모 참조로 이를 강제하는 방법</li>
<li><strong>IDisposable 패턴</strong>: 자동 리소스 정리를 위한 <code>use</code> 키워드</li>
<li><strong>빌더 패턴</strong>: 복잡한 API를 간단한 메서드 호출로 감싸는 <code>OpBuilder</code></li>
<li><strong>타입 안전성</strong>: 장황함 없이 컴파일 시점 타입 검사를 제공하는 F# 래퍼</li>
</ol>
<h2 id="다음-단계-1"><a class="header" href="#다음-단계-1">다음 단계</a></h2>
<p>Chapter 05에서는 이 래퍼 레이어를 사용하여 <strong>완전한 컴파일러</strong>를 구축한다. 정수 리터럴을 갖는 간단한 FunLang 프로그램을 파싱하고, MLIR IR로 변환하며, LLVM dialect로 낮추고, 네이티브 바이너리로 컴파일하여 실행할 것이다.</p>
<p>이것이 Phase 1의 정점이다 – 실제 코드를 실행하는 것이다!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-05-산술-컴파일러---첫-번째-네이티브-바이너리"><a class="header" href="#chapter-05-산술-컴파일러---첫-번째-네이티브-바이너리">Chapter 05: 산술 컴파일러 - 첫 번째 네이티브 바이너리</a></h1>
<h2 id="소개-5"><a class="header" href="#소개-5">소개</a></h2>
<p>지금까지의 여정:</p>
<ul>
<li><strong>Chapter 00</strong>: LLVM/MLIR을 빌드하고 .NET SDK를 설치했다</li>
<li><strong>Chapter 01</strong>: MLIR 개념 (dialect, operation, region, block, SSA)을 배웠다</li>
<li><strong>Chapter 02</strong>: F#에서 처음으로 MLIR IR을 생성했다</li>
<li><strong>Chapter 03</strong>: 완전한 P/Invoke 바인딩 모듈을 구축했다</li>
<li><strong>Chapter 04</strong>: 안전하고 관용적인 F# 래퍼 레이어를 만들었다</li>
</ul>
<p>이제 보상을 받을 시간이다.</p>
<p>이 장에서는 <strong>실제 컴파일러</strong>를 구축한다. 소스 코드를 입력으로 받아 실행 가능한 네이티브 바이너리를 출력하는 컴파일러다. 단순화를 위해 FunLang의 매우 작은 부분집합, 즉 <strong>정수 리터럴</strong>만 다룬다. 이것이 사소해 보일 수 있지만 전체 컴파일 파이프라인을 보여준다:</p>
<pre><code>Source code → AST → MLIR IR → Lowering → LLVM IR → Object file → Native binary
</code></pre>
<p>이 장을 마치면 <code>42</code>를 네이티브 실행 파일로 컴파일하고 실행하여 프로그램 종료 코드로 <code>42</code>를 볼 수 있다.</p>
<blockquote>
<p><strong>마일스톤:</strong> 이것은 Phase 1의 정점이다. 이 장 이후에는 실제 코드를 컴파일하고 실행하는 작동하는 컴파일러를 갖게 된다!</p>
</blockquote>
<h2 id="funlang-부분집합"><a class="header" href="#funlang-부분집합">FunLang 부분집합</a></h2>
<p>지금은 단 하나의 구문만 지원한다:</p>
<pre><code>program ::= &lt;integer&gt;
</code></pre>
<p>예시:</p>
<ul>
<li><code>42</code></li>
<li><code>0</code></li>
<li><code>1337</code></li>
</ul>
<p>이 프로그램은 정수를 종료 코드로 반환한다. Unix에서는 <code>$?</code>로 확인할 수 있다:</p>
<pre><code class="language-bash">./program
echo $?  # 42 출력
</code></pre>
<p>단순해 보이지만 이것은 다음을 포함한 <strong>완전한 컴파일 파이프라인</strong>을 요구한다:</p>
<ol>
<li>소스를 AST로 파싱</li>
<li>AST를 MLIR IR로 변환</li>
<li>MLIR IR 검증</li>
<li>LLVM dialect로 낮추기</li>
<li>LLVM IR로 변환</li>
<li>오브젝트 파일 생성</li>
<li>실행 파일로 링크</li>
</ol>
<h2 id="컴파일러-파이프라인-개요"><a class="header" href="#컴파일러-파이프라인-개요">컴파일러 파이프라인 개요</a></h2>
<p>전체 파이프라인을 시각화해 본다:</p>
<pre><code>┌─────────────┐
│   42        │  소스 코드 (문자열)
└──────┬──────┘
       │ parse
       ▼
┌─────────────┐
│ IntLiteral  │  타입 있는 AST
│   value=42  │
└──────┬──────┘
       │ translateToMlir
       ▼
┌──────────────────────────────┐
│ func.func @main() -&gt; i32 {   │  MLIR IR (high-level)
│   %c = arith.constant 42     │
│   return %c                  │
│ }                            │
└──────┬───────────────────────┘
       │ mlirPassManagerRun
       │ (convert-to-llvm)
       ▼
┌──────────────────────────────┐
│ llvm.func @main() -&gt; i32 {   │  MLIR IR (LLVM dialect)
│   %c = llvm.mlir.constant 42 │
│   llvm.return %c             │
│ }                            │
└──────┬───────────────────────┘
       │ mlirTranslateModuleToLLVMIR
       ▼
┌──────────────────────────────┐
│ define i32 @main() {         │  LLVM IR
│   ret i32 42                 │
│ }                            │
└──────┬───────────────────────┘
       │ llc -filetype=obj
       ▼
┌─────────────┐
│ program.o   │  오브젝트 파일 (ELF/Mach-O)
└──────┬──────┘
       │ cc -o program
       ▼
┌─────────────┐
│ ./program   │  네이티브 실행 파일
└─────────────┘
</code></pre>
<p>각 단계를 하나씩 구현해 본다.</p>
<h2 id="1단계-ast-정의와-파싱"><a class="header" href="#1단계-ast-정의와-파싱">1단계: AST 정의와 파싱</a></h2>
<p>먼저 FunLang AST의 부분집합을 정의한다. 새 파일 <code>Ast.fs</code>를 만든다:</p>
<pre><code class="language-fsharp">namespace FunLangCompiler

/// FunLang 표현식 AST
type Expr =
    | IntLiteral of int

/// 최상위 프로그램
type Program =
    { expr: Expr }
</code></pre>
<p>극도로 단순하다. 프로그램은 하나의 표현식이고, 표현식은 정수 리터럴이다.</p>
<p>이제 파서를 작성한다. 실제 프로젝트에서는 LangTutorial의 파서를 재사용할 것이다. 여기서는 단순성을 위해 <code>int.Parse</code>를 사용한다:</p>
<pre><code class="language-fsharp">/// 간단한 파서 - 문자열을 정수로 파싱
module Parser =
    open System

    let parse (source: string) : Program =
        let trimmed = source.Trim()
        match Int32.TryParse(trimmed) with
        | (true, value) -&gt;
            { expr = IntLiteral value }
        | (false, _) -&gt;
            failwithf "Parse error: expected integer, got '%s'" trimmed
</code></pre>
<p><strong>테스트:</strong></p>
<pre><code class="language-fsharp">let program = Parser.parse "42"
// { expr = IntLiteral 42 }
</code></pre>
<h2 id="2단계-ast를-mlir로-변환"><a class="header" href="#2단계-ast를-mlir로-변환">2단계: AST를 MLIR로 변환</a></h2>
<p>이제 핵심 컴파일 단계다. AST를 MLIR IR로 변환한다. 목표는 다음 IR을 생성하는 것이다:</p>
<pre><code class="language-mlir">module {
  func.func @main() -&gt; i32 {
    %c42 = arith.constant 42 : i32
    return %c42 : i32
  }
}
</code></pre>
<p>새 파일 <code>CodeGen.fs</code>를 만든다:</p>
<pre><code class="language-fsharp">namespace FunLangCompiler

open System
open MlirWrapper
open MlirBindings

/// AST를 MLIR IR로 변환
module CodeGen =

    /// 표현식을 MLIR value로 컴파일
    let rec compileExpr
        (builder: OpBuilder)
        (block: MlirBlock)
        (location: Location)
        (expr: Expr)
        : MlirValue =

        match expr with
        | IntLiteral value -&gt;
            // arith.constant operation 생성
            let i32Type = builder.I32Type()
            let constOp = builder.CreateConstant(value, i32Type, location)

            // block에 operation 추가
            MlirNative.mlirBlockAppendOwnedOperation(block, constOp)

            // 결과 value 반환
            builder.GetResult(constOp, 0)

    /// 프로그램을 MLIR module로 컴파일
    let translateToMlir (program: Program) : Module =
        let ctx = new Context()
        ctx.LoadDialect("arith")
        ctx.LoadDialect("func")

        let loc = Location.Unknown(ctx)
        let mlirMod = new Module(ctx, loc)

        let builder = OpBuilder(ctx)
        let i32Type = builder.I32Type()

        // main 함수 생성: () -&gt; i32
        let funcType = builder.FunctionType([||], [| i32Type |])
        let funcOp = builder.CreateFunction("main", funcType, loc)

        // 함수 body에 entry block 생성
        let bodyRegion = MlirNative.mlirOperationGetRegion(funcOp, 0n)
        let entryBlock = MlirNative.mlirBlockCreate(0n, nativeint 0, nativeint 0)
        MlirNative.mlirRegionAppendOwnedBlock(bodyRegion, entryBlock)

        // 표현식 컴파일 (상수 생성)
        let resultValue = compileExpr builder entryBlock loc program.expr

        // return operation 생성
        let returnOp = builder.CreateReturn([| resultValue |], loc)
        MlirNative.mlirBlockAppendOwnedOperation(entryBlock, returnOp)

        // 함수를 module에 추가
        MlirNative.mlirBlockAppendOwnedOperation(mlirMod.Body, funcOp)

        mlirMod
</code></pre>
<blockquote>
<p><strong>설계 결정:</strong> <code>compileExpr</code>은 재귀적이다. 현재는 IntLiteral만 처리하지만, 나중 장에서 더 많은 케이스 (BinaryOp, IfThenElse, FunctionCall 등)를 추가할 것이다.</p>
</blockquote>
<p><strong>테스트:</strong></p>
<pre><code class="language-fsharp">let program = Parser.parse "42"
let mlirMod = CodeGen.translateToMlir program
printfn "%s" (mlirMod.Print())
</code></pre>
<p><strong>출력:</strong></p>
<pre><code class="language-mlir">module {
  func.func @main() -&gt; i32 {
    %0 = arith.constant 42 : i32
    return %0 : i32
  }
}
</code></pre>
<h2 id="3단계-mlir-검증"><a class="header" href="#3단계-mlir-검증">3단계: MLIR 검증</a></h2>
<p>MLIR은 강력한 검증 인프라를 제공한다. 모든 operation이 올바른 형식인지 확인한다:</p>
<ul>
<li>모든 block이 terminator (return, branch 등)로 끝나는가?</li>
<li>SSA dominance 규칙이 존중되는가?</li>
<li>타입이 일치하는가?</li>
</ul>
<p><code>CodeGen.fs</code>에 검증 단계를 추가한다:</p>
<pre><code class="language-fsharp">    /// MLIR module을 검증. 실패 시 예외 발생.
    let verify (mlirMod: Module) =
        if not (mlirMod.Verify()) then
            eprintfn "MLIR verification failed:"
            eprintfn "%s" (mlirMod.Print())
            failwith "MLIR IR is invalid"
</code></pre>
<p><strong>사용:</strong></p>
<pre><code class="language-fsharp">let mlirMod = CodeGen.translateToMlir program
CodeGen.verify mlirMod  // 실패 시 예외 발생
</code></pre>
<blockquote>
<p><strong>마일스톤:</strong> 이 시점에서 올바른 MLIR IR을 생성할 수 있다. 다음 단계는 LLVM으로 낮추는 것이다.</p>
</blockquote>
<h2 id="4단계-llvm-dialect로-낮추기"><a class="header" href="#4단계-llvm-dialect로-낮추기">4단계: LLVM Dialect로 낮추기</a></h2>
<p>MLIR IR은 계층적이다. 고수준 dialect (<code>arith</code>, <code>func</code>)에서 시작하여 LLVM dialect로 점진적으로 낮춘다. 이를 <strong>progressive lowering</strong>이라고 한다 (Chapter 01 참조).</p>
<p>MLIR의 pass manager를 사용하여 변환을 수행한다:</p>
<pre><code class="language-fsharp">namespace FunLangCompiler

open MlirBindings

/// MLIR lowering pass
module Lowering =

    /// arith와 func dialect를 LLVM dialect로 낮춘다
    let lowerToLLVMDialect (mlirMod: Module) =
        let ctx = mlirMod.Context

        // Pass manager 생성
        let pm = MlirNative.mlirPassManagerCreate(ctx.Handle)

        // convert-func-to-llvm pass 추가
        MlirStringRef.WithString "convert-func-to-llvm" (fun passName -&gt;
            let pass = MlirNative.mlirCreateConversionPass(passName)
            MlirNative.mlirPassManagerAddOwnedPass(pm, pass))

        // convert-arith-to-llvm pass 추가
        MlirStringRef.WithString "convert-arith-to-llvm" (fun passName -&gt;
            let pass = MlirNative.mlirCreateConversionPass(passName)
            MlirNative.mlirPassManagerAddOwnedPass(pm, pass))

        // Pass 실행
        let moduleOp = MlirNative.mlirModuleGetOperation(mlirMod.Handle)
        let success = MlirNative.mlirPassManagerRunOnOp(pm, moduleOp)

        if not success then
            failwith "MLIR lowering failed"

        // Pass manager 정리
        MlirNative.mlirPassManagerDestroy(pm)
</code></pre>
<blockquote>
<p><strong>아키텍처 노트:</strong> Pass는 MLIR의 강력한 기능이다. 각 pass는 IR을 변환한다 (최적화, 낮추기, 분석). 여러 pass를 체인으로 연결하여 복잡한 변환을 구성할 수 있다.</p>
</blockquote>
<p><strong>변환 전 (high-level):</strong></p>
<pre><code class="language-mlir">func.func @main() -&gt; i32 {
  %c42 = arith.constant 42 : i32
  return %c42 : i32
}
</code></pre>
<p><strong>변환 후 (LLVM dialect):</strong></p>
<pre><code class="language-mlir">llvm.func @main() -&gt; i32 {
  %c42 = llvm.mlir.constant(42 : i32) : i32
  llvm.return %c42 : i32
}
</code></pre>
<p>차이를 주목한다:</p>
<ul>
<li><code>func.func</code> → <code>llvm.func</code></li>
<li><code>arith.constant</code> → <code>llvm.mlir.constant</code></li>
<li><code>return</code> → <code>llvm.return</code></li>
</ul>
<p>이제 IR이 LLVM IR로 변환할 준비가 되었다.</p>
<h2 id="5단계-llvm-ir-변환"><a class="header" href="#5단계-llvm-ir-변환">5단계: LLVM IR 변환</a></h2>
<p>MLIR은 LLVM IR로 변환하는 빌트인 변환기를 제공한다. <code>Lowering.fs</code>에 추가한다:</p>
<pre><code class="language-fsharp">    open System.Runtime.InteropServices

    /// MLIR module (LLVM dialect)을 LLVM IR 문자열로 변환
    let translateToLLVMIR (mlirMod: Module) : string =
        let ctx = mlirMod.Context
        let moduleOp = MlirNative.mlirModuleGetOperation(mlirMod.Handle)

        // LLVM context 생성
        let llvmCtx = MlirNative.llvmContextCreate()

        // MLIR을 LLVM IR로 변환
        let llvmModule = MlirNative.mlirTranslateModuleToLLVMIR(
            moduleOp,
            llvmCtx)

        if llvmModule = nativeint 0 then
            failwith "Failed to translate MLIR to LLVM IR"

        // LLVM IR을 문자열로 출력
        let irString = MlirNative.llvmPrintModuleToString(llvmModule)

        // 정리
        MlirNative.llvmDisposeModule(llvmModule)
        MlirNative.llvmContextDispose(llvmCtx)

        Marshal.PtrToStringAnsi(irString)
</code></pre>
<blockquote>
<p><strong>구현 참고:</strong> MLIR C API는 LLVM IR로 변환하는 <code>mlirTranslateModuleToLLVMIR</code>을 제공한다. 그런 다음 LLVM C API (<code>llvmPrintModuleToString</code>)를 사용하여 문자열화한다.</p>
</blockquote>
<p><strong>출력 (LLVM IR):</strong></p>
<pre><code class="language-llvm">define i32 @main() {
  ret i32 42
}
</code></pre>
<p>완벽하다! 이것은 순수한 LLVM IR이다. MLIR 개념이 전혀 없다.</p>
<h2 id="6단계-오브젝트-파일-생성"><a class="header" href="#6단계-오브젝트-파일-생성">6단계: 오브젝트 파일 생성</a></h2>
<p>이제 LLVM IR을 네이티브 머신 코드로 컴파일해야 한다. LLVM의 <code>llc</code> 도구를 사용한다:</p>
<pre><code class="language-fsharp">namespace FunLangCompiler

open System
open System.IO
open System.Diagnostics

/// 네이티브 코드 생성
module NativeCodeGen =

    /// LLVM IR을 오브젝트 파일로 컴파일 (llc 사용)
    let emitObjectFile (llvmIR: string) (outputPath: string) =
        // 임시 .ll 파일에 LLVM IR 쓰기
        let llFile = Path.GetTempFileName() + ".ll"
        File.WriteAllText(llFile, llvmIR)

        try
            // llc 실행: .ll → .o
            let psi = ProcessStartInfo()
            psi.FileName &lt;- "llc"
            psi.Arguments &lt;- sprintf "-filetype=obj -o %s %s" outputPath llFile
            psi.RedirectStandardOutput &lt;- true
            psi.RedirectStandardError &lt;- true
            psi.UseShellExecute &lt;- false

            let proc = Process.Start(psi)
            proc.WaitForExit()

            if proc.ExitCode &lt;&gt; 0 then
                let stderr = proc.StandardError.ReadToEnd()
                failwithf "llc failed:\n%s" stderr

            printfn "Generated object file: %s" outputPath

        finally
            // 임시 파일 정리
            File.Delete(llFile)
</code></pre>
<blockquote>
<p><strong>도구 요구사항:</strong> <code>llc</code>는 LLVM 도구체인의 일부다. Chapter 00에서 LLVM을 빌드했다면 <code>$HOME/mlir-install/bin/llc</code>에 있다. PATH에 있는지 확인한다.</p>
</blockquote>
<p><strong>사용:</strong></p>
<pre><code class="language-fsharp">let llvmIR = Lowering.translateToLLVMIR mlirMod
NativeCodeGen.emitObjectFile llvmIR "program.o"
</code></pre>
<p>이제 <code>program.o</code>가 있다 – ELF 오브젝트 파일 (Linux) 또는 Mach-O (macOS).</p>
<h2 id="7단계-실행-파일로-링크"><a class="header" href="#7단계-실행-파일로-링크">7단계: 실행 파일로 링크</a></h2>
<p>마지막 단계는 오브젝트 파일을 실행 파일로 링크하는 것이다. 시스템 링커 (<code>cc</code> 또는 <code>clang</code>)를 사용한다:</p>
<pre><code class="language-fsharp">    /// 오브젝트 파일을 실행 파일로 링크 (cc 사용)
    let linkExecutable (objectPath: string) (outputPath: string) =
        let psi = ProcessStartInfo()
        psi.FileName &lt;- "cc"  // 또는 "clang"
        psi.Arguments &lt;- sprintf "-o %s %s" outputPath objectPath
        psi.RedirectStandardOutput &lt;- true
        psi.RedirectStandardError &lt;- true
        psi.UseShellExecute &lt;- false

        let proc = Process.Start(psi)
        proc.WaitForExit()

        if proc.ExitCode &lt;&gt; 0 then
            let stderr = proc.StandardError.ReadToEnd()
            failwithf "Linking failed:\n%s" stderr

        printfn "Generated executable: %s" outputPath
</code></pre>
<p><strong>사용:</strong></p>
<pre><code class="language-fsharp">NativeCodeGen.linkExecutable "program.o" "program"
</code></pre>
<p>완료! <code>./program</code> 실행 파일이 생성되었다.</p>
<h2 id="완전한-컴파일러-드라이버"><a class="header" href="#완전한-컴파일러-드라이버">완전한 컴파일러 드라이버</a></h2>
<p>모든 것을 <code>Compiler.fs</code>에 하나로 모은다:</p>
<pre><code class="language-fsharp">namespace FunLangCompiler

open System
open System.IO

/// 메인 컴파일러 드라이버
module Compiler =

    /// 소스 파일을 네이티브 실행 파일로 컴파일
    let compile (sourceFile: string) (outputFile: string) =
        printfn "=== FunLang Compiler ==="
        printfn "Source: %s" sourceFile
        printfn "Output: %s" outputFile
        printfn ""

        // 1단계: 파싱
        printfn "[1/7] Parsing..."
        let source = File.ReadAllText(sourceFile)
        let program = Parser.parse source
        printfn "  AST: %A" program

        // 2단계: MLIR로 변환
        printfn "[2/7] Translating to MLIR..."
        let mlirMod = CodeGen.translateToMlir program
        printfn "  MLIR (high-level):"
        printfn "%s" (mlirMod.Print())

        // 3단계: 검증
        printfn "[3/7] Verifying MLIR..."
        CodeGen.verify mlirMod
        printfn "  ✓ Verification passed"

        // 4단계: LLVM dialect로 낮추기
        printfn "[4/7] Lowering to LLVM dialect..."
        Lowering.lowerToLLVMDialect mlirMod
        printfn "  MLIR (LLVM dialect):"
        printfn "%s" (mlirMod.Print())

        // 5단계: LLVM IR로 변환
        printfn "[5/7] Translating to LLVM IR..."
        let llvmIR = Lowering.translateToLLVMIR mlirMod
        printfn "  LLVM IR:"
        printfn "%s" llvmIR

        // 6단계: 오브젝트 파일 생성
        printfn "[6/7] Emitting object file..."
        let objectFile = outputFile + ".o"
        NativeCodeGen.emitObjectFile llvmIR objectFile

        // 7단계: 링크
        printfn "[7/7] Linking executable..."
        NativeCodeGen.linkExecutable objectFile outputFile

        // 정리
        mlirMod.Dispose()

        printfn ""
        printfn "=== Compilation successful ==="
        printfn "Run: ./%s" outputFile
</code></pre>
<h2 id="실행해-보기"><a class="header" href="#실행해-보기">실행해 보기</a></h2>
<p>테스트 프로그램을 작성한다:</p>
<pre><code class="language-bash">echo "42" &gt; test.fun
</code></pre>
<p>컴파일한다:</p>
<pre><code class="language-bash">dotnet fsi Compiler.fs -- test.fun program
</code></pre>
<p><strong>출력:</strong></p>
<pre><code>=== FunLang Compiler ===
Source: test.fun
Output: program

[1/7] Parsing...
  AST: { expr = IntLiteral 42 }
[2/7] Translating to MLIR...
  MLIR (high-level):
module {
  func.func @main() -&gt; i32 {
    %0 = arith.constant 42 : i32
    return %0 : i32
  }
}
[3/7] Verifying MLIR...
  ✓ Verification passed
[4/7] Lowering to LLVM dialect...
  MLIR (LLVM dialect):
module {
  llvm.func @main() -&gt; i32 {
    %0 = llvm.mlir.constant(42 : i32) : i32
    llvm.return %0 : i32
  }
}
[5/7] Translating to LLVM IR...
  LLVM IR:
define i32 @main() {
  ret i32 42
}
[6/7] Emitting object file...
Generated object file: program.o
[7/7] Linking executable...
Generated executable: program

=== Compilation successful ===
Run: ./program
</code></pre>
<p>실행한다:</p>
<pre><code class="language-bash">./program
echo $?
</code></pre>
<p><strong>출력:</strong></p>
<pre><code>42
</code></pre>
<blockquote>
<p><strong>마일스톤:</strong> 축하한다! 실제 코드를 컴파일하고 실행했다! 🎉</p>
</blockquote>
<h2 id="구축한-것"><a class="header" href="#구축한-것">구축한 것</a></h2>
<p>이 장에서 다음을 성취했다:</p>
<ol>
<li>
<p><strong>완전한 컴파일 파이프라인</strong>:</p>
<ul>
<li>소스 → AST (파싱)</li>
<li>AST → MLIR IR (코드 생성)</li>
<li>MLIR 검증</li>
<li>High-level dialect → LLVM dialect (progressive lowering)</li>
<li>MLIR → LLVM IR (변환)</li>
<li>LLVM IR → 오브젝트 파일 (<code>llc</code>)</li>
<li>오브젝트 파일 → 실행 파일 (링커)</li>
</ul>
</li>
<li>
<p><strong>실제 컴파일러</strong>: 단순하지만 이것은 실제 컴파일러다. 텍스트를 받아 네이티브 머신 코드를 생성한다.</p>
</li>
<li>
<p><strong>확장 가능한 아키텍처</strong>: <code>compileExpr</code>은 재귀적이다. 나중 장에서 더 많은 표현식 타입을 추가할 것이다:</p>
<ul>
<li>Chapter 06: 이진 연산 (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>)</li>
<li>Chapter 07: Let 바인딩과 변수</li>
<li>Chapter 08: If/then/else</li>
<li>Chapter 09: 함수와 재귀</li>
<li>Chapter 10+: 클로저, 패턴 매칭, 리스트</li>
</ul>
</li>
</ol>
<h2 id="다음-단계-2"><a class="header" href="#다음-단계-2">다음 단계</a></h2>
<p><strong>Phase 1 완료!</strong> 다음 phase에서는:</p>
<ul>
<li><strong>Phase 2</strong>: 산술 연산자, let 바인딩, if/else</li>
<li><strong>Phase 3</strong>: 함수와 재귀</li>
<li><strong>Phase 4</strong>: 클로저와 고차 함수</li>
<li><strong>Phase 5</strong>: 커스텀 MLIR dialect (Appendix 참조)</li>
<li><strong>Phase 6</strong>: 패턴 매칭과 데이터 구조</li>
<li><strong>Phase 7</strong>: 최적화와 마무리</li>
</ul>
<p><strong>Appendix를 읽는 것을 잊지 마라</strong>: 커스텀 MLIR dialect를 C++에서 정의하고 F#에서 사용하는 방법을 다룬다. 이것은 Phase 5의 기초가 된다.</p>
<hr>
<p><strong>Phase 1의 정점에 도달했다. 실제 컴파일러를 구축했다!</strong></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-06-산술-표현식---연산자와-비교"><a class="header" href="#chapter-06-산술-표현식---연산자와-비교">Chapter 06: 산술 표현식 - 연산자와 비교</a></h1>
<h2 id="소개-6"><a class="header" href="#소개-6">소개</a></h2>
<p>Chapter 05에서 정수 리터럴 하나만 컴파일하는 최소한의 컴파일러를 구축했다. <code>42</code>를 입력으로 받아 네이티브 바이너리로 출력하는 전체 파이프라인이 작동한다. 하지만 실제 프로그램을 작성하려면 산술 연산자가 필요하다.</p>
<p>이 장에서는 다음을 추가한다:</p>
<ul>
<li><strong>이진 연산자</strong>: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> (정수 산술)</li>
<li><strong>비교 연산자</strong>: <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>=</code>, <code>&lt;&gt;</code> (i1 boolean 반환)</li>
<li><strong>단항 연산자</strong>: <code>-</code> (부정)</li>
<li><strong>출력 기능</strong>: <code>print</code> 함수로 결과를 stdout에 출력</li>
</ul>
<p>이 장을 마치면 <code>10 + 3 * 4</code>와 같은 표현식을 컴파일하고, 비교를 수행하고, 결과를 화면에 출력하는 완전한 계산기 컴파일러를 갖게 된다.</p>
<blockquote>
<p><strong>중요:</strong> 산술 연산은 MLIR의 <code>arith</code> dialect를 사용한다 (Chapter 01의 primer에서 배웠다). 이 dialect는 SSA 형태의 연산을 제공하며 LLVM dialect로 깔끔하게 낮춰진다.</p>
</blockquote>
<h2 id="확장된-ast-정의"><a class="header" href="#확장된-ast-정의">확장된 AST 정의</a></h2>
<p>Chapter 05의 AST는 <code>IntLiteral</code> 하나만 가졌다. 이제 표현식을 확장한다:</p>
<pre><code class="language-fsharp">namespace FunLangCompiler

/// 이진 연산자
type Operator =
    | Add       // +
    | Subtract  // -
    | Multiply  // *
    | Divide    // /

/// 비교 연산자
type CompareOp =
    | LessThan       // &lt;
    | GreaterThan    // &gt;
    | LessEqual      // &lt;=
    | GreaterEqual   // &gt;=
    | Equal          // =
    | NotEqual       // &lt;&gt;

/// 단항 연산자
type UnaryOp =
    | Negate  // -

/// FunLang 표현식 AST
type Expr =
    | IntLiteral of int
    | BinaryOp of Operator * Expr * Expr       // 예: Add(IntLiteral 10, IntLiteral 20)
    | UnaryOp of UnaryOp * Expr                // 예: Negate(IntLiteral 42)
    | Comparison of CompareOp * Expr * Expr    // 예: LessThan(IntLiteral 5, IntLiteral 10)

/// 최상위 프로그램
type Program =
    { expr: Expr }
</code></pre>
<p><strong>설계 결정:</strong></p>
<ul>
<li><strong>Operator와 CompareOp 분리</strong>: 산술 연산은 i32를 반환하지만, 비교는 i1 (boolean)을 반환한다. 타입 시스템이 다르므로 별도의 타입으로 구분한다.</li>
<li><strong>UnaryOp은 확장 가능</strong>: 지금은 Negate만 있지만 나중에 논리 부정 (<code>not</code>) 등을 추가할 수 있다.</li>
</ul>
<p><strong>AST 예시:</strong></p>
<pre><code class="language-fsharp">// Source: 10 + 3 * 4
BinaryOp(Add,
  IntLiteral 10,
  BinaryOp(Multiply,
    IntLiteral 3,
    IntLiteral 4))

// Source: -(5 + 10)
UnaryOp(Negate,
  BinaryOp(Add,
    IntLiteral 5,
    IntLiteral 10))

// Source: 5 &lt; 10
Comparison(LessThan,
  IntLiteral 5,
  IntLiteral 10)
</code></pre>
<blockquote>
<p><strong>파서 노트:</strong> 실제 파서는 연산자 우선순위를 처리해야 한다 (<code>*</code>가 <code>+</code>보다 높음). 이 장에서는 코드 생성에 집중하므로 파서 구현은 생략한다. LangTutorial의 파서를 재사용하거나 간단한 재귀 하강 파서를 작성하면 된다.</p>
</blockquote>
<h2 id="arith-dialect를-위한-pinvoke-바인딩"><a class="header" href="#arith-dialect를-위한-pinvoke-바인딩">arith Dialect를 위한 P/Invoke 바인딩</a></h2>
<p>Chapter 03에서 기본 MLIR C API 바인딩을 구축했다. 이제 <code>arith</code> dialect 연산을 위한 바인딩을 추가한다.</p>
<p><strong>MlirBindings.fs</strong>에 다음을 추가한다:</p>
<pre><code class="language-fsharp">namespace FunLangCompiler

open System
open System.Runtime.InteropServices

module MlirBindings =

    // ... (기존 바인딩 코드)

    // ===== arith dialect operations =====

    /// arith.addi: 정수 덧셈 (SSA)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirArithAddiCreate(
        MlirContext context,
        MlirLocation location,
        MlirValue lhs,
        MlirValue rhs)

    /// arith.subi: 정수 뺄셈 (SSA)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirArithSubiCreate(
        MlirContext context,
        MlirLocation location,
        MlirValue lhs,
        MlirValue rhs)

    /// arith.muli: 정수 곱셈 (SSA)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirArithMuliCreate(
        MlirContext context,
        MlirLocation location,
        MlirValue lhs,
        MlirValue rhs)

    /// arith.divsi: 부호 있는 정수 나눗셈 (SSA)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirArithDivSICreate(
        MlirContext context,
        MlirLocation location,
        MlirValue lhs,
        MlirValue rhs)

    /// arith.cmpi: 정수 비교 (predicate 지정)
    /// predicate 값:
    ///   0 = eq (equal)
    ///   1 = ne (not equal)
    ///   2 = slt (signed less than)
    ///   3 = sle (signed less or equal)
    ///   4 = sgt (signed greater than)
    ///   5 = sge (signed greater or equal)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirArithCmpiCreate(
        MlirContext context,
        MlirLocation location,
        int predicate,
        MlirValue lhs,
        MlirValue rhs)

    /// arith.constant: 상수 정수/boolean
    /// (이미 Chapter 03에서 mlirArithConstantCreate가 있다고 가정.
    /// 없다면 여기에 추가)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirArithConstantCreate(
        MlirContext context,
        MlirLocation location,
        MlirAttribute value)
</code></pre>
<p><strong>연산자 매핑 표:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>FunLang Operator</th><th>MLIR Operation</th><th>타입 시그니처</th></tr>
</thead>
<tbody>
<tr><td><code>+</code></td><td><code>arith.addi</code></td><td><code>(i32, i32) -&gt; i32</code></td></tr>
<tr><td><code>-</code></td><td><code>arith.subi</code></td><td><code>(i32, i32) -&gt; i32</code></td></tr>
<tr><td><code>*</code></td><td><code>arith.muli</code></td><td><code>(i32, i32) -&gt; i32</code></td></tr>
<tr><td><code>/</code></td><td><code>arith.divsi</code></td><td><code>(i32, i32) -&gt; i32</code> (부호 있는 나눗셈)</td></tr>
<tr><td><code>&lt;</code></td><td><code>arith.cmpi slt</code></td><td><code>(i32, i32) -&gt; i1</code></td></tr>
<tr><td><code>&gt;</code></td><td><code>arith.cmpi sgt</code></td><td><code>(i32, i32) -&gt; i1</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>arith.cmpi sle</code></td><td><code>(i32, i32) -&gt; i1</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>arith.cmpi sge</code></td><td><code>(i32, i32) -&gt; i1</code></td></tr>
<tr><td><code>=</code></td><td><code>arith.cmpi eq</code></td><td><code>(i32, i32) -&gt; i1</code></td></tr>
<tr><td><code>&lt;&gt;</code></td><td><code>arith.cmpi ne</code></td><td><code>(i32, i32) -&gt; i1</code></td></tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>C API 노트:</strong> MLIR C API는 <code>mlir-c/Dialect/Arith.h</code>에서 arith dialect 연산을 노출한다. 실제 함수 이름은 위와 다를 수 있다 (예: <code>mlirArithAddiOpCreate</code> vs <code>mlirArithAddiCreate</code>). MLIR 설치의 헤더 파일을 확인하여 정확한 시그니처를 사용한다.</p>
</blockquote>
<p><strong>arith.cmpi predicate 값:</strong></p>
<pre><code class="language-fsharp">/// arith.cmpi predicate enum
module ArithCmpIPredicate =
    let eq = 0    // equal
    let ne = 1    // not equal
    let slt = 2   // signed less than
    let sle = 3   // signed less or equal
    let sgt = 4   // signed greater than
    let sge = 5   // signed greater or equal
    let ult = 6   // unsigned less than (나중에 사용)
    let ule = 7   // unsigned less or equal
    let ugt = 8   // unsigned greater than
    let uge = 9   // unsigned greater or equal
</code></pre>
<h2 id="f-래퍼-확장"><a class="header" href="#f-래퍼-확장">F# 래퍼 확장</a></h2>
<p>이제 Chapter 04의 <code>OpBuilder</code> 래퍼를 확장하여 산술 연산을 쉽게 생성하도록 한다.</p>
<p><strong>MlirWrapper.fs</strong>에 <code>OpBuilder</code> 타입 확장:</p>
<pre><code class="language-fsharp">namespace FunLangCompiler

open MlirBindings

/// OpBuilder 확장: 산술 연산 생성
type OpBuilder with

    /// arith.addi 생성 (정수 덧셈)
    member this.CreateArithAddi(lhs: MlirValue, rhs: MlirValue, location: Location) : MlirOperation =
        let loc = location.Handle
        MlirNative.mlirArithAddiCreate(this.Context.Handle, loc, lhs, rhs)

    /// arith.subi 생성 (정수 뺄셈)
    member this.CreateArithSubi(lhs: MlirValue, rhs: MlirValue, location: Location) : MlirOperation =
        let loc = location.Handle
        MlirNative.mlirArithSubiCreate(this.Context.Handle, loc, lhs, rhs)

    /// arith.muli 생성 (정수 곱셈)
    member this.CreateArithMuli(lhs: MlirValue, rhs: MlirValue, location: Location) : MlirOperation =
        let loc = location.Handle
        MlirNative.mlirArithMuliCreate(this.Context.Handle, loc, lhs, rhs)

    /// arith.divsi 생성 (부호 있는 정수 나눗셈)
    member this.CreateArithDivSI(lhs: MlirValue, rhs: MlirValue, location: Location) : MlirOperation =
        let loc = location.Handle
        MlirNative.mlirArithDivSICreate(this.Context.Handle, loc, lhs, rhs)

    /// arith.cmpi 생성 (정수 비교)
    member this.CreateArithCmpi(predicate: int, lhs: MlirValue, rhs: MlirValue, location: Location) : MlirOperation =
        let loc = location.Handle
        MlirNative.mlirArithCmpiCreate(this.Context.Handle, loc, predicate, lhs, rhs)

    /// 이진 연산 헬퍼: Operator -&gt; arith operation
    member this.CreateArithBinaryOp(op: Operator, lhs: MlirValue, rhs: MlirValue, location: Location) : MlirOperation =
        match op with
        | Add -&gt; this.CreateArithAddi(lhs, rhs, location)
        | Subtract -&gt; this.CreateArithSubi(lhs, rhs, location)
        | Multiply -&gt; this.CreateArithMuli(lhs, rhs, location)
        | Divide -&gt; this.CreateArithDivSI(lhs, rhs, location)

    /// 비교 헬퍼: CompareOp -&gt; arith.cmpi with predicate
    member this.CreateArithCompare(compareOp: CompareOp, lhs: MlirValue, rhs: MlirValue, location: Location) : MlirOperation =
        let predicate =
            match compareOp with
            | LessThan -&gt; ArithCmpIPredicate.slt
            | GreaterThan -&gt; ArithCmpIPredicate.sgt
            | LessEqual -&gt; ArithCmpIPredicate.sle
            | GreaterEqual -&gt; ArithCmpIPredicate.sge
            | Equal -&gt; ArithCmpIPredicate.eq
            | NotEqual -&gt; ArithCmpIPredicate.ne
        this.CreateArithCmpi(predicate, lhs, rhs, location)

    /// 단항 부정 헬퍼: -expr = 0 - expr
    member this.CreateArithNegate(value: MlirValue, location: Location) : MlirOperation =
        // 상수 0 생성
        let i32Type = this.I32Type()
        let zeroAttr = this.Context.GetIntegerAttr(i32Type, 0L)
        let zeroOp = this.CreateConstant(zeroAttr, location)
        let zeroVal = this.GetResult(zeroOp, 0)

        // 0 - value
        this.CreateArithSubi(zeroVal, value, location)
</code></pre>
<p><strong>설계 결정:</strong></p>
<ul>
<li><strong>헬퍼 메서드</strong>: <code>CreateArithBinaryOp</code>은 Operator를 받아 적절한 arith 연산으로 매핑한다. 코드 생성 로직이 단순해진다.</li>
<li><strong>부정 구현</strong>: <code>-expr</code>은 <code>0 - expr</code>로 변환한다. 별도의 arith.negate 연산이 없으므로 이것이 표준 방법이다.</li>
<li><strong>타입 안전성</strong>: CompareOp -&gt; predicate 매핑은 타입 세이프하다. 잘못된 predicate 값을 생성할 수 없다.</li>
</ul>
<h2 id="공통-에러-1부"><a class="header" href="#공통-에러-1부">공통 에러 (1부)</a></h2>
<h3 id="에러-1-잘못된-정수-타입-사용-i64-vs-i32"><a class="header" href="#에러-1-잘못된-정수-타입-사용-i64-vs-i32">에러 1: 잘못된 정수 타입 사용 (i64 vs i32)</a></h3>
<p><strong>증상:</strong></p>
<pre><code>MLIR verification failed:
  Type mismatch: expected i32, got i64
</code></pre>
<p><strong>원인:</strong>
MLIR은 타입이 엄격하다. 상수를 i64로 생성했지만 함수 시그니처는 i32를 요구하는 경우.</p>
<p><strong>해결:</strong></p>
<pre><code class="language-fsharp">// WRONG: i64 타입 사용
let i64Type = builder.Context.GetIntegerType(64)
let attr = builder.Context.GetIntegerAttr(i64Type, 42L)

// CORRECT: i32 타입 사용
let i32Type = builder.Context.GetIntegerType(32)
let attr = builder.Context.GetIntegerAttr(i32Type, 42L)
</code></pre>
<p><strong>규칙:</strong> 모든 FunLang 정수는 i32로 컴파일한다. 타입을 일관되게 유지한다.</p>
<h3 id="에러-2-연산자-우선순위를-파서에서-처리하지-않음"><a class="header" href="#에러-2-연산자-우선순위를-파서에서-처리하지-않음">에러 2: 연산자 우선순위를 파서에서 처리하지 않음</a></h3>
<p><strong>증상:</strong></p>
<pre><code>Source: 10 + 3 * 4
Expected: 22
Actual: 52  (잘못된 결과)
</code></pre>
<p><strong>원인:</strong>
파서가 우선순위를 무시하고 왼쪽에서 오른쪽으로 파싱하여 <code>(10 + 3) * 4 = 52</code>가 됨.</p>
<p><strong>해결:</strong>
파서에서 연산자 우선순위를 구현한다:</p>
<ul>
<li>곱셈/나눗셈 (<code>*</code>, <code>/</code>)이 덧셈/뺄셈 (<code>+</code>, <code>-</code>)보다 우선순위가 높다.</li>
<li>비교 연산자는 산술 연산보다 우선순위가 낮다.</li>
</ul>
<p><strong>재귀 하강 파서 예시:</strong></p>
<pre><code class="language-fsharp">// Precedence climbing algorithm
// additive := multiplicative (('+' | '-') multiplicative)*
// multiplicative := primary (('*' | '/') primary)*
// primary := number | '(' additive ')'
</code></pre>
<blockquote>
<p><strong>파서 구현은 이 장의 범위를 벗어난다.</strong> LangTutorial의 기존 파서를 사용하거나 FParsec 같은 파서 라이브러리를 사용한다.</p>
</blockquote>
<h2 id="산술-표현식을-위한-코드-생성"><a class="header" href="#산술-표현식을-위한-코드-생성">산술 표현식을 위한 코드 생성</a></h2>
<p>이제 Chapter 05의 <code>compileExpr</code>을 확장하여 모든 산술 표현식을 처리한다.</p>
<p><strong>CodeGen.fs</strong> 수정:</p>
<pre><code class="language-fsharp">namespace FunLangCompiler

open System
open MlirWrapper
open MlirBindings

module CodeGen =

    /// 표현식을 MLIR value로 컴파일 (재귀적)
    let rec compileExpr
        (builder: OpBuilder)
        (block: MlirBlock)
        (location: Location)
        (expr: Expr)
        : MlirValue =

        match expr with
        | IntLiteral value -&gt;
            // arith.constant operation 생성
            let i32Type = builder.I32Type()
            let attr = builder.Context.GetIntegerAttr(i32Type, int64 value)
            let constOp = builder.CreateConstant(attr, location)
            MlirNative.mlirBlockAppendOwnedOperation(block, constOp)
            builder.GetResult(constOp, 0)

        | BinaryOp(op, lhs, rhs) -&gt;
            // 왼쪽 피연산자 컴파일 (재귀)
            let lhsVal = compileExpr builder block location lhs

            // 오른쪽 피연산자 컴파일 (재귀)
            let rhsVal = compileExpr builder block location rhs

            // 이진 연산 생성
            let binOp = builder.CreateArithBinaryOp(op, lhsVal, rhsVal, location)
            MlirNative.mlirBlockAppendOwnedOperation(block, binOp)
            builder.GetResult(binOp, 0)

        | UnaryOp(Negate, expr) -&gt;
            // 피연산자 컴파일
            let val = compileExpr builder block location expr

            // 부정 연산 생성 (0 - val)
            let negOp = builder.CreateArithNegate(val, location)
            MlirNative.mlirBlockAppendOwnedOperation(block, negOp)
            builder.GetResult(negOp, 0)

        | Comparison(compareOp, lhs, rhs) -&gt;
            // 피연산자 컴파일
            let lhsVal = compileExpr builder block location lhs
            let rhsVal = compileExpr builder block location rhs

            // 비교 연산 생성 (i1 반환)
            let cmpOp = builder.CreateArithCompare(compareOp, lhsVal, rhsVal, location)
            MlirNative.mlirBlockAppendOwnedOperation(block, cmpOp)
            builder.GetResult(cmpOp, 0)

    /// 프로그램을 MLIR module로 컴파일
    let translateToMlir (program: Program) : Module =
        let ctx = new Context()
        ctx.LoadDialect("arith")
        ctx.LoadDialect("func")

        let loc = Location.Unknown(ctx)
        let mlirMod = new Module(ctx, loc)

        let builder = OpBuilder(ctx)
        let i32Type = builder.I32Type()

        // main 함수 생성: () -&gt; i32
        let funcType = builder.FunctionType([||], [| i32Type |])
        let funcOp = builder.CreateFunction("main", funcType, loc)

        // 함수 body에 entry block 생성
        let bodyRegion = MlirNative.mlirOperationGetRegion(funcOp, 0n)
        let entryBlock = MlirNative.mlirBlockCreate(0n, nativeint 0, nativeint 0)
        MlirNative.mlirRegionAppendOwnedBlock(bodyRegion, entryBlock)

        // 표현식 컴파일 (재귀적으로 모든 연산 처리)
        let resultValue = compileExpr builder entryBlock loc program.expr

        // return operation 생성
        let returnOp = builder.CreateReturn([| resultValue |], loc)
        MlirNative.mlirBlockAppendOwnedOperation(entryBlock, returnOp)

        // 함수를 module에 추가
        MlirNative.mlirBlockAppendOwnedOperation(mlirMod.Body, funcOp)

        mlirMod

    /// MLIR module을 검증
    let verify (mlirMod: Module) =
        if not (mlirMod.Verify()) then
            eprintfn "MLIR verification failed:"
            eprintfn "%s" (mlirMod.Print())
            failwith "MLIR IR is invalid"
</code></pre>
<p><strong>SSA 형태 유지:</strong></p>
<p>재귀 호출이 SSA 형태를 자연스럽게 유지한다는 것을 주목한다:</p>
<ul>
<li>각 <code>compileExpr</code> 호출은 새로운 SSA value를 반환한다.</li>
<li>중복 계산이 없다 (각 표현식은 정확히 한 번만 평가된다).</li>
<li>지배 관계가 자동으로 유지된다 (하위 표현식이 먼저 평가된다).</li>
</ul>
<p><strong>예시: 복잡한 표현식 컴파일</strong></p>
<pre><code class="language-fsharp">// Source: 10 + 3 * 4
let ast = BinaryOp(Add,
            IntLiteral 10,
            BinaryOp(Multiply,
              IntLiteral 3,
              IntLiteral 4))

let mlirMod = CodeGen.translateToMlir { expr = ast }
printfn "%s" (mlirMod.Print())
</code></pre>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">module {
  func.func @main() -&gt; i32 {
    %c10 = arith.constant 10 : i32
    %c3 = arith.constant 3 : i32
    %c4 = arith.constant 4 : i32
    %0 = arith.muli %c3, %c4 : i32     // 3 * 4 = 12
    %1 = arith.addi %c10, %0 : i32     // 10 + 12 = 22
    func.return %1 : i32
  }
}
</code></pre>
<p><strong>동작 분석:</strong></p>
<ol>
<li>상수 10, 3, 4가 생성된다 (<code>arith.constant</code>)</li>
<li>먼저 곱셈 계산: <code>%0 = 3 * 4</code> (하위 표현식이 먼저)</li>
<li>그 다음 덧셈: <code>%1 = 10 + %0</code></li>
<li>결과 반환: <code>return %1</code></li>
</ol>
<blockquote>
<p><strong>중요:</strong> 연산 순서는 AST 구조가 결정한다. 파서가 올바른 우선순위로 AST를 구축하면 코드 생성이 자동으로 올바른 평가 순서를 생성한다.</p>
</blockquote>
<p><strong>비교 예시:</strong></p>
<pre><code class="language-fsharp">// Source: 5 &lt; 10
let ast = Comparison(LessThan, IntLiteral 5, IntLiteral 10)

let mlirMod = CodeGen.translateToMlir { expr = ast }
printfn "%s" (mlirMod.Print())
</code></pre>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">module {
  func.func @main() -&gt; i32 {
    %c5 = arith.constant 5 : i32
    %c10 = arith.constant 10 : i32
    %0 = arith.cmpi slt, %c5, %c10 : i32  // returns i1
    // 문제: %0은 i1이지만 함수는 i32를 반환해야 함!
    func.return %0 : i32  // TYPE ERROR!
  }
}
</code></pre>
<p><strong>타입 불일치 문제:</strong> 비교는 i1 (boolean)을 반환하지만 main 함수는 i32를 기대한다. 이를 해결하려면 boolean을 정수로 확장해야 한다:</p>
<pre><code class="language-fsharp">// compileExpr 수정 (Comparison 케이스)
| Comparison(compareOp, lhs, rhs) -&gt;
    let lhsVal = compileExpr builder block location lhs
    let rhsVal = compileExpr builder block location rhs

    // 비교 연산 (i1 반환)
    let cmpOp = builder.CreateArithCompare(compareOp, lhsVal, rhsVal, location)
    MlirNative.mlirBlockAppendOwnedOperation(block, cmpOp)
    let cmpVal = builder.GetResult(cmpOp, 0)

    // i1 -&gt; i32 확장 (zero extend)
    let i32Type = builder.I32Type()
    let extOp = builder.CreateArithExtUI(cmpVal, i32Type, location)  // unsigned extend
    MlirNative.mlirBlockAppendOwnedOperation(block, extOp)
    builder.GetResult(extOp, 0)
</code></pre>
<p><strong>생성된 MLIR IR (수정 후):</strong></p>
<pre><code class="language-mlir">module {
  func.func @main() -&gt; i32 {
    %c5 = arith.constant 5 : i32
    %c10 = arith.constant 10 : i32
    %0 = arith.cmpi slt, %c5, %c10 : i32   // returns i1
    %1 = arith.extui %0 : i1 to i32        // i1 -&gt; i32 (0 or 1)
    func.return %1 : i32
  }
}
</code></pre>
<p>이제 비교 결과가 정수로 반환된다 (true = 1, false = 0).</p>
<p><strong>단항 부정 예시:</strong></p>
<pre><code class="language-fsharp">// Source: -(10 + 5)
let ast = UnaryOp(Negate, BinaryOp(Add, IntLiteral 10, IntLiteral 5))

let mlirMod = CodeGen.translateToMlir { expr = ast }
printfn "%s" (mlirMod.Print())
</code></pre>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">module {
  func.func @main() -&gt; i32 {
    %c10 = arith.constant 10 : i32
    %c5 = arith.constant 5 : i32
    %0 = arith.addi %c10, %c5 : i32     // 10 + 5 = 15
    %c0 = arith.constant 0 : i32
    %1 = arith.subi %c0, %0 : i32       // 0 - 15 = -15
    func.return %1 : i32
  }
}
</code></pre>
<h2 id="출력-기능-추가-printf로-결과-출력"><a class="header" href="#출력-기능-추가-printf로-결과-출력">출력 기능 추가: printf로 결과 출력</a></h2>
<p>지금까지 프로그램은 결과를 종료 코드로만 반환했다. 이제 <code>printf</code>를 사용하여 stdout에 출력하는 기능을 추가한다.</p>
<h3 id="llvmcall-연산을-위한-pinvoke-바인딩"><a class="header" href="#llvmcall-연산을-위한-pinvoke-바인딩">llvm.call 연산을 위한 P/Invoke 바인딩</a></h3>
<p>LLVM dialect는 외부 함수를 호출하는 <code>llvm.call</code> 연산을 제공한다.</p>
<p><strong>MlirBindings.fs</strong>에 추가:</p>
<pre><code class="language-fsharp">    // ===== LLVM dialect operations =====

    /// llvm.call: 외부 함수 호출
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirLLVMCallCreate(
        MlirContext context,
        MlirLocation location,
        MlirValue callee,
        MlirValue[] args,
        int numArgs)

    /// llvm.mlir.global: 전역 문자열 상수
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirLLVMGlobalCreate(
        MlirContext context,
        MlirLocation location,
        MlirType type,
        MlirAttribute initializer,
        MlirStringRef name)

    /// llvm.mlir.addressof: 전역 변수의 주소 가져오기
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirLLVMAddressOfCreate(
        MlirContext context,
        MlirLocation location,
        MlirStringRef globalName)
</code></pre>
<blockquote>
<p><strong>C API 경고:</strong> 실제 MLIR C API는 LLVM dialect에 대한 직접 지원이 제한적일 수 있다. 필요한 경우 Chapter 05의 Appendix 패턴 (C++ wrapper)을 사용한다.</p>
</blockquote>
<h3 id="printf-함수-선언-생성"><a class="header" href="#printf-함수-선언-생성">printf 함수 선언 생성</a></h3>
<p>printf를 호출하려면 먼저 함수 선언과 전역 포맷 문자열이 필요하다.</p>
<p><strong>CodeGen.fs</strong>에 헬퍼 함수 추가:</p>
<pre><code class="language-fsharp">    /// printf 함수 선언 생성 (module 레벨)
    let createPrintfDeclaration (builder: OpBuilder) (mlirMod: Module) (location: Location) =
        // printf 시그니처: (i8*, ...) -&gt; i32
        let i8Type = builder.Context.GetIntegerType(8)
        let i8PtrType = builder.Context.GetPointerType(i8Type)
        let i32Type = builder.I32Type()

        // func.func @printf(%fmt: !llvm.ptr&lt;i8&gt;, ...) -&gt; i32 attributes { sym_visibility = "private" }
        let printfType = builder.FunctionType([| i8PtrType |], [| i32Type |])
        let printfOp = builder.CreateFunction("printf", printfType, location)

        // 가변 인자 속성 추가 (실제 구현에서는 속성 API 필요)
        // 여기서는 단순화를 위해 생략

        MlirNative.mlirBlockAppendOwnedOperation(mlirMod.Body, printfOp)

    /// 전역 포맷 문자열 생성: "%d\n\0"
    let createFormatString (builder: OpBuilder) (mlirMod: Module) (location: Location) : string =
        let formatStrName = ".str.fmt"
        let formatStrValue = "%d\n\0"

        // LLVM global 생성
        let i8Type = builder.Context.GetIntegerType(8)
        let arrayType = builder.Context.GetArrayType(i8Type, formatStrValue.Length)
        let strAttr = builder.Context.GetStringAttr(formatStrValue)

        let globalOp = builder.CreateLLVMGlobal(arrayType, strAttr, formatStrName, location)
        MlirNative.mlirBlockAppendOwnedOperation(mlirMod.Body, globalOp)

        formatStrName

    /// print_int 헬퍼 함수 생성: 정수를 출력
    let createPrintIntHelper
        (builder: OpBuilder)
        (mlirMod: Module)
        (location: Location)
        (formatStrName: string)
        =

        // func.func @print_int(%arg: i32) -&gt; i32
        let i32Type = builder.I32Type()
        let funcType = builder.FunctionType([| i32Type |], [| i32Type |])
        let funcOp = builder.CreateFunction("print_int", funcType, location)

        // 함수 body
        let bodyRegion = MlirNative.mlirOperationGetRegion(funcOp, 0n)
        let entryBlock = MlirNative.mlirBlockCreate(1n, &amp;i32Type, nativeint 0)  // 1 argument
        MlirNative.mlirRegionAppendOwnedBlock(bodyRegion, entryBlock)

        // 인자 가져오기
        let arg = MlirNative.mlirBlockGetArgument(entryBlock, 0n)

        // 포맷 문자열 주소 가져오기
        let formatStrOp = builder.CreateLLVMAddressOf(formatStrName, location)
        MlirNative.mlirBlockAppendOwnedOperation(entryBlock, formatStrOp)
        let formatStrPtr = builder.GetResult(formatStrOp, 0)

        // printf 호출
        let printfCallOp = builder.CreateLLVMCall("printf", [| formatStrPtr; arg |], location)
        MlirNative.mlirBlockAppendOwnedOperation(entryBlock, printfCallOp)

        // 인자를 그대로 반환 (print는 부수 효과)
        let returnOp = builder.CreateReturn([| arg |], location)
        MlirNative.mlirBlockAppendOwnedOperation(entryBlock, returnOp)

        MlirNative.mlirBlockAppendOwnedOperation(mlirMod.Body, funcOp)
</code></pre>
<h3 id="main-함수에서-print_int-호출"><a class="header" href="#main-함수에서-print_int-호출">main 함수에서 print_int 호출</a></h3>
<p>이제 main 함수를 수정하여 결과를 출력하도록 한다:</p>
<pre><code class="language-fsharp">    /// 프로그램을 MLIR module로 컴파일 (print 지원)
    let translateToMlirWithPrint (program: Program) : Module =
        let ctx = new Context()
        ctx.LoadDialect("arith")
        ctx.LoadDialect("func")
        ctx.LoadDialect("llvm")

        let loc = Location.Unknown(ctx)
        let mlirMod = new Module(ctx, loc)

        let builder = OpBuilder(ctx)
        let i32Type = builder.I32Type()

        // printf 선언과 print_int 헬퍼 생성
        createPrintfDeclaration builder mlirMod loc
        let formatStrName = createFormatString builder mlirMod loc
        createPrintIntHelper builder mlirMod loc formatStrName

        // main 함수 생성
        let funcType = builder.FunctionType([||], [| i32Type |])
        let funcOp = builder.CreateFunction("main", funcType, loc)

        let bodyRegion = MlirNative.mlirOperationGetRegion(funcOp, 0n)
        let entryBlock = MlirNative.mlirBlockCreate(0n, nativeint 0, nativeint 0)
        MlirNative.mlirRegionAppendOwnedBlock(bodyRegion, entryBlock)

        // 표현식 컴파일
        let resultValue = compileExpr builder entryBlock loc program.expr

        // print_int 호출
        let printOp = builder.CreateFunctionCall("print_int", [| resultValue |], loc)
        MlirNative.mlirBlockAppendOwnedOperation(entryBlock, printOp)
        let printedVal = builder.GetResult(printOp, 0)

        // 결과 반환
        let returnOp = builder.CreateReturn([| printedVal |], loc)
        MlirNative.mlirBlockAppendOwnedOperation(entryBlock, returnOp)

        MlirNative.mlirBlockAppendOwnedOperation(mlirMod.Body, funcOp)

        mlirMod
</code></pre>
<p><strong>생성된 MLIR IR (전체):</strong></p>
<pre><code class="language-mlir">module {
  // printf 선언
  func.func private @printf(!llvm.ptr&lt;i8&gt;, ...) -&gt; i32

  // 포맷 문자열
  llvm.mlir.global private constant @.str.fmt("%d\n\00")

  // print_int 헬퍼
  func.func @print_int(%arg0: i32) -&gt; i32 {
    %fmt = llvm.mlir.addressof @.str.fmt : !llvm.ptr&lt;array&lt;4 x i8&gt;&gt;
    %fmt_ptr = llvm.bitcast %fmt : !llvm.ptr&lt;array&lt;4 x i8&gt;&gt; to !llvm.ptr&lt;i8&gt;
    %result = llvm.call @printf(%fmt_ptr, %arg0) : (!llvm.ptr&lt;i8&gt;, i32) -&gt; i32
    func.return %arg0 : i32
  }

  // main 함수
  func.func @main() -&gt; i32 {
    %c10 = arith.constant 10 : i32
    %c3 = arith.constant 3 : i32
    %c4 = arith.constant 4 : i32
    %0 = arith.muli %c3, %c4 : i32
    %1 = arith.addi %c10, %0 : i32
    %2 = func.call @print_int(%1) : (i32) -&gt; i32
    func.return %2 : i32
  }
}
</code></pre>
<p><strong>실행 결과:</strong></p>
<pre><code class="language-bash">$ ./program
22
$ echo $?
22
</code></pre>
<p>결과가 stdout에 출력되고 종료 코드로도 반환된다!</p>
<h2 id="완전한-컴파일러-드라이버-1"><a class="header" href="#완전한-컴파일러-드라이버-1">완전한 컴파일러 드라이버</a></h2>
<p>Chapter 05의 컴파일러 드라이버를 업데이트하여 새로운 기능을 지원한다:</p>
<p><strong>Compiler.fs 업데이트:</strong></p>
<pre><code class="language-fsharp">namespace FunLangCompiler

open System
open System.IO

module Compiler =

    /// 소스 파일을 네이티브 실행 파일로 컴파일
    let compile (sourceFile: string) (outputFile: string) (withPrint: bool) =
        printfn "=== FunLang Compiler ==="
        printfn "Source: %s" sourceFile
        printfn "Output: %s" outputFile
        printfn ""

        // 1단계: 파싱
        printfn "[1/7] Parsing..."
        let source = File.ReadAllText(sourceFile)
        let program = Parser.parse source  // 실제 파서 사용 (LangTutorial 재사용)
        printfn "  AST: %A" program

        // 2단계: MLIR로 변환
        printfn "[2/7] Translating to MLIR..."
        let mlirMod =
            if withPrint then
                CodeGen.translateToMlirWithPrint program
            else
                CodeGen.translateToMlir program
        printfn "  MLIR (high-level):"
        printfn "%s" (mlirMod.Print())

        // 3단계: 검증
        printfn "[3/7] Verifying MLIR..."
        CodeGen.verify mlirMod
        printfn "  ✓ Verification passed"

        // 4-7단계: Lowering, LLVM IR, object file, linking (Chapter 05와 동일)
        Lowering.lowerToLLVMDialect mlirMod
        let llvmIR = Lowering.translateToLLVMIR mlirMod
        let objectFile = outputFile + ".o"
        NativeCodeGen.emitObjectFile llvmIR objectFile
        NativeCodeGen.linkExecutable objectFile outputFile

        mlirMod.Dispose()

        printfn ""
        printfn "=== Compilation successful ==="
        printfn "Run: ./%s" outputFile

[&lt;EntryPoint&gt;]
let main args =
    if args.Length &lt; 2 then
        eprintfn "Usage: compiler &lt;source.fun&gt; &lt;output&gt; [--print]"
        exit 1

    let sourceFile = args.[0]
    let outputFile = args.[1]
    let withPrint = args.Length &gt; 2 &amp;&amp; args.[2] = "--print"

    Compiler.compile sourceFile outputFile withPrint
    0
</code></pre>
<p><strong>사용 예시:</strong></p>
<pre><code class="language-bash"># 결과를 출력하지 않음 (종료 코드만)
$ dotnet run test.fun program

# 결과를 출력함 (stdout + 종료 코드)
$ dotnet run test.fun program --print
$ ./program
22
</code></pre>
<h2 id="공통-에러-2부"><a class="header" href="#공통-에러-2부">공통 에러 (2부)</a></h2>
<h3 id="에러-3-비교가-i1을-반환하지만-i32가-필요한-곳에서-사용"><a class="header" href="#에러-3-비교가-i1을-반환하지만-i32가-필요한-곳에서-사용">에러 3: 비교가 i1을 반환하지만 i32가 필요한 곳에서 사용</a></h3>
<p><strong>증상:</strong></p>
<pre><code>MLIR verification failed:
  Type mismatch in func.return: expected i32, got i1
</code></pre>
<p><strong>원인:</strong>
비교 연산은 i1 (boolean)을 반환하지만 main 함수는 i32를 반환해야 한다.</p>
<p><strong>해결:</strong>
i1을 i32로 확장한다:</p>
<pre><code class="language-fsharp">// arith.extui 사용 (zero extend)
let extOp = builder.CreateArithExtUI(cmpVal, i32Type, location)
</code></pre>
<p><strong>또는</strong> main 함수가 i1을 반환하도록 변경 (덜 일반적):</p>
<pre><code class="language-fsharp">// main 함수 시그니처를 i1으로 변경 (비권장)
let funcType = builder.FunctionType([||], [| builder.Context.GetIntegerType(1) |])
</code></pre>
<p><strong>권장 방법:</strong> 항상 i32로 확장한다. Unix 종료 코드는 8비트 정수이므로 boolean을 정수로 표현하는 것이 자연스럽다.</p>
<h3 id="에러-4-0으로-나누기-런타임-vs-컴파일-타임"><a class="header" href="#에러-4-0으로-나누기-런타임-vs-컴파일-타임">에러 4: 0으로 나누기 (런타임 vs 컴파일 타임)</a></h3>
<p><strong>증상:</strong></p>
<pre><code class="language-bash">$ ./program
Floating point exception (core dumped)
</code></pre>
<p><strong>원인:</strong>
<code>10 / 0</code>과 같은 표현식이 런타임에 0으로 나누기를 시도한다.</p>
<p><strong>컴파일 타임 해결:</strong>
AST를 분석하여 상수 0으로 나누기를 감지한다:</p>
<pre><code class="language-fsharp">| BinaryOp(Divide, lhs, IntLiteral 0) -&gt;
    failwith "Compile error: division by zero"
</code></pre>
<p><strong>런타임 해결 (더 일반적):</strong>
동적 검사 코드를 삽입한다:</p>
<pre><code class="language-fsharp">| BinaryOp(Divide, lhs, rhs) -&gt;
    let lhsVal = compileExpr builder block location lhs
    let rhsVal = compileExpr builder block location rhs

    // rhsVal == 0 검사
    let zero = builder.CreateConstant(0, builder.I32Type(), location)
    let isZero = builder.CreateArithCmpi(ArithCmpIPredicate.eq, rhsVal, zero, location)

    // if (rhsVal == 0) abort() else lhs / rhs
    // scf.if 사용 (Chapter 08에서 다룸)
    // 지금은 단순화를 위해 생략
</code></pre>
<p><strong>실용적 접근:</strong> 대부분의 컴파일러는 0으로 나누기를 런타임 에러로 남긴다. 프로그램이 SIGFPE로 종료되는 것이 예상 동작이다.</p>
<h3 id="에러-5-printf-포맷-문자열에-null-terminator-누락"><a class="header" href="#에러-5-printf-포맷-문자열에-null-terminator-누락">에러 5: printf 포맷 문자열에 null terminator 누락</a></h3>
<p><strong>증상:</strong></p>
<pre><code class="language-bash">$ ./program
22ݠ�(garbage characters)
</code></pre>
<p><strong>원인:</strong>
C 문자열은 null terminator (<code>\0</code>)가 필요하다. <code>"%d\n"</code> 대신 <code>"%d\n\0"</code>를 사용해야 한다.</p>
<p><strong>해결:</strong></p>
<pre><code class="language-fsharp">// WRONG: null terminator 없음
let formatStrValue = "%d\n"

// CORRECT: null terminator 포함
let formatStrValue = "%d\n\0"
</code></pre>
<p><strong>MLIR IR:</strong></p>
<pre><code class="language-mlir">// CORRECT
llvm.mlir.global private constant @.str.fmt("%d\0A\00") : !llvm.array&lt;4 x i8&gt;
</code></pre>
<h3 id="에러-6-arith-연산-후-llvm-dialect로-낮추기-잊음"><a class="header" href="#에러-6-arith-연산-후-llvm-dialect로-낮추기-잊음">에러 6: arith 연산 후 LLVM dialect로 낮추기 잊음</a></h3>
<p><strong>증상:</strong></p>
<pre><code>Translation error: Unhandled operation 'arith.addi'
</code></pre>
<p><strong>원인:</strong>
arith dialect를 LLVM IR로 변환하려면 먼저 LLVM dialect로 낮춰야 한다.</p>
<p><strong>해결:</strong>
Lowering 단계에서 <code>convert-arith-to-llvm</code> pass를 실행한다:</p>
<pre><code class="language-fsharp">// Pass manager에 추가
MlirStringRef.WithString "convert-arith-to-llvm" (fun passName -&gt;
    let pass = MlirNative.mlirCreateConversionPass(passName)
    MlirNative.mlirPassManagerAddOwnedPass(pm, pass))
</code></pre>
<p><strong>Pass 순서:</strong></p>
<ol>
<li><code>convert-func-to-llvm</code></li>
<li><code>convert-arith-to-llvm</code></li>
<li><code>reconcile-unrealized-casts</code></li>
<li>그 다음 <code>mlirTranslateModuleToLLVMIR</code></li>
</ol>
<h2 id="장-요약"><a class="header" href="#장-요약">장 요약</a></h2>
<p>이 장에서 다음을 성취했다:</p>
<ol>
<li><strong>확장된 AST</strong>: 이진 연산자, 비교, 단항 부정을 지원하는 표현식 타입</li>
<li><strong>P/Invoke 바인딩</strong>: arith dialect의 addi, subi, muli, divsi, cmpi 연산</li>
<li><strong>F# 래퍼 확장</strong>: OpBuilder에 편리한 헬퍼 메서드 추가</li>
<li><strong>재귀 코드 생성</strong>: SSA 형태를 유지하며 복잡한 표현식 컴파일</li>
<li><strong>출력 기능</strong>: printf를 통한 결과 출력</li>
<li><strong>완전한 예제</strong>: MLIR IR 출력을 보여주는 실행 가능한 코드</li>
</ol>
<p><strong>독자가 할 수 있는 것:</strong></p>
<ul>
<li><code>10 + 3 * 4</code> 컴파일 → 네이티브 바이너리 → 실행 → 결과: 22 ✓</li>
<li><code>5 &lt; 10</code> 컴파일 → boolean 반환 (1 = true) ✓</li>
<li><code>-42</code> 컴파일 → 부정 연산 ✓</li>
<li><code>print(10 + 20)</code> 컴파일 → stdout 출력: 30 ✓</li>
</ul>
<p><strong>다음 장 미리보기:</strong></p>
<p>Chapter 07에서는 <strong>let 바인딩</strong>을 추가한다:</p>
<pre><code class="language-fsharp">let x = 10 in
let y = 20 in
x + y
</code></pre>
<p>이것은 다음을 도입한다:</p>
<ul>
<li>변수 이름과 SSA value 간의 환경 (symbol table)</li>
<li>중첩된 스코프 (nested scopes)</li>
<li>변수 섀도잉 (shadowing) vs 뮤테이션 (mutation)</li>
</ul>
<p><strong>Phase 2는 계속된다!</strong></p>
<hr>
<p><strong>이제 독자는 산술 표현식을 컴파일하고 결과를 출력할 수 있다!</strong></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-07-let-바인딩과-ssa-형태"><a class="header" href="#chapter-07-let-바인딩과-ssa-형태">Chapter 07: Let 바인딩과 SSA 형태</a></h1>
<h2 id="소개-7"><a class="header" href="#소개-7">소개</a></h2>
<p>프로그래밍에서 변수는 필수적이다. 값을 이름에 바인딩하고, 나중에 그 이름을 참조하여 값을 재사용한다. Chapter 06까지는 표현식을 직접 계산했지만, 실제 프로그램을 작성하려면 중간 결과를 저장하고 참조할 수 있어야 한다.</p>
<p>이 장에서는 <strong>let 바인딩</strong>을 추가한다:</p>
<pre><code class="language-fsharp">let x = 10 in
let y = 20 in
x + y
</code></pre>
<p>함수형 언어의 let 바인딩은 명령형 언어의 변수 할당과 다르다:</p>
<ul>
<li><strong>명령형</strong>: <code>x = 5; x = 10;</code> (뮤테이션 - 값이 변경됨)</li>
<li><strong>함수형</strong>: <code>let x = 5 in let x = 10 in x</code> (섀도잉 - 새로운 바인딩 생성, 뮤테이션 아님)</li>
</ul>
<p><strong>핵심 통찰력:</strong> let 바인딩은 **불변(immutable)**이다. 이것이 MLIR의 SSA (Static Single Assignment) 형태와 완벽하게 일치한다. 함수형 프로그래밍은 SSA를 자연스럽게 표현한다!</p>
<p>이 장을 마치면:</p>
<ul>
<li>let 바인딩을 컴파일하여 네이티브 바이너리로 만들 수 있다</li>
<li>중첩된 바인딩과 스코프를 이해한다</li>
<li>SSA 형태가 무엇이고 왜 중요한지 안다</li>
<li>환경 전달(environment passing)로 변수를 관리하는 방법을 안다</li>
</ul>
<blockquote>
<p><strong>중요:</strong> 이 장은 SSA 개념을 소개한다. SSA는 현대 컴파일러의 핵심 기술이며, MLIR은 SSA를 기본으로 한다.</p>
</blockquote>
<h2 id="ssa-형태-설명"><a class="header" href="#ssa-형태-설명">SSA 형태 설명</a></h2>
<h3 id="ssa란-무엇인가"><a class="header" href="#ssa란-무엇인가">SSA란 무엇인가?</a></h3>
<p>**SSA (Static Single Assignment)**는 중간 표현(IR)의 속성이다:</p>
<blockquote>
<p><strong>정의:</strong> 각 변수는 프로그램에서 정확히 한 번만 할당된다.</p>
</blockquote>
<p>예시:</p>
<pre><code class="language-fsharp">// SSA가 아님 (명령형):
x = 5
x = 10  // x가 두 번 할당됨!

// SSA (함수형):
let x1 = 5 in    // x1은 한 번만 할당
let x2 = 10 in   // x2는 한 번만 할당
x2
</code></pre>
<p>MLIR IR에서 SSA value는 <code>%</code> 기호로 표시된다:</p>
<pre><code class="language-mlir">%x = arith.constant 5 : i32      // %x 정의 (한 번만)
%y = arith.addi %x, %x : i32     // %x 사용 (여러 번 가능)
%z = arith.muli %y, %x : i32     // %x, %y 사용
</code></pre>
<p>각 SSA value (<code>%x</code>, <code>%y</code>, <code>%z</code>)는 정확히 한 번만 정의된다. 사용은 여러 번 가능하다.</p>
<h3 id="왜-ssa가-중요한가"><a class="header" href="#왜-ssa가-중요한가">왜 SSA가 중요한가?</a></h3>
<p>SSA 형태는 컴파일러 최적화를 극적으로 단순화한다:</p>
<h4 id="1-상수-전파-constant-propagation"><a class="header" href="#1-상수-전파-constant-propagation">1. 상수 전파 (Constant Propagation)</a></h4>
<pre><code class="language-mlir">// SSA 형태
%c5 = arith.constant 5 : i32
%result = arith.addi %c5, %c5 : i32

// 최적화: %c5가 상수임을 알고 있으므로
%c10 = arith.constant 10 : i32  // 컴파일 타임에 계산
</code></pre>
<p>SSA value는 한 번만 정의되므로, 정의를 추적하여 상수 값을 전파할 수 있다.</p>
<h4 id="2-죽은-코드-제거-dead-code-elimination"><a class="header" href="#2-죽은-코드-제거-dead-code-elimination">2. 죽은 코드 제거 (Dead Code Elimination)</a></h4>
<pre><code class="language-mlir">// SSA 형태
%unused = arith.constant 42 : i32  // 정의되지만 사용되지 않음
%result = arith.constant 10 : i32
func.return %result : i32

// 최적화: %unused는 사용되지 않으므로 제거 가능
</code></pre>
<p>SSA value가 사용되지 않으면 정의도 불필요하다. 쉽게 감지하고 제거할 수 있다.</p>
<h4 id="3-레지스터-할당-register-allocation"><a class="header" href="#3-레지스터-할당-register-allocation">3. 레지스터 할당 (Register Allocation)</a></h4>
<pre><code class="language-mlir">%x = arith.constant 5 : i32       // %x의 수명 시작
%y = arith.constant 10 : i32      // %y의 수명 시작
%z = arith.addi %x, %y : i32      // %x, %y 사용 (%x, %y 수명 끝)
func.return %z : i32               // %z 사용 (%z 수명 끝)
</code></pre>
<p>SSA value의 수명(lifetime)이 명확하다:</p>
<ul>
<li>정의 지점에서 시작</li>
<li>마지막 사용 지점에서 끝</li>
</ul>
<p>레지스터 할당기가 수명 분석을 쉽게 수행하여 레지스터를 효율적으로 재사용할 수 있다.</p>
<h3 id="let-바인딩은-자연스럽게-ssa다"><a class="header" href="#let-바인딩은-자연스럽게-ssa다">Let 바인딩은 자연스럽게 SSA다</a></h3>
<p>함수형 언어의 let 바인딩은 불변이므로, 변환 없이 SSA로 직접 매핑된다:</p>
<pre><code class="language-fsharp">// FunLang 소스
let x = 5 in
x + x
</code></pre>
<p><strong>MLIR IR로 변환:</strong></p>
<pre><code class="language-mlir">func.func @main() -&gt; i32 {
  %x = arith.constant 5 : i32      // let x = 5
  %result = arith.addi %x, %x : i32  // x + x
  func.return %result : i32
}
</code></pre>
<p><code>let x = 5</code>가 SSA value <code>%x</code>의 <strong>단일 정의</strong>가 된다. 추가 작업이 필요 없다!</p>
<h3 id="명령형-언어와의-대비"><a class="header" href="#명령형-언어와의-대비">명령형 언어와의 대비</a></h3>
<p>명령형 언어는 변수 뮤테이션을 허용하므로 SSA 변환이 필요하다:</p>
<pre><code class="language-c">// C 코드 (SSA 아님)
int x = 5;
int y = x + x;
x = 10;       // 뮤테이션!
int z = x + y;
</code></pre>
<p><strong>SSA로 변환 (컴파일러가 수행):</strong></p>
<pre><code class="language-mlir">%x_0 = arith.constant 5 : i32       // x = 5
%y = arith.addi %x_0, %x_0 : i32    // y = x + x
%x_1 = arith.constant 10 : i32      // x = 10 (새로운 SSA value)
%z = arith.addi %x_1, %y : i32      // z = x + y
</code></pre>
<p>각 “할당“이 새로운 SSA value를 생성한다 (<code>%x_0</code>, <code>%x_1</code>). 이것이 SSA 변환(SSA conversion)이다.</p>
<p><strong>함수형 언어의 이점:</strong> 뮤테이션이 없으므로 SSA 변환이 불필요하다. let 바인딩이 이미 SSA다!</p>
<h3 id="섀도잉-새로운-값-뮤테이션-아님"><a class="header" href="#섀도잉-새로운-값-뮤테이션-아님">섀도잉: 새로운 값, 뮤테이션 아님</a></h3>
<p>함수형 언어에서 같은 이름을 다시 바인딩하면 어떻게 될까?</p>
<pre><code class="language-fsharp">let x = 5 in
let x = 10 in
x
</code></pre>
<p>이것은 **섀도잉(shadowing)**이다:</p>
<pre><code class="language-mlir">func.func @main() -&gt; i32 {
  %x = arith.constant 5 : i32      // 첫 번째 x 바인딩
  %x_0 = arith.constant 10 : i32   // 두 번째 x 바인딩 (새로운 값)
  func.return %x_0 : i32            // 내부 x 사용
}
</code></pre>
<p><strong>핵심:</strong> MLIR은 자동으로 고유한 이름을 생성한다 (<code>%x</code>, <code>%x_0</code>, <code>%x_1</code>, …). 섀도잉은 새로운 SSA value를 만들 뿐, 기존 값을 변경하지 않는다.</p>
<p>외부 <code>%x</code>는 여전히 존재하지만 내부 스코프에서는 가려진다 (shadowed). 스코프가 끝나면 외부 <code>%x</code>가 다시 보인다.</p>
<h3 id="ssa의-제약"><a class="header" href="#ssa의-제약">SSA의 제약</a></h3>
<p>SSA에서 <strong>제어 흐름(control flow)</strong> 합류 지점에서는 어떻게 될까?</p>
<pre><code class="language-fsharp">let x = if condition then 10 else 20 in
x + x
</code></pre>
<p>if 표현식이 두 가지 다른 값 (10 또는 20)을 생성할 수 있다. 어떤 SSA value를 <code>x</code>에 바인딩해야 할까?</p>
<p><strong>해답:</strong> MLIR은 <strong>block arguments</strong>를 사용한다. Chapter 08 (제어 흐름)에서 자세히 다룰 것이다. 지금은 let 바인딩이 단순한 값 바인딩이며 조건부 바인딩이 없다는 점만 기억하자.</p>
<h3 id="ssa-요약"><a class="header" href="#ssa-요약">SSA 요약</a></h3>
<p><strong>SSA 형태:</strong></p>
<ul>
<li>각 value는 정확히 한 번만 정의된다</li>
<li>사용은 여러 번 가능하다</li>
<li>컴파일러 최적화를 단순화한다</li>
<li>MLIR은 SSA를 기본으로 한다</li>
</ul>
<p><strong>Let 바인딩과 SSA:</strong></p>
<ul>
<li>함수형 언어의 let 바인딩은 불변이다</li>
<li>불변 = 자연스러운 SSA 형태</li>
<li>섀도잉은 새로운 SSA value를 생성한다</li>
<li>뮤테이션이 없으므로 SSA 변환이 불필요하다</li>
</ul>
<blockquote>
<p><strong>명심:</strong> SSA는 이론이 아니라 실용이다. 모든 현대 컴파일러 (LLVM, GCC, MLIR)는 SSA를 사용한다. 함수형 언어는 SSA를 “무료로” 얻는다!</p>
</blockquote>
<h2 id="확장된-ast-let과-var"><a class="header" href="#확장된-ast-let과-var">확장된 AST: Let과 Var</a></h2>
<p>이제 AST에 let 바인딩과 변수 참조를 추가한다.</p>
<p><strong>Ast.fs</strong> 수정:</p>
<pre><code class="language-fsharp">namespace FunLangCompiler

/// 이진 연산자 (Chapter 06)
type Operator =
    | Add
    | Subtract
    | Multiply
    | Divide

/// 비교 연산자 (Chapter 06)
type CompareOp =
    | LessThan
    | GreaterThan
    | LessEqual
    | GreaterEqual
    | Equal
    | NotEqual

/// 단항 연산자 (Chapter 06)
type UnaryOp =
    | Negate

/// FunLang 표현식 AST
type Expr =
    | IntLiteral of int
    | BinaryOp of Operator * Expr * Expr
    | UnaryOp of UnaryOp * Expr
    | Comparison of CompareOp * Expr * Expr
    // NEW: let 바인딩과 변수 참조
    | Let of name: string * binding: Expr * body: Expr
    | Var of name: string

/// 최상위 프로그램
type Program =
    { expr: Expr }
</code></pre>
<p><strong>새로운 케이스 설명:</strong></p>
<h3 id="let-of-name--binding--body"><a class="header" href="#let-of-name--binding--body">Let of name * binding * body</a></h3>
<pre><code class="language-fsharp">| Let of name: string * binding: Expr * body: Expr
</code></pre>
<p><strong>의미:</strong> <code>let {name} = {binding} in {body}</code></p>
<p><strong>필드:</strong></p>
<ul>
<li><code>name</code>: 바인딩할 변수 이름 (예: “x”)</li>
<li><code>binding</code>: 변수에 바인딩할 표현식 (예: <code>IntLiteral 10</code>)</li>
<li><code>body</code>: 바인딩이 유효한 스코프 (예: <code>BinaryOp(Add, Var "x", Var "x")</code>)</li>
</ul>
<p><strong>예시:</strong></p>
<pre><code class="language-fsharp">// FunLang: let x = 10 in x + x
Let("x",
  IntLiteral 10,
  BinaryOp(Add, Var "x", Var "x"))
</code></pre>
<p><strong>스코프:</strong> <code>body</code> 표현식 내에서만 <code>name</code>이 유효하다. 스코프 밖에서는 변수가 존재하지 않는다.</p>
<h3 id="var-of-name"><a class="header" href="#var-of-name">Var of name</a></h3>
<pre><code class="language-fsharp">| Var of name: string
</code></pre>
<p><strong>의미:</strong> 변수 참조 - 이전에 바인딩된 변수의 값을 사용한다.</p>
<p><strong>필드:</strong></p>
<ul>
<li><code>name</code>: 참조할 변수 이름 (예: “x”)</li>
</ul>
<p><strong>예시:</strong></p>
<pre><code class="language-fsharp">// FunLang: x
Var "x"
</code></pre>
<p><strong>바인딩 필요:</strong> <code>Var "x"</code>를 사용하려면 스코프에서 <code>x</code>가 바인딩되어 있어야 한다. 바인딩되지 않은 변수를 참조하면 컴파일 에러다.</p>
<h3 id="중첩된-let-바인딩"><a class="header" href="#중첩된-let-바인딩">중첩된 Let 바인딩</a></h3>
<pre><code class="language-fsharp">// FunLang:
// let x = 10 in
// let y = 20 in
// x + y

Let("x",
  IntLiteral 10,
  Let("y",
    IntLiteral 20,
    BinaryOp(Add, Var "x", Var "y")))
</code></pre>
<p><strong>스코프 중첩:</strong></p>
<ul>
<li>외부 let (<code>x</code>)의 body는 내부 let (<code>y</code>)이다</li>
<li>내부 let의 body에서 <code>x</code>와 <code>y</code> 모두 보인다</li>
<li>내부 스코프는 외부 스코프를 “확장“한다</li>
</ul>
<h3 id="섀도잉-예시"><a class="header" href="#섀도잉-예시">섀도잉 예시</a></h3>
<pre><code class="language-fsharp">// FunLang:
// let x = 5 in
// let x = x + 1 in
// x

Let("x",
  IntLiteral 5,
  Let("x",
    BinaryOp(Add, Var "x", IntLiteral 1),  // 외부 x 사용
    Var "x"))  // 내부 x 반환
</code></pre>
<p><strong>섀도잉 동작:</strong></p>
<ul>
<li>두 번째 <code>Let("x", ...)</code>: 새로운 <code>x</code> 바인딩</li>
<li><code>BinaryOp(Add, Var "x", ...)</code>: 여기서 <code>Var "x"</code>는 <strong>외부 x</strong> (값 5)를 참조한다</li>
<li><code>body</code>의 <code>Var "x"</code>: 여기서 <code>Var "x"</code>는 <strong>내부 x</strong> (값 6)를 참조한다</li>
</ul>
<p><strong>결과:</strong> 6을 반환한다.</p>
<h3 id="ast-완전한-예시"><a class="header" href="#ast-완전한-예시">AST 완전한 예시</a></h3>
<pre><code class="language-fsharp">// FunLang:
// let x = 10 in
// let y = 20 in
// let z = x + y in
// z * 2

Let("x",
  IntLiteral 10,
  Let("y",
    IntLiteral 20,
    Let("z",
      BinaryOp(Add, Var "x", Var "y"),
      BinaryOp(Multiply, Var "z", IntLiteral 2))))
</code></pre>
<p><strong>예상 결과:</strong></p>
<ul>
<li>x = 10</li>
<li>y = 20</li>
<li>z = x + y = 30</li>
<li>z * 2 = 60</li>
</ul>
<p>이 AST를 컴파일하면 60을 반환하는 네이티브 바이너리가 생성된다.</p>
<h2 id="환경-개념-environment"><a class="header" href="#환경-개념-environment">환경 개념 (Environment)</a></h2>
<p>변수를 컴파일하려면 **환경(environment)**이 필요하다.</p>
<h3 id="환경이란"><a class="header" href="#환경이란">환경이란?</a></h3>
<p><strong>정의:</strong> 환경은 변수 이름을 SSA value에 매핑하는 자료구조다.</p>
<p><strong>타입 정의:</strong></p>
<pre><code class="language-fsharp">/// 변수 이름 -&gt; MLIR SSA value 매핑
type Env = Map&lt;string, MlirValue&gt;
</code></pre>
<p>F#의 <code>Map</code> 타입은 불변 딕셔너리다. 키-값 쌍을 저장하며, 함수형 방식으로 확장할 수 있다.</p>
<h3 id="환경-연산"><a class="header" href="#환경-연산">환경 연산</a></h3>
<h4 id="1-빈-환경-생성"><a class="header" href="#1-빈-환경-생성">1. 빈 환경 생성</a></h4>
<pre><code class="language-fsharp">let emptyEnv : Env = Map.empty
</code></pre>
<p>프로그램 시작 시 환경은 비어 있다. 아직 변수가 바인딩되지 않았다.</p>
<h4 id="2-환경-확장-바인딩-추가"><a class="header" href="#2-환경-확장-바인딩-추가">2. 환경 확장 (바인딩 추가)</a></h4>
<pre><code class="language-fsharp">// x를 %c5 SSA value에 바인딩
let env = Map.empty
let env' = env.Add("x", someValue)
</code></pre>
<p><code>env.Add(name, value)</code>는 새로운 환경을 반환한다. 기존 환경 <code>env</code>는 변경되지 않는다 (불변성).</p>
<h4 id="3-변수-조회"><a class="header" href="#3-변수-조회">3. 변수 조회</a></h4>
<pre><code class="language-fsharp">// x의 SSA value 찾기
match env.TryFind("x") with
| Some(value) -&gt; value  // x가 바인딩되어 있음
| None -&gt; failwith "Unbound variable: x"  // x가 바인딩되지 않음
</code></pre>
<p><code>TryFind</code>는 <code>Option</code> 타입을 반환한다:</p>
<ul>
<li><code>Some(value)</code>: 변수가 환경에 존재</li>
<li><code>None</code>: 변수가 존재하지 않음 (컴파일 에러)</li>
</ul>
<h3 id="환경과-스코프"><a class="header" href="#환경과-스코프">환경과 스코프</a></h3>
<p>스코프는 환경을 통해 구현된다:</p>
<pre><code class="language-fsharp">// let x = 10 in let y = 20 in x + y
// 각 let이 환경을 확장한다

let env0 = Map.empty             // 초기 환경 (비어 있음)

// let x = 10
let env1 = env0.Add("x", %c10)   // env1 = { x -&gt; %c10 }

// let y = 20
let env2 = env1.Add("y", %c20)   // env2 = { x -&gt; %c10, y -&gt; %c20 }

// x + y (env2에서 x와 y 조회)
// x = %c10, y = %c20
</code></pre>
<p><strong>환경 스택 다이어그램:</strong></p>
<pre><code>let x = 5 in       env = { x -&gt; %c5 }
  let y = 10 in    env = { x -&gt; %c5, y -&gt; %c10 }
    x + y          lookup x, lookup y -&gt; arith.addi %c5, %c10
</code></pre>
<p>각 let 바인딩이 환경에 새로운 항목을 추가한다. 내부 스코프의 환경은 외부 스코프의 모든 바인딩을 포함한다.</p>
<h3 id="섀도잉과-환경"><a class="header" href="#섀도잉과-환경">섀도잉과 환경</a></h3>
<p>같은 이름을 다시 바인딩하면?</p>
<pre><code class="language-fsharp">// let x = 5 in let x = 10 in x
let env0 = Map.empty
let env1 = env0.Add("x", %c5)   // env1 = { x -&gt; %c5 }
let env2 = env1.Add("x", %c10)  // env2 = { x -&gt; %c10 }

// env2에서 x 조회 -&gt; %c10 (새로운 바인딩)
</code></pre>
<p><code>Map.Add</code>는 기존 키가 있으면 값을 덮어쓴다. 하지만 <code>env1</code>은 변경되지 않는다 (불변):</p>
<pre><code class="language-fsharp">// env1에서 x 조회 -&gt; 여전히 %c5
// env2에서 x 조회 -&gt; %c10
</code></pre>
<p>이것이 <strong>스코프 기반 섀도잉</strong>이다. 내부 스코프가 끝나면 외부 바인딩이 다시 보인다:</p>
<pre><code class="language-fsharp">// let x = 5 in (let x = 10 in x) + x
//               ^^^^^^^^^^^^^   ^^^
//               내부 x = 10     외부 x = 5

let env0 = Map.empty
let env1 = env0.Add("x", %c5)

// 내부 스코프
let env2 = env1.Add("x", %c10)
// 내부 body에서 x 조회 -&gt; %c10

// 외부 스코프로 돌아옴 (env1 사용)
// 외부 body에서 x 조회 -&gt; %c5
</code></pre>
<p><strong>결과:</strong> <code>10 + 5 = 15</code></p>
<h3 id="환경-전달-패턴"><a class="header" href="#환경-전달-패턴">환경 전달 패턴</a></h3>
<p>컴파일러는 환경을 함수 인자로 전달한다:</p>
<pre><code class="language-fsharp">let rec compileExpr (builder: OpBuilder) (expr: Expr) (env: Env) : MlirValue =
  match expr with
  | IntLiteral n -&gt; ...  // env 사용 안 함
  | Var name -&gt;
      // env에서 변수 조회
      match env.TryFind(name) with
      | Some(value) -&gt; value
      | None -&gt; failwithf "Unbound variable: %s" name
  | Let(name, binding, body) -&gt;
      // 1. binding 표현식 컴파일 (현재 env 사용)
      let bindVal = compileExpr builder binding env
      // 2. env 확장
      let env' = env.Add(name, bindVal)
      // 3. body 표현식 컴파일 (확장된 env' 사용)
      compileExpr builder body env'
  | BinaryOp(op, lhs, rhs) -&gt;
      // 재귀 호출에 env 전달
      let lhsVal = compileExpr builder lhs env
      let rhsVal = compileExpr builder rhs env
      ...
</code></pre>
<p><strong>핵심 패턴:</strong></p>
<ul>
<li><code>compileExpr</code>이 <code>env</code> 파라미터를 받는다</li>
<li>모든 재귀 호출에서 <code>env</code>를 전달한다</li>
<li><code>Let</code> 케이스에서 <code>env</code>를 확장하고 body에 전달한다</li>
<li><code>Var</code> 케이스에서 <code>env</code>를 조회한다</li>
</ul>
<p>이것이 **환경 전달(environment passing)**이다. 함수형 프로그래밍에서 흔한 패턴이다.</p>
<h3 id="환경-요약"><a class="header" href="#환경-요약">환경 요약</a></h3>
<p><strong>환경:</strong></p>
<ul>
<li>변수 이름 -&gt; SSA value 매핑</li>
<li>F# <code>Map&lt;string, MlirValue&gt;</code> 타입</li>
<li>불변 자료구조</li>
</ul>
<p><strong>연산:</strong></p>
<ul>
<li><code>Map.empty</code>: 빈 환경</li>
<li><code>env.Add(name, value)</code>: 바인딩 추가 (새 환경 반환)</li>
<li><code>env.TryFind(name)</code>: 변수 조회 (Option 반환)</li>
</ul>
<p><strong>스코프:</strong></p>
<ul>
<li>각 let 바인딩이 환경을 확장한다</li>
<li>내부 스코프는 외부 바인딩을 모두 포함한다</li>
<li>섀도잉은 <code>Map.Add</code>로 구현된다</li>
</ul>
<p><strong>환경 전달:</strong></p>
<ul>
<li><code>compileExpr</code>에 <code>env</code> 파라미터 추가</li>
<li>재귀 호출에서 <code>env</code> 전달</li>
<li><code>Let</code> 케이스에서 <code>env</code> 확장</li>
</ul>
<blockquote>
<p><strong>다음 섹션:</strong> 환경을 사용하여 let 바인딩을 MLIR IR로 컴파일하는 코드를 작성한다!</p>
</blockquote>
<h2 id="환경을-사용한-코드-생성"><a class="header" href="#환경을-사용한-코드-생성">환경을 사용한 코드 생성</a></h2>
<p>이제 Chapter 06의 <code>compileExpr</code>을 확장하여 let 바인딩과 변수를 처리한다.</p>
<h3 id="compileexpr-시그니처-변경"><a class="header" href="#compileexpr-시그니처-변경">compileExpr 시그니처 변경</a></h3>
<p>먼저 환경 파라미터를 추가한다:</p>
<pre><code class="language-fsharp">// 기존 (Chapter 06):
let rec compileExpr
    (builder: OpBuilder)
    (block: MlirBlock)
    (location: Location)
    (expr: Expr)
    : MlirValue = ...

// 새로운 (Chapter 07):
let rec compileExpr
    (builder: OpBuilder)
    (block: MlirBlock)
    (location: Location)
    (expr: Expr)
    (env: Env)        // 환경 추가!
    : MlirValue = ...
</code></pre>
<p><strong>환경 타입 정의:</strong></p>
<pre><code class="language-fsharp">/// 변수 이름 -&gt; MLIR SSA value 매핑
type Env = Map&lt;string, MlirValue&gt;
</code></pre>
<h3 id="let-케이스-구현"><a class="header" href="#let-케이스-구현">Let 케이스 구현</a></h3>
<pre><code class="language-fsharp">| Let(name, binding, body) -&gt;
    // 1. binding 표현식 컴파일 (현재 환경 사용)
    let bindVal = compileExpr builder block location binding env

    // 2. 환경 확장: name -&gt; bindVal 매핑 추가
    let env' = env.Add(name, bindVal)

    // 3. body 표현식 컴파일 (확장된 환경 사용)
    compileExpr builder block location body env'
</code></pre>
<p><strong>동작 설명:</strong></p>
<ol>
<li><code>binding</code> 표현식을 먼저 컴파일한다. 이것이 변수에 바인딩될 값이다.</li>
<li>현재 환경 <code>env</code>를 확장하여 <code>name</code>을 <code>bindVal</code>에 매핑한다. 새로운 환경 <code>env'</code>가 생성된다.</li>
<li><code>body</code> 표현식을 컴파일할 때 확장된 환경 <code>env'</code>를 사용한다. body 내에서 <code>name</code>을 참조할 수 있다.</li>
</ol>
<p><strong>핵심:</strong> let 바인딩은 MLIR IR에 새로운 연산을 생성하지 않는다. 단지 환경을 확장하고 body를 컴파일할 뿐이다. SSA value는 <code>binding</code> 표현식에서 이미 생성되었다.</p>
<h3 id="var-케이스-구현"><a class="header" href="#var-케이스-구현">Var 케이스 구현</a></h3>
<pre><code class="language-fsharp">| Var(name) -&gt;
    // 환경에서 변수 조회
    match env.TryFind(name) with
    | Some(value) -&gt; value  // 바인딩된 SSA value 반환
    | None -&gt; failwithf "Unbound variable: %s" name  // 컴파일 에러
</code></pre>
<p><strong>동작 설명:</strong></p>
<ul>
<li><code>env.TryFind(name)</code>으로 변수를 조회한다.</li>
<li>바인딩되어 있으면 (<code>Some(value)</code>) 해당 SSA value를 반환한다.</li>
<li>바인딩되지 않았으면 (<code>None</code>) 에러를 발생시킨다.</li>
</ul>
<p><strong>중요:</strong> 변수 참조는 MLIR IR에 새로운 연산을 생성하지 않는다. 단지 기존 SSA value를 반환할 뿐이다. 이것이 SSA의 핵심이다!</p>
<h3 id="기존-케이스-업데이트"><a class="header" href="#기존-케이스-업데이트">기존 케이스 업데이트</a></h3>
<p>모든 기존 케이스에서 재귀 호출에 <code>env</code>를 전달해야 한다:</p>
<pre><code class="language-fsharp">| IntLiteral value -&gt;
    // 환경 사용 안 함 (리터럴은 변수를 참조하지 않음)
    let i32Type = builder.I32Type()
    let attr = builder.Context.GetIntegerAttr(i32Type, int64 value)
    let constOp = builder.CreateConstant(attr, location)
    MlirNative.mlirBlockAppendOwnedOperation(block, constOp)
    builder.GetResult(constOp, 0)

| BinaryOp(op, lhs, rhs) -&gt;
    // 재귀 호출에 env 전달
    let lhsVal = compileExpr builder block location lhs env
    let rhsVal = compileExpr builder block location rhs env
    let binOp = builder.CreateArithBinaryOp(op, lhsVal, rhsVal, location)
    MlirNative.mlirBlockAppendOwnedOperation(block, binOp)
    builder.GetResult(binOp, 0)

| UnaryOp(Negate, expr) -&gt;
    // 재귀 호출에 env 전달
    let val = compileExpr builder block location expr env
    let negOp = builder.CreateArithNegate(val, location)
    MlirNative.mlirBlockAppendOwnedOperation(block, negOp)
    builder.GetResult(negOp, 0)

| Comparison(compareOp, lhs, rhs) -&gt;
    // 재귀 호출에 env 전달
    let lhsVal = compileExpr builder block location lhs env
    let rhsVal = compileExpr builder block location rhs env
    let cmpOp = builder.CreateArithCompare(compareOp, lhsVal, rhsVal, location)
    MlirNative.mlirBlockAppendOwnedOperation(block, cmpOp)
    let cmpVal = builder.GetResult(cmpOp, 0)
    // i1 -&gt; i32 확장 (Chapter 06과 동일)
    let i32Type = builder.I32Type()
    let extOp = builder.CreateArithExtUI(cmpVal, i32Type, location)
    MlirNative.mlirBlockAppendOwnedOperation(block, extOp)
    builder.GetResult(extOp, 0)
</code></pre>
<p><strong>패턴:</strong> 모든 재귀 호출에서 현재 환경 <code>env</code>를 그대로 전달한다. Let 케이스만 환경을 확장한다.</p>
<h3 id="완전한-codegenfs-리스팅"><a class="header" href="#완전한-codegenfs-리스팅">완전한 CodeGen.fs 리스팅</a></h3>
<p><strong>CodeGen.fs</strong> (환경 지원 버전):</p>
<pre><code class="language-fsharp">namespace FunLangCompiler

open System
open MlirWrapper
open MlirBindings

module CodeGen =

    /// 변수 이름 -&gt; MLIR SSA value 매핑
    type Env = Map&lt;string, MlirValue&gt;

    /// 표현식을 MLIR value로 컴파일 (재귀적, 환경 전달)
    let rec compileExpr
        (builder: OpBuilder)
        (block: MlirBlock)
        (location: Location)
        (expr: Expr)
        (env: Env)
        : MlirValue =

        match expr with
        | IntLiteral value -&gt;
            let i32Type = builder.I32Type()
            let attr = builder.Context.GetIntegerAttr(i32Type, int64 value)
            let constOp = builder.CreateConstant(attr, location)
            MlirNative.mlirBlockAppendOwnedOperation(block, constOp)
            builder.GetResult(constOp, 0)

        | Var(name) -&gt;
            match env.TryFind(name) with
            | Some(value) -&gt; value
            | None -&gt; failwithf "Unbound variable: %s" name

        | Let(name, binding, body) -&gt;
            let bindVal = compileExpr builder block location binding env
            let env' = env.Add(name, bindVal)
            compileExpr builder block location body env'

        | BinaryOp(op, lhs, rhs) -&gt;
            let lhsVal = compileExpr builder block location lhs env
            let rhsVal = compileExpr builder block location rhs env
            let binOp = builder.CreateArithBinaryOp(op, lhsVal, rhsVal, location)
            MlirNative.mlirBlockAppendOwnedOperation(block, binOp)
            builder.GetResult(binOp, 0)

        | UnaryOp(Negate, expr) -&gt;
            let val = compileExpr builder block location expr env
            let negOp = builder.CreateArithNegate(val, location)
            MlirNative.mlirBlockAppendOwnedOperation(block, negOp)
            builder.GetResult(negOp, 0)

        | Comparison(compareOp, lhs, rhs) -&gt;
            let lhsVal = compileExpr builder block location lhs env
            let rhsVal = compileExpr builder block location rhs env
            let cmpOp = builder.CreateArithCompare(compareOp, lhsVal, rhsVal, location)
            MlirNative.mlirBlockAppendOwnedOperation(block, cmpOp)
            let cmpVal = builder.GetResult(cmpOp, 0)
            let i32Type = builder.I32Type()
            let extOp = builder.CreateArithExtUI(cmpVal, i32Type, location)
            MlirNative.mlirBlockAppendOwnedOperation(block, extOp)
            builder.GetResult(extOp, 0)

    /// 프로그램을 MLIR module로 컴파일
    let translateToMlir (program: Program) : Module =
        let ctx = new Context()
        ctx.LoadDialect("arith")
        ctx.LoadDialect("func")

        let loc = Location.Unknown(ctx)
        let mlirMod = new Module(ctx, loc)

        let builder = OpBuilder(ctx)
        let i32Type = builder.I32Type()

        // main 함수 생성
        let funcType = builder.FunctionType([||], [| i32Type |])
        let funcOp = builder.CreateFunction("main", funcType, loc)

        let bodyRegion = MlirNative.mlirOperationGetRegion(funcOp, 0n)
        let entryBlock = MlirNative.mlirBlockCreate(0n, nativeint 0, nativeint 0)
        MlirNative.mlirRegionAppendOwnedBlock(bodyRegion, entryBlock)

        // 빈 환경에서 시작
        let env = Map.empty

        // 표현식 컴파일 (환경 전달)
        let resultValue = compileExpr builder entryBlock loc program.expr env

        // return operation 생성
        let returnOp = builder.CreateReturn([| resultValue |], loc)
        MlirNative.mlirBlockAppendOwnedOperation(entryBlock, returnOp)

        // 함수를 module에 추가
        MlirNative.mlirBlockAppendOwnedOperation(mlirMod.Body, funcOp)

        mlirMod

    /// MLIR module 검증
    let verify (mlirMod: Module) =
        if not (mlirMod.Verify()) then
            eprintfn "MLIR verification failed:"
            eprintfn "%s" (mlirMod.Print())
            failwith "MLIR IR is invalid"
</code></pre>
<p><strong>주목할 점:</strong></p>
<ul>
<li><code>compileExpr</code>이 <code>env</code> 파라미터를 받는다</li>
<li><code>translateToMlir</code>에서 빈 환경 (<code>Map.empty</code>)으로 시작한다</li>
<li>모든 재귀 호출에서 <code>env</code>를 전달한다</li>
</ul>
<h2 id="중첩된-let-바인딩-1"><a class="header" href="#중첩된-let-바인딩-1">중첩된 Let 바인딩</a></h2>
<p>중첩된 let 바인딩이 어떻게 컴파일되는지 보자.</p>
<p><strong>FunLang 소스:</strong></p>
<pre><code class="language-fsharp">let x = 10 in
let y = 20 in
let z = x + y in
z * 2
</code></pre>
<p><strong>AST:</strong></p>
<pre><code class="language-fsharp">Let("x",
  IntLiteral 10,
  Let("y",
    IntLiteral 20,
    Let("z",
      BinaryOp(Add, Var "x", Var "y"),
      BinaryOp(Multiply, Var "z", IntLiteral 2))))
</code></pre>
<p><strong>컴파일 과정:</strong></p>
<ol>
<li>
<p><strong>Let(“x”, IntLiteral 10, …)</strong></p>
<ul>
<li><code>binding</code> 컴파일: <code>%c10 = arith.constant 10 : i32</code></li>
<li><code>env0 = {}</code></li>
<li><code>env1 = env0.Add("x", %c10) = { x -&gt; %c10 }</code></li>
<li><code>body</code> 컴파일 (env1 사용)</li>
</ul>
</li>
<li>
<p><strong>Let(“y”, IntLiteral 20, …)</strong> (env1에서)</p>
<ul>
<li><code>binding</code> 컴파일: <code>%c20 = arith.constant 20 : i32</code></li>
<li><code>env2 = env1.Add("y", %c20) = { x -&gt; %c10, y -&gt; %c20 }</code></li>
<li><code>body</code> 컴파일 (env2 사용)</li>
</ul>
</li>
<li>
<p><strong>Let(“z”, BinaryOp(Add, Var “x”, Var “y”), …)</strong> (env2에서)</p>
<ul>
<li><code>binding</code> 컴파일:
<ul>
<li><code>Var "x"</code>: env2에서 조회 → %c10</li>
<li><code>Var "y"</code>: env2에서 조회 → %c20</li>
<li><code>%z = arith.addi %c10, %c20 : i32</code></li>
</ul>
</li>
<li><code>env3 = env2.Add("z", %z) = { x -&gt; %c10, y -&gt; %c20, z -&gt; %z }</code></li>
<li><code>body</code> 컴파일 (env3 사용)</li>
</ul>
</li>
<li>
<p><strong>BinaryOp(Multiply, Var “z”, IntLiteral 2)</strong> (env3에서)</p>
<ul>
<li><code>Var "z"</code>: env3에서 조회 → %z</li>
<li><code>IntLiteral 2</code>: <code>%c2 = arith.constant 2 : i32</code></li>
<li><code>%result = arith.muli %z, %c2 : i32</code></li>
</ul>
</li>
</ol>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">module {
  func.func @main() -&gt; i32 {
    %c10 = arith.constant 10 : i32      // let x = 10
    %c20 = arith.constant 20 : i32      // let y = 20
    %z = arith.addi %c10, %c20 : i32    // let z = x + y
    %c2 = arith.constant 2 : i32
    %result = arith.muli %z, %c2 : i32  // z * 2
    func.return %result : i32
  }
}
</code></pre>
<p><strong>분석:</strong></p>
<ul>
<li>각 let 바인딩이 SSA value를 생성한다</li>
<li>변수 참조는 기존 SSA value를 재사용한다</li>
<li>명시적인 저장/로드 연산이 없다 (모든 것이 레지스터에 있다)</li>
<li>SSA value가 자유롭게 흐른다 (%c10과 %c20이 %z에서 사용됨)</li>
</ul>
<p><strong>실행:</strong></p>
<pre><code class="language-bash">$ ./program
$ echo $?
60
</code></pre>
<p>예상대로 60을 반환한다!</p>
<h2 id="변수-섀도잉"><a class="header" href="#변수-섀도잉">변수 섀도잉</a></h2>
<p>섀도잉이 어떻게 작동하는지 보자.</p>
<p><strong>FunLang 소스:</strong></p>
<pre><code class="language-fsharp">let x = 5 in
let x = x + 1 in
x
</code></pre>
<p><strong>AST:</strong></p>
<pre><code class="language-fsharp">Let("x",
  IntLiteral 5,
  Let("x",
    BinaryOp(Add, Var "x", IntLiteral 1),
    Var "x"))
</code></pre>
<p><strong>컴파일 과정:</strong></p>
<ol>
<li>
<p><strong>첫 번째 Let(“x”, IntLiteral 5, …)</strong></p>
<ul>
<li><code>binding</code>: <code>%x = arith.constant 5 : i32</code></li>
<li><code>env1 = { x -&gt; %x }</code></li>
</ul>
</li>
<li>
<p><strong>두 번째 Let(“x”, BinaryOp(Add, Var “x”, IntLiteral 1), …)</strong> (env1에서)</p>
<ul>
<li><code>binding</code>:
<ul>
<li><code>Var "x"</code>: env1에서 조회 → %x (값 5)</li>
<li><code>IntLiteral 1</code>: <code>%c1 = arith.constant 1 : i32</code></li>
<li><code>%x_0 = arith.addi %x, %c1 : i32</code></li>
</ul>
</li>
<li><code>env2 = env1.Add("x", %x_0) = { x -&gt; %x_0 }</code>  ← 섀도잉!</li>
</ul>
</li>
<li>
<p><strong>Var “x”</strong> (env2에서)</p>
<ul>
<li>env2에서 조회 → %x_0 (값 6)</li>
</ul>
</li>
</ol>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">module {
  func.func @main() -&gt; i32 {
    %x = arith.constant 5 : i32        // 외부 x
    %c1 = arith.constant 1 : i32
    %x_0 = arith.addi %x, %c1 : i32    // 내부 x = 외부 x + 1
    func.return %x_0 : i32              // 내부 x 반환
  }
}
</code></pre>
<p><strong>핵심 통찰력:</strong></p>
<ul>
<li>MLIR은 자동으로 고유한 이름을 생성한다 (<code>%x</code>, <code>%x_0</code>)</li>
<li>두 번째 <code>Let("x", ...)</code>에서 <code>binding</code> 표현식은 <strong>외부 x</strong>를 참조한다 (env1에서 컴파일)</li>
<li>body 표현식은 <strong>내부 x</strong>를 참조한다 (env2에서 컴파일)</li>
<li>섀도잉은 새로운 SSA value를 생성하지, 기존 value를 변경하지 않는다</li>
</ul>
<p><strong>실행:</strong></p>
<pre><code class="language-bash">$ ./program
$ echo $?
6
</code></pre>
<p>예상대로 6을 반환한다!</p>
<h2 id="완전한-예시와-드라이버"><a class="header" href="#완전한-예시와-드라이버">완전한 예시와 드라이버</a></h2>
<p>이제 완전한 컴파일러 드라이버를 작성하자.</p>
<p><strong>Main.fs 예시:</strong></p>
<pre><code class="language-fsharp">namespace FunLangCompiler

open System

module Main =

    [&lt;EntryPoint&gt;]
    let main args =
        printfn "=== FunLang Compiler with Let Bindings ==="

        // 예시: let x = 10 in let y = 20 in x + y
        let ast =
            Let("x",
              IntLiteral 10,
              Let("y",
                IntLiteral 20,
                BinaryOp(Add, Var "x", Var "y")))

        let program = { expr = ast }

        printfn "AST: %A" ast
        printfn ""

        // MLIR로 컴파일
        printfn "Compiling to MLIR..."
        let mlirMod = CodeGen.translateToMlir program
        printfn "%s" (mlirMod.Print())

        // 검증
        printfn "Verifying..."
        CodeGen.verify mlirMod
        printfn "✓ Verification passed"

        // Lowering과 네이티브 코드 생성 (Chapter 05와 동일)
        Lowering.lowerToLLVMDialect mlirMod
        let llvmIR = Lowering.translateToLLVMIR mlirMod
        NativeCodeGen.emitObjectFile llvmIR "program.o"
        NativeCodeGen.linkExecutable "program.o" "program"

        mlirMod.Dispose()

        printfn ""
        printfn "=== Compilation successful ==="
        printfn "Run: ./program"
        printfn "Expected output (exit code): 30"

        0
</code></pre>
<p><strong>컴파일과 실행:</strong></p>
<pre><code class="language-bash">$ dotnet run
=== FunLang Compiler with Let Bindings ===
AST: Let ("x", IntLiteral 10, Let ("y", IntLiteral 20, BinaryOp (Add, Var "x", Var "y")))

Compiling to MLIR...
module {
  func.func @main() -&gt; i32 {
    %c10 = arith.constant 10 : i32
    %c20 = arith.constant 20 : i32
    %0 = arith.addi %c10, %c20 : i32
    func.return %0 : i32
  }
}
Verifying...
✓ Verification passed
[... lowering과 linking ...]

=== Compilation successful ===
Run: ./program
Expected output (exit code): 30

$ ./program
$ echo $?
30
</code></pre>
<p>완벽하다!</p>
<h2 id="공통-에러"><a class="header" href="#공통-에러">공통 에러</a></h2>
<h3 id="에러-1-바인딩되지-않은-변수-참조"><a class="header" href="#에러-1-바인딩되지-않은-변수-참조">에러 1: 바인딩되지 않은 변수 참조</a></h3>
<p><strong>증상:</strong></p>
<pre><code>Exception: Unbound variable: y
</code></pre>
<p><strong>원인:</strong></p>
<p>변수가 스코프에 없는데 참조하려고 했다.</p>
<p><strong>예시:</strong></p>
<pre><code class="language-fsharp">// WRONG: y가 바인딩되지 않음
let x = 10 in
y + x
</code></pre>
<p><strong>해결:</strong></p>
<p>변수를 사용하기 전에 let 바인딩으로 정의한다:</p>
<pre><code class="language-fsharp">// CORRECT
let x = 10 in
let y = 20 in
y + x
</code></pre>
<h3 id="에러-2-스코프-밖에서-변수-사용"><a class="header" href="#에러-2-스코프-밖에서-변수-사용">에러 2: 스코프 밖에서 변수 사용</a></h3>
<p><strong>증상:</strong></p>
<pre><code>Exception: Unbound variable: x
</code></pre>
<p><strong>원인:</strong></p>
<p>변수가 스코프 밖에서 사용되었다.</p>
<p><strong>예시:</strong></p>
<pre><code class="language-fsharp">// WRONG: 두 번째 x는 스코프 밖
(let x = 10 in x + x) + x
//                      ^ x는 여기서 바인딩되지 않음
</code></pre>
<p>let 바인딩의 스코프는 <code>body</code> 표현식까지만이다. 밖에서는 보이지 않는다.</p>
<p><strong>해결:</strong></p>
<p>필요한 스코프 전체를 감싸거나, 바인딩을 외부로 이동한다:</p>
<pre><code class="language-fsharp">// CORRECT: x를 외부에서 바인딩
let x = 10 in
(x + x) + x
</code></pre>
<h3 id="에러-3-환경을-재귀-호출에-전달하지-않음"><a class="header" href="#에러-3-환경을-재귀-호출에-전달하지-않음">에러 3: 환경을 재귀 호출에 전달하지 않음</a></h3>
<p><strong>증상:</strong></p>
<pre><code>Compilation error: 'env' is not defined
</code></pre>
<p><strong>원인:</strong></p>
<p><code>compileExpr</code> 재귀 호출에서 <code>env</code> 파라미터를 빠뜨렸다.</p>
<p><strong>예시:</strong></p>
<pre><code class="language-fsharp">// WRONG: env 파라미터 누락
| BinaryOp(op, lhs, rhs) -&gt;
    let lhsVal = compileExpr builder block location lhs  // env 없음!
    ...
</code></pre>
<p><strong>해결:</strong></p>
<p>모든 <code>compileExpr</code> 호출에 <code>env</code>를 전달한다:</p>
<pre><code class="language-fsharp">// CORRECT
| BinaryOp(op, lhs, rhs) -&gt;
    let lhsVal = compileExpr builder block location lhs env
    let rhsVal = compileExpr builder block location rhs env
    ...
</code></pre>
<p><strong>패턴:</strong> 각 케이스를 추가할 때마다 재귀 호출에 <code>env</code>를 전달하는지 확인한다.</p>
<h3 id="에러-4-let-바인딩에서-환경-확장-잊음"><a class="header" href="#에러-4-let-바인딩에서-환경-확장-잊음">에러 4: Let 바인딩에서 환경 확장 잊음</a></h3>
<p><strong>증상:</strong></p>
<p>변수가 body에서 보이지 않는다.</p>
<p><strong>원인:</strong></p>
<p><code>Let</code> 케이스에서 <code>env.Add</code>를 호출했지만 확장된 환경을 body에 전달하지 않았다.</p>
<p><strong>예시:</strong></p>
<pre><code class="language-fsharp">// WRONG: 확장된 환경을 사용하지 않음
| Let(name, binding, body) -&gt;
    let bindVal = compileExpr builder block location binding env
    let env' = env.Add(name, bindVal)
    compileExpr builder block location body env  // env' 대신 env 사용!
</code></pre>
<p><strong>해결:</strong></p>
<p>확장된 환경 <code>env'</code>를 body에 전달한다:</p>
<pre><code class="language-fsharp">// CORRECT
| Let(name, binding, body) -&gt;
    let bindVal = compileExpr builder block location binding env
    let env' = env.Add(name, bindVal)
    compileExpr builder block location body env'  // env' 사용!
</code></pre>
<h3 id="에러-5-섀도잉을-뮤테이션으로-착각"><a class="header" href="#에러-5-섀도잉을-뮤테이션으로-착각">에러 5: 섀도잉을 뮤테이션으로 착각</a></h3>
<p><strong>개념 오류:</strong></p>
<pre><code class="language-fsharp">// 이것은 뮤테이션이 아니다!
let x = 5 in
let x = 10 in
x
</code></pre>
<p><strong>설명:</strong></p>
<p>이것은 변수 “x“를 덮어쓰는 것이 아니다. 새로운 바인딩을 만드는 것이다:</p>
<ul>
<li>외부 <code>x</code>는 값 5를 가진 SSA value <code>%x</code></li>
<li>내부 <code>x</code>는 값 10을 가진 SSA value <code>%x_0</code></li>
<li>두 value 모두 존재한다 (외부 x는 변경되지 않음)</li>
</ul>
<p><strong>MLIR IR 확인:</strong></p>
<pre><code class="language-mlir">%x = arith.constant 5 : i32    // 외부 x (여전히 존재)
%x_0 = arith.constant 10 : i32  // 내부 x (새로운 value)
func.return %x_0 : i32
</code></pre>
<h2 id="장-요약-1"><a class="header" href="#장-요약-1">장 요약</a></h2>
<p>이 장에서 다음을 성취했다:</p>
<ol>
<li><strong>SSA 형태 이해</strong>: 각 value는 한 번만 정의되며, 이것이 컴파일러 최적화를 단순화한다</li>
<li><strong>Let 바인딩 추가</strong>: 함수형 언어의 불변 바인딩이 SSA와 자연스럽게 일치한다</li>
<li><strong>환경 구현</strong>: <code>Map&lt;string, MlirValue&gt;</code>로 변수 스코프 관리</li>
<li><strong>환경 전달 패턴</strong>: 재귀 함수에 환경을 전달하여 중첩 스코프 구현</li>
<li><strong>섀도잉 vs 뮤테이션</strong>: 섀도잉은 새로운 SSA value를 생성하지, 기존 value를 변경하지 않는다</li>
<li><strong>완전한 예제</strong>: 중첩된 let 바인딩이 올바른 MLIR IR로 컴파일된다</li>
</ol>
<p><strong>독자가 할 수 있는 것:</strong></p>
<ul>
<li><code>let x = 5 in x + x</code> 컴파일 → 네이티브 바이너리 → 결과: 10 ✓</li>
<li><code>let x = 10 in let y = 20 in x + y</code> 컴파일 → 결과: 30 ✓</li>
<li>섀도잉 이해: <code>let x = 5 in let x = 10 in x</code> → 결과: 10 ✓</li>
<li>환경 전달로 스코프 관리 ✓</li>
<li>스코프 에러 디버깅 (바인딩되지 않은 변수) ✓</li>
</ul>
<p><strong>핵심 개념:</strong></p>
<ul>
<li><strong>SSA 형태</strong>: 각 value는 한 번만 정의된다</li>
<li><strong>Let 바인딩 = SSA value</strong>: 불변 바인딩이 SSA를 자연스럽게 표현한다</li>
<li><strong>환경 = 변수 스코프</strong>: Map으로 변수 이름을 SSA value에 매핑한다</li>
<li><strong>환경 전달 = 스코프 중첩</strong>: 재귀 호출로 스코프를 확장한다</li>
<li><strong>섀도잉 ≠ 뮤테이션</strong>: 새로운 value 생성, 기존 value 변경 아님</li>
</ul>
<p><strong>다음 장 미리보기:</strong></p>
<p>Chapter 08에서는 **제어 흐름 (if/else)**을 추가한다:</p>
<pre><code class="language-fsharp">let x = if 5 &lt; 10 then 42 else 0 in
x + x
</code></pre>
<p>이것은 다음을 도입한다:</p>
<ul>
<li><strong>scf.if</strong> 연산: 구조화된 제어 흐름</li>
<li><strong>Block arguments</strong>: MLIR의 PHI 노드 대안</li>
<li><strong>scf.yield</strong>: 분기에서 값 반환</li>
<li><strong>SSA at control flow merges</strong>: 조건부 값을 어떻게 SSA로 표현하는가</li>
</ul>
<p><strong>Phase 2는 계속된다!</strong></p>
<hr>
<p><strong>이제 독자는 let 바인딩과 변수를 컴파일하고, SSA 형태를 이해한다!</strong></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-08-제어-흐름과-block-arguments"><a class="header" href="#chapter-08-제어-흐름과-block-arguments">Chapter 08: 제어 흐름과 Block Arguments</a></h1>
<h2 id="소개-8"><a class="header" href="#소개-8">소개</a></h2>
<p>프로그래밍에서 조건부 실행은 필수다. 조건에 따라 다른 코드 경로를 실행하는 능력은 모든 실용적인 프로그램의 핵심이다.</p>
<p>함수형 언어에서 **if/then/else는 표현식(expression)**이다. 명령형 언어의 문(statement)이 아니라, 값을 생성하는 표현식이다:</p>
<pre><code class="language-fsharp">// 함수형 스타일 - if는 값을 반환한다
let result = if condition then 42 else 0

// 명령형 스타일과 대비
int result;
if (condition) {
    result = 42;
} else {
    result = 0;
}
</code></pre>
<p>함수형 스타일에서 if 표현식은 <strong>값을 생성</strong>한다. 두 분기(then/else) 중 하나가 실행되고, 그 결과가 if 표현식의 값이 된다.</p>
<p><strong>컴파일 도전과제:</strong> SSA 형태에서 두 분기가 어떻게 하나의 값으로 합쳐지는가?</p>
<pre><code class="language-fsharp">let x = if condition then 10 else 20 in
x + x
</code></pre>
<p>조건이 true면 <code>x = 10</code>, false면 <code>x = 20</code>이다. 하지만 SSA 형태에서 <code>x</code>는 단일 SSA value여야 한다. 두 분기의 값을 어떻게 합칠까?</p>
<p><strong>MLIR의 우아한 해답:</strong> <strong>Block Arguments</strong></p>
<p>전통적인 SSA는 PHI 노드를 사용하지만, MLIR은 더 깔끔한 방식을 제공한다. 이 장에서 MLIR의 block arguments와 <code>scf.if</code> 연산을 배운다.</p>
<p>이 장을 마치면:</p>
<ul>
<li>if/then/else 표현식을 네이티브 바이너리로 컴파일할 수 있다</li>
<li>Block arguments와 PHI 노드의 차이를 이해한다</li>
<li>MLIR의 <code>scf.if</code> 연산과 <code>scf.yield</code> 종결자를 사용할 수 있다</li>
<li>제어 흐름 합류 지점에서 SSA 값이 어떻게 병합되는지 안다</li>
</ul>
<blockquote>
<p><strong>중요:</strong> Block arguments는 MLIR의 핵심 혁신이다. PHI 노드의 복잡성을 제거하고 SSA 형태를 더 명확하게 만든다.</p>
</blockquote>
<h2 id="phi-노드-문제"><a class="header" href="#phi-노드-문제">PHI 노드 문제</a></h2>
<h3 id="전통적인-ssa-phi-노드"><a class="header" href="#전통적인-ssa-phi-노드">전통적인 SSA: PHI 노드</a></h3>
<p>LLVM IR과 전통적인 SSA 형태는 <strong>PHI 노드</strong>를 사용하여 제어 흐름 합류 지점에서 값을 병합한다.</p>
<p><strong>LLVM IR 예시:</strong></p>
<pre><code class="language-llvm">define i32 @example(i1 %cond) {
entry:
  br i1 %cond, label %then, label %else

then:
  %a = add i32 10, 1
  br label %merge

else:
  %b = add i32 20, 1
  br label %merge

merge:
  %result = phi i32 [ %a, %then ], [ %b, %else ]
  ret i32 %result
}
</code></pre>
<p><strong>동작 설명:</strong></p>
<ol>
<li><code>entry</code> 블록에서 조건 분기 (<code>br i1 %cond</code>)</li>
<li><code>then</code> 블록: <code>%a = 11</code> 계산 후 <code>merge</code>로 이동</li>
<li><code>else</code> 블록: <code>%b = 21</code> 계산 후 <code>merge</code>로 이동</li>
<li><code>merge</code> 블록: <strong>PHI 노드</strong>가 선택
<ul>
<li><code>%then</code> 블록에서 왔으면 <code>%a</code> 사용</li>
<li><code>%else</code> 블록에서 왔으면 <code>%b</code> 사용</li>
</ul>
</li>
</ol>
<p>PHI 노드는 “어느 블록에서 왔는가“에 따라 값을 선택한다. 표기법: <code>phi type [ value1, pred1 ], [ value2, pred2 ]</code></p>
<h3 id="phi-노드의-문제점"><a class="header" href="#phi-노드의-문제점">PHI 노드의 문제점</a></h3>
<h4 id="1-블록-시작-위치-제약"><a class="header" href="#1-블록-시작-위치-제약">1. 블록 시작 위치 제약</a></h4>
<p>PHI 노드는 <strong>반드시 블록의 시작</strong>에 있어야 한다:</p>
<pre><code class="language-llvm">merge:
  %result = phi i32 [ %a, %then ], [ %b, %else ]  ; PHI는 여기!
  %x = add i32 %result, 1                          ; 일반 연산은 PHI 뒤
  ; PHI를 여기에 추가할 수 없다 - 순서 규칙 위반
</code></pre>
<p>이 제약은 코드 생성을 복잡하게 만든다. PHI 노드를 먼저 모으고, 일반 연산을 뒤에 배치해야 한다.</p>
<h4 id="2-lost-copy-problem"><a class="header" href="#2-lost-copy-problem">2. Lost Copy Problem</a></h4>
<p>PHI 노드의 의미는 “블록 진입 시” 값을 선택하는 것이다. 하지만 실제 구현에서는 <strong>선행 블록의 끝</strong>에서 값을 복사한다:</p>
<pre><code class="language-llvm">then:
  %a = add i32 10, 1
  ; 실제로는 여기서 %a를 %result로 복사
  br label %merge

merge:
  %result = phi i32 [ %a, %then ], [ %b, %else ]
  ; %result는 이미 복사된 값을 가진다
</code></pre>
<p>이것이 <strong>lost copy problem</strong>이다:</p>
<ul>
<li>PHI 노드는 “merge 블록 진입 시” 선택하는 것처럼 보인다</li>
<li>실제 구현은 “선행 블록 종료 시” 복사한다</li>
<li>의미론과 구현의 불일치</li>
</ul>
<h4 id="3-dominance-frontier-계산"><a class="header" href="#3-dominance-frontier-계산">3. Dominance Frontier 계산</a></h4>
<p>PHI 노드를 올바르게 배치하려면 <strong>dominance frontier</strong> 알고리즘이 필요하다:</p>
<pre><code>// 어디에 PHI 노드를 삽입해야 할까?
// 복잡한 제어 흐름에서는 자명하지 않다
if (cond1) {
  x = 10;
} else if (cond2) {
  x = 20;
} else {
  x = 30;
}
// 여기서 x에 PHI 노드가 필요하다
// 하지만 몇 개의 선행 블록이 있는가?
</code></pre>
<p>Dominance frontier는 “변수가 재정의되는 모든 블록의 지배 경계“를 계산한다. 알고리즘이 복잡하고 구현이 어렵다.</p>
<h4 id="4-가독성-문제"><a class="header" href="#4-가독성-문제">4. 가독성 문제</a></h4>
<p>PHI 노드는 직관적이지 않다:</p>
<pre><code class="language-llvm">%result = phi i32 [ %a, %then ], [ %b, %else ]
; 이것이 무엇을 의미하는가?
; "then에서 왔으면 %a, else에서 왔으면 %b"
; 함수 호출처럼 보이지만 실제로는 특별한 의미를 가진다
</code></pre>
<p>초보자가 PHI 노드를 이해하기 어렵다. 특별한 규칙(블록 시작, 순서 지정, edge 의미론)을 배워야 한다.</p>
<h3 id="phi-노드-요약"><a class="header" href="#phi-노드-요약">PHI 노드 요약</a></h3>
<p><strong>PHI 노드의 특징:</strong></p>
<ul>
<li>제어 흐름 합류 지점에서 값을 병합한다</li>
<li>블록 시작에 위치해야 한다 (특별한 위치 규칙)</li>
<li>Lost copy problem - 의미론과 구현의 불일치</li>
<li>Dominance frontier 계산 필요</li>
<li>가독성이 낮다</li>
</ul>
<p><strong>MLIR의 해답:</strong> Block Arguments - PHI 노드를 대체하는 더 깔끔한 방식</p>
<h2 id="block-arguments-in-mlir"><a class="header" href="#block-arguments-in-mlir">Block Arguments in MLIR</a></h2>
<p>MLIR은 PHI 노드 대신 <strong>block arguments</strong>를 사용한다.</p>
<h3 id="block-arguments-개념"><a class="header" href="#block-arguments-개념">Block Arguments 개념</a></h3>
<p><strong>핵심 아이디어:</strong> 기본 블록(basic block)도 함수처럼 파라미터를 받을 수 있다.</p>
<p>함수는 인자를 받는다:</p>
<pre><code class="language-fsharp">let add(x: int, y: int) = x + y
</code></pre>
<p><strong>MLIR에서는 블록도 인자를 받는다:</strong></p>
<pre><code class="language-mlir">^myblock(%arg0: i32, %arg1: i32):
  %sum = arith.addi %arg0, %arg1 : i32
  ...
</code></pre>
<p><code>^myblock</code>은 두 개의 i32 인자를 받는다. 블록으로 분기할 때 값을 전달한다:</p>
<pre><code class="language-mlir">cf.br ^myblock(%value1, %value2 : i32, i32)
</code></pre>
<p>이것은 함수 호출과 유사하다: <code>myblock(value1, value2)</code></p>
<h3 id="block-arguments-vs-phi-nodes"><a class="header" href="#block-arguments-vs-phi-nodes">Block Arguments vs PHI Nodes</a></h3>
<p>같은 예시를 block arguments로 작성하면:</p>
<p><strong>MLIR with Block Arguments:</strong></p>
<pre><code class="language-mlir">func.func @example(%cond: i1) -&gt; i32 {
  cf.cond_br %cond, ^then, ^else

^then:
  %a = arith.constant 11 : i32
  cf.br ^merge(%a : i32)

^else:
  %b = arith.constant 21 : i32
  cf.br ^merge(%b : i32)

^merge(%result: i32):
  func.return %result : i32
}
</code></pre>
<p><strong>차이점 분석:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>측면</th><th>PHI 노드 (LLVM)</th><th>Block Arguments (MLIR)</th></tr>
</thead>
<tbody>
<tr><td><strong>값 전달</strong></td><td><code>phi i32 [ %a, %then ], [ %b, %else ]</code></td><td><code>cf.br ^merge(%a : i32)</code></td></tr>
<tr><td><strong>의미론</strong></td><td>“어느 블록에서 왔는가”</td><td>“블록 호출 시 인자 전달”</td></tr>
<tr><td><strong>위치 제약</strong></td><td>블록 시작에만 가능</td><td>블록 인자로 선언 (일반 파라미터)</td></tr>
<tr><td><strong>가독성</strong></td><td>특별한 문법, edge 리스트</td><td>함수 호출과 유사</td></tr>
</tbody>
</table>
</div>
<p><strong>핵심 통찰력:</strong></p>
<ul>
<li><strong>PHI 노드:</strong> “merge 블록이 선행 블록을 검사하여 값을 선택”</li>
<li><strong>Block Arguments:</strong> “선행 블록이 merge 블록에 값을 전달” (함수 호출처럼)</li>
</ul>
<p>Block arguments는 제어의 역전(inversion of control)이다:</p>
<ul>
<li>PHI: pull 방식 (merge 블록이 값을 가져온다)</li>
<li>Block Arguments: push 방식 (선행 블록이 값을 전달한다)</li>
</ul>
<h3 id="block-arguments의-장점"><a class="header" href="#block-arguments의-장점">Block Arguments의 장점</a></h3>
<h4 id="1-통일된-의미론"><a class="header" href="#1-통일된-의미론">1. 통일된 의미론</a></h4>
<p>함수 인자와 블록 인자가 같은 개념이다:</p>
<pre><code class="language-mlir">// 함수 인자
func.func @foo(%arg: i32) -&gt; i32 {
  ...
}

// 블록 인자 (동일한 문법!)
^myblock(%arg: i32):
  ...
</code></pre>
<p>배울 것이 하나다. 함수를 이해하면 블록도 이해한다.</p>
<h4 id="2-lost-copy-problem-해결"><a class="header" href="#2-lost-copy-problem-해결">2. Lost Copy Problem 해결</a></h4>
<p>Block arguments는 의미론과 구현이 일치한다:</p>
<pre><code class="language-mlir">^then:
  %a = arith.constant 11 : i32
  cf.br ^merge(%a : i32)  ; 명시적으로 %a 전달
</code></pre>
<p>“분기할 때 값을 전달한다“는 의미가 명확하다. Lost copy problem이 없다.</p>
<h4 id="3-위치-제약-없음"><a class="header" href="#3-위치-제약-없음">3. 위치 제약 없음</a></h4>
<p>Block arguments는 블록 파라미터다. 블록 내 어디서든 일반 value처럼 사용할 수 있다:</p>
<pre><code class="language-mlir">^merge(%result: i32):
  %x = arith.constant 1 : i32
  %y = arith.addi %result, %x : i32  ; %result 사용
  func.return %y : i32
</code></pre>
<p>특별한 위치 규칙이 없다. 블록 파라미터는 블록 내 모든 곳에서 유효하다.</p>
<h4 id="4-가독성"><a class="header" href="#4-가독성">4. 가독성</a></h4>
<p>코드가 더 명확하다:</p>
<pre><code class="language-mlir">cf.br ^merge(%a : i32)  ; "merge 블록을 %a와 함께 호출"
^merge(%result: i32):   ; "merge 블록은 %result 파라미터를 받는다"
</code></pre>
<p>함수 호출 비유가 자연스럽다. 초보자가 쉽게 이해한다.</p>
<h3 id="block-arguments-예시"><a class="header" href="#block-arguments-예시">Block Arguments 예시</a></h3>
<p><strong>복잡한 제어 흐름:</strong></p>
<pre><code class="language-mlir">func.func @complex(%x: i32) -&gt; i32 {
  %c0 = arith.constant 0 : i32
  %c10 = arith.constant 10 : i32

  %cond1 = arith.cmpi slt, %x, %c0 : i32
  cf.cond_br %cond1, ^negative, ^nonnegative

^negative:
  %neg = arith.constant -1 : i32
  cf.br ^merge(%neg : i32)

^nonnegative:
  %cond2 = arith.cmpi sgt, %x, %c10 : i32
  cf.cond_br %cond2, ^large, ^small

^large:
  %l = arith.constant 1 : i32
  cf.br ^merge(%l : i32)

^small:
  cf.br ^merge(%c0 : i32)

^merge(%result: i32):
  func.return %result : i32
}
</code></pre>
<p><strong>동작:</strong></p>
<ul>
<li><code>x &lt; 0</code>: ^negative → ^merge(-1)</li>
<li><code>x &gt; 10</code>: ^nonnegative → ^large → ^merge(1)</li>
<li><code>0 ≤ x ≤ 10</code>: ^nonnegative → ^small → ^merge(0)</li>
</ul>
<p><code>^merge</code> 블록은 세 곳에서 호출된다. 각 선행 블록이 값을 전달한다. Block argument <code>%result</code>가 전달된 값을 받는다.</p>
<p><strong>PHI 노드로 작성했다면:</strong></p>
<pre><code class="language-llvm">merge:
  %result = phi i32 [ %neg, %negative ], [ %l, %large ], [ %c0, %small ]
</code></pre>
<p>어느 쪽이 더 명확한가? Block arguments가 push 방식으로 값을 전달하므로 추적하기 쉽다.</p>
<h3 id="block-arguments-요약"><a class="header" href="#block-arguments-요약">Block Arguments 요약</a></h3>
<p><strong>Block Arguments:</strong></p>
<ul>
<li>기본 블록이 함수처럼 파라미터를 받는다</li>
<li>분기 시 값을 전달: <code>cf.br ^block(%value : type)</code></li>
<li>블록 선언에서 파라미터 정의: <code>^block(%arg: type):</code></li>
</ul>
<p><strong>장점:</strong></p>
<ul>
<li>함수 인자와 통일된 의미론</li>
<li>Lost copy problem 해결</li>
<li>위치 제약 없음</li>
<li>가독성 향상</li>
</ul>
<p><strong>PHI 노드 대비:</strong></p>
<ul>
<li>PHI는 pull (merge가 선택), Block Arguments는 push (선행이 전달)</li>
<li>PHI는 특별한 규칙, Block Arguments는 일반 파라미터</li>
</ul>
<blockquote>
<p><strong>다음 섹션:</strong> MLIR의 고수준 제어 흐름인 <code>scf.if</code> 연산을 배운다!</p>
</blockquote>
<h2 id="scfif-고수준-제어-흐름"><a class="header" href="#scfif-고수준-제어-흐름">scf.if: 고수준 제어 흐름</a></h2>
<p>Block arguments를 직접 사용하는 것은 저수준(low-level) 방식이다. MLIR은 **구조화된 제어 흐름(Structured Control Flow)**을 위한 <code>scf</code> dialect를 제공한다.</p>
<h3 id="scf-dialect-소개"><a class="header" href="#scf-dialect-소개">scf Dialect 소개</a></h3>
<p><strong>scf (Structured Control Flow) dialect:</strong></p>
<ul>
<li>고수준 제어 흐름 연산 제공</li>
<li><code>scf.if</code>, <code>scf.for</code>, <code>scf.while</code> 등</li>
<li>구조화된 방식으로 제어 흐름 표현</li>
<li>나중에 저수준 <code>cf</code> dialect로 lowering된다</li>
</ul>
<p><strong>Progressive Lowering 철학:</strong></p>
<pre><code>scf.if (high-level)
  ↓ lowering pass
cf.cond_br (low-level branches)
  ↓ lowering pass
llvm.cond_br (LLVM IR)
</code></pre>
<p>사용자는 고수준 <code>scf.if</code>를 사용한다. 컴파일러가 자동으로 저수준 분기로 변환한다.</p>
<h3 id="scfif-문법"><a class="header" href="#scfif-문법">scf.if 문법</a></h3>
<p><strong>기본 형태:</strong></p>
<pre><code class="language-mlir">%result = scf.if %condition -&gt; (result_type) {
  // then region
  scf.yield %then_value : result_type
} else {
  // else region
  scf.yield %else_value : result_type
}
</code></pre>
<p><strong>구성 요소:</strong></p>
<ol>
<li><strong>%condition</strong>: i1 타입의 boolean 값</li>
<li><strong>-&gt; (result_type)</strong>: 반환할 타입 선언</li>
<li><strong>then region</strong>: 조건이 true일 때 실행</li>
<li><strong>else region</strong>: 조건이 false일 때 실행</li>
<li><strong>scf.yield</strong>: 각 region의 종결자, 값을 반환</li>
</ol>
<p><strong>중요:</strong> 양쪽 region이 <strong>같은 타입</strong>을 yield해야 한다!</p>
<h3 id="scfif-예시"><a class="header" href="#scfif-예시">scf.if 예시</a></h3>
<p><strong>간단한 예시:</strong></p>
<pre><code class="language-mlir">func.func @example(%cond: i1) -&gt; i32 {
  %result = scf.if %cond -&gt; (i32) {
    %c42 = arith.constant 42 : i32
    scf.yield %c42 : i32
  } else {
    %c0 = arith.constant 0 : i32
    scf.yield %c0 : i32
  }
  func.return %result : i32
}
</code></pre>
<p><strong>동작:</strong></p>
<ul>
<li><code>%cond</code>가 true: then region 실행 → <code>%c42</code> yield → <code>%result = 42</code></li>
<li><code>%cond</code>가 false: else region 실행 → <code>%c0</code> yield → <code>%result = 0</code></li>
</ul>
<p><strong>핵심:</strong> <code>scf.if</code>는 <strong>표현식</strong>이다. 값을 반환한다 (<code>%result</code>). if/then/else의 함수형 의미론!</p>
<h3 id="scfyield-종결자"><a class="header" href="#scfyield-종결자">scf.yield 종결자</a></h3>
<p><strong>scf.yield의 역할:</strong></p>
<pre><code class="language-mlir">scf.yield %value : type
</code></pre>
<ul>
<li>Region의 **종결자(terminator)**다</li>
<li>Region을 종료하고 값을 반환한다</li>
<li>함수의 <code>return</code>과 유사하지만, region에서 사용한다</li>
</ul>
<p><strong>중요 규칙:</strong></p>
<ol>
<li>
<p><strong>모든 region은 종결자가 필요하다</strong></p>
<pre><code class="language-mlir">scf.if %cond -&gt; (i32) {
  %c42 = arith.constant 42 : i32
  // 에러! scf.yield 누락
}
</code></pre>
</li>
<li>
<p><strong>yield 타입이 일치해야 한다</strong></p>
<pre><code class="language-mlir">// 에러! then은 i32, else는 i1
scf.if %cond -&gt; (i32) {
  %c42 = arith.constant 42 : i32
  scf.yield %c42 : i32
} else {
  %true = arith.constant 1 : i1
  scf.yield %true : i1  // 타입 불일치!
}
</code></pre>
</li>
<li>
<p><strong>선언된 결과 타입과 일치해야 한다</strong></p>
<pre><code class="language-mlir">// 에러! -&gt; (i32) 선언했지만 i64 yield
%result = scf.if %cond -&gt; (i32) {
  %c42 = arith.constant 42 : i64
  scf.yield %c42 : i64  // 타입 불일치!
}
</code></pre>
</li>
</ol>
<h3 id="scfif의-장점"><a class="header" href="#scfif의-장점">scf.if의 장점</a></h3>
<h4 id="1-타입-안전성"><a class="header" href="#1-타입-안전성">1. 타입 안전성</a></h4>
<p>결과 타입을 미리 선언한다 (<code>-&gt; (i32)</code>). 컴파일러가 양쪽 region을 검증한다.</p>
<pre><code class="language-mlir">%result = scf.if %cond -&gt; (i32) {
  scf.yield %then_val : i32
} else {
  scf.yield %else_val : i32
}
// 컴파일러: "양쪽 모두 i32를 yield하는가?" ✓
</code></pre>
<h4 id="2-구조화된-형태"><a class="header" href="#2-구조화된-형태">2. 구조화된 형태</a></h4>
<p><code>scf.if</code>는 블록 구조가 명확하다:</p>
<ul>
<li>then region</li>
<li>else region</li>
<li>둘 다 명확한 시작과 끝</li>
</ul>
<p>저수준 분기(<code>cf.cond_br</code>)는 임의의 블록으로 점프할 수 있다 (덜 구조화됨).</p>
<h4 id="3-변환-용이성"><a class="header" href="#3-변환-용이성">3. 변환 용이성</a></h4>
<p>고수준 구조는 최적화와 분석이 쉽다:</p>
<ul>
<li>Dead branch elimination</li>
<li>Condition hoisting</li>
<li>Pattern matching</li>
</ul>
<p>저수준 분기는 제어 흐름 그래프(CFG) 분석이 필요하다.</p>
<h3 id="scfif에서-cfcond_br로-lowering"><a class="header" href="#scfif에서-cfcond_br로-lowering">scf.if에서 cf.cond_br로 Lowering</a></h3>
<p><code>scf.if</code>는 나중에 <code>cf.cond_br</code>와 block arguments로 변환된다.</p>
<p><strong>High-level (scf.if):</strong></p>
<pre><code class="language-mlir">%result = scf.if %cond -&gt; (i32) {
  %c42 = arith.constant 42 : i32
  scf.yield %c42 : i32
} else {
  %c0 = arith.constant 0 : i32
  scf.yield %c0 : i32
}
func.return %result : i32
</code></pre>
<p><strong>Lowering 후 (cf.cond_br + block arguments):</strong></p>
<pre><code class="language-mlir">cf.cond_br %cond, ^then, ^else

^then:
  %c42 = arith.constant 42 : i32
  cf.br ^merge(%c42 : i32)

^else:
  %c0 = arith.constant 0 : i32
  cf.br ^merge(%c0 : i32)

^merge(%result: i32):
  func.return %result : i32
</code></pre>
<p><strong>변환 과정:</strong></p>
<ol>
<li><code>scf.if</code>의 then region → <code>^then</code> 블록</li>
<li><code>scf.if</code>의 else region → <code>^else</code> 블록</li>
<li><code>scf.yield</code> → <code>cf.br ^merge(value)</code></li>
<li><code>scf.if</code>의 결과 → <code>^merge</code> 블록의 block argument</li>
</ol>
<p><strong>자동 변환:</strong> <code>--convert-scf-to-cf</code> pass가 이 변환을 수행한다. 사용자는 신경 쓰지 않아도 된다!</p>
<h3 id="multiple-results"><a class="header" href="#multiple-results">Multiple Results</a></h3>
<p><code>scf.if</code>는 여러 값을 반환할 수 있다:</p>
<pre><code class="language-mlir">%x, %y = scf.if %cond -&gt; (i32, i32) {
  %a = arith.constant 10 : i32
  %b = arith.constant 20 : i32
  scf.yield %a, %b : i32, i32
} else {
  %c = arith.constant 30 : i32
  %d = arith.constant 40 : i32
  scf.yield %c, %d : i32, i32
}
// %x, %y는 (10, 20) 또는 (30, 40)
</code></pre>
<p><strong>Lowering 후:</strong></p>
<pre><code class="language-mlir">^merge(%x: i32, %y: i32):
  // %x, %y는 block arguments
</code></pre>
<p>Block arguments도 여러 개 가질 수 있다. <code>scf.if</code>의 유연성이 그대로 lowering된다.</p>
<h3 id="scfif-요약"><a class="header" href="#scfif-요약">scf.if 요약</a></h3>
<p><strong>scf.if 연산:</strong></p>
<ul>
<li>고수준 구조화된 제어 흐름</li>
<li>결과 타입 선언: <code>-&gt; (type)</code></li>
<li>양쪽 region이 같은 타입 yield</li>
<li><code>scf.yield</code> 종결자로 값 반환</li>
</ul>
<p><strong>장점:</strong></p>
<ul>
<li>타입 안전성</li>
<li>구조화된 형태</li>
<li>최적화 용이성</li>
<li>Progressive lowering: scf → cf → llvm</li>
</ul>
<p><strong>다음:</strong> F# P/Invoke 바인딩을 추가하여 <code>scf.if</code>와 <code>scf.yield</code>를 생성한다!</p>
<h2 id="pinvoke-바인딩-scf-dialect"><a class="header" href="#pinvoke-바인딩-scf-dialect">P/Invoke 바인딩: SCF Dialect</a></h2>
<p>이제 F#에서 SCF dialect 연산을 사용할 수 있도록 P/Invoke 바인딩을 추가한다.</p>
<h3 id="mlir-c-api-for-scf"><a class="header" href="#mlir-c-api-for-scf">MLIR C API for SCF</a></h3>
<p>MLIR C API는 <code>mlir-c/Dialect/SCF.h</code> 헤더에서 SCF dialect 지원을 제공한다.</p>
<p><strong>주요 함수:</strong></p>
<pre><code class="language-c">// mlir-c/Dialect/SCF.h

// scf.if operation 생성
MlirOperation mlirSCFIfCreate(
    MlirLocation location,
    MlirValue condition,
    bool hasElse
);

// scf.yield operation 생성
MlirOperation mlirSCFYieldCreate(
    MlirLocation location,
    intptr_t nResults,
    MlirValue const *results
);

// scf.if의 then/else region 접근
MlirRegion mlirSCFIfGetThenRegion(MlirOperation ifOp);
MlirRegion mlirSCFIfGetElseRegion(MlirOperation ifOp);
</code></pre>
<p><strong>Note:</strong> 실제 MLIR C API에서 SCF dialect 지원은 제한적일 수 있다. 필요한 함수가 없으면 C++ shim을 작성한다 (Appendix 참조).</p>
<h3 id="f-pinvoke-바인딩"><a class="header" href="#f-pinvoke-바인딩">F# P/Invoke 바인딩</a></h3>
<p><strong>MlirBindings.fs에 추가:</strong></p>
<pre><code class="language-fsharp">namespace MlirBindings

open System
open System.Runtime.InteropServices

module MlirNative =
    // ... 기존 바인딩 ...

    // ===== SCF Dialect Operations =====

    /// scf.if operation 생성
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirSCFIfCreate(
        MlirLocation location,
        MlirValue condition,
        bool hasElse
    )

    /// scf.yield operation 생성
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirOperation mlirSCFYieldCreate(
        MlirLocation location,
        nativeint nResults,
        MlirValue[] results
    )

    /// scf.if의 then region 가져오기
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirRegion mlirSCFIfGetThenRegion(MlirOperation ifOp)

    /// scf.if의 else region 가져오기
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern MlirRegion mlirSCFIfGetElseRegion(MlirOperation ifOp)

    /// operation의 결과 개수 설정 (scf.if 결과 타입용)
    [&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void mlirOperationSetResultTypes(
        MlirOperation operation,
        nativeint nTypes,
        MlirType[] types
    )
</code></pre>
<p><strong>바인딩 설명:</strong></p>
<ol>
<li>
<p><strong>mlirSCFIfCreate</strong>: <code>scf.if</code> operation 생성</p>
<ul>
<li><code>location</code>: operation 위치</li>
<li><code>condition</code>: i1 타입 boolean 값</li>
<li><code>hasElse</code>: else region 포함 여부 (true면 then/else, false면 then만)</li>
</ul>
</li>
<li>
<p><strong>mlirSCFYieldCreate</strong>: <code>scf.yield</code> operation 생성</p>
<ul>
<li><code>nResults</code>: yield할 값 개수</li>
<li><code>results</code>: yield할 값 배열</li>
</ul>
</li>
<li>
<p><strong>mlirSCFIfGetThenRegion/ElseRegion</strong>: region 접근</p>
<ul>
<li><code>scf.if</code>는 내부에 then/else region을 가진다</li>
<li>Region에 블록을 추가하고 연산을 작성한다</li>
</ul>
</li>
</ol>
<h3 id="c-api-제약과-대안"><a class="header" href="#c-api-제약과-대안">C API 제약과 대안</a></h3>
<p>MLIR C API의 SCF dialect 지원은 완전하지 않을 수 있다. 특히:</p>
<ul>
<li><code>scf.if</code> 결과 타입 설정 API가 명확하지 않을 수 있다</li>
<li>Region builder API가 제한적일 수 있다</li>
</ul>
<p><strong>대안 1: Operation State Builder 사용</strong></p>
<p>MLIR C API의 일반 operation builder를 사용:</p>
<pre><code class="language-fsharp">let createScfIf (builder: OpBuilder) (condition: MlirValue) (resultTypes: MlirType[]) (location: MlirLocation) =
    let opName = MlirHelpers.fromString("scf.if")
    let state = MlirNative.mlirOperationStateGet(opName, location)

    // operand 추가 (condition)
    MlirNative.mlirOperationStateAddOperands(state, 1n, [| condition |])

    // 결과 타입 추가
    MlirNative.mlirOperationStateAddResults(state, nativeint resultTypes.Length, resultTypes)

    // region 추가 (then, else)
    MlirNative.mlirOperationStateAddOwnedRegions(state, 2n, [| thenRegion; elseRegion |])

    // operation 생성
    MlirNative.mlirOperationCreate(state)
</code></pre>
<p><strong>대안 2: C++ Shim 작성</strong></p>
<p>Appendix (Chapter 01-03에서 다룬 C++ dialect wrapper 패턴)에 따라 C++ shim을 작성:</p>
<pre><code class="language-cpp">// mlir_scf_wrapper.cpp
extern "C" {

MlirOperation mlirCreateSCFIf(
    MlirLocation location,
    MlirValue condition,
    MlirType* resultTypes,
    intptr_t numResults,
    bool hasElse
) {
    // C++ MLIR API 사용
    mlir::OpBuilder builder(...);
    auto ifOp = builder.create&lt;mlir::scf::IfOp&gt;(
        unwrap(location),
        llvm::ArrayRef&lt;mlir::Type&gt;(...),
        unwrap(condition),
        hasElse
    );
    return wrap(ifOp.getOperation());
}

} // extern "C"
</code></pre>
<p>이 shim을 컴파일하여 F#에서 호출한다.</p>
<p><strong>권장 방안:</strong> 먼저 C API를 시도하고, 부족하면 C++ shim을 작성한다. Chapter 01 Appendix가 이미 패턴을 확립했다.</p>
<h3 id="opbuilder-헬퍼-메서드"><a class="header" href="#opbuilder-헬퍼-메서드">OpBuilder 헬퍼 메서드</a></h3>
<p>고수준 래퍼를 <code>OpBuilder</code> 클래스에 추가한다:</p>
<p><strong>MlirWrapper.fs에 추가:</strong></p>
<pre><code class="language-fsharp">type OpBuilder(context: Context) =
    // ... 기존 메서드 ...

    /// scf.if operation 생성
    member this.CreateScfIf(condition: MlirValue, resultTypes: MlirType[], location: MlirLocation) : MlirOperation =
        let ifOp = MlirNative.mlirSCFIfCreate(location, condition, true)

        // 결과 타입 설정 (C API 함수 사용)
        MlirNative.mlirOperationSetResultTypes(ifOp, nativeint resultTypes.Length, resultTypes)

        ifOp

    /// scf.if의 then region에 블록 추가
    member this.GetThenBlock(ifOp: MlirOperation) : MlirBlock =
        let thenRegion = MlirNative.mlirSCFIfGetThenRegion(ifOp)
        let block = MlirNative.mlirBlockCreate(0n, nativeint 0, nativeint 0)
        MlirNative.mlirRegionAppendOwnedBlock(thenRegion, block)
        block

    /// scf.if의 else region에 블록 추가
    member this.GetElseBlock(ifOp: MlirOperation) : MlirBlock =
        let elseRegion = MlirNative.mlirSCFIfGetElseRegion(ifOp)
        let block = MlirNative.mlirBlockCreate(0n, nativeint 0, nativeint 0)
        MlirNative.mlirRegionAppendOwnedBlock(elseRegion, block)
        block

    /// scf.yield operation 생성
    member this.CreateScfYield(results: MlirValue[], location: MlirLocation) : MlirOperation =
        MlirNative.mlirSCFYieldCreate(location, nativeint results.Length, results)
</code></pre>
<p><strong>사용 예시:</strong></p>
<pre><code class="language-fsharp">// scf.if operation 생성
let i32Type = builder.I32Type()
let ifOp = builder.CreateScfIf(condition, [| i32Type |], location)

// then region 작성
let thenBlock = builder.GetThenBlock(ifOp)
// ... thenBlock에 연산 추가 ...
let thenYield = builder.CreateScfYield([| thenValue |], location)
MlirNative.mlirBlockAppendOwnedOperation(thenBlock, thenYield)

// else region 작성
let elseBlock = builder.GetElseBlock(ifOp)
// ... elseBlock에 연산 추가 ...
let elseYield = builder.CreateScfYield([| elseValue |], location)
MlirNative.mlirBlockAppendOwnedOperation(elseBlock, elseYield)
</code></pre>
<h3 id="dialect-로딩"><a class="header" href="#dialect-로딩">Dialect 로딩</a></h3>
<p>SCF dialect를 사용하려면 context에 로드해야 한다:</p>
<pre><code class="language-fsharp">let ctx = new Context()
ctx.LoadDialect("arith")
ctx.LoadDialect("func")
ctx.LoadDialect("scf")  // SCF dialect 로드!
</code></pre>
<p>이것으로 <code>scf.if</code>와 <code>scf.yield</code> 연산을 사용할 준비가 완료되었다!</p>
<h3 id="pinvoke-바인딩-요약"><a class="header" href="#pinvoke-바인딩-요약">P/Invoke 바인딩 요약</a></h3>
<p><strong>추가한 바인딩:</strong></p>
<ul>
<li><code>mlirSCFIfCreate</code>: scf.if operation 생성</li>
<li><code>mlirSCFYieldCreate</code>: scf.yield operation 생성</li>
<li><code>mlirSCFIfGetThenRegion/ElseRegion</code>: region 접근</li>
</ul>
<p><strong>OpBuilder 헬퍼:</strong></p>
<ul>
<li><code>CreateScfIf</code>: scf.if 생성 + 결과 타입 설정</li>
<li><code>GetThenBlock/GetElseBlock</code>: region에 블록 추가</li>
<li><code>CreateScfYield</code>: scf.yield 생성</li>
</ul>
<p><strong>C API 제약:</strong></p>
<ul>
<li>C API가 불완전하면 C++ shim 작성 (Appendix 패턴 따름)</li>
<li>Operation State Builder를 일반 대안으로 사용</li>
</ul>
<p><strong>다음 섹션:</strong> AST에 If 케이스를 추가하고, 코드 생성을 구현한다!</p>
<h2 id="ast-확장-if-표현식과-boolean-리터럴"><a class="header" href="#ast-확장-if-표현식과-boolean-리터럴">AST 확장: If 표현식과 Boolean 리터럴</a></h2>
<p>이제 AST에 if 표현식과 boolean 리터럴을 추가한다.</p>
<h3 id="expr-타입-확장"><a class="header" href="#expr-타입-확장">Expr 타입 확장</a></h3>
<p><strong>Ast.fs 수정:</strong></p>
<pre><code class="language-fsharp">namespace FunLangCompiler

/// 이진 연산자 (Chapter 06)
type Operator =
    | Add
    | Subtract
    | Multiply
    | Divide

/// 비교 연산자 (Chapter 06)
type CompareOp =
    | LessThan
    | GreaterThan
    | LessEqual
    | GreaterEqual
    | Equal
    | NotEqual

/// 단항 연산자 (Chapter 06)
type UnaryOp =
    | Negate

/// FunLang 표현식 AST
type Expr =
    | IntLiteral of int
    | BinaryOp of Operator * Expr * Expr
    | UnaryOp of UnaryOp * Expr
    | Comparison of CompareOp * Expr * Expr
    | Let of name: string * binding: Expr * body: Expr
    | Var of name: string
    // NEW: If 표현식과 Boolean 리터럴
    | If of condition: Expr * thenBranch: Expr * elseBranch: Expr
    | Bool of bool

/// 최상위 프로그램
type Program =
    { expr: Expr }
</code></pre>
<p><strong>새로운 케이스 설명:</strong></p>
<h3 id="if-of-condition--thenbranch--elsebranch"><a class="header" href="#if-of-condition--thenbranch--elsebranch">If of condition * thenBranch * elseBranch</a></h3>
<pre><code class="language-fsharp">| If of condition: Expr * thenBranch: Expr * elseBranch: Expr
</code></pre>
<p><strong>의미:</strong> <code>if {condition} then {thenBranch} else {elseBranch}</code></p>
<p><strong>필드:</strong></p>
<ul>
<li><code>condition</code>: 조건 표현식 (i1 boolean 값을 생성해야 함)</li>
<li><code>thenBranch</code>: 조건이 true일 때 실행하는 표현식</li>
<li><code>elseBranch</code>: 조건이 false일 때 실행하는 표현식</li>
</ul>
<p><strong>타입 제약:</strong></p>
<ul>
<li><code>condition</code>은 i1 타입을 생성해야 한다</li>
<li><code>thenBranch</code>와 <code>elseBranch</code>는 <strong>같은 타입</strong>을 생성해야 한다</li>
</ul>
<p><strong>예시:</strong></p>
<pre><code class="language-fsharp">// FunLang: if 5 &lt; 10 then 42 else 0
If(
  Comparison(LessThan, IntLiteral 5, IntLiteral 10),
  IntLiteral 42,
  IntLiteral 0
)
</code></pre>
<h3 id="bool-of-bool"><a class="header" href="#bool-of-bool">Bool of bool</a></h3>
<pre><code class="language-fsharp">| Bool of bool
</code></pre>
<p><strong>의미:</strong> Boolean 리터럴 - <code>true</code> 또는 <code>false</code></p>
<p><strong>필드:</strong></p>
<ul>
<li><code>bool</code>: F# boolean 값 (true 또는 false)</li>
</ul>
<p><strong>예시:</strong></p>
<pre><code class="language-fsharp">// FunLang: if true then 1 else 0
If(
  Bool true,
  IntLiteral 1,
  IntLiteral 0
)
</code></pre>
<p><strong>MLIR로 컴파일:</strong> <code>Bool true</code> → <code>arith.constant 1 : i1</code>, <code>Bool false</code> → <code>arith.constant 0 : i1</code></p>
<h3 id="ast-예시"><a class="header" href="#ast-예시">AST 예시</a></h3>
<p><strong>간단한 if:</strong></p>
<pre><code class="language-fsharp">// FunLang: if true then 42 else 0
If(Bool true, IntLiteral 42, IntLiteral 0)
</code></pre>
<p><strong>비교 조건:</strong></p>
<pre><code class="language-fsharp">// FunLang: if 5 &lt; 10 then 1 else 0
If(
  Comparison(LessThan, IntLiteral 5, IntLiteral 10),
  IntLiteral 1,
  IntLiteral 0
)
</code></pre>
<p><strong>let 바인딩과 결합:</strong></p>
<pre><code class="language-fsharp">// FunLang: let x = 5 in if x &gt; 0 then x * 2 else 0
Let("x",
  IntLiteral 5,
  If(
    Comparison(GreaterThan, Var "x", IntLiteral 0),
    BinaryOp(Multiply, Var "x", IntLiteral 2),
    IntLiteral 0
  )
)
</code></pre>
<h2 id="boolean-표현식"><a class="header" href="#boolean-표현식">Boolean 표현식</a></h2>
<p>Boolean 값은 MLIR에서 <strong>i1 타입</strong> (1-bit integer)으로 표현된다.</p>
<h3 id="boolean-타입-i1"><a class="header" href="#boolean-타입-i1">Boolean 타입: i1</a></h3>
<p>MLIR은 boolean을 위한 전용 타입이 없다. 대신 1-bit integer (<code>i1</code>)를 사용한다:</p>
<pre><code class="language-mlir">%true = arith.constant 1 : i1    // Boolean true
%false = arith.constant 0 : i1   // Boolean false
</code></pre>
<p><strong>i1의 값:</strong></p>
<ul>
<li><code>1</code>: true</li>
<li><code>0</code>: false</li>
</ul>
<h3 id="boolean-리터럴-컴파일"><a class="header" href="#boolean-리터럴-컴파일">Boolean 리터럴 컴파일</a></h3>
<p><code>Bool</code> 케이스를 i1 상수로 컴파일한다:</p>
<pre><code class="language-fsharp">| Bool(value) -&gt;
    let i1Type = builder.Context.GetIntegerType(1)  // 1-bit integer
    let intValue = if value then 1L else 0L
    let attr = builder.Context.GetIntegerAttr(i1Type, intValue)
    let constOp = builder.CreateConstant(attr, location)
    MlirNative.mlirBlockAppendOwnedOperation(block, constOp)
    builder.GetResult(constOp, 0)
</code></pre>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">// Bool true
%true = arith.constant 1 : i1

// Bool false
%false = arith.constant 0 : i1
</code></pre>
<h3 id="비교-연산은-이미-i1을-반환한다"><a class="header" href="#비교-연산은-이미-i1을-반환한다">비교 연산은 이미 i1을 반환한다</a></h3>
<p>Chapter 06에서 구현한 비교 연산 (<code>arith.cmpi</code>)은 i1을 반환한다:</p>
<pre><code class="language-mlir">%c5 = arith.constant 5 : i32
%c10 = arith.constant 10 : i32
%cond = arith.cmpi slt, %c5, %c10 : i32  // 결과는 i1
</code></pre>
<p><strong>중요:</strong> if 조건으로 비교 연산을 사용할 때, i1 → i32 확장(<code>arith.extui</code>)을 제거해야 한다!</p>
<p>Chapter 06에서는 main 함수 반환을 위해 i1을 i32로 확장했다:</p>
<pre><code class="language-fsharp">// Chapter 06 코드 (비교 결과를 i32로 확장)
| Comparison(compareOp, lhs, rhs) -&gt;
    let lhsVal = compileExpr builder block location lhs env
    let rhsVal = compileExpr builder block location rhs env
    let cmpOp = builder.CreateArithCompare(compareOp, lhsVal, rhsVal, location)
    MlirNative.mlirBlockAppendOwnedOperation(block, cmpOp)
    let cmpVal = builder.GetResult(cmpOp, 0)  // i1 값
    // i1 -&gt; i32 확장
    let i32Type = builder.I32Type()
    let extOp = builder.CreateArithExtUI(cmpVal, i32Type, location)
    MlirNative.mlirBlockAppendOwnedOperation(block, extOp)
    builder.GetResult(extOp, 0)  // i32 반환
</code></pre>
<p><strong>문제:</strong> if 조건은 i1이 필요한데, 위 코드는 i32를 반환한다!</p>
<p><strong>해결 방안:</strong> 컨텍스트에 따라 확장 여부를 결정한다:</p>
<ul>
<li>if 조건: i1 그대로 사용</li>
<li>main 함수 반환: i32로 확장</li>
</ul>
<p><strong>간단한 접근:</strong> Comparison 케이스가 i1을 반환하도록 하고, main 함수에서만 확장한다.</p>
<p><strong>수정된 Comparison 케이스:</strong></p>
<pre><code class="language-fsharp">| Comparison(compareOp, lhs, rhs) -&gt;
    let lhsVal = compileExpr builder block location lhs env
    let rhsVal = compileExpr builder block location rhs env
    let cmpOp = builder.CreateArithCompare(compareOp, lhsVal, rhsVal, location)
    MlirNative.mlirBlockAppendOwnedOperation(block, cmpOp)
    builder.GetResult(cmpOp, 0)  // i1 반환 (확장 안 함)
</code></pre>
<p><strong>main 함수에서 확장:</strong></p>
<pre><code class="language-fsharp">let resultValue = compileExpr builder entryBlock loc program.expr env

// 결과가 i1이면 i32로 확장 (main 함수 반환용)
let resultType = MlirNative.mlirValueGetType(resultValue)
let finalResult =
    if MlirNative.mlirTypeIsI1(resultType) then
        let i32Type = builder.I32Type()
        let extOp = builder.CreateArithExtUI(resultValue, i32Type, loc)
        MlirNative.mlirBlockAppendOwnedOperation(entryBlock, extOp)
        builder.GetResult(extOp, 0)
    else
        resultValue
</code></pre>
<h3 id="boolean-연산-선택-사항"><a class="header" href="#boolean-연산-선택-사항">Boolean 연산 (선택 사항)</a></h3>
<p>Boolean 값에 논리 연산을 적용할 수 있다:</p>
<p><strong>AND:</strong></p>
<pre><code class="language-mlir">%a = arith.constant 1 : i1
%b = arith.constant 0 : i1
%result = arith.andi %a, %b : i1  // 결과: 0 (false)
</code></pre>
<p><strong>OR:</strong></p>
<pre><code class="language-mlir">%result = arith.ori %a, %b : i1  // 결과: 1 (true)
</code></pre>
<p><strong>NOT (XOR with 1):</strong></p>
<pre><code class="language-mlir">%c1 = arith.constant 1 : i1
%result = arith.xori %a, %c1 : i1  // a의 반대
</code></pre>
<p><strong>AST 추가 (나중에):</strong></p>
<p>Phase 2에서는 boolean 연산을 추가하지 않는다. if/then/else만으로 충분하다. 필요하면 나중에 추가한다.</p>
<h2 id="ifthenelse-코드-생성"><a class="header" href="#ifthenelse-코드-생성">If/Then/Else 코드 생성</a></h2>
<p>이제 If 케이스를 scf.if로 컴파일한다.</p>
<h3 id="if-케이스-구현"><a class="header" href="#if-케이스-구현">If 케이스 구현</a></h3>
<p><strong>CodeGen.fs에 추가:</strong></p>
<pre><code class="language-fsharp">| If(condition, thenExpr, elseExpr) -&gt;
    // 1. 조건 표현식 컴파일 (i1 타입 필요)
    let condVal = compileExpr builder block location condition env

    // 2. 결과 타입 결정 (thenBranch의 타입을 사용)
    // 실제로는 타입 추론이 필요하지만, 지금은 i32로 가정
    let i32Type = builder.I32Type()
    let resultTypes = [| i32Type |]

    // 3. scf.if operation 생성
    let ifOp = builder.CreateScfIf(condVal, resultTypes, location)

    // 4. Then region 작성
    let thenBlock = builder.GetThenBlock(ifOp)
    let thenVal = compileExpr builder thenBlock location thenExpr env
    let thenYield = builder.CreateScfYield([| thenVal |], location)
    MlirNative.mlirBlockAppendOwnedOperation(thenBlock, thenYield)

    // 5. Else region 작성
    let elseBlock = builder.GetElseBlock(ifOp)
    let elseVal = compileExpr builder elseBlock location elseExpr env
    let elseYield = builder.CreateScfYield([| elseVal |], location)
    MlirNative.mlirBlockAppendOwnedOperation(elseBlock, elseYield)

    // 6. scf.if를 블록에 추가
    MlirNative.mlirBlockAppendOwnedOperation(block, ifOp)

    // 7. scf.if의 결과 반환
    builder.GetResult(ifOp, 0)
</code></pre>
<p><strong>동작 설명:</strong></p>
<ol>
<li><strong>조건 컴파일:</strong> <code>condition</code> 표현식을 컴파일하여 i1 값을 얻는다</li>
<li><strong>결과 타입:</strong> if 표현식의 결과 타입 (여기서는 i32로 가정)</li>
<li><strong>scf.if 생성:</strong> <code>CreateScfIf</code>로 operation 생성</li>
<li><strong>Then region:</strong> thenBranch 컴파일 → scf.yield로 값 반환</li>
<li><strong>Else region:</strong> elseBranch 컴파일 → scf.yield로 값 반환</li>
<li><strong>Operation 추가:</strong> scf.if를 부모 블록에 추가</li>
<li><strong>결과 사용:</strong> scf.if의 결과 (SSA value)를 반환</li>
</ol>
<p><strong>핵심:</strong> 각 region에서 <code>compileExpr</code>를 호출할 때 <strong>해당 region의 블록</strong>을 전달한다. 이렇게 하면 연산이 올바른 region에 추가된다.</p>
<h3 id="예시-if-true-then-42-else-0"><a class="header" href="#예시-if-true-then-42-else-0">예시: if true then 42 else 0</a></h3>
<p><strong>AST:</strong></p>
<pre><code class="language-fsharp">If(Bool true, IntLiteral 42, IntLiteral 0)
</code></pre>
<p><strong>컴파일 과정:</strong></p>
<ol>
<li><code>Bool true</code> 컴파일: <code>%true = arith.constant 1 : i1</code></li>
<li><code>scf.if</code> 생성</li>
<li>Then region:
<ul>
<li><code>IntLiteral 42</code> 컴파일: <code>%c42 = arith.constant 42 : i32</code></li>
<li><code>scf.yield %c42</code></li>
</ul>
</li>
<li>Else region:
<ul>
<li><code>IntLiteral 0</code> 컴파일: <code>%c0 = arith.constant 0 : i32</code></li>
<li><code>scf.yield %c0</code></li>
</ul>
</li>
<li>scf.if 결과: <code>%result</code></li>
</ol>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">module {
  func.func @main() -&gt; i32 {
    %true = arith.constant 1 : i1
    %result = scf.if %true -&gt; (i32) {
      %c42 = arith.constant 42 : i32
      scf.yield %c42 : i32
    } else {
      %c0 = arith.constant 0 : i32
      scf.yield %c0 : i32
    }
    func.return %result : i32
  }
}
</code></pre>
<p><strong>실행:</strong></p>
<pre><code class="language-bash">$ ./program
$ echo $?
42
</code></pre>
<p>조건이 true이므로 42를 반환한다!</p>
<h3 id="예시-if-5--10-then-1-else-0"><a class="header" href="#예시-if-5--10-then-1-else-0">예시: if 5 &lt; 10 then 1 else 0</a></h3>
<p><strong>AST:</strong></p>
<pre><code class="language-fsharp">If(
  Comparison(LessThan, IntLiteral 5, IntLiteral 10),
  IntLiteral 1,
  IntLiteral 0
)
</code></pre>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">module {
  func.func @main() -&gt; i32 {
    %c5 = arith.constant 5 : i32
    %c10 = arith.constant 10 : i32
    %cond = arith.cmpi slt, %c5, %c10 : i32  // i1 결과
    %result = scf.if %cond -&gt; (i32) {
      %c1 = arith.constant 1 : i32
      scf.yield %c1 : i32
    } else {
      %c0 = arith.constant 0 : i32
      scf.yield %c0 : i32
    }
    func.return %result : i32
  }
}
</code></pre>
<p><strong>실행:</strong></p>
<pre><code class="language-bash">$ ./program
$ echo $?
1
</code></pre>
<p>5 &lt; 10이 true이므로 1을 반환한다!</p>
<h2 id="lowering-pass-업데이트"><a class="header" href="#lowering-pass-업데이트">Lowering Pass 업데이트</a></h2>
<p>SCF dialect를 사용하므로 lowering pass에 <code>--convert-scf-to-cf</code>를 추가해야 한다.</p>
<h3 id="pass-manager-순서"><a class="header" href="#pass-manager-순서">Pass Manager 순서</a></h3>
<p><strong>Lowering.fs 수정:</strong></p>
<pre><code class="language-fsharp">namespace FunLangCompiler

module Lowering =

    /// MLIR module을 LLVM dialect로 lowering
    let lowerToLLVMDialect (mlirMod: Module) =
        let ctx = mlirMod.Context
        let pm = MlirNative.mlirPassManagerCreate(ctx.Handle)

        // 1. SCF -&gt; CF 변환 (구조화된 제어 흐름 -&gt; 분기)
        let scfToCfPass = MlirNative.mlirCreateConversionConvertSCFToCFPass()
        MlirNative.mlirPassManagerAddOwnedPass(pm, scfToCfPass)

        // 2. Arith -&gt; LLVM 변환
        let arithToLLVMPass = MlirNative.mlirCreateConversionConvertArithToLLVMPass()
        MlirNative.mlirPassManagerAddOwnedPass(pm, arithToLLVMPass)

        // 3. Func -&gt; LLVM 변환
        let funcToLLVMPass = MlirNative.mlirCreateConversionConvertFuncToLLVMPass()
        MlirNative.mlirPassManagerAddOwnedPass(pm, funcToLLVMPass)

        // 4. Unrealized casts 정리
        let reconcilePass = MlirNative.mlirCreateConversionReconcileUnrealizedCastsPass()
        MlirNative.mlirPassManagerAddOwnedPass(pm, reconcilePass)

        // Pass 실행
        let result = MlirNative.mlirPassManagerRun(pm, mlirMod.Handle)
        if not (MlirNative.mlirLogicalResultIsSuccess(result)) then
            failwith "Failed to run lowering passes"

        MlirNative.mlirPassManagerDestroy(pm)

    /// MLIR module을 LLVM IR로 변환
    let translateToLLVMIR (mlirMod: Module) : string =
        let llvmIR = MlirNative.mlirTranslateModuleToLLVMIR(mlirMod.Handle)
        MlirHelpers.toString llvmIR
</code></pre>
<p><strong>Pass 순서 설명:</strong></p>
<ol>
<li><strong>SCF → CF:</strong> <code>scf.if</code> → <code>cf.cond_br</code> + block arguments</li>
<li><strong>Arith → LLVM:</strong> <code>arith.constant</code>, <code>arith.addi</code> 등 → <code>llvm.mlir.constant</code>, <code>llvm.add</code> 등</li>
<li><strong>Func → LLVM:</strong> <code>func.func</code>, <code>func.return</code> → <code>llvm.func</code>, <code>llvm.return</code></li>
<li><strong>Reconcile:</strong> 중간 cast 연산 정리</li>
</ol>
<h3 id="mlirbindingsfs에-pass-추가"><a class="header" href="#mlirbindingsfs에-pass-추가">MlirBindings.fs에 Pass 추가</a></h3>
<p><strong>MlirBindings.fs에 추가:</strong></p>
<pre><code class="language-fsharp">/// SCF to CF 변환 pass 생성
[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirPass mlirCreateConversionConvertSCFToCFPass()
</code></pre>
<p><strong>Note:</strong> 함수 이름은 MLIR C API 버전에 따라 다를 수 있다. <code>mlir-c/Conversion/Passes.h</code> 헤더를 확인한다.</p>
<h3 id="lowering-후-mlir-ir"><a class="header" href="#lowering-후-mlir-ir">Lowering 후 MLIR IR</a></h3>
<p><strong>scf.if lowering 전:</strong></p>
<pre><code class="language-mlir">func.func @main() -&gt; i32 {
  %c5 = arith.constant 5 : i32
  %c10 = arith.constant 10 : i32
  %cond = arith.cmpi slt, %c5, %c10 : i32
  %result = scf.if %cond -&gt; (i32) {
    %c1 = arith.constant 1 : i32
    scf.yield %c1 : i32
  } else {
    %c0 = arith.constant 0 : i32
    scf.yield %c0 : i32
  }
  func.return %result : i32
}
</code></pre>
<p><strong>scf.if lowering 후 (cf dialect):</strong></p>
<pre><code class="language-mlir">func.func @main() -&gt; i32 {
  %c5 = arith.constant 5 : i32
  %c10 = arith.constant 10 : i32
  %cond = arith.cmpi slt, %c5, %c10 : i32
  cf.cond_br %cond, ^then, ^else

^then:
  %c1 = arith.constant 1 : i32
  cf.br ^merge(%c1 : i32)

^else:
  %c0 = arith.constant 0 : i32
  cf.br ^merge(%c0 : i32)

^merge(%result: i32):
  func.return %result : i32
}
</code></pre>
<p><strong>핵심:</strong></p>
<ul>
<li><code>scf.if</code> → <code>cf.cond_br</code> + 블록</li>
<li><code>scf.yield</code> → <code>cf.br ^merge(value)</code></li>
<li>Block argument <code>%result</code>가 PHI 역할</li>
</ul>
<h2 id="let-바인딩과-if-결합"><a class="header" href="#let-바인딩과-if-결합">Let 바인딩과 If 결합</a></h2>
<p>Let 바인딩과 if 표현식을 결합한 예시를 보자.</p>
<p><strong>FunLang 소스:</strong></p>
<pre><code class="language-fsharp">let x = 5 in
if x &gt; 0 then x * 2 else 0
</code></pre>
<p><strong>AST:</strong></p>
<pre><code class="language-fsharp">Let("x",
  IntLiteral 5,
  If(
    Comparison(GreaterThan, Var "x", IntLiteral 0),
    BinaryOp(Multiply, Var "x", IntLiteral 2),
    IntLiteral 0
  )
)
</code></pre>
<p><strong>컴파일 과정:</strong></p>
<ol>
<li>
<p><code>Let("x", IntLiteral 5, ...)</code></p>
<ul>
<li><code>IntLiteral 5</code> 컴파일: <code>%c5 = arith.constant 5 : i32</code></li>
<li><code>env' = env.Add("x", %c5)</code></li>
<li>Body 컴파일 (env’ 사용)</li>
</ul>
</li>
<li>
<p><code>If(...)</code> (env’에서)</p>
<ul>
<li>Condition: <code>Comparison(GreaterThan, Var "x", IntLiteral 0)</code>
<ul>
<li><code>Var "x"</code>: env’에서 조회 → %c5</li>
<li><code>IntLiteral 0</code>: <code>%c0 = arith.constant 0 : i32</code></li>
<li><code>%cond = arith.cmpi sgt, %c5, %c0 : i32</code></li>
</ul>
</li>
<li>Then: <code>BinaryOp(Multiply, Var "x", IntLiteral 2)</code>
<ul>
<li><code>Var "x"</code>: env’에서 조회 → %c5</li>
<li><code>IntLiteral 2</code>: <code>%c2 = arith.constant 2 : i32</code></li>
<li><code>%then_val = arith.muli %c5, %c2 : i32</code></li>
</ul>
</li>
<li>Else: <code>IntLiteral 0</code>
<ul>
<li><code>%else_val = arith.constant 0 : i32</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">module {
  func.func @main() -&gt; i32 {
    %c5 = arith.constant 5 : i32          // let x = 5
    %c0 = arith.constant 0 : i32
    %cond = arith.cmpi sgt, %c5, %c0 : i32  // x &gt; 0
    %result = scf.if %cond -&gt; (i32) {
      %c2 = arith.constant 2 : i32
      %then_val = arith.muli %c5, %c2 : i32  // x * 2
      scf.yield %then_val : i32
    } else {
      %else_val = arith.constant 0 : i32
      scf.yield %else_val : i32
    }
    func.return %result : i32
  }
}
</code></pre>
<p><strong>실행:</strong></p>
<pre><code class="language-bash">$ ./program
$ echo $?
10
</code></pre>
<p>x = 5, x &gt; 0이 true, x * 2 = 10!</p>
<h3 id="중첩된-if"><a class="header" href="#중첩된-if">중첩된 If</a></h3>
<p>if 안에 if를 넣을 수도 있다:</p>
<pre><code class="language-fsharp">// FunLang: if x &gt; 0 then (if x &lt; 10 then 1 else 2) else 0
If(
  Comparison(GreaterThan, Var "x", IntLiteral 0),
  If(
    Comparison(LessThan, Var "x", IntLiteral 10),
    IntLiteral 1,
    IntLiteral 2
  ),
  IntLiteral 0
)
</code></pre>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">%outer_cond = arith.cmpi sgt, %x, %c0 : i32
%result = scf.if %outer_cond -&gt; (i32) {
  %inner_cond = arith.cmpi slt, %x, %c10 : i32
  %inner_result = scf.if %inner_cond -&gt; (i32) {
    %c1 = arith.constant 1 : i32
    scf.yield %c1 : i32
  } else {
    %c2 = arith.constant 2 : i32
    scf.yield %c2 : i32
  }
  scf.yield %inner_result : i32
} else {
  %c0 = arith.constant 0 : i32
  scf.yield %c0 : i32
}
</code></pre>
<p>중첩된 scf.if가 올바르게 생성된다!</p>
<h2 id="공통-에러-1"><a class="header" href="#공통-에러-1">공통 에러</a></h2>
<h3 id="에러-1-조건이-i32인데-i1이-필요"><a class="header" href="#에러-1-조건이-i32인데-i1이-필요">에러 1: 조건이 i32인데 i1이 필요</a></h3>
<p><strong>증상:</strong></p>
<pre><code>MLIR verification failed:
'scf.if' op operand #0 must be 1-bit signless integer, but got 'i32'
</code></pre>
<p><strong>원인:</strong></p>
<p>if 조건에 i32 값을 전달했다.</p>
<p><strong>해결:</strong></p>
<p>조건은 반드시 i1 타입이어야 한다:</p>
<ul>
<li>Boolean 리터럴: <code>Bool true</code> → <code>arith.constant 1 : i1</code></li>
<li>비교 연산: <code>arith.cmpi</code> → i1 결과</li>
<li>i32를 i1로 변환하지 말고, 비교 연산을 사용한다</li>
</ul>
<pre><code class="language-fsharp">// WRONG: i32를 조건으로 사용
let x = IntLiteral 5
If(x, ..., ...)  // 에러! x는 i32

// CORRECT: 비교 연산 사용
If(Comparison(GreaterThan, x, IntLiteral 0), ..., ...)
</code></pre>
<h3 id="에러-2-scfyield-타입-불일치"><a class="header" href="#에러-2-scfyield-타입-불일치">에러 2: scf.yield 타입 불일치</a></h3>
<p><strong>증상:</strong></p>
<pre><code>MLIR verification failed:
'scf.yield' op types mismatch between then and else regions
</code></pre>
<p><strong>원인:</strong></p>
<p>then region과 else region이 다른 타입을 yield했다.</p>
<p><strong>해결:</strong></p>
<p>양쪽 region이 같은 타입을 yield해야 한다:</p>
<pre><code class="language-fsharp">// WRONG: then은 i32, else는 i1
If(cond,
  IntLiteral 42,        // i32
  Bool true)            // i1 - 타입 불일치!

// CORRECT: 둘 다 i32
If(cond,
  IntLiteral 42,        // i32
  IntLiteral 0)         // i32
</code></pre>
<h3 id="에러-3-scfyield-누락"><a class="header" href="#에러-3-scfyield-누락">에러 3: scf.yield 누락</a></h3>
<p><strong>증상:</strong></p>
<pre><code>MLIR verification failed:
Region does not have a terminator
</code></pre>
<p><strong>원인:</strong></p>
<p>then 또는 else region에 scf.yield를 추가하지 않았다.</p>
<p><strong>해결:</strong></p>
<p>모든 region은 종결자가 필요하다. 코드 생성 시 항상 scf.yield를 추가한다:</p>
<pre><code class="language-fsharp">// 올바른 코드 생성 패턴
let thenBlock = builder.GetThenBlock(ifOp)
let thenVal = compileExpr builder thenBlock location thenExpr env
let thenYield = builder.CreateScfYield([| thenVal |], location)
MlirNative.mlirBlockAppendOwnedOperation(thenBlock, thenYield)  // 필수!
</code></pre>
<h3 id="에러-4-convert-scf-to-cf-pass-누락"><a class="header" href="#에러-4-convert-scf-to-cf-pass-누락">에러 4: –convert-scf-to-cf pass 누락</a></h3>
<p><strong>증상:</strong></p>
<pre><code>Failed to translate MLIR to LLVM IR:
Unhandled operation: scf.if
</code></pre>
<p><strong>원인:</strong></p>
<p>Lowering pass에서 SCF → CF 변환을 실행하지 않았다.</p>
<p><strong>해결:</strong></p>
<p>Pass manager에 <code>--convert-scf-to-cf</code>를 추가한다:</p>
<pre><code class="language-fsharp">let scfToCfPass = MlirNative.mlirCreateConversionConvertSCFToCFPass()
MlirNative.mlirPassManagerAddOwnedPass(pm, scfToCfPass)
</code></pre>
<p>Pass 순서: SCF → CF → Arith → Func → Reconcile</p>
<h2 id="장-요약-2"><a class="header" href="#장-요약-2">장 요약</a></h2>
<p>이 장에서 다음을 성취했다:</p>
<ol>
<li><strong>PHI 노드 문제 이해</strong>: 위치 제약, lost copy problem, dominance frontier 계산</li>
<li><strong>Block Arguments 학습</strong>: MLIR의 우아한 대안, 함수 인자와 통일된 의미론</li>
<li><strong>scf.if 연산 사용</strong>: 고수준 구조화된 제어 흐름, scf.yield 종결자</li>
<li><strong>P/Invoke 바인딩 추가</strong>: SCF dialect 지원 (mlirSCFIfCreate, mlirSCFYieldCreate)</li>
<li><strong>AST 확장</strong>: If 표현식과 Bool 리터럴 추가</li>
<li><strong>Boolean 타입</strong>: i1 (1-bit integer), true = 1, false = 0</li>
<li><strong>코드 생성 구현</strong>: If 케이스를 scf.if로 컴파일</li>
<li><strong>Lowering pass 업데이트</strong>: SCF → CF 변환 추가</li>
<li><strong>완전한 예제</strong>: if/then/else와 let 바인딩 결합</li>
</ol>
<p><strong>독자가 할 수 있는 것:</strong></p>
<ul>
<li><code>if true then 42 else 0</code> 컴파일 → 네이티브 바이너리 → 결과: 42 ✓</li>
<li><code>if 5 &lt; 10 then 1 else 0</code> 컴파일 → 결과: 1 ✓</li>
<li><code>let x = 5 in if x &gt; 0 then x * 2 else 0</code> 컴파일 → 결과: 10 ✓</li>
<li>Block arguments vs PHI 노드 차이 이해 ✓</li>
<li>scf.if lowering 과정 이해 ✓</li>
<li>Boolean 타입 (i1) 사용 ✓</li>
<li>타입 불일치 에러 디버깅 ✓</li>
</ul>
<p><strong>핵심 개념:</strong></p>
<ul>
<li><strong>Block Arguments &gt; PHI 노드</strong>: 깔끔한 의미론, push vs pull</li>
<li><strong>scf.if = 표현식</strong>: 값을 반환, 함수형 의미론</li>
<li><strong>scf.yield = 종결자</strong>: Region에서 값 반환, return과 유사</li>
<li><strong>i1 타입 = Boolean</strong>: 1 = true, 0 = false</li>
<li><strong>Progressive Lowering</strong>: scf → cf → llvm</li>
</ul>
<p><strong>다음 장 미리보기:</strong></p>
<p>Chapter 09에서는 <strong>메모리 관리</strong>를 다룬다:</p>
<ul>
<li>Stack vs Heap 할당</li>
<li><code>memref.alloca</code> (stack allocation)</li>
<li><code>memref.alloc</code> (heap allocation)</li>
<li><strong>Boehm GC 통합</strong> (garbage collection)</li>
</ul>
<p>Phase 2의 마지막 장이다. Phase 3에서는 함수와 클로저를 구현할 것이다!</p>
<hr>
<p><strong>이제 독자는 if/then/else 제어 흐름을 컴파일하고, block arguments와 scf.if를 이해한다!</strong></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-09-메모리-관리와-boehm-gc"><a class="header" href="#chapter-09-메모리-관리와-boehm-gc">Chapter 09: 메모리 관리와 Boehm GC</a></h1>
<h2 id="소개-9"><a class="header" href="#소개-9">소개</a></h2>
<p>지금까지 FunLang 컴파일러는 모든 값을 SSA 레지스터로 처리했다. 정수, boolean, 심지어 let 바인딩도 메모리 연산 없이 SSA value로만 표현했다.</p>
<pre><code class="language-mlir">func.func @main() -&gt; i32 {
  %c5 = arith.constant 5 : i32       // SSA value (레지스터)
  %c10 = arith.constant 10 : i32     // SSA value (레지스터)
  %sum = arith.addi %c5, %c10 : i32  // SSA value (레지스터)
  func.return %sum : i32
}
</code></pre>
<p>이 접근 방식은 단순한 표현식에서는 완벽하게 작동한다. 하지만 앞으로 구현할 기능은 <strong>메모리 할당</strong>이 필요하다:</p>
<ul>
<li><strong>클로저(Closures)</strong>: 외부 스코프의 변수를 캡처하는 함수</li>
<li><strong>데이터 구조</strong>: 리스트, 튜플, 문자열 등 동적 크기 데이터</li>
<li><strong>함수에서 반환되는 값</strong>: 함수 스코프를 벗어나 생존하는 값</li>
</ul>
<p>이 장에서는 메모리 관리 전략을 학습한다:</p>
<ul>
<li>Stack vs Heap 할당 전략</li>
<li>MLIR의 <code>memref</code> dialect</li>
<li><strong>Boehm GC</strong> 통합 (자동 메모리 회수)</li>
</ul>
<p><strong>중요한 관점:</strong> Phase 2 프로그램은 아직 메모리 할당이 필요하지 않다. 하지만 Phase 3 (함수와 클로저)에 들어가기 전에 GC 인프라를 미리 준비한다. “필요하기 전에 왜 GC가 필요한지“를 이해하는 것이 목표다.</p>
<p>이 장을 마치면:</p>
<ul>
<li>Stack과 heap의 차이를 이해한다</li>
<li>어떤 값이 stack에, 어떤 값이 heap에 가는지 안다</li>
<li>MLIR의 <code>memref</code> 연산을 사용할 수 있다</li>
<li>Boehm GC를 빌드하고 링킹할 수 있다</li>
<li>왜 클로저에 GC가 필요한지 이해한다</li>
</ul>
<blockquote>
<p><strong>Preview:</strong> Phase 3에서 클로저를 구현할 때, 이 장에서 준비한 GC가 바로 사용된다!</p>
</blockquote>
<h2 id="메모리-관리-전략"><a class="header" href="#메모리-관리-전략">메모리 관리 전략</a></h2>
<p>프로그램이 실행될 때 두 종류의 메모리 영역을 사용한다: <strong>Stack</strong>과 <strong>Heap</strong>.</p>
<h3 id="stack-할당"><a class="header" href="#stack-할당">Stack 할당</a></h3>
<p>**Stack (스택)**은 함수 호출 시 자동으로 관리되는 메모리 영역이다.</p>
<p><strong>Stack에 저장되는 것:</strong></p>
<ul>
<li>함수 파라미터</li>
<li>지역 변수</li>
<li>임시 계산 값</li>
<li>함수 반환 주소</li>
</ul>
<p><strong>Stack의 특징:</strong></p>
<ol>
<li>
<p><strong>자동 할당 및 해제</strong></p>
<pre><code class="language-c">int foo() {
    int x = 5;    // Stack에 할당
    int y = 10;   // Stack에 할당
    return x + y;
    // 함수 종료 시 x, y 자동 해제
}
</code></pre>
</li>
<li>
<p><strong>빠른 할당</strong></p>
<ul>
<li>Stack pointer만 이동 (포인터 연산 한 번)</li>
<li>별도의 할당자(allocator) 불필요</li>
</ul>
</li>
<li>
<p><strong>LIFO (Last-In-First-Out) 구조</strong></p>
<pre><code>foo() 호출:
┌──────────────┐
│ foo의 지역변수│ ← stack top
├──────────────┤
│ main의 지역변수│
├──────────────┤
│    ...       │
└──────────────┘

foo() 종료:
┌──────────────┐
│ main의 지역변수│ ← stack top (foo의 프레임 제거됨)
├──────────────┤
│    ...       │
└──────────────┘
</code></pre>
</li>
<li>
<p><strong>크기 제한</strong></p>
<ul>
<li>Stack 크기는 고정 (보통 1-8MB)</li>
<li>너무 많은 지역 변수나 깊은 재귀는 stack overflow 유발</li>
</ul>
</li>
</ol>
<p><strong>언제 stack을 사용하는가:</strong></p>
<ul>
<li>함수 내부에서만 사용되는 값</li>
<li>크기가 컴파일 타임에 결정되는 값</li>
<li>함수 종료 시 사라져도 되는 값</li>
</ul>
<h3 id="heap-할당"><a class="header" href="#heap-할당">Heap 할당</a></h3>
<p>**Heap (힙)**은 명시적으로 할당하고 해제하는 메모리 영역이다.</p>
<p><strong>Heap에 저장되는 것:</strong></p>
<ul>
<li>함수 스코프를 벗어나 생존하는 값</li>
<li>동적 크기 데이터 (런타임에 크기 결정)</li>
<li>여러 함수/클로저가 공유하는 값</li>
</ul>
<p><strong>Heap의 특징:</strong></p>
<ol>
<li>
<p><strong>명시적 할당</strong></p>
<pre><code class="language-c">void* ptr = malloc(100);  // Heap에 100바이트 할당
// ... ptr 사용 ...
free(ptr);                // 명시적 해제 필요
</code></pre>
</li>
<li>
<p><strong>느린 할당</strong></p>
<ul>
<li>할당자가 적절한 메모리 블록을 찾아야 함</li>
<li>Fragmentation (단편화) 관리 필요</li>
</ul>
</li>
<li>
<p><strong>유연한 생명주기</strong></p>
<pre><code class="language-c">int* create_value() {
    int* p = malloc(sizeof(int));
    *p = 42;
    return p;  // 함수 종료 후에도 값이 살아있다
}
</code></pre>
</li>
<li>
<p><strong>크기 제한이 크다</strong></p>
<ul>
<li>Heap은 시스템 전체 가용 메모리를 사용할 수 있다</li>
<li>Stack보다 훨씬 큰 데이터 구조 가능</li>
</ul>
</li>
</ol>
<p><strong>언제 heap을 사용하는가:</strong></p>
<ul>
<li>함수에서 반환되는 값</li>
<li>동적 크기 데이터 (리스트 길이를 런타임에 결정)</li>
<li>여러 클로저가 공유하는 환경</li>
</ul>
<h3 id="funlang의-메모리-전략"><a class="header" href="#funlang의-메모리-전략">FunLang의 메모리 전략</a></h3>
<p><strong>Phase 2 (현재):</strong></p>
<ul>
<li>모든 값이 SSA 레지스터</li>
<li>정수와 boolean만 존재</li>
<li>메모리 할당이 전혀 없다</li>
</ul>
<pre><code class="language-mlir">// Phase 2: 모든 것이 SSA value
func.func @main() -&gt; i32 {
  %c5 = arith.constant 5 : i32      // 레지스터
  %c10 = arith.constant 10 : i32    // 레지스터
  %sum = arith.addi %c5, %c10 : i32 // 레지스터
  func.return %sum : i32
}
</code></pre>
<p><strong>Phase 3 (클로저):</strong></p>
<ul>
<li>클로저가 환경을 캡처</li>
<li><strong>캡처된 환경은 heap에 할당</strong> (함수를 벗어나 생존)</li>
<li>GC가 자동으로 회수</li>
</ul>
<pre><code class="language-mlir">// Phase 3 예시 (preview):
// let x = 5 in (fun y -&gt; x + y)  // 클로저가 x를 캡처
func.func @main() -&gt; !closure {
  %c5 = arith.constant 5 : i32

  // 클로저 환경을 heap에 할당
  %env_size = arith.constant 8 : i64  // x를 저장할 공간
  %env = llvm.call @GC_malloc(%env_size) : (i64) -&gt; !llvm.ptr

  // x를 환경에 저장
  llvm.store %c5, %env : !llvm.ptr

  // 클로저 생성 (함수 포인터 + 환경 포인터)
  %closure = funlang.create_closure @lambda, %env
  func.return %closure : !closure
}
</code></pre>
<p><strong>Phase 6 (데이터 구조):</strong></p>
<ul>
<li>리스트, 튜플, 문자열</li>
<li>모두 heap에 할당</li>
<li>GC가 관리</li>
</ul>
<h3 id="stack-vs-heap-다이어그램"><a class="header" href="#stack-vs-heap-다이어그램">Stack vs Heap 다이어그램</a></h3>
<pre><code>함수 호출 스택                      Heap (GC 관리)
┌─────────────────────┐            ┌─────────────────────┐
│ main() 프레임       │            │ 클로저 환경 #1      │
│ - return addr       │     ┌─────&gt;│ - x = 5            │
│ - local: result     │─────┘      │ - y = 10           │
│ - temp: %c5, %c10   │            ├─────────────────────┤
├─────────────────────┤            │ 리스트 노드         │
│ foo() 프레임        │            │ - head = 1         │
│ - return addr       │            │ - tail = ...       │
│ - param: x          │            └─────────────────────┘
│ - local: y          │                     ↑
└─────────────────────┘                     │
   (함수 종료 시 자동 해제)           (GC가 회수)
</code></pre>
<p><strong>핵심 차이:</strong></p>
<ul>
<li><strong>Stack</strong>: 함수 스코프에 묶임, 자동 해제, 빠름</li>
<li><strong>Heap</strong>: 스코프 독립, 명시적 할당/해제, 유연함</li>
</ul>
<h3 id="왜-funlang은-heap이-필요한가"><a class="header" href="#왜-funlang은-heap이-필요한가">왜 FunLang은 Heap이 필요한가?</a></h3>
<p><strong>클로저가 핵심 이유다:</strong></p>
<pre><code class="language-fsharp">// FunLang 예시
let makeAdder = fun x -&gt;
    fun y -&gt; x + y

let add5 = makeAdder 5   // 클로저: x=5를 캡처
let add10 = makeAdder 10 // 클로저: x=10을 캡처

add5 3    // 결과: 8  (x=5 사용)
add10 3   // 결과: 13 (x=10 사용)
</code></pre>
<p><strong>문제:</strong></p>
<ul>
<li><code>makeAdder 5</code>가 반환될 때, <code>x=5</code>는 어디에 저장되는가?</li>
<li><code>makeAdder</code> 함수는 이미 종료되었다 (stack 프레임 해제됨)</li>
<li>하지만 <code>add5</code>를 호출할 때 <code>x=5</code>가 필요하다!</li>
</ul>
<p><strong>해답:</strong> <code>x=5</code>를 <strong>heap에 할당</strong>한다. 클로저는 heap 포인터를 가진다.</p>
<pre><code>makeAdder(5) 실행:
1. Heap에 환경 할당: { x: 5 }
2. 클로저 생성: (function_ptr, env_ptr)
3. makeAdder 종료 (stack 해제)
4. 클로저 반환 (env_ptr는 여전히 유효)

add5(3) 호출:
1. env_ptr에서 x 로드: x = 5
2. y = 3 (파라미터)
3. x + y = 8 반환
</code></pre>
<p><strong>GC 없이는?</strong></p>
<ul>
<li>수동으로 <code>free(env_ptr)</code> 호출 필요</li>
<li>언제 해제? <code>add5</code>가 더 이상 사용되지 않을 때</li>
<li>하지만 <code>add5</code>가 다른 변수에 할당되었다면?</li>
<li><strong>복잡성 폭발!</strong> → Garbage Collection 필요</li>
</ul>
<h2 id="mlir-memref-dialect-개요"><a class="header" href="#mlir-memref-dialect-개요">MLIR memref Dialect 개요</a></h2>
<p>MLIR은 메모리 연산을 위해 <strong>memref (memory reference)</strong> dialect를 제공한다.</p>
<h3 id="memref-타입"><a class="header" href="#memref-타입">memref 타입</a></h3>
<p><strong>memref</strong>는 “메모리 영역에 대한 참조“를 나타낸다:</p>
<pre><code class="language-mlir">memref&lt;10xi32&gt;           // 10개의 i32 배열
memref&lt;1xi32&gt;            // 단일 i32 (크기 1 배열)
memref&lt;5x5xf32&gt;          // 5×5 float 행렬
memref&lt;*xi32&gt;            // 동적 크기 i32 배열
</code></pre>
<p><strong>구성:</strong></p>
<ul>
<li><code>memref&lt;shape x type&gt;</code>: shape은 차원, type은 요소 타입</li>
<li><code>memref&lt;1xi32&gt;</code>: 하나의 i32를 저장하는 메모리 영역</li>
</ul>
<h3 id="stack-할당-memrefalloca"><a class="header" href="#stack-할당-memrefalloca">Stack 할당: memref.alloca</a></h3>
<p><strong>Stack에 메모리를 할당</strong>하는 연산:</p>
<pre><code class="language-mlir">func.func @stack_example() -&gt; i32 {
  // Stack에 i32 하나 할당
  %stack = memref.alloca() : memref&lt;1xi32&gt;

  %c0 = arith.constant 0 : index      // 인덱스 0
  %c42 = arith.constant 42 : i32      // 값 42

  // Stack에 값 저장
  memref.store %c42, %stack[%c0] : memref&lt;1xi32&gt;

  // Stack에서 값 로드
  %loaded = memref.load %stack[%c0] : memref&lt;1xi32&gt;

  func.return %loaded : i32
  // 함수 종료 시 stack 자동 해제
}
</code></pre>
<p><strong>동작:</strong></p>
<ol>
<li><code>memref.alloca</code>: Stack에 공간 할당</li>
<li><code>memref.store</code>: 메모리에 값 쓰기</li>
<li><code>memref.load</code>: 메모리에서 값 읽기</li>
<li>함수 종료: Stack 자동 해제</li>
</ol>
<p><strong>인덱스 타입:</strong></p>
<ul>
<li><code>index</code>: MLIR의 배열 인덱스 전용 타입</li>
<li>플랫폼에 따라 i32 또는 i64로 lowering됨</li>
</ul>
<p><strong>LLVM IR로 lowering:</strong></p>
<pre><code class="language-llvm">define i32 @stack_example() {
  %stack = alloca i32, i32 1         ; Stack 할당
  store i32 42, i32* %stack          ; 저장
  %loaded = load i32, i32* %stack    ; 로드
  ret i32 %loaded
}
</code></pre>
<h3 id="heap-할당-memrefalloc"><a class="header" href="#heap-할당-memrefalloc">Heap 할당: memref.alloc</a></h3>
<p><strong>Heap에 메모리를 할당</strong>하는 연산:</p>
<pre><code class="language-mlir">func.func @heap_example() -&gt; memref&lt;10xi32&gt; {
  // Heap에 i32 배열 10개 할당
  %heap = memref.alloc() : memref&lt;10xi32&gt;

  // ... heap 사용 ...

  // 명시적 해제 (수동 메모리 관리)
  // memref.dealloc %heap : memref&lt;10xi32&gt;

  func.return %heap : memref&lt;10xi32&gt;
  // heap은 함수 종료 후에도 유효
}
</code></pre>
<p><strong>동작:</strong></p>
<ol>
<li><code>memref.alloc</code>: Heap에 메모리 할당 (malloc과 유사)</li>
<li>메모리 사용</li>
<li><code>memref.dealloc</code>: 명시적 해제 (free와 유사)
<ul>
<li><strong>주의:</strong> 수동 해제는 에러 유발 (use-after-free, double-free)</li>
<li>FunLang은 GC를 사용하므로 dealloc을 호출하지 않는다!</li>
</ul>
</li>
</ol>
<p><strong>LLVM IR로 lowering:</strong></p>
<pre><code class="language-llvm">define ptr @heap_example() {
  ; malloc 호출
  %size = mul i64 10, 4                    ; 10 * sizeof(i32)
  %heap = call ptr @malloc(i64 %size)

  ; ... heap 사용 ...

  ret ptr %heap
}
</code></pre>
<h3 id="memrefload와-memrefstore"><a class="header" href="#memrefload와-memrefstore">memref.load와 memref.store</a></h3>
<p><strong>메모리 읽기/쓰기:</strong></p>
<pre><code class="language-mlir">// 쓰기
memref.store %value, %memref[%index] : memref&lt;10xi32&gt;

// 읽기
%loaded = memref.load %memref[%index] : memref&lt;10xi32&gt;
</code></pre>
<p><strong>다차원 배열:</strong></p>
<pre><code class="language-mlir">// 5×5 행렬
%matrix = memref.alloc() : memref&lt;5x5xi32&gt;
%c1 = arith.constant 1 : index
%c2 = arith.constant 2 : index
%c42 = arith.constant 42 : i32

// matrix[1][2] = 42
memref.store %c42, %matrix[%c1, %c2] : memref&lt;5x5xi32&gt;

// value = matrix[1][2]
%value = memref.load %matrix[%c1, %c2] : memref&lt;5x5xi32&gt;
</code></pre>
<h3 id="phase-2에서-memref를-사용하지-않는-이유"><a class="header" href="#phase-2에서-memref를-사용하지-않는-이유">Phase 2에서 memref를 사용하지 않는 이유</a></h3>
<p><strong>Phase 2 프로그램은 SSA 레지스터만으로 충분하다:</strong></p>
<pre><code class="language-mlir">// Phase 2 스타일 (SSA only)
func.func @main() -&gt; i32 {
  %x = arith.constant 5 : i32      // SSA value
  %y = arith.constant 10 : i32     // SSA value
  %sum = arith.addi %x, %y : i32   // SSA value
  func.return %sum : i32
}

// memref 스타일로 작성하면? (불필요하게 복잡)
func.func @main() -&gt; i32 {
  %x_mem = memref.alloca() : memref&lt;1xi32&gt;
  %c0 = arith.constant 0 : index
  %c5 = arith.constant 5 : i32
  memref.store %c5, %x_mem[%c0] : memref&lt;1xi32&gt;

  %y_mem = memref.alloca() : memref&lt;1xi32&gt;
  %c10 = arith.constant 10 : i32
  memref.store %c10, %y_mem[%c0] : memref&lt;1xi32&gt;

  %x = memref.load %x_mem[%c0] : memref&lt;1xi32&gt;
  %y = memref.load %y_mem[%c0] : memref&lt;1xi32&gt;
  %sum = arith.addi %x, %y : i32
  func.return %sum : i32
}
</code></pre>
<p>첫 번째 버전이 훨씬 간단하다! SSA 레지스터만으로 충분하면 memref를 사용할 필요가 없다.</p>
<p><strong>memref가 필요한 경우:</strong></p>
<ul>
<li>값이 함수 스코프를 벗어나야 할 때 (클로저 환경)</li>
<li>포인터가 필요할 때 (데이터 구조 간 참조)</li>
<li>Mutation이 필요할 때 (SSA는 immutable)</li>
</ul>
<h3 id="memref-요약"><a class="header" href="#memref-요약">memref 요약</a></h3>
<p><strong>memref dialect:</strong></p>
<ul>
<li>MLIR의 메모리 연산 추상화</li>
<li><code>memref.alloca</code>: Stack 할당 (자동 해제)</li>
<li><code>memref.alloc</code>: Heap 할당 (수동 해제 또는 GC)</li>
<li><code>memref.load/store</code>: 메모리 읽기/쓰기</li>
</ul>
<p><strong>Phase 2 vs Phase 3:</strong></p>
<ul>
<li>Phase 2: SSA 레지스터만 사용 (memref 불필요)</li>
<li>Phase 3: 클로저 환경 → heap 할당 → memref 필요</li>
</ul>
<p><strong>다음 섹션:</strong> 왜 Garbage Collection이 필요한가?</p>
<h2 id="왜-garbage-collection이-필요한가"><a class="header" href="#왜-garbage-collection이-필요한가">왜 Garbage Collection이 필요한가</a></h2>
<p>Heap 메모리는 명시적으로 할당하고 해제해야 한다. 하지만 수동 메모리 관리는 <strong>매우 어렵고 에러가 많다</strong>.</p>
<h3 id="수동-메모리-관리의-문제"><a class="header" href="#수동-메모리-관리의-문제">수동 메모리 관리의 문제</a></h3>
<h4 id="1-use-after-free"><a class="header" href="#1-use-after-free">1. Use-After-Free</a></h4>
<p><strong>freed 메모리에 접근:</strong></p>
<pre><code class="language-c">int* ptr = malloc(sizeof(int));
*ptr = 42;
free(ptr);        // 메모리 해제
printf("%d\n", *ptr);  // 에러! freed 메모리 접근
</code></pre>
<p><strong>결과:</strong></p>
<ul>
<li>Undefined behavior (프로그램 crash 또는 잘못된 값)</li>
<li>보안 취약점 (공격자가 freed 메모리를 재사용)</li>
</ul>
<h4 id="2-double-free"><a class="header" href="#2-double-free">2. Double-Free</a></h4>
<p><strong>같은 메모리를 두 번 해제:</strong></p>
<pre><code class="language-c">int* ptr = malloc(sizeof(int));
free(ptr);
free(ptr);  // 에러! 이미 freed된 메모리
</code></pre>
<p><strong>결과:</strong></p>
<ul>
<li>Heap 메타데이터 손상</li>
<li>프로그램 crash</li>
</ul>
<h4 id="3-memory-leak"><a class="header" href="#3-memory-leak">3. Memory Leak</a></h4>
<p><strong>메모리 해제를 잊음:</strong></p>
<pre><code class="language-c">void leak() {
    int* ptr = malloc(sizeof(int));
    *ptr = 42;
    return;  // ptr을 free하지 않음!
}

// leak()을 1000번 호출하면?
for (int i = 0; i &lt; 1000; i++) {
    leak();  // 메모리 누수: 1000 * sizeof(int) 바이트
}
</code></pre>
<p><strong>결과:</strong></p>
<ul>
<li>메모리 사용량 계속 증가</li>
<li>Out-of-memory 에러</li>
</ul>
<h3 id="클로저가-수동-메모리-관리를-어렵게-만드는-이유"><a class="header" href="#클로저가-수동-메모리-관리를-어렵게-만드는-이유">클로저가 수동 메모리 관리를 어렵게 만드는 이유</a></h3>
<p><strong>문제: 언제 클로저 환경을 해제하는가?</strong></p>
<pre><code class="language-fsharp">// FunLang 예시
let makeAdder x = fun y -&gt; x + y

let add5 = makeAdder 5   // 클로저 1: env = { x: 5 }
let add10 = makeAdder 10 // 클로저 2: env = { x: 10 }

// Q: env { x: 5 }를 언제 해제하는가?
// A: add5가 더 이상 사용되지 않을 때

// 하지만 이것이 언제인가?
let adders = [add5; add10]  // add5를 리스트에 저장
// 여기서 add5를 해제할 수 있는가? No! 리스트가 참조 중

let result = List.head adders 3  // add5 사용
// 이제 해제? 아직 adders가 add5를 가리킨다

// ... 프로그램 계속 실행 ...
</code></pre>
<p><strong>복잡성:</strong></p>
<ul>
<li><code>add5</code>가 언제 “더 이상 사용되지 않는가“를 결정하기 어렵다</li>
<li>여러 변수가 같은 클로저를 참조할 수 있다</li>
<li>클로저가 다른 클로저를 캡처할 수 있다 (환경이 중첩)</li>
</ul>
<p><strong>수동 관리 시도:</strong></p>
<pre><code class="language-fsharp">// 명시적 free 추가?
let add5 = makeAdder 5
// ... add5 사용 ...
free(add5)  // 하지만 다른 변수가 add5를 참조하면?

let alias = add5
free(add5)  // alias는 이제 invalid pointer!
</code></pre>
<p><strong>불가능한 이유:</strong></p>
<ul>
<li>참조 추적이 필요 (누가 클로저를 가리키는가?)</li>
<li>런타임 추적 메커니즘 필요</li>
<li><strong>이미 Garbage Collector를 구현하는 것과 같다!</strong></li>
</ul>
<h3 id="클로저-생명주기-예시"><a class="header" href="#클로저-생명주기-예시">클로저 생명주기 예시</a></h3>
<p><strong>복잡한 시나리오:</strong></p>
<pre><code class="language-fsharp">let outer x =
    let inner y =
        fun z -&gt; x + y + z  // x와 y를 모두 캡처
    inner

let f = outer 5 10   // f는 클로저, env = { x: 5, y: 10 }

// outer 함수는 종료됨 (stack 해제)
// 하지만 env { x: 5, y: 10 }은 heap에 살아있어야 함

let result = f 3     // x=5, y=10, z=3 → 18

// 언제 env를 해제?
// f가 더 이상 참조되지 않을 때
</code></pre>
<p><strong>Garbage Collector의 역할:</strong></p>
<ul>
<li>런타임에 객체 참조를 추적한다</li>
<li>더 이상 참조되지 않는 객체를 찾는다</li>
<li>자동으로 메모리를 회수한다</li>
</ul>
<h3 id="garbage-collection의-이점"><a class="header" href="#garbage-collection의-이점">Garbage Collection의 이점</a></h3>
<p><strong>1. 안전성</strong></p>
<ul>
<li>Use-after-free: 불가능 (GC가 사용 중인 객체를 해제하지 않음)</li>
<li>Double-free: 불가능 (GC가 한 번만 해제)</li>
<li>Memory leak: 최소화 (접근 불가능한 객체는 자동 회수)</li>
</ul>
<p><strong>2. 생산성</strong></p>
<ul>
<li>프로그래머가 메모리 관리를 신경 쓰지 않아도 됨</li>
<li>버그가 적다</li>
<li>코드가 간결해진다</li>
</ul>
<p><strong>3. 클로저 지원</strong></p>
<ul>
<li>클로저 환경의 생명주기를 자동 관리</li>
<li>복잡한 참조 그래프도 처리</li>
</ul>
<p><strong>트레이드오프:</strong></p>
<ul>
<li>성능: GC가 주기적으로 실행됨 (pause time)</li>
<li>메모리: GC는 약간의 메모리 오버헤드 존재</li>
<li><strong>FunLang의 선택:</strong> 클로저 지원을 위해 GC는 필수</li>
</ul>
<h3 id="gc-없이-클로저를-구현한다면"><a class="header" href="#gc-없이-클로저를-구현한다면">GC 없이 클로저를 구현한다면?</a></h3>
<p><strong>대안들:</strong></p>
<ol>
<li>
<p><strong>Reference Counting</strong></p>
<ul>
<li>각 객체의 참조 카운트 추적</li>
<li>카운트가 0이 되면 해제</li>
<li><strong>문제:</strong> 순환 참조 처리 불가
<pre><code class="language-fsharp">let rec loop x = fun y -&gt; loop y x  // 순환 참조!
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Arena Allocation</strong></p>
<ul>
<li>모든 객체를 arena에 할당</li>
<li>Arena 전체를 한 번에 해제</li>
<li><strong>문제:</strong> 클로저가 서로 다른 생명주기를 가질 때 비효율</li>
</ul>
</li>
<li>
<p><strong>Ownership System (Rust 스타일)</strong></p>
<ul>
<li>컴파일 타임에 생명주기 추적</li>
<li>런타임 오버헤드 없음</li>
<li><strong>문제:</strong> FunLang은 타입 추론 언어 (ownership 추가는 언어 복잡성 증가)</li>
</ul>
</li>
</ol>
<p><strong>결론:</strong> Garbage Collection이 가장 적합한 선택이다!</p>
<h3 id="왜-gc가-필요한가-요약"><a class="header" href="#왜-gc가-필요한가-요약">왜 GC가 필요한가 요약</a></h3>
<p><strong>문제:</strong></p>
<ul>
<li>클로저 환경은 heap에 할당해야 한다 (함수 스코프를 벗어남)</li>
<li>환경의 생명주기는 복잡하다 (여러 참조, 중첩, 순환)</li>
<li>수동 메모리 관리는 에러가 많다 (use-after-free, leak)</li>
</ul>
<p><strong>해답: Garbage Collection</strong></p>
<ul>
<li>런타임에 객체 참조를 추적한다</li>
<li>접근 불가능한 객체를 자동으로 회수한다</li>
<li>프로그래머가 메모리 관리를 신경 쓰지 않아도 된다</li>
</ul>
<p><strong>다음 섹션:</strong> Boehm GC 소개 - FunLang이 사용할 GC!</p>
<h2 id="boehm-gc-소개"><a class="header" href="#boehm-gc-소개">Boehm GC 소개</a></h2>
<p>FunLang은 <strong>Boehm-Demers-Weiser Garbage Collector</strong> (줄여서 Boehm GC 또는 bdwgc)를 사용한다.</p>
<h3 id="boehm-gc란"><a class="header" href="#boehm-gc란">Boehm GC란?</a></h3>
<p><strong>Boehm GC</strong>는 C와 C++을 위한 <strong>보수적(conservative) 가비지 컬렉터</strong>다.</p>
<p><strong>핵심 특징:</strong></p>
<ol>
<li>
<p><strong>Conservative Collection</strong></p>
<ul>
<li>“보수적“이란 정확한 타입 정보 없이 동작한다는 의미</li>
<li>Stack과 heap을 스캔하여 “포인터처럼 보이는 값“을 찾는다</li>
<li>값이 유효한 heap 주소 범위에 있으면 포인터로 간주한다</li>
</ul>
</li>
<li>
<p><strong>Drop-in Replacement for malloc/free</strong></p>
<pre><code class="language-c">// 기존 코드
int* ptr = malloc(sizeof(int) * 10);
// ... 사용 ...
free(ptr);

// Boehm GC 사용
int* ptr = GC_malloc(sizeof(int) * 10);
// ... 사용 ...
// free 불필요! GC가 자동으로 회수
</code></pre>
</li>
<li>
<p><strong>Battle-Tested</strong></p>
<ul>
<li>1988년부터 개발됨 (30년 이상 역사)</li>
<li>많은 프로그래밍 언어 구현에서 사용:
<ul>
<li>GNU Guile (Scheme)</li>
<li>Mono (.NET on Linux)</li>
<li>W3m (텍스트 브라우저)</li>
</ul>
</li>
<li>안정성이 검증됨</li>
</ul>
</li>
<li>
<p><strong>Thread-Safe</strong></p>
<ul>
<li>멀티스레드 환경에서 안전</li>
<li>적절한 초기화 필요 (<code>GC_INIT()</code>)</li>
</ul>
</li>
</ol>
<h3 id="왜-boehm-gc를-선택했는가"><a class="header" href="#왜-boehm-gc를-선택했는가">왜 Boehm GC를 선택했는가?</a></h3>
<p><strong>장점:</strong></p>
<ol>
<li>
<p><strong>컴파일러 변경 최소화</strong></p>
<ul>
<li>Stack map 불필요 (conservative 스캔)</li>
<li>Write barrier 불필요</li>
<li>GC를 위한 특별한 코드 생성 불필요</li>
</ul>
</li>
<li>
<p><strong>간단한 통합</strong></p>
<ul>
<li>C 라이브러리로 제공</li>
<li><code>GC_malloc</code> 호출만으로 사용 가능</li>
<li>기존 C runtime과 함께 링킹</li>
</ul>
</li>
<li>
<p><strong>안정성</strong></p>
<ul>
<li>오래 사용됨, 버그가 적다</li>
<li>다양한 플랫폼 지원 (Linux, macOS, Windows)</li>
</ul>
</li>
</ol>
<p><strong>단점:</strong></p>
<ol>
<li>
<p><strong>보수적 수집</strong></p>
<ul>
<li>False positive: 포인터가 아닌 값을 포인터로 오인</li>
<li>결과: 일부 객체가 회수되지 않을 수 있음 (메모리 누수)</li>
<li>실제로는 드물고, 대부분의 프로그램에서 문제없음</li>
</ul>
</li>
<li>
<p><strong>Stop-the-world GC</strong></p>
<ul>
<li>GC 실행 중 프로그램 전체가 일시 중지</li>
<li>Latency-critical 애플리케이션에는 부적합</li>
<li>FunLang은 교육용이므로 문제없음</li>
</ul>
</li>
</ol>
<h3 id="대안과-비교"><a class="header" href="#대안과-비교">대안과 비교</a></h3>
<p><strong>1. Reference Counting</strong></p>
<ul>
<li><strong>장점:</strong> 즉시 회수, 예측 가능</li>
<li><strong>단점:</strong> 순환 참조 처리 불가, 성능 오버헤드 (카운트 업데이트)</li>
<li><strong>FunLang:</strong> 클로저는 순환 참조 가능 → 부적합</li>
</ul>
<p><strong>2. LLVM Statepoints (Precise GC)</strong></p>
<ul>
<li><strong>장점:</strong> 정확한 수집 (false positive 없음)</li>
<li><strong>단점:</strong> 복잡한 컴파일러 지원 필요 (safepoint 삽입, stack map 생성)</li>
<li><strong>FunLang:</strong> 교육용으로는 너무 복잡 → 부적합</li>
</ul>
<p><strong>3. Custom Mark-Sweep GC</strong></p>
<ul>
<li><strong>장점:</strong> 완전한 제어</li>
<li><strong>단점:</strong> 구현이 어렵고 버그가 많음</li>
<li><strong>FunLang:</strong> Boehm GC가 이미 잘 동작 → 불필요</li>
</ul>
<p><strong>결론:</strong> Boehm GC가 FunLang에 가장 적합하다!</p>
<h3 id="boehm-gc-핵심-함수"><a class="header" href="#boehm-gc-핵심-함수">Boehm GC 핵심 함수</a></h3>
<p><strong>1. GC_INIT()</strong></p>
<pre><code class="language-c">GC_INIT();  // 프로그램 시작 시 한 번 호출
</code></pre>
<ul>
<li>GC를 초기화한다</li>
<li>반드시 <code>main()</code> 시작 부분이나 첫 <code>GC_malloc</code> 전에 호출</li>
<li>Thread-local storage 설정, heap 초기화</li>
</ul>
<p><strong>2. GC_malloc(size)</strong></p>
<pre><code class="language-c">void* ptr = GC_malloc(100);  // 100바이트 할당
</code></pre>
<ul>
<li>Heap에 메모리 할당</li>
<li><code>malloc</code>과 동일하게 사용</li>
<li>GC가 자동으로 회수 (free 불필요)</li>
</ul>
<p><strong>3. GC_malloc_atomic(size)</strong></p>
<pre><code class="language-c">void* ptr = GC_malloc_atomic(100);  // 포인터 없는 데이터
</code></pre>
<ul>
<li>포인터를 포함하지 않는 데이터용 할당</li>
<li>예: 문자열, 정수 배열</li>
<li>GC가 스캔하지 않음 (성능 향상)</li>
</ul>
<p><strong>4. GC_free(ptr)</strong> (선택 사항)</p>
<pre><code class="language-c">GC_free(ptr);  // 명시적 해제 (힌트)
</code></pre>
<ul>
<li>GC에게 “이 메모리를 즉시 회수해도 됨“을 알림</li>
<li>필수는 아님 (GC가 나중에 자동 회수)</li>
<li>성능 최적화용</li>
</ul>
<h3 id="conservative-gc-동작-원리"><a class="header" href="#conservative-gc-동작-원리">Conservative GC 동작 원리</a></h3>
<p><strong>1. Heap 스캔:</strong></p>
<pre><code>Heap:
┌────────────────┐ 0x1000
│ Object A       │
├────────────────┤ 0x1010
│ Object B       │
├────────────────┤ 0x1020
│ Free space     │
└────────────────┘
</code></pre>
<p><strong>2. Stack 스캔:</strong></p>
<pre><code>Stack:
┌────────────────┐
│ var1 = 0x1000  │ ← 포인터처럼 보임 (Object A 가리킴)
├────────────────┤
│ var2 = 42      │ ← 포인터 아님 (heap 범위 밖)
├────────────────┤
│ var3 = 0x1010  │ ← 포인터처럼 보임 (Object B 가리킴)
└────────────────┘
</code></pre>
<p><strong>3. Mark Phase:</strong></p>
<ul>
<li>Stack에서 <code>0x1000</code>, <code>0x1010</code> 발견</li>
<li>Object A와 Object B를 “live“로 표시</li>
</ul>
<p><strong>4. Sweep Phase:</strong></p>
<ul>
<li>Heap 전체를 스캔</li>
<li>“live” 표시 없는 객체 회수</li>
</ul>
<p><strong>False Positive 예시:</strong></p>
<pre><code class="language-c">int x = 0x1000;  // 우연히 heap 주소와 같은 정수
// GC는 x를 포인터로 오인할 수 있음
// 결과: 0x1000의 객체가 회수되지 않음 (누수)
</code></pre>
<p>실제로는 드물고, 대부분의 프로그램에서 문제없음.</p>
<h2 id="boehm-gc-빌드-및-설치"><a class="header" href="#boehm-gc-빌드-및-설치">Boehm GC 빌드 및 설치</a></h2>
<p>Boehm GC를 소스에서 빌드하거나 패키지 매니저로 설치할 수 있다.</p>
<h3 id="소스에서-빌드"><a class="header" href="#소스에서-빌드">소스에서 빌드</a></h3>
<p><strong>1. 저장소 클론:</strong></p>
<pre><code class="language-bash"># Boehm GC 저장소
git clone https://github.com/ivmai/bdwgc
cd bdwgc

# Atomic operations 라이브러리 (의존성)
git clone https://github.com/ivmai/libatomic_ops
</code></pre>
<p><strong>2. libatomic_ops 링크:</strong></p>
<pre><code class="language-bash"># bdwgc가 libatomic_ops를 찾을 수 있도록 심볼릭 링크 생성
ln -s $(pwd)/libatomic_ops $(pwd)/libatomic_ops
</code></pre>
<p>또는:</p>
<pre><code class="language-bash">cd bdwgc
ln -s ../libatomic_ops libatomic_ops
</code></pre>
<p><strong>3. Build 설정:</strong></p>
<pre><code class="language-bash">cd bdwgc
autoreconf -vif        # autoconf 파일 생성
automake --add-missing # 누락된 파일 추가
./configure --prefix=$HOME/boehm-gc --enable-threads=posix
</code></pre>
<p><strong>configure 옵션:</strong></p>
<ul>
<li><code>--prefix=$HOME/boehm-gc</code>: 설치 경로 (홈 디렉토리)</li>
<li><code>--enable-threads=posix</code>: 멀티스레드 지원 (POSIX threads)</li>
</ul>
<p><strong>4. 빌드 및 설치:</strong></p>
<pre><code class="language-bash">make -j$(nproc)        # 병렬 빌드 (CPU 코어 수만큼)
make check             # 테스트 실행 (선택 사항)
make install           # $HOME/boehm-gc에 설치
</code></pre>
<p><strong>5. 환경 변수 설정:</strong></p>
<pre><code class="language-bash"># 라이브러리 경로 추가
export LD_LIBRARY_PATH=$HOME/boehm-gc/lib:$LD_LIBRARY_PATH

# 헤더 경로 추가
export C_INCLUDE_PATH=$HOME/boehm-gc/include:$C_INCLUDE_PATH

# bashrc에 추가하여 영구 적용
echo 'export LD_LIBRARY_PATH=$HOME/boehm-gc/lib:$LD_LIBRARY_PATH' &gt;&gt; ~/.bashrc
echo 'export C_INCLUDE_PATH=$HOME/boehm-gc/include:$C_INCLUDE_PATH' &gt;&gt; ~/.bashrc
</code></pre>
<h3 id="패키지-매니저로-설치"><a class="header" href="#패키지-매니저로-설치">패키지 매니저로 설치</a></h3>
<p><strong>Ubuntu/Debian:</strong></p>
<pre><code class="language-bash">sudo apt update
sudo apt install libgc-dev
</code></pre>
<p><strong>macOS (Homebrew):</strong></p>
<pre><code class="language-bash">brew install bdw-gc
</code></pre>
<p><strong>Fedora/RHEL:</strong></p>
<pre><code class="language-bash">sudo dnf install gc-devel
</code></pre>
<p><strong>Arch Linux:</strong></p>
<pre><code class="language-bash">sudo pacman -S gc
</code></pre>
<p>패키지 매니저로 설치하면 환경 변수 설정이 자동으로 처리된다.</p>
<h3 id="설치-확인-1"><a class="header" href="#설치-확인-1">설치 확인</a></h3>
<p><strong>테스트 프로그램 작성:</strong></p>
<pre><code class="language-c">// test_gc.c
#include &lt;stdio.h&gt;
#include &lt;gc.h&gt;

int main() {
    GC_INIT();

    void* ptr = GC_malloc(100);
    if (ptr == NULL) {
        printf("GC_malloc failed\n");
        return 1;
    }

    printf("GC_malloc succeeded: %p\n", ptr);
    // GC_free 불필요 - GC가 자동 회수

    return 0;
}
</code></pre>
<p><strong>컴파일 및 실행:</strong></p>
<pre><code class="language-bash"># 소스 빌드한 경우
gcc test_gc.c -o test_gc -I$HOME/boehm-gc/include -L$HOME/boehm-gc/lib -lgc
./test_gc

# 패키지 매니저로 설치한 경우
gcc test_gc.c -o test_gc -lgc
./test_gc
</code></pre>
<p><strong>예상 출력:</strong></p>
<pre><code>GC_malloc succeeded: 0x7f1234567890
</code></pre>
<p>성공! Boehm GC가 올바르게 설치되었다.</p>
<h2 id="funlang-runtime-통합"><a class="header" href="#funlang-runtime-통합">FunLang Runtime 통합</a></h2>
<p>이제 FunLang 컴파일러가 생성하는 바이너리와 Boehm GC를 연결한다.</p>
<h3 id="c-runtime-작성"><a class="header" href="#c-runtime-작성">C Runtime 작성</a></h3>
<p><strong>runtime.c</strong> - FunLang 실행 환경:</p>
<pre><code class="language-c">// runtime.c - FunLang runtime with Boehm GC
#include &lt;stdio.h&gt;
#include &lt;gc.h&gt;

/**
 * GC 초기화
 * 프로그램 시작 시 한 번 호출
 */
void funlang_init() {
    GC_INIT();
}

/**
 * GC-managed 메모리 할당
 *
 * @param size 할당할 바이트 수
 * @return 할당된 메모리 포인터
 */
void* funlang_alloc(size_t size) {
    return GC_malloc(size);
}

/**
 * Atomic 메모리 할당 (포인터 없는 데이터용)
 *
 * @param size 할당할 바이트 수
 * @return 할당된 메모리 포인터
 */
void* funlang_alloc_atomic(size_t size) {
    return GC_malloc_atomic(size);
}

/**
 * 정수 출력 (Chapter 06에서 구현)
 *
 * @param value 출력할 정수 값
 */
void print_int(int value) {
    printf("%d\n", value);
}

/**
 * MLIR 컴파일된 main 함수
 * F# 컴파일러가 생성한 LLVM IR에서 정의됨
 */
extern int funlang_main();

/**
 * C 프로그램 진입점
 * GC 초기화 후 funlang_main 호출
 */
int main(int argc, char** argv) {
    funlang_init();
    int result = funlang_main();
    return result;
}
</code></pre>
<p><strong>Runtime 구조:</strong></p>
<ol>
<li><strong>funlang_init()</strong>: GC 초기화</li>
<li><strong>funlang_alloc()</strong>: Heap 할당 (Phase 3+에서 사용)</li>
<li><strong>print_int()</strong>: 정수 출력 (Phase 2에서 이미 사용 중)</li>
<li><strong>main()</strong>: GC 초기화 → funlang_main 호출</li>
</ol>
<h3 id="runtime-컴파일"><a class="header" href="#runtime-컴파일">Runtime 컴파일</a></h3>
<pre><code class="language-bash"># 소스 빌드한 경우
gcc -c runtime.c -o runtime.o -I$HOME/boehm-gc/include

# 패키지 매니저로 설치한 경우
gcc -c runtime.c -o runtime.o
</code></pre>
<p><strong>결과:</strong> <code>runtime.o</code> 오브젝트 파일 생성</p>
<h3 id="mlir에서-gc_malloc-호출"><a class="header" href="#mlir에서-gc_malloc-호출">MLIR에서 GC_malloc 호출</a></h3>
<p>Phase 3에서 클로저 환경을 heap에 할당할 때 사용할 패턴 (미리보기):</p>
<p><strong>1. GC_malloc 선언 (MLIR):</strong></p>
<pre><code class="language-mlir">// External function 선언
llvm.func @GC_malloc(i64) -&gt; !llvm.ptr attributes {
    sym_visibility = "private"
}
</code></pre>
<p><strong>2. Heap 할당 호출:</strong></p>
<pre><code class="language-mlir">func.func @allocate_closure_env() -&gt; !llvm.ptr {
    // 클로저 환경 크기 (예: 2개의 i64 값)
    %size = arith.constant 16 : i64  // 2 * 8 bytes

    // GC_malloc 호출
    %env = llvm.call @GC_malloc(%size) : (i64) -&gt; !llvm.ptr

    // env에 캡처된 값 저장
    // (Phase 3에서 구현)

    func.return %env : !llvm.ptr
}
</code></pre>
<p><strong>3. F# 코드 생성 패턴:</strong></p>
<pre><code class="language-fsharp">// MlirWrapper.fs에 추가할 헬퍼 메서드 (Phase 3)
type OpBuilder(context: Context) =
    // ... 기존 메서드 ...

    /// GC_malloc external function 선언
    member this.DeclareGCMalloc() : MlirOperation =
        let ptrType = this.LLVMPointerType()
        let i64Type = builder.Context.GetIntegerType(64)
        let funcType = MlirNative.mlirFunctionTypeGet(
            ctx.Handle,
            1n, [| i64Type |],
            1n, [| ptrType |]
        )

        let name = MlirHelpers.fromString("GC_malloc")
        let funcOp = MlirNative.mlirLLVMFuncCreate(location, name, funcType)

        // 가시성 속성 설정
        // ...

        funcOp

    /// GC_malloc 호출하여 메모리 할당
    member this.CallGCMalloc(size: MlirValue, location: MlirLocation) : MlirValue =
        let gcMalloc = // ... GC_malloc 함수 참조 ...
        let callOp = MlirNative.mlirLLVMCallCreate(
            location, gcMalloc, 1n, [| size |]
        )
        MlirNative.mlirOperationGetResult(callOp, 0)
</code></pre>
<p><strong>Phase 2에서는 사용하지 않지만</strong>, runtime.c에 <code>funlang_alloc</code>을 미리 정의하여 Phase 3에서 바로 사용할 수 있다.</p>
<h2 id="빌드-파이프라인-업데이트"><a class="header" href="#빌드-파이프라인-업데이트">빌드 파이프라인 업데이트</a></h2>
<p>Boehm GC를 포함한 완전한 빌드 파이프라인:</p>
<h3 id="단계별-빌드-과정"><a class="header" href="#단계별-빌드-과정">단계별 빌드 과정</a></h3>
<p><strong>1. FunLang 소스 → LLVM IR:</strong></p>
<pre><code class="language-bash"># F# 컴파일러 실행
dotnet run "let x = 5 in if x &gt; 0 then x * 2 else 0"

# 출력: output.ll (LLVM IR 파일)
</code></pre>
<p><strong>2. LLVM IR → Object 파일:</strong></p>
<pre><code class="language-bash">llc -filetype=obj output.ll -o output.o
</code></pre>
<p><strong>3. Runtime 컴파일:</strong></p>
<pre><code class="language-bash"># 소스 빌드한 경우
gcc -c runtime.c -o runtime.o -I$HOME/boehm-gc/include

# 패키지 매니저로 설치한 경우
gcc -c runtime.c -o runtime.o
</code></pre>
<p><strong>4. 링킹 (Boehm GC 포함):</strong></p>
<pre><code class="language-bash"># 소스 빌드한 경우
gcc output.o runtime.o -o program \
    -L$HOME/boehm-gc/lib -lgc \
    -Wl,-rpath,$HOME/boehm-gc/lib

# 패키지 매니저로 설치한 경우
gcc output.o runtime.o -o program -lgc
</code></pre>
<p><strong>링커 옵션 설명:</strong></p>
<ul>
<li><code>-L$HOME/boehm-gc/lib</code>: 라이브러리 검색 경로</li>
<li><code>-lgc</code>: Boehm GC 라이브러리 링크</li>
<li><code>-Wl,-rpath,$HOME/boehm-gc/lib</code>: 실행 시 라이브러리 경로 (RPATH)</li>
</ul>
<p><strong>5. 실행:</strong></p>
<pre><code class="language-bash">./program
echo $?   # Exit code 확인
</code></pre>
<h3 id="자동화된-빌드-스크립트"><a class="header" href="#자동화된-빌드-스크립트">자동화된 빌드 스크립트</a></h3>
<p><strong>build.sh:</strong></p>
<pre><code class="language-bash">#!/bin/bash
# FunLang 빌드 스크립트

set -e  # 에러 시 중단

FUNLANG_SRC="$1"
OUTPUT="program"

# 1. FunLang → LLVM IR
echo "Compiling FunLang to LLVM IR..."
dotnet run "$FUNLANG_SRC" &gt; output.ll

# 2. LLVM IR → Object
echo "Compiling LLVM IR to object file..."
llc -filetype=obj output.ll -o output.o

# 3. Runtime 컴파일 (필요 시)
if [ ! -f runtime.o ]; then
    echo "Compiling runtime..."
    gcc -c runtime.c -o runtime.o
fi

# 4. 링킹
echo "Linking with Boehm GC..."
if [ -d "$HOME/boehm-gc" ]; then
    # 소스 빌드
    gcc output.o runtime.o -o "$OUTPUT" \
        -L$HOME/boehm-gc/lib -lgc \
        -Wl,-rpath,$HOME/boehm-gc/lib
else
    # 패키지 매니저
    gcc output.o runtime.o -o "$OUTPUT" -lgc
fi

echo "Build complete: $OUTPUT"
</code></pre>
<p><strong>사용:</strong></p>
<pre><code class="language-bash">chmod +x build.sh
./build.sh "let x = 5 in x + x"
./program
</code></pre>
<h3 id="f-통합"><a class="header" href="#f-통합">F# 통합</a></h3>
<p><strong>Compiler.fs에 추가:</strong></p>
<pre><code class="language-fsharp">module Compiler =

    /// LLVM IR을 object 파일로 컴파일
    let compileToObject (llvmIR: string) (outputPath: string) =
        // LLVM IR을 파일에 쓰기
        let llPath = Path.ChangeExtension(outputPath, ".ll")
        File.WriteAllText(llPath, llvmIR)

        // llc 호출
        let llcArgs = sprintf "-filetype=obj %s -o %s" llPath outputPath
        let result = Process.Start("llc", llcArgs)
        result.WaitForExit()

        if result.ExitCode &lt;&gt; 0 then
            failwith "llc compilation failed"

    /// Object 파일과 runtime을 링킹
    let linkWithGC (objPath: string) (exePath: string) =
        let runtimePath = "runtime.o"

        // Boehm GC 경로 확인
        let gcPath = Environment.GetEnvironmentVariable("HOME") + "/boehm-gc"
        let hasSourceBuild = Directory.Exists(gcPath)

        let gccArgs =
            if hasSourceBuild then
                sprintf "%s %s -o %s -L%s/lib -lgc -Wl,-rpath,%s/lib"
                    objPath runtimePath exePath gcPath gcPath
            else
                sprintf "%s %s -o %s -lgc"
                    objPath runtimePath exePath

        let result = Process.Start("gcc", gccArgs)
        result.WaitForExit()

        if result.ExitCode &lt;&gt; 0 then
            failwith "gcc linking failed"

    /// 전체 컴파일 파이프라인
    let compileProgram (source: string) (outputExe: string) =
        // 1. Parse
        let ast = Parser.parse source

        // 2. MLIR IR 생성
        let mlirModule = CodeGen.compile ast

        // 3. Lowering
        Lowering.lowerToLLVMDialect mlirModule

        // 4. LLVM IR 변환
        let llvmIR = Lowering.translateToLLVMIR mlirModule

        // 5. Object 컴파일
        let objPath = Path.ChangeExtension(outputExe, ".o")
        compileToObject llvmIR objPath

        // 6. 링킹
        linkWithGC objPath outputExe

        printfn "Compilation successful: %s" outputExe
</code></pre>
<p><strong>사용:</strong></p>
<pre><code class="language-fsharp">// Program.fs
[&lt;EntryPoint&gt;]
let main argv =
    if argv.Length &lt; 1 then
        printfn "Usage: dotnet run &lt;source&gt; [output]"
        1
    else
        let source = argv.[0]
        let output = if argv.Length &gt; 1 then argv.[1] else "program"

        Compiler.compileProgram source output
        0
</code></pre>
<h2 id="phase-2-vs-phase-3-메모리-사용"><a class="header" href="#phase-2-vs-phase-3-메모리-사용">Phase 2 vs Phase 3+ 메모리 사용</a></h2>
<p>FunLang의 메모리 사용 패턴은 단계별로 진화한다.</p>
<h3 id="phase-2-현재"><a class="header" href="#phase-2-현재">Phase 2 (현재)</a></h3>
<p><strong>특징:</strong></p>
<ul>
<li>모든 값이 SSA 레지스터</li>
<li>메모리 할당 없음</li>
<li>GC 초기화되지만 사용되지 않음</li>
</ul>
<p><strong>생성되는 MLIR IR:</strong></p>
<pre><code class="language-mlir">module {
  func.func @funlang_main() -&gt; i32 {
    %c5 = arith.constant 5 : i32
    %c10 = arith.constant 10 : i32
    %sum = arith.addi %c5, %c10 : i32
    func.return %sum : i32
  }
}
</code></pre>
<p><strong>GC 호출:</strong> 없음 (<code>funlang_alloc</code> 호출 0회)</p>
<h3 id="phase-3-함수와-클로저"><a class="header" href="#phase-3-함수와-클로저">Phase 3 (함수와 클로저)</a></h3>
<p><strong>특징:</strong></p>
<ul>
<li>클로저가 환경을 캡처</li>
<li>환경은 heap에 할당 (<code>GC_malloc</code>)</li>
<li>GC가 죽은 클로저 회수</li>
</ul>
<p><strong>예시: 클로저 환경 할당</strong></p>
<pre><code class="language-mlir">// let makeAdder x = fun y -&gt; x + y
func.func @makeAdder(%x: i32) -&gt; !llvm.ptr {
    // 클로저 환경 할당 (x를 저장)
    %size = arith.constant 8 : i64
    %env = llvm.call @GC_malloc(%size) : (i64) -&gt; !llvm.ptr

    // x를 환경에 저장
    %x_i64 = arith.extsi %x : i32 to i64
    llvm.store %x_i64, %env : !llvm.ptr

    // 클로저 생성 (function pointer + env pointer)
    %closure = funlang.make_closure @lambda, %env

    func.return %closure : !llvm.ptr
}

// fun y -&gt; x + y
func.func private @lambda(%env: !llvm.ptr, %y: i32) -&gt; i32 {
    // 환경에서 x 로드
    %x_i64 = llvm.load %env : !llvm.ptr -&gt; i64
    %x = arith.trunci %x_i64 : i64 to i32

    // x + y
    %result = arith.addi %x, %y : i32
    func.return %result : i32
}
</code></pre>
<p><strong>GC 호출:</strong> <code>makeAdder</code> 호출마다 1회</p>
<h3 id="phase-6-데이터-구조"><a class="header" href="#phase-6-데이터-구조">Phase 6 (데이터 구조)</a></h3>
<p><strong>특징:</strong></p>
<ul>
<li>리스트, 튜플, 문자열 모두 heap 할당</li>
<li>재귀적 데이터 구조 (리스트의 tail)</li>
<li>GC가 복잡한 참조 그래프 처리</li>
</ul>
<p><strong>예시: 리스트 cons</strong></p>
<pre><code class="language-mlir">// cons(1, cons(2, nil))
func.func @build_list() -&gt; !llvm.ptr {
    // nil
    %nil = llvm.mlir.null : !llvm.ptr

    // cons(2, nil)
    %size = arith.constant 16 : i64  // head + tail
    %cons2 = llvm.call @GC_malloc(%size) : (i64) -&gt; !llvm.ptr
    %c2 = arith.constant 2 : i64
    llvm.store %c2, %cons2 : !llvm.ptr
    %tail_ptr = llvm.getelementptr %cons2[8] : !llvm.ptr
    llvm.store %nil, %tail_ptr : !llvm.ptr

    // cons(1, cons2)
    %cons1 = llvm.call @GC_malloc(%size) : (i64) -&gt; !llvm.ptr
    %c1 = arith.constant 1 : i64
    llvm.store %c1, %cons1 : !llvm.ptr
    %tail_ptr1 = llvm.getelementptr %cons1[8] : !llvm.ptr
    llvm.store %cons2, %tail_ptr1 : !llvm.ptr

    func.return %cons1 : !llvm.ptr
}
</code></pre>
<p><strong>GC 호출:</strong> cons 노드마다 1회</p>
<p><strong>메모리 그래프:</strong></p>
<pre><code>%cons1 ─→ [ head: 1 | tail: ─→ %cons2 ─→ [ head: 2 | tail: nil ] ]
</code></pre>
<p>GC는 <code>%cons1</code>이 접근 불가능해지면 전체 체인을 회수한다.</p>
<h3 id="메모리-사용-비교"><a class="header" href="#메모리-사용-비교">메모리 사용 비교</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Phase</th><th>할당 위치</th><th>GC 사용</th><th>복잡도</th></tr>
</thead>
<tbody>
<tr><td>Phase 2</td><td>SSA 레지스터만</td><td>초기화만 (호출 0회)</td><td>낮음</td></tr>
<tr><td>Phase 3</td><td>클로저 환경 → Heap</td><td>클로저 생성 시</td><td>중간</td></tr>
<tr><td>Phase 6</td><td>모든 데이터 구조 → Heap</td><td>거의 모든 연산</td><td>높음</td></tr>
</tbody>
</table>
</div>
<p><strong>핵심:</strong> Phase 2는 GC 인프라를 준비하지만, 실제 사용은 Phase 3부터다.</p>
<h2 id="공통-에러-및-해결"><a class="header" href="#공통-에러-및-해결">공통 에러 및 해결</a></h2>
<p>GC 통합 시 자주 발생하는 에러와 해결 방법:</p>
<h3 id="에러-1-gc_malloc-호출-시-segfault"><a class="header" href="#에러-1-gc_malloc-호출-시-segfault">에러 1: GC_malloc 호출 시 Segfault</a></h3>
<p><strong>증상:</strong></p>
<pre><code>Segmentation fault (core dumped)
</code></pre>
<p><strong>원인:</strong>
<code>GC_INIT()</code>을 호출하지 않고 <code>GC_malloc</code>을 사용했다.</p>
<p><strong>해결:</strong>
<code>main()</code> 시작 부분에서 <code>GC_INIT()</code> 호출:</p>
<pre><code class="language-c">int main() {
    GC_INIT();  // 필수!
    // ... 나머지 코드 ...
}
</code></pre>
<p><strong>FunLang runtime.c:</strong></p>
<pre><code class="language-c">void funlang_init() {
    GC_INIT();
}

int main(int argc, char** argv) {
    funlang_init();  // 첫 번째 호출
    // ...
}
</code></pre>
<h3 id="에러-2-linker-error---undefined-reference-to-gc_malloc"><a class="header" href="#에러-2-linker-error---undefined-reference-to-gc_malloc">에러 2: Linker Error - Undefined Reference to GC_malloc</a></h3>
<p><strong>증상:</strong></p>
<pre><code>undefined reference to `GC_malloc'
collect2: error: ld returned 1 exit status
</code></pre>
<p><strong>원인:</strong>
Boehm GC 라이브러리를 링킹하지 않았다.</p>
<p><strong>해결:</strong>
링킹 시 <code>-lgc</code> 옵션 추가:</p>
<pre><code class="language-bash">gcc output.o runtime.o -o program -lgc
</code></pre>
<p>또는 라이브러리 경로 지정:</p>
<pre><code class="language-bash">gcc output.o runtime.o -o program -L$HOME/boehm-gc/lib -lgc
</code></pre>
<h3 id="에러-3-실행-시-library-not-found"><a class="header" href="#에러-3-실행-시-library-not-found">에러 3: 실행 시 Library Not Found</a></h3>
<p><strong>증상:</strong></p>
<pre><code>error while loading shared libraries: libgc.so.1: cannot open shared object file
</code></pre>
<p><strong>원인:</strong>
실행 시 <code>libgc.so</code>를 찾을 수 없다.</p>
<p><strong>해결:</strong></p>
<p><strong>옵션 1: LD_LIBRARY_PATH 설정</strong></p>
<pre><code class="language-bash">export LD_LIBRARY_PATH=$HOME/boehm-gc/lib:$LD_LIBRARY_PATH
./program
</code></pre>
<p><strong>옵션 2: RPATH 사용 (권장)</strong></p>
<pre><code class="language-bash">gcc output.o runtime.o -o program \
    -L$HOME/boehm-gc/lib -lgc \
    -Wl,-rpath,$HOME/boehm-gc/lib
</code></pre>
<p>RPATH는 바이너리에 라이브러리 경로를 포함시킨다. <code>LD_LIBRARY_PATH</code> 설정 불필요.</p>
<h3 id="에러-4-gc가-메모리를-회수하지-않음"><a class="header" href="#에러-4-gc가-메모리를-회수하지-않음">에러 4: GC가 메모리를 회수하지 않음</a></h3>
<p><strong>증상:</strong>
프로그램 메모리 사용량이 계속 증가한다.</p>
<p><strong>원인:</strong>
Boehm GC는 보수적(conservative)이므로 일부 객체를 회수하지 못할 수 있다.</p>
<p><strong>확인 방법:</strong></p>
<pre><code class="language-c">#include &lt;gc.h&gt;

int main() {
    GC_INIT();

    for (int i = 0; i &lt; 1000000; i++) {
        void* ptr = GC_malloc(100);
        // ptr을 더 이상 사용하지 않음
    }

    // GC 통계 출력
    GC_gcollect();  // 강제 수집
    printf("Heap size: %zu\n", GC_get_heap_size());
    printf("Free bytes: %zu\n", GC_get_free_bytes());

    return 0;
}
</code></pre>
<p><strong>일반적인 경우:</strong></p>
<ul>
<li>Phase 2-3 프로그램에서는 문제없음</li>
<li>Conservative GC의 false positive는 드물다</li>
<li>메모리 누수가 심각하면 정확한(precise) GC 고려</li>
</ul>
<h3 id="에러-5-multi-threading-관련-crash"><a class="header" href="#에러-5-multi-threading-관련-crash">에러 5: Multi-threading 관련 Crash</a></h3>
<p><strong>증상:</strong>
멀티스레드 프로그램에서 random crash.</p>
<p><strong>원인:</strong>
GC를 멀티스레드 모드로 초기화하지 않았다.</p>
<p><strong>해결:</strong></p>
<p><strong>Phase 2-5:</strong> 싱글스레드만 사용하므로 문제없음.</p>
<p><strong>Phase 6+ (Future):</strong> 스레드 생성 시 GC-aware 함수 사용:</p>
<pre><code class="language-c">#include &lt;gc.h&gt;
#include &lt;pthread.h&gt;

void* thread_func(void* arg) {
    GC_pthread_create(...);  // GC-aware thread creation
    // ...
}
</code></pre>
<p>또는 빌드 시 thread-safe 옵션:</p>
<pre><code class="language-bash">./configure --enable-threads=posix
</code></pre>
<h2 id="장-요약-3"><a class="header" href="#장-요약-3">장 요약</a></h2>
<p>이 장에서 메모리 관리의 기초와 Boehm GC 통합을 완료했다.</p>
<h3 id="주요-성취"><a class="header" href="#주요-성취">주요 성취</a></h3>
<ol>
<li>
<p><strong>Stack vs Heap 이해</strong></p>
<ul>
<li>Stack: 함수 스코프, 자동 관리, LIFO</li>
<li>Heap: 유연한 생명주기, 명시적 할당/해제</li>
</ul>
</li>
<li>
<p><strong>FunLang 메모리 전략</strong></p>
<ul>
<li>Phase 2: SSA 레지스터만 사용</li>
<li>Phase 3+: 클로저 환경 → heap 할당</li>
</ul>
</li>
<li>
<p><strong>MLIR memref Dialect</strong></p>
<ul>
<li><code>memref.alloca</code>: Stack 할당</li>
<li><code>memref.alloc</code>: Heap 할당</li>
<li><code>memref.load/store</code>: 메모리 읽기/쓰기</li>
</ul>
</li>
<li>
<p><strong>GC 필요성 이해</strong></p>
<ul>
<li>수동 메모리 관리의 문제: use-after-free, leak, double-free</li>
<li>클로저가 복잡한 생명주기를 가진다</li>
<li>GC가 자동으로 회수한다</li>
</ul>
</li>
<li>
<p><strong>Boehm GC 통합</strong></p>
<ul>
<li>Conservative GC: 타입 정보 불필요</li>
<li><code>GC_INIT()</code>, <code>GC_malloc()</code> 사용</li>
<li>빌드 및 설치 완료</li>
</ul>
</li>
<li>
<p><strong>Runtime 작성</strong></p>
<ul>
<li><code>runtime.c</code>: GC 초기화, 메모리 할당 wrapper</li>
<li><code>funlang_main()</code> 호출 전에 <code>funlang_init()</code></li>
</ul>
</li>
<li>
<p><strong>빌드 파이프라인</strong></p>
<ul>
<li>FunLang → LLVM IR → Object → 링킹 (+ Boehm GC)</li>
<li>자동화 스크립트 및 F# 통합</li>
</ul>
</li>
<li>
<p><strong>에러 처리</strong></p>
<ul>
<li>GC_INIT 누락, 링킹 오류, 라이브러리 경로 문제 해결</li>
</ul>
</li>
</ol>
<h3 id="독자가-할-수-있는-것"><a class="header" href="#독자가-할-수-있는-것">독자가 할 수 있는 것</a></h3>
<ul>
<li>Stack과 heap의 차이를 설명할 수 있다 ✓</li>
<li>언제 heap 할당이 필요한지 안다 (클로저, 데이터 구조) ✓</li>
<li>Boehm GC를 빌드하고 설치할 수 있다 ✓</li>
<li><code>runtime.c</code>를 작성하여 GC를 초기화할 수 있다 ✓</li>
<li>FunLang 컴파일러 출력을 Boehm GC와 링킹할 수 있다 ✓</li>
<li>GC 관련 에러를 디버깅할 수 있다 ✓</li>
<li>왜 클로저가 GC를 필요로 하는지 이해한다 ✓</li>
</ul>
<h3 id="phase-2-완료"><a class="header" href="#phase-2-완료">Phase 2 완료!</a></h3>
<p><strong>Chapter 06:</strong> 산술 표현식 (+, -, *, /, 비교, 부정, print)
<strong>Chapter 07:</strong> Let 바인딩과 SSA 환경 전달
<strong>Chapter 08:</strong> 제어 흐름 (scf.if, block arguments, boolean)
<strong>Chapter 09:</strong> 메모리 관리 (stack/heap 전략, Boehm GC 통합)</p>
<p><strong>독자가 컴파일할 수 있는 프로그램:</strong></p>
<pre><code class="language-fsharp">// 복잡한 예시
let x = 5 in
let y = 10 in
if x &gt; 0 then
    if y &lt; 20 then
        x * y
    else
        x + y
else
    0
</code></pre>
<p><strong>생성되는 바이너리:</strong></p>
<ul>
<li>MLIR로 컴파일</li>
<li>LLVM IR로 lowering</li>
<li>Native object 생성</li>
<li>Boehm GC와 링킹</li>
<li>실행 가능한 바이너리!</li>
</ul>
<pre><code class="language-bash">$ ./program
$ echo $?
50
</code></pre>
<h3 id="phase-3-preview-함수와-클로저"><a class="header" href="#phase-3-preview-함수와-클로저">Phase 3 Preview: 함수와 클로저</a></h3>
<p>다음 Phase에서 다룰 내용:</p>
<p><strong>함수 정의:</strong></p>
<pre><code class="language-fsharp">let add = fun x -&gt; fun y -&gt; x + y
</code></pre>
<p><strong>클로저 캡처:</strong></p>
<pre><code class="language-fsharp">let makeAdder x = fun y -&gt; x + y
let add5 = makeAdder 5  // x=5를 캡처
</code></pre>
<p><strong>메모리 할당:</strong></p>
<ul>
<li>클로저 환경을 heap에 할당 (<code>GC_malloc</code>)</li>
<li>함수 포인터 + 환경 포인터 구조</li>
<li>GC가 죽은 클로저 회수</li>
</ul>
<p><strong>MLIR 연산:</strong></p>
<ul>
<li><code>llvm.call @GC_malloc</code>: Heap 할당</li>
<li><code>llvm.store</code>, <code>llvm.load</code>: 환경 읽기/쓰기</li>
<li>Function 타입과 호출 규약</li>
</ul>
<p><strong>이 장에서 준비한 GC 인프라가 바로 사용된다!</strong></p>
<hr>
<p><strong>독자는 이제 메모리 관리를 이해하고, Boehm GC를 통합했다. Phase 3로 가자!</strong></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-10-함수와-func-다이얼렉트"><a class="header" href="#chapter-10-함수와-func-다이얼렉트">Chapter 10: 함수와 func 다이얼렉트</a></h1>
<h2 id="소개-10"><a class="header" href="#소개-10">소개</a></h2>
<p>지금까지 FunLang 컴파일러는 **표현식(expression)**만 처리했다. Chapter 06부터 09까지 산술, 비교, let 바인딩, if 표현식을 컴파일하는 방법을 배웠다. 모든 것이 하나의 표현식이었고, 그 결과가 프로그램의 최종 값이었다.</p>
<pre><code class="language-fsharp">// 지금까지의 FunLang - 단일 표현식
let x = 10 in
let y = 20 in
if x &gt; y then x else y
</code></pre>
<p>이것은 단순한 스크립트에서는 작동하지만, 실제 프로그램은 <strong>재사용 가능한 코드 단위</strong>가 필요하다. 계산을 이름에 바인딩하고, 여러 곳에서 호출할 수 있어야 한다. 바로 **함수(function)**다.</p>
<p>이 장에서는 **최상위 명명된 함수(top-level named functions)**를 추가한다:</p>
<pre><code class="language-fsharp">// 함수 정의
let add x y = x + y

// 함수 호출
add 10 20   // 결과: 30
</code></pre>
<p><strong>중요한 범위 구분:</strong> 이 장은 <strong>Phase 3의 첫 단계</strong>로, 간단한 함수만 다룬다:</p>
<ul>
<li>최상위 함수 정의 (module-level functions)</li>
<li>함수 파라미터 (고정된 개수)</li>
<li>함수 호출 (call-by-value)</li>
<li>함수 반환값</li>
</ul>
<p><strong>제외되는 것 (Phase 4에서 다룸):</strong></p>
<ul>
<li><strong>클로저(Closures)</strong>: 외부 변수를 캡처하는 함수</li>
<li><strong>고차 함수(Higher-order functions)</strong>: 함수를 인자로 받거나 반환하는 함수</li>
<li><strong>익명 함수(Lambda expressions)</strong>: <code>fun x -&gt; x + 1</code></li>
</ul>
<p>왜 Phase 3과 Phase 4로 나누는가?</p>
<ul>
<li>Phase 3: 함수의 <strong>정적 측면</strong> (함수 정의, 호출, 재귀)</li>
<li>Phase 4: 함수의 <strong>동적 측면</strong> (클로저, 환경 캡처, 함수 값)</li>
</ul>
<p>Phase 3 함수는 C나 Java의 static method와 유사하다: 이름으로 호출하고, 외부 상태를 캡처하지 않는다. Phase 4에서 환경 캡처를 추가하면 진정한 함수형 언어가 된다.</p>
<p><strong>학습 목표:</strong></p>
<ul>
<li>MLIR func 다이얼렉트의 연산들 (<code>func.func</code>, <code>func.call</code>, <code>func.return</code>)</li>
<li>함수 파라미터를 block arguments로 표현하는 방법</li>
<li>함수 호출과 반환 값 처리</li>
<li>LLVM 호출 규약(calling convention)의 기초</li>
<li>재귀 함수의 작동 원리 (Chapter 11 preview)</li>
</ul>
<p>이 장을 마치면:</p>
<ul>
<li>다중 함수 정의를 포함한 FunLang 프로그램을 컴파일할 수 있다</li>
<li>함수가 MLIR IR로, 그리고 네이티브 코드로 변환되는 과정을 이해한다</li>
<li>함수 파라미터가 SSA value로 처리되는 원리를 안다</li>
<li>모듈 레벨 심볼 테이블이 어떻게 재귀를 가능하게 하는지 안다</li>
</ul>
<blockquote>
<p><strong>Preview:</strong> Chapter 11에서는 재귀와 상호 재귀를 다룬다. Chapter 10은 함수의 기초를 확립한다.</p>
</blockquote>
<h2 id="mlir-func-다이얼렉트"><a class="header" href="#mlir-func-다이얼렉트">MLIR func 다이얼렉트</a></h2>
<p>MLIR은 함수를 표현하기 위한 전용 다이얼렉트를 제공한다: <strong>func 다이얼렉트</strong>.</p>
<h3 id="func-다이얼렉트-개요"><a class="header" href="#func-다이얼렉트-개요">func 다이얼렉트 개요</a></h3>
<p><strong>func 다이얼렉트</strong>는 함수 정의와 호출을 표현하는 고수준 추상화다. C, C++, Rust 같은 언어의 함수와 동일한 개념이다.</p>
<p><strong>핵심 연산:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>연산</th><th>목적</th><th>예시</th></tr>
</thead>
<tbody>
<tr><td><code>func.func</code></td><td>함수 정의</td><td><code>func.func @add(%arg0: i32, %arg1: i32) -&gt; i32</code></td></tr>
<tr><td><code>func.call</code></td><td>함수 호출</td><td><code>%result = func.call @add(%x, %y) : (i32, i32) -&gt; i32</code></td></tr>
<tr><td><code>func.return</code></td><td>함수에서 값 반환</td><td><code>func.return %result : i32</code></td></tr>
</tbody>
</table>
</div>
<p><strong>func 다이얼렉트의 위치 (다이얼렉트 스택):</strong></p>
<pre><code>High-level:  func 다이얼렉트 (함수 추상화)
             scf 다이얼렉트 (제어 흐름)
             arith 다이얼렉트 (산술)
             ↓ (lowering passes)
Middle:      LLVM 다이얼렉트 (LLVM IR 추상화)
             ↓ (mlir-translate)
Low-level:   LLVM IR (define, call, ret)
             ↓ (llc)
Native:      Machine code (x86-64, ARM, etc.)
</code></pre>
<p>func 다이얼렉트는 <strong>고수준 추상화</strong>다. 플랫폼 독립적으로 함수를 정의하고, 나중에 LLVM 다이얼렉트로 내려가면서 호출 규약, 레지스터 할당, 스택 프레임 관리가 추가된다.</p>
<h3 id="funcfunc-연산-함수-정의"><a class="header" href="#funcfunc-연산-함수-정의">func.func 연산: 함수 정의</a></h3>
<p><code>func.func</code> 연산은 함수를 정의한다. C의 function definition, Java의 method declaration과 동일한 개념이다.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="language-mlir">func.func @function_name(%arg0: type0, %arg1: type1, ...) -&gt; return_type {
  // function body
  func.return %result : return_type
}
</code></pre>
<p><strong>구성 요소:</strong></p>
<ol>
<li><strong>Symbol name (<code>@function_name</code>)</strong>: 함수의 이름. <code>@</code> 기호는 모듈 레벨 심볼을 나타낸다.</li>
<li><strong>Parameters (<code>%arg0</code>, <code>%arg1</code>)</strong>: 함수의 파라미터. Block arguments로 표현된다.</li>
<li><strong>Function type (<code>(type0, type1) -&gt; return_type</code>)</strong>: 파라미터 타입과 반환 타입.</li>
<li><strong>Function body</strong>: 함수 본체. Region (영역) 내부에 블록을 포함한다.</li>
<li><strong>Terminator (<code>func.return</code>)</strong>: 함수 종료. 반환 값을 지정한다.</li>
</ol>
<p><strong>예시 1: 단순한 함수 (두 정수 더하기)</strong></p>
<pre><code class="language-mlir">func.func @add(%arg0: i32, %arg1: i32) -&gt; i32 {
  %result = arith.addi %arg0, %arg1 : i32
  func.return %result : i32
}
</code></pre>
<p><strong>해석:</strong></p>
<ul>
<li>함수 이름: <code>@add</code></li>
<li>파라미터: <code>%arg0</code> (i32), <code>%arg1</code> (i32)</li>
<li>반환 타입: i32</li>
<li>본체: <code>%arg0 + %arg1</code> 계산</li>
<li>반환: <code>%result</code> 값 반환</li>
</ul>
<p>이것은 C의 <code>int add(int arg0, int arg1) { return arg0 + arg1; }</code>와 동일하다.</p>
<p><strong>예시 2: 파라미터 없는 함수</strong></p>
<pre><code class="language-mlir">func.func @get_constant() -&gt; i32 {
  %c42 = arith.constant 42 : i32
  func.return %c42 : i32
}
</code></pre>
<p>파라미터가 없으면 괄호 내부가 비어있다: <code>()</code>.</p>
<p><strong>예시 3: 다중 연산을 포함하는 함수</strong></p>
<pre><code class="language-mlir">func.func @compute(%x: i32) -&gt; i32 {
  %c2 = arith.constant 2 : i32
  %doubled = arith.muli %x, %c2 : i32
  %c10 = arith.constant 10 : i32
  %result = arith.addi %doubled, %c10 : i32
  func.return %result : i32
}
</code></pre>
<p><strong>해석:</strong></p>
<ul>
<li><code>x * 2 + 10</code> 계산</li>
<li>중간 계산 (<code>%doubled</code>) 저장</li>
<li>최종 결과 반환</li>
</ul>
<h3 id="funccall-연산-함수-호출"><a class="header" href="#funccall-연산-함수-호출">func.call 연산: 함수 호출</a></h3>
<p><code>func.call</code> 연산은 함수를 호출한다. 함수 이름을 심볼 참조로 지정하고, 인자를 전달하고, 결과를 받는다.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="language-mlir">%result = func.call @function_name(%arg0, %arg1, ...) : (type0, type1, ...) -&gt; return_type
</code></pre>
<p><strong>구성 요소:</strong></p>
<ol>
<li><strong>Callee (<code>@function_name</code>)</strong>: 호출할 함수의 심볼 참조.</li>
<li><strong>Arguments (<code>%arg0</code>, <code>%arg1</code>)</strong>: 함수에 전달할 인자 (SSA values).</li>
<li><strong>Function type annotation</strong>: 함수의 시그니처 (파라미터 타입과 반환 타입).</li>
<li><strong>Result (<code>%result</code>)</strong>: 함수 호출의 결과 (SSA value).</li>
</ol>
<p><strong>예시 1: add 함수 호출</strong></p>
<pre><code class="language-mlir">func.func @main() -&gt; i32 {
  %c10 = arith.constant 10 : i32
  %c20 = arith.constant 20 : i32
  %sum = func.call @add(%c10, %c20) : (i32, i32) -&gt; i32
  func.return %sum : i32
}

func.func @add(%arg0: i32, %arg1: i32) -&gt; i32 {
  %result = arith.addi %arg0, %arg1 : i32
  func.return %result : i32
}
</code></pre>
<p><strong>실행 흐름:</strong></p>
<ol>
<li><code>@main</code> 함수 시작</li>
<li><code>%c10 = 10</code>, <code>%c20 = 20</code> 생성</li>
<li><code>@add</code> 함수 호출 (인자: 10, 20)</li>
<li><code>@add</code> 내부: <code>%arg0 = 10</code>, <code>%arg1 = 20</code></li>
<li><code>%result = 10 + 20 = 30</code> 계산</li>
<li><code>@add</code> 반환: 30</li>
<li><code>@main</code>에서 <code>%sum = 30</code> 저장</li>
<li><code>@main</code> 반환: 30</li>
</ol>
<p><strong>예시 2: 중첩 호출 (함수 결과를 다른 함수의 인자로 사용)</strong></p>
<pre><code class="language-mlir">func.func @main() -&gt; i32 {
  %c5 = arith.constant 5 : i32
  %doubled = func.call @double(%c5) : (i32) -&gt; i32
  %result = func.call @double(%doubled) : (i32) -&gt; i32
  func.return %result : i32
}

func.func @double(%x: i32) -&gt; i32 {
  %c2 = arith.constant 2 : i32
  %result = arith.muli %x, %c2 : i32
  func.return %result : i32
}
</code></pre>
<p><strong>실행:</strong></p>
<ul>
<li><code>double(5)</code> → 10</li>
<li><code>double(10)</code> → 20</li>
<li>최종 결과: 20</li>
</ul>
<h3 id="funcreturn-연산-함수-종료"><a class="header" href="#funcreturn-연산-함수-종료">func.return 연산: 함수 종료</a></h3>
<p><code>func.return</code> 연산은 함수를 종료하고 값을 반환한다. C의 <code>return</code> 문과 동일하다.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="language-mlir">func.return %value : type
</code></pre>
<p><strong>중요한 규칙:</strong></p>
<ol>
<li>
<p><strong>모든 함수는 func.return으로 끝나야 한다</strong>: <code>func.return</code>은 terminator operation이다. 함수 본체의 마지막 연산이어야 한다.</p>
</li>
<li>
<p><strong>반환 타입 일치</strong>: 반환 값의 타입은 함수 시그니처의 반환 타입과 일치해야 한다.</p>
<pre><code class="language-mlir">// 올바름
func.func @example() -&gt; i32 {
  %c42 = arith.constant 42 : i32
  func.return %c42 : i32  // i32 반환 (시그니처와 일치)
}

// 오류: 타입 불일치
func.func @wrong() -&gt; i32 {
  %c1 = arith.constant 1 : i1  // i1 타입
  func.return %c1 : i1  // 오류! i32를 반환해야 함
}
</code></pre>
</li>
<li>
<p><strong>Multiple returns (여러 반환 지점)</strong>: 함수는 여러 반환 지점을 가질 수 있다 (조건부).</p>
<pre><code class="language-mlir">func.func @abs(%x: i32) -&gt; i32 {
  %c0 = arith.constant 0 : i32
  %is_negative = arith.cmpi slt, %x, %c0 : i32
  %result = scf.if %is_negative -&gt; (i32) {
    %neg = arith.subi %c0, %x : i32
    scf.yield %neg : i32
  } else {
    scf.yield %x : i32
  }
  func.return %result : i32
}
</code></pre>
</li>
</ol>
<h3 id="함수-가시성-visibility"><a class="header" href="#함수-가시성-visibility">함수 가시성 (Visibility)</a></h3>
<p>함수는 <strong>가시성(visibility)</strong> 속성을 가질 수 있다:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>가시성</th><th>의미</th><th>사용 예</th></tr>
</thead>
<tbody>
<tr><td><code>public</code> (기본값)</td><td>모듈 외부에서 접근 가능</td><td><code>func.func @main() -&gt; i32</code></td></tr>
<tr><td><code>private</code></td><td>모듈 내부에서만 접근 가능</td><td><code>func.func private @helper() -&gt; i32</code></td></tr>
<tr><td><code>nested</code></td><td>부모 함수 내부에서만 접근 가능 (Phase 4에서 다룸)</td><td></td></tr>
</tbody>
</table>
</div>
<p><strong>예시: private 함수 (헬퍼 함수)</strong></p>
<pre><code class="language-mlir">// Public 함수 - 외부에서 호출 가능
func.func @main() -&gt; i32 {
  %result = func.call @helper() : () -&gt; i32
  func.return %result : i32
}

// Private 함수 - main에서만 호출 가능
func.func private @helper() -&gt; i32 {
  %c42 = arith.constant 42 : i32
  func.return %c42 : i32
}
</code></pre>
<p>Phase 3에서는 모든 함수가 <code>public</code>이다 (기본값). 가시성을 명시할 필요가 없다.</p>
<h3 id="함수와-심볼-테이블"><a class="header" href="#함수와-심볼-테이블">함수와 심볼 테이블</a></h3>
<p>MLIR 모듈은 **심볼 테이블(symbol table)**을 유지한다. 모든 <code>func.func</code> 연산은 모듈 레벨 심볼로 등록된다.</p>
<p><strong>핵심 특성:</strong></p>
<ol>
<li>
<p><strong>Flat namespace (평면 네임스페이스)</strong>: 모든 함수가 동일한 네임스페이스에 있다. 함수 정의 순서는 중요하지 않다.</p>
</li>
<li>
<p><strong>Forward references (전방 참조)</strong>: 함수를 정의하기 전에 호출할 수 있다.</p>
<pre><code class="language-mlir">// foo는 아직 정의되지 않았지만 호출 가능
func.func @main() -&gt; i32 {
  %result = func.call @foo() : () -&gt; i32
  func.return %result : i32
}

// 나중에 정의됨
func.func @foo() -&gt; i32 {
  %c42 = arith.constant 42 : i32
  func.return %c42 : i32
}
</code></pre>
</li>
<li>
<p><strong>재귀 가능</strong>: 함수가 자기 자신을 호출할 수 있다 (심볼이 모듈에 등록되므로).</p>
<pre><code class="language-mlir">func.func @factorial(%n: i32) -&gt; i32 {
  %c1 = arith.constant 1 : i32
  %is_one = arith.cmpi sle, %n, %c1 : i32
  %result = scf.if %is_one -&gt; (i32) {
    scf.yield %c1 : i32
  } else {
    %n_minus_1 = arith.subi %n, %c1 : i32
    %rec = func.call @factorial(%n_minus_1) : (i32) -&gt; i32  // 재귀 호출
    %product = arith.muli %n, %rec : i32
    scf.yield %product : i32
  }
  func.return %result : i32
}
</code></pre>
</li>
<li>
<p><strong>상호 재귀 가능</strong>: 두 함수가 서로를 호출할 수 있다.</p>
<pre><code class="language-mlir">func.func @is_even(%n: i32) -&gt; i1 {
  // ... calls @is_odd ...
}

func.func @is_odd(%n: i32) -&gt; i1 {
  // ... calls @is_even ...
}
</code></pre>
</li>
</ol>
<p>심볼 테이블 덕분에 함수 정의 순서나 전방 선언을 걱정할 필요가 없다. 모든 함수가 모듈 로드 시 등록된다.</p>
<h3 id="phase-2와의-비교-함수-vs-표현식"><a class="header" href="#phase-2와의-비교-함수-vs-표현식">Phase 2와의 비교: 함수 vs 표현식</a></h3>
<p>Phase 2에서는 모든 것이 단일 표현식이었다:</p>
<pre><code class="language-mlir">// Phase 2 스타일 - 단일 main 함수
func.func @main() -&gt; i32 {
  %c10 = arith.constant 10 : i32
  %c20 = arith.constant 20 : i32
  %sum = arith.addi %c10, %c20 : i32
  func.return %sum : i32
}
</code></pre>
<p>Phase 3에서는 재사용 가능한 함수를 정의한다:</p>
<pre><code class="language-mlir">// Phase 3 스타일 - 여러 함수
func.func @add(%a: i32, %b: i32) -&gt; i32 {
  %result = arith.addi %a, %b : i32
  func.return %result : i32
}

func.func @main() -&gt; i32 {
  %c10 = arith.constant 10 : i32
  %c20 = arith.constant 20 : i32
  %sum = func.call @add(%c10, %c20) : (i32, i32) -&gt; i32
  func.return %sum : i32
}
</code></pre>
<p><strong>차이점:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>측면</th><th>Phase 2 (표현식)</th><th>Phase 3 (함수)</th></tr>
</thead>
<tbody>
<tr><td>코드 조직</td><td>단일 main 함수</td><td>여러 함수 정의</td></tr>
<tr><td>재사용</td><td>불가능 (중복 코드)</td><td>가능 (함수 호출)</td></tr>
<tr><td>추상화</td><td>없음</td><td>함수 이름으로 추상화</td></tr>
<tr><td>모듈성</td><td>낮음</td><td>높음 (함수 단위)</td></tr>
<tr><td>컴파일 결과</td><td>단일 함수</td><td>여러 함수 심볼</td></tr>
</tbody>
</table>
</div>
<p>함수는 코드를 <strong>모듈화</strong>하고 <strong>재사용 가능</strong>하게 만든다. Phase 2의 표현식 컴파일러를 함수 본체 내부에서 재사용한다!</p>
<h2 id="ast-확장-fundef와-app"><a class="header" href="#ast-확장-fundef와-app">AST 확장: FunDef와 App</a></h2>
<p>FunLang에 함수를 추가하려면 AST를 확장해야 한다. 두 가지 새로운 노드가 필요하다:</p>
<ol>
<li><strong>FunDef</strong>: 함수 정의 (<code>let f x y = ...</code>)</li>
<li><strong>App</strong>: 함수 적용 (호출) (<code>f 10 20</code>)</li>
</ol>
<h3 id="fundef-함수-정의"><a class="header" href="#fundef-함수-정의">FunDef: 함수 정의</a></h3>
<p><strong>FunDef</strong>는 최상위 함수 정의를 표현한다.</p>
<p><strong>F# AST 정의:</strong></p>
<pre><code class="language-fsharp">type Expr =
    | Int of int
    | Bool of bool
    | Var of string
    | BinOp of Expr * Operator * Expr
    | UnaryOp of UnaryOperator * Expr
    | Compare of Expr * CompareOp * Expr
    | Let of string * Expr * Expr
    | If of Expr * Expr * Expr
    | App of string * Expr list              // NEW: 함수 호출
    // ... Lambda는 Phase 4에서 추가 ...

type FunDef = {                               // NEW: 함수 정의
    name: string                              // 함수 이름
    parameters: string list                   // 파라미터 이름 리스트
    body: Expr                                // 함수 본체 (표현식)
}

type Program = {                              // NEW: 프로그램 구조
    functions: FunDef list                    // 함수 정의 리스트
    main: Expr                                // Main 표현식
}
</code></pre>
<p><strong>예시: <code>let add x y = x + y</code></strong></p>
<pre><code class="language-fsharp">let addFunction = {
    name = "add"
    parameters = ["x"; "y"]
    body = BinOp(Var "x", Add, Var "y")
}
</code></pre>
<p><strong>구성 요소:</strong></p>
<ul>
<li><code>name</code>: 함수 이름 (<code>"add"</code>)</li>
<li><code>parameters</code>: 파라미터 이름 리스트 (<code>["x"; "y"]</code>)</li>
<li><code>body</code>: 함수 본체 (<code>x + y</code> 표현식)</li>
</ul>
<p><strong>예시: <code>let square x = x * x</code></strong></p>
<pre><code class="language-fsharp">let squareFunction = {
    name = "square"
    parameters = ["x"]
    body = BinOp(Var "x", Mul, Var "x")
}
</code></pre>
<p><strong>예시: 파라미터가 없는 함수 <code>let getConstant = 42</code></strong></p>
<pre><code class="language-fsharp">let constantFunction = {
    name = "getConstant"
    parameters = []                           // 빈 리스트
    body = Int 42
}
</code></pre>
<h3 id="app-함수-적용-호출"><a class="header" href="#app-함수-적용-호출">App: 함수 적용 (호출)</a></h3>
<p><strong>App</strong>는 함수 호출을 표현한다. 함수 이름과 인자 리스트를 포함한다.</p>
<p><strong>F# AST 정의:</strong></p>
<pre><code class="language-fsharp">type Expr =
    | ...
    | App of string * Expr list               // 함수 이름, 인자 리스트
</code></pre>
<p><strong>예시: <code>add 10 20</code></strong></p>
<pre><code class="language-fsharp">let callExpr = App("add", [Int 10; Int 20])
</code></pre>
<p><strong>구성 요소:</strong></p>
<ul>
<li>함수 이름: <code>"add"</code></li>
<li>인자 리스트: <code>[Int 10; Int 20]</code></li>
</ul>
<p><strong>예시: <code>square 5</code></strong></p>
<pre><code class="language-fsharp">let squareCall = App("square", [Int 5])
</code></pre>
<p><strong>예시: 중첩 호출 <code>add (square 3) (square 4)</code></strong></p>
<pre><code class="language-fsharp">let nestedCall =
    App("add", [
        App("square", [Int 3]);
        App("square", [Int 4])
    ])
</code></pre>
<p><strong>해석:</strong></p>
<ul>
<li><code>square 3</code> → 9</li>
<li><code>square 4</code> → 16</li>
<li><code>add 9 16</code> → 25</li>
</ul>
<h3 id="program-프로그램-구조"><a class="header" href="#program-프로그램-구조">Program: 프로그램 구조</a></h3>
<p>지금까지는 FunLang 프로그램이 단일 표현식이었다. 이제 <strong>여러 함수 정의 + main 표현식</strong>으로 구성된다.</p>
<p><strong>F# 정의:</strong></p>
<pre><code class="language-fsharp">type Program = {
    functions: FunDef list                    // 함수 정의 리스트
    main: Expr                                // Main 표현식
}
</code></pre>
<p><strong>예시 프로그램:</strong></p>
<pre><code class="language-fsharp">// FunLang 소스:
// let add x y = x + y
// let square x = x * x
// square (add 3 4)

let program = {
    functions = [
        { name = "add"
          parameters = ["x"; "y"]
          body = BinOp(Var "x", Add, Var "y") };
        { name = "square"
          parameters = ["x"]
          body = BinOp(Var "x", Mul, Var "x") }
    ]
    main = App("square", [App("add", [Int 3; Int 4])])
}
</code></pre>
<p><strong>실행:</strong></p>
<ol>
<li><code>add 3 4</code> → 7</li>
<li><code>square 7</code> → 49</li>
<li>최종 결과: 49</li>
</ol>
<p><strong>프로그램 구조 시각화:</strong></p>
<pre><code>Program
├── functions
│   ├── FunDef("add", ["x", "y"], x + y)
│   └── FunDef("square", ["x"], x * x)
└── main
    └── App("square", [App("add", [3, 4])])
</code></pre>
<h3 id="lambda는-어디에"><a class="header" href="#lambda는-어디에">Lambda는 어디에?</a></h3>
<p>함수형 언어의 핵심 기능인 **lambda (익명 함수)**는 어디에 있는가?</p>
<p><strong>Phase 3 범위: 최상위 명명된 함수만</strong></p>
<ul>
<li><code>let f x = ...</code> (함수 정의)</li>
<li><code>f 10</code> (함수 호출)</li>
</ul>
<p><strong>Phase 4에서 추가: Lambda와 클로저</strong></p>
<ul>
<li><code>fun x -&gt; x + 1</code> (익명 함수)</li>
<li><code>let makeAdder n = fun x -&gt; x + n</code> (클로저, 외부 변수 캡처)</li>
<li>함수를 값으로 전달 (고차 함수)</li>
</ul>
<p>Phase 3 함수는 <strong>정적</strong>이다:</p>
<ul>
<li>컴파일 타임에 모든 함수가 알려진다</li>
<li>함수 이름은 고정된 심볼이다</li>
<li>외부 환경을 캡처하지 않는다</li>
</ul>
<p>Phase 4 클로저는 <strong>동적</strong>이다:</p>
<ul>
<li>런타임에 클로저가 생성된다</li>
<li>클로저는 값처럼 전달된다</li>
<li>외부 환경을 캡처하고 유지한다</li>
</ul>
<p>Phase 3은 함수의 <strong>기초</strong>를 다진다. Phase 4는 그 위에 클로저를 추가한다.</p>
<h2 id="pinvoke-바인딩-func-다이얼렉트"><a class="header" href="#pinvoke-바인딩-func-다이얼렉트">P/Invoke 바인딩: func 다이얼렉트</a></h2>
<p>MLIR의 func 다이얼렉트 연산을 사용하려면 C API 바인딩이 필요하다. 이미 Phase 1에서 기본 바인딩을 작성했으므로, func 관련 함수를 추가한다.</p>
<h3 id="function-type-api"><a class="header" href="#function-type-api">Function Type API</a></h3>
<p>MLIR에서 함수는 <strong>function type</strong>을 가진다. Function type은 파라미터 타입과 반환 타입을 표현한다.</p>
<p><strong>Function type 생성:</strong></p>
<pre><code class="language-c">// C API
MlirType mlirFunctionTypeGet(
    MlirContext ctx,
    intptr_t numInputs,
    MlirType const *inputs,
    intptr_t numResults,
    MlirType const *results
);
</code></pre>
<p><strong>파라미터:</strong></p>
<ul>
<li><code>ctx</code>: MLIR context</li>
<li><code>numInputs</code>: 파라미터 개수</li>
<li><code>inputs</code>: 파라미터 타입 배열</li>
<li><code>numResults</code>: 반환 값 개수 (보통 0 또는 1)</li>
<li><code>results</code>: 반환 타입 배열</li>
</ul>
<p><strong>예시: <code>(i32, i32) -&gt; i32</code> 타입</strong></p>
<pre><code class="language-c">MlirType i32Type = mlirIntegerTypeGet(ctx, 32);
MlirType paramTypes[] = { i32Type, i32Type };  // 두 개의 i32 파라미터
MlirType resultTypes[] = { i32Type };          // 하나의 i32 반환값

MlirType funcType = mlirFunctionTypeGet(
    ctx,
    2, paramTypes,   // 2개 파라미터
    1, resultTypes   // 1개 반환값
);
</code></pre>
<p><strong>Function type 쿼리:</strong></p>
<pre><code class="language-c">// 파라미터 개수 가져오기
intptr_t mlirFunctionTypeGetNumInputs(MlirType type);

// 반환 값 개수 가져오기
intptr_t mlirFunctionTypeGetNumResults(MlirType type);

// N번째 파라미터 타입 가져오기
MlirType mlirFunctionTypeGetInput(MlirType type, intptr_t pos);

// N번째 반환 타입 가져오기
MlirType mlirFunctionTypeGetResult(MlirType type, intptr_t pos);
</code></pre>
<p><strong>F# P/Invoke 바인딩:</strong></p>
<pre><code class="language-fsharp">// MlirBindings.fs에 추가

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirType mlirFunctionTypeGet(
    MlirContext ctx,
    nativeint numInputs,
    [&lt;MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1s)&gt;] MlirType[] inputs,
    nativeint numResults,
    [&lt;MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3s)&gt;] MlirType[] results
)

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern nativeint mlirFunctionTypeGetNumInputs(MlirType funcType)

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern nativeint mlirFunctionTypeGetNumResults(MlirType funcType)

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirType mlirFunctionTypeGetInput(MlirType funcType, nativeint pos)

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirType mlirFunctionTypeGetResult(MlirType funcType, nativeint pos)
</code></pre>
<p><strong>사용 예시:</strong></p>
<pre><code class="language-fsharp">// (i32, i32) -&gt; i32 타입 생성
let i32Type = mlirIntegerTypeGet(ctx, 32u)
let paramTypes = [| i32Type; i32Type |]
let resultTypes = [| i32Type |]

let funcType = mlirFunctionTypeGet(
    ctx,
    2n, paramTypes,
    1n, resultTypes
)

// 타입 쿼리
let numParams = mlirFunctionTypeGetNumInputs(funcType)  // 2
let param0Type = mlirFunctionTypeGetInput(funcType, 0n)  // i32
</code></pre>
<h3 id="symbol-reference-attribute"><a class="header" href="#symbol-reference-attribute">Symbol Reference Attribute</a></h3>
<p>함수 호출 시 <strong>symbol reference</strong>가 필요하다. 심볼 참조는 <code>@function_name</code> 형태로, attribute로 표현된다.</p>
<p><strong>C API:</strong></p>
<pre><code class="language-c">// Flat symbol reference (단일 심볼)
MlirAttribute mlirFlatSymbolRefAttrGet(
    MlirContext ctx,
    MlirStringRef symbol
);
</code></pre>
<p><strong>F# P/Invoke 바인딩:</strong></p>
<pre><code class="language-fsharp">[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirAttribute mlirFlatSymbolRefAttrGet(
    MlirContext ctx,
    MlirStringRef symbol
)
</code></pre>
<p><strong>사용 예시:</strong></p>
<pre><code class="language-fsharp">// @add 심볼 참조 생성
let addSymbol = MlirStringRef.FromString("add")
let addSymbolAttr = mlirFlatSymbolRefAttrGet(ctx, addSymbol)
</code></pre>
<h3 id="generic-operation-creation-for-funcfunc"><a class="header" href="#generic-operation-creation-for-funcfunc">Generic Operation Creation for func.func</a></h3>
<p>MLIR C API는 <code>func.func</code> 전용 생성 함수를 제공하지 않는다. 대신 <strong>generic operation creation</strong>을 사용한다.</p>
<p><strong>func.func 연산 생성 단계:</strong></p>
<ol>
<li>
<p><strong>Operation state 초기화</strong></p>
<pre><code class="language-c">MlirOperationState state = mlirOperationStateGet(
    mlirStringRefCreateFromCString("func.func"),
    location
);
</code></pre>
</li>
<li>
<p><strong>Attributes 추가 (sym_name, function_type)</strong></p>
<pre><code class="language-c">// sym_name: 함수 이름
MlirAttribute nameAttr = mlirStringAttrGet(ctx, nameStringRef);
MlirNamedAttribute symNameAttr = {
    mlirIdentifierGet(ctx, mlirStringRefCreateFromCString("sym_name")),
    nameAttr
};

// function_type: 함수 타입
MlirAttribute typeAttr = mlirTypeAttrGet(functionType);
MlirNamedAttribute funcTypeAttr = {
    mlirIdentifierGet(ctx, mlirStringRefCreateFromCString("function_type")),
    typeAttr
};

MlirNamedAttribute attrs[] = { symNameAttr, funcTypeAttr };
mlirOperationStateAddAttributes(&amp;state, 2, attrs);
</code></pre>
</li>
<li>
<p><strong>Region 추가 (함수 본체)</strong></p>
<pre><code class="language-c">MlirRegion bodyRegion = mlirRegionCreate();
MlirBlock entryBlock = mlirBlockCreate(numParams, paramTypes, NULL);
mlirRegionAppendOwnedBlock(bodyRegion, entryBlock);
mlirOperationStateAddOwnedRegions(&amp;state, 1, &amp;bodyRegion);
</code></pre>
</li>
<li>
<p><strong>Operation 생성</strong></p>
<pre><code class="language-c">MlirOperation funcOp = mlirOperationCreate(&amp;state);
</code></pre>
</li>
</ol>
<p><strong>F# 헬퍼 함수 (OpBuilder에 추가 예정):</strong></p>
<pre><code class="language-fsharp">// OpBuilder.fs에 추가할 메서드 (다음 섹션에서 구현)
member this.CreateFuncOp(name: string, paramTypes: MlirType[], resultType: MlirType) =
    // ... implementation ...
</code></pre>
<h3 id="generic-operation-creation-for-funccall"><a class="header" href="#generic-operation-creation-for-funccall">Generic Operation Creation for func.call</a></h3>
<p><strong>func.call 연산 생성 단계:</strong></p>
<ol>
<li>
<p><strong>Operation state 초기화</strong></p>
<pre><code class="language-c">MlirOperationState state = mlirOperationStateGet(
    mlirStringRefCreateFromCString("func.call"),
    location
);
</code></pre>
</li>
<li>
<p><strong>Callee attribute 추가</strong></p>
<pre><code class="language-c">MlirAttribute calleeAttr = mlirFlatSymbolRefAttrGet(ctx, calleeSymbol);
MlirNamedAttribute attr = {
    mlirIdentifierGet(ctx, mlirStringRefCreateFromCString("callee")),
    calleeAttr
};
mlirOperationStateAddAttributes(&amp;state, 1, &amp;attr);
</code></pre>
</li>
<li>
<p><strong>Operands 추가 (인자)</strong></p>
<pre><code class="language-c">mlirOperationStateAddOperands(&amp;state, numArgs, argValues);
</code></pre>
</li>
<li>
<p><strong>Result types 추가</strong></p>
<pre><code class="language-c">mlirOperationStateAddResults(&amp;state, 1, &amp;resultType);
</code></pre>
</li>
<li>
<p><strong>Operation 생성</strong></p>
<pre><code class="language-c">MlirOperation callOp = mlirOperationCreate(&amp;state);
</code></pre>
</li>
</ol>
<p><strong>F# 헬퍼 함수:</strong></p>
<pre><code class="language-fsharp">member this.CreateFuncCall(calleeName: string, args: MlirValue[], resultType: MlirType) =
    // ... implementation ...
</code></pre>
<h3 id="complete-mlirbindingsfs-additions"><a class="header" href="#complete-mlirbindingsfs-additions">Complete MlirBindings.fs Additions</a></h3>
<p><strong>전체 추가 코드 (MlirBindings.fs):</strong></p>
<pre><code class="language-fsharp">// ============================================================
// Function Type API
// ============================================================

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirType mlirFunctionTypeGet(
    MlirContext ctx,
    nativeint numInputs,
    [&lt;MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1s)&gt;] MlirType[] inputs,
    nativeint numResults,
    [&lt;MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3s)&gt;] MlirType[] results
)

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern nativeint mlirFunctionTypeGetNumInputs(MlirType funcType)

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern nativeint mlirFunctionTypeGetNumResults(MlirType funcType)

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirType mlirFunctionTypeGetInput(MlirType funcType, nativeint pos)

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirType mlirFunctionTypeGetResult(MlirType funcType, nativeint pos)

// ============================================================
// Symbol Reference Attribute
// ============================================================

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirAttribute mlirFlatSymbolRefAttrGet(
    MlirContext ctx,
    MlirStringRef symbol
)

// ============================================================
// Block Arguments (for function parameters)
// ============================================================

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirValue mlirBlockGetArgument(
    MlirBlock block,
    nativeint pos
)

[&lt;DllImport("MLIR-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern nativeint mlirBlockGetNumArguments(MlirBlock block)
</code></pre>
<p><strong>설명:</strong></p>
<ul>
<li><code>mlirFunctionTypeGet</code>: 함수 타입 생성</li>
<li><code>mlirFunctionTypeGetInput/GetResult</code>: 함수 타입 쿼리</li>
<li><code>mlirFlatSymbolRefAttrGet</code>: 심볼 참조 attribute 생성</li>
<li><code>mlirBlockGetArgument</code>: 블록의 N번째 argument 가져오기 (함수 파라미터)</li>
<li><code>mlirBlockGetNumArguments</code>: 블록의 argument 개수 (파라미터 개수)</li>
</ul>
<p>이 바인딩으로 func 다이얼렉트의 모든 연산을 생성할 수 있다!</p>
<h2 id="opbuilder-확장-func-연산-헬퍼"><a class="header" href="#opbuilder-확장-func-연산-헬퍼">OpBuilder 확장: func 연산 헬퍼</a></h2>
<p>P/Invoke 바인딩은 저수준 API다. 사용하기 편리한 F# 헬퍼 메서드를 OpBuilder 클래스에 추가한다.</p>
<h3 id="createfuncop-함수-생성"><a class="header" href="#createfuncop-함수-생성">CreateFuncOp: 함수 생성</a></h3>
<p><strong>목적:</strong> func.func 연산을 생성한다. 함수 이름, 파라미터 타입, 반환 타입을 받아 함수 operation을 반환한다.</p>
<p><strong>시그니처:</strong></p>
<pre><code class="language-fsharp">member this.CreateFuncOp(
    name: string,
    paramTypes: MlirType[],
    resultType: MlirType
) : MlirOperation
</code></pre>
<p><strong>구현:</strong></p>
<pre><code class="language-fsharp">member this.CreateFuncOp(name: string, paramTypes: MlirType[], resultType: MlirType) =
    let loc = this.UnknownLoc()

    // 1. Function type 생성
    let resultTypes = [| resultType |]
    let funcType = mlirFunctionTypeGet(
        this.Context,
        nativeint paramTypes.Length, paramTypes,
        1n, resultTypes
    )

    // 2. Operation state 초기화
    let opName = MlirStringRef.FromString("func.func")
    let mutable state = mlirOperationStateGet(opName, loc)

    // 3. sym_name attribute 추가
    let nameStr = MlirStringRef.FromString(name)
    let nameAttr = mlirStringAttrGet(this.Context, nameStr)
    let symNameId = mlirIdentifierGet(this.Context, MlirStringRef.FromString("sym_name"))
    let mutable symNameAttr = MlirNamedAttribute(symNameId, nameAttr)

    // 4. function_type attribute 추가
    let typeAttr = mlirTypeAttrGet(funcType)
    let funcTypeId = mlirIdentifierGet(this.Context, MlirStringRef.FromString("function_type"))
    let mutable funcTypeAttr = MlirNamedAttribute(funcTypeId, typeAttr)

    // 5. Attributes 추가
    let attrs = [| symNameAttr; funcTypeAttr |]
    mlirOperationStateAddAttributes(&amp;state, 2n, attrs)

    // 6. Body region 생성 (entry block with parameters)
    let bodyRegion = mlirRegionCreate()
    let entryBlock = mlirBlockCreate(
        nativeint paramTypes.Length,
        paramTypes,
        Array.zeroCreate paramTypes.Length  // Location array (null array)
    )
    mlirRegionAppendOwnedBlock(bodyRegion, entryBlock)

    let regions = [| bodyRegion |]
    mlirOperationStateAddOwnedRegions(&amp;state, 1n, regions)

    // 7. Operation 생성
    let funcOp = mlirOperationCreate(&amp;state)
    funcOp
</code></pre>
<p><strong>사용 예시:</strong></p>
<pre><code class="language-fsharp">let builder = new OpBuilder(ctx, module)

// func.func @add(%arg0: i32, %arg1: i32) -&gt; i32
let funcOp = builder.CreateFuncOp(
    "add",
    [| i32Type; i32Type |],
    i32Type
)

// 이제 funcOp 내부에 body를 추가해야 한다
</code></pre>
<p><strong>핵심 포인트:</strong></p>
<ul>
<li><code>paramTypes</code>는 블록 arguments의 타입이 된다</li>
<li>Entry block이 자동으로 생성되고 region에 추가된다</li>
<li>반환된 <code>MlirOperation</code>은 아직 비어있는 함수 (body를 채워야 함)</li>
</ul>
<h3 id="getfunctionentryblock-entry-block-가져오기"><a class="header" href="#getfunctionentryblock-entry-block-가져오기">GetFunctionEntryBlock: entry block 가져오기</a></h3>
<p>함수 본체를 작성하려면 entry block을 가져와야 한다.</p>
<p><strong>시그니처:</strong></p>
<pre><code class="language-fsharp">member this.GetFunctionEntryBlock(funcOp: MlirOperation) : MlirBlock
</code></pre>
<p><strong>구현:</strong></p>
<pre><code class="language-fsharp">member this.GetFunctionEntryBlock(funcOp: MlirOperation) =
    // func.func operation은 region을 하나 가진다
    let bodyRegion = mlirOperationGetRegion(funcOp, 0n)
    // Region의 첫 번째 block이 entry block
    mlirRegionGetFirstBlock(bodyRegion)
</code></pre>
<p><strong>사용 예시:</strong></p>
<pre><code class="language-fsharp">let funcOp = builder.CreateFuncOp("add", [| i32Type; i32Type |], i32Type)
let entryBlock = builder.GetFunctionEntryBlock(funcOp)

// 이제 entryBlock에 연산을 추가할 수 있다
builder.SetInsertionPointToEnd(entryBlock)
</code></pre>
<h3 id="getfunctionblockarg-파라미터-가져오기"><a class="header" href="#getfunctionblockarg-파라미터-가져오기">GetFunctionBlockArg: 파라미터 가져오기</a></h3>
<p>함수 파라미터는 entry block의 <strong>block arguments</strong>로 표현된다. 파라미터를 사용하려면 block argument를 가져와야 한다.</p>
<p><strong>시그니처:</strong></p>
<pre><code class="language-fsharp">member this.GetFunctionBlockArg(block: MlirBlock, index: int) : MlirValue
</code></pre>
<p><strong>구현:</strong></p>
<pre><code class="language-fsharp">member this.GetFunctionBlockArg(block: MlirBlock, index: int) =
    mlirBlockGetArgument(block, nativeint index)
</code></pre>
<p><strong>사용 예시:</strong></p>
<pre><code class="language-fsharp">let funcOp = builder.CreateFuncOp("add", [| i32Type; i32Type |], i32Type)
let entryBlock = builder.GetFunctionEntryBlock(funcOp)

// 파라미터 가져오기
let arg0 = builder.GetFunctionBlockArg(entryBlock, 0)  // %arg0
let arg1 = builder.GetFunctionBlockArg(entryBlock, 1)  // %arg1

// 파라미터를 사용하여 연산 수행
builder.SetInsertionPointToEnd(entryBlock)
let sum = builder.CreateArithBinaryOp(ArithOp.Addi, arg0, arg1, i32Type)
</code></pre>
<h3 id="createfunccall-함수-호출-생성"><a class="header" href="#createfunccall-함수-호출-생성">CreateFuncCall: 함수 호출 생성</a></h3>
<p><strong>시그니처:</strong></p>
<pre><code class="language-fsharp">member this.CreateFuncCall(
    calleeName: string,
    args: MlirValue[],
    resultType: MlirType
) : MlirValue
</code></pre>
<p><strong>구현:</strong></p>
<pre><code class="language-fsharp">member this.CreateFuncCall(calleeName: string, args: MlirValue[], resultType: MlirType) =
    let loc = this.UnknownLoc()

    // 1. Operation state 초기화
    let opName = MlirStringRef.FromString("func.call")
    let mutable state = mlirOperationStateGet(opName, loc)

    // 2. callee attribute 추가
    let calleeSymbol = MlirStringRef.FromString(calleeName)
    let calleeAttr = mlirFlatSymbolRefAttrGet(this.Context, calleeSymbol)
    let calleeId = mlirIdentifierGet(this.Context, MlirStringRef.FromString("callee"))
    let mutable calleeNamedAttr = MlirNamedAttribute(calleeId, calleeAttr)

    mlirOperationStateAddAttributes(&amp;state, 1n, [| calleeNamedAttr |])

    // 3. Operands 추가
    mlirOperationStateAddOperands(&amp;state, nativeint args.Length, args)

    // 4. Result type 추가
    mlirOperationStateAddResults(&amp;state, 1n, [| resultType |])

    // 5. Operation 생성
    let callOp = mlirOperationCreate(&amp;state)

    // 6. 현재 insertion point에 추가
    mlirBlockAppendOwnedOperation(this.currentBlock, callOp)

    // 7. Result value 반환
    mlirOperationGetResult(callOp, 0n)
</code></pre>
<p><strong>사용 예시:</strong></p>
<pre><code class="language-fsharp">builder.SetInsertionPointToEnd(mainBlock)

// func.call @add(%c10, %c20) : (i32, i32) -&gt; i32
let c10 = builder.CreateConstant(10, i32Type)
let c20 = builder.CreateConstant(20, i32Type)
let result = builder.CreateFuncCall("add", [| c10; c20 |], i32Type)
</code></pre>
<h3 id="createfuncreturn-함수-반환"><a class="header" href="#createfuncreturn-함수-반환">CreateFuncReturn: 함수 반환</a></h3>
<p><strong>시그니처:</strong></p>
<pre><code class="language-fsharp">member this.CreateFuncReturn(value: MlirValue) : unit
</code></pre>
<p><strong>구현:</strong></p>
<pre><code class="language-fsharp">member this.CreateFuncReturn(value: MlirValue) =
    let loc = this.UnknownLoc()

    // 1. Operation state 초기화
    let opName = MlirStringRef.FromString("func.return")
    let mutable state = mlirOperationStateGet(opName, loc)

    // 2. Operand 추가 (반환 값)
    mlirOperationStateAddOperands(&amp;state, 1n, [| value |])

    // 3. Operation 생성
    let returnOp = mlirOperationCreate(&amp;state)

    // 4. 현재 insertion point에 추가
    mlirBlockAppendOwnedOperation(this.currentBlock, returnOp)
</code></pre>
<p><strong>사용 예시:</strong></p>
<pre><code class="language-fsharp">builder.SetInsertionPointToEnd(entryBlock)
let sum = builder.CreateArithBinaryOp(ArithOp.Addi, arg0, arg1, i32Type)
builder.CreateFuncReturn(sum)
</code></pre>
<h3 id="완전한-함수-생성-예시"><a class="header" href="#완전한-함수-생성-예시">완전한 함수 생성 예시</a></h3>
<p><strong>전체 흐름 (add 함수 생성):</strong></p>
<pre><code class="language-fsharp">let builder = new OpBuilder(ctx, module)
let i32Type = builder.I32Type()

// 1. 함수 operation 생성
let funcOp = builder.CreateFuncOp("add", [| i32Type; i32Type |], i32Type)

// 2. Entry block 가져오기
let entryBlock = builder.GetFunctionEntryBlock(funcOp)

// 3. 파라미터 가져오기
let arg0 = builder.GetFunctionBlockArg(entryBlock, 0)
let arg1 = builder.GetFunctionBlockArg(entryBlock, 1)

// 4. Insertion point 설정
builder.SetInsertionPointToEnd(entryBlock)

// 5. 함수 본체 작성
let sum = builder.CreateArithBinaryOp(ArithOp.Addi, arg0, arg1, i32Type)

// 6. 반환
builder.CreateFuncReturn(sum)

// 7. 모듈에 함수 추가
builder.AddOperationToModule(funcOp)
</code></pre>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">func.func @add(%arg0: i32, %arg1: i32) -&gt; i32 {
  %0 = arith.addi %arg0, %arg1 : i32
  func.return %0 : i32
}
</code></pre>
<p>이 헬퍼 메서드들로 func 다이얼렉트 연산을 쉽게 생성할 수 있다!</p>
<h2 id="함수-파라미터와-block-arguments"><a class="header" href="#함수-파라미터와-block-arguments">함수 파라미터와 Block Arguments</a></h2>
<p>함수 파라미터는 MLIR에서 <strong>block arguments</strong>로 표현된다. 이것은 MLIR의 핵심 설계 원칙이며, Chapter 08에서 배운 block arguments 개념의 확장이다.</p>
<h3 id="파라미터는-변수가-아니다"><a class="header" href="#파라미터는-변수가-아니다">파라미터는 변수가 아니다</a></h3>
<p>전통적인 프로그래밍 언어에서 함수 파라미터는 “변수“처럼 보인다:</p>
<pre><code class="language-c">// C 함수
int add(int x, int y) {
    return x + y;
}
</code></pre>
<p>하지만 MLIR에서 파라미터는 <strong>block arguments</strong>다:</p>
<pre><code class="language-mlir">func.func @add(%arg0: i32, %arg1: i32) -&gt; i32 {
  %result = arith.addi %arg0, %arg1 : i32
  func.return %result : i32
}
</code></pre>
<p><strong>차이점:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>관점</th><th>변수 (C/Java)</th><th>Block Arguments (MLIR)</th></tr>
</thead>
<tbody>
<tr><td>저장 위치</td><td>스택 메모리 (또는 레지스터)</td><td>SSA value (레지스터 직접 사용)</td></tr>
<tr><td>초기화</td><td>함수 진입 시 스택에 복사</td><td>블록 진입 시 이미 존재</td></tr>
<tr><td>뮤테이션</td><td>가능 (재할당 가능)</td><td>불가능 (SSA, 한 번만 정의)</td></tr>
<tr><td>주소</td><td>주소 가져오기 가능 (<code>&amp;x</code>)</td><td>주소 없음 (값 자체)</td></tr>
</tbody>
</table>
</div>
<p>MLIR에서 파라미터는 <strong>이미 존재하는 SSA value</strong>다. 함수가 호출되면, 인자 값들이 entry block의 arguments로 전달된다.</p>
<h3 id="block-arguments-복습-chapter-08-연결"><a class="header" href="#block-arguments-복습-chapter-08-연결">Block Arguments 복습 (Chapter 08 연결)</a></h3>
<p>Chapter 08에서 <code>scf.if</code>의 block arguments를 배웠다:</p>
<pre><code class="language-mlir">%result = scf.if %condition -&gt; (i32) {
  %c10 = arith.constant 10 : i32
  scf.yield %c10 : i32
} else {
  %c20 = arith.constant 20 : i32
  scf.yield %c20 : i32
}
// %result는 block argument (scf.if의 결과)
</code></pre>
<p>함수 파라미터도 동일한 메커니즘이다:</p>
<pre><code class="language-mlir">func.func @example(%arg0: i32) -&gt; i32 {
  // %arg0는 entry block의 argument
  func.return %arg0 : i32
}
</code></pre>
<p><strong>공통점:</strong></p>
<ul>
<li>둘 다 <strong>block arguments</strong>다</li>
<li>둘 다 SSA values다</li>
<li>둘 다 블록 진입 시 이미 정의되어 있다</li>
</ul>
<p><strong>차이점:</strong></p>
<ul>
<li><code>scf.if</code> block arguments: 분기의 결과 값 (yield로 전달)</li>
<li>함수 block arguments: 함수의 입력 값 (호출자가 전달)</li>
</ul>
<h3 id="entry-block과-파라미터"><a class="header" href="#entry-block과-파라미터">Entry Block과 파라미터</a></h3>
<p>함수의 entry block은 함수 정의 시 자동으로 생성된다. 파라미터 개수만큼 block arguments를 가진다.</p>
<p><strong>예시: 파라미터가 3개인 함수</strong></p>
<pre><code class="language-mlir">func.func @sum3(%arg0: i32, %arg1: i32, %arg2: i32) -&gt; i32 {
  // Entry block은 3개의 arguments를 가진다:
  // - %arg0 (첫 번째 파라미터)
  // - %arg1 (두 번째 파라미터)
  // - %arg2 (세 번째 파라미터)

  %sum01 = arith.addi %arg0, %arg1 : i32
  %sum012 = arith.addi %sum01, %arg2 : i32
  func.return %sum012 : i32
}
</code></pre>
<p><strong>MLIR IR 구조 시각화:</strong></p>
<pre><code>func.func @sum3(...) {
^entry(%arg0: i32, %arg1: i32, %arg2: i32):
    // %arg0, %arg1, %arg2는 block arguments
    %sum01 = arith.addi %arg0, %arg1
    %sum012 = arith.addi %sum01, %arg2
    func.return %sum012
}
</code></pre>
<p>Entry block의 arguments는 함수 시그니처의 파라미터와 1:1 대응된다.</p>
<h3 id="파라미터와-환경-environment"><a class="header" href="#파라미터와-환경-environment">파라미터와 환경 (Environment)</a></h3>
<p>Chapter 07에서 let 바인딩을 위한 **환경(environment)**을 구현했다:</p>
<pre><code class="language-fsharp">type Environment = Map&lt;string, MlirValue&gt;
</code></pre>
<p>함수 파라미터도 환경에 추가해야 한다. 하지만 let 바인딩과는 다른 방식으로 처리한다:</p>
<p><strong>Let 바인딩:</strong></p>
<ul>
<li>표현식을 컴파일하여 SSA value 생성</li>
<li>환경에 추가</li>
<li>본체 표현식 컴파일</li>
</ul>
<p><strong>함수 파라미터:</strong></p>
<ul>
<li>Block arguments로 이미 존재</li>
<li>환경에 추가 (이름 → block argument 매핑)</li>
<li>본체 표현식 컴파일</li>
</ul>
<p><strong>코드 비교:</strong></p>
<pre><code class="language-fsharp">// Let 바인딩 (Phase 2)
| Let(name, valueExpr, bodyExpr) -&gt;
    let value = compileExpr builder env valueExpr  // 표현식 컴파일
    let newEnv = Map.add name value env            // 환경 확장
    compileExpr builder newEnv bodyExpr

// 함수 파라미터 (Phase 3)
let compileFuncDef builder (funcDef: FunDef) =
    // ...
    let entryBlock = builder.GetFunctionEntryBlock(funcOp)

    // 파라미터를 환경에 추가
    let initialEnv =
        funcDef.parameters
        |&gt; List.mapi (fun i name -&gt;
            let arg = builder.GetFunctionBlockArg(entryBlock, i)
            (name, arg)
        )
        |&gt; Map.ofList

    // 본체 컴파일 (환경 전달)
    let bodyValue = compileExpr builder initialEnv funcDef.body
    builder.CreateFuncReturn(bodyValue)
</code></pre>
<p><strong>핵심 차이:</strong></p>
<ul>
<li>Let 바인딩: <code>compileExpr</code>로 value 생성</li>
<li>함수 파라미터: <code>GetFunctionBlockArg</code>로 기존 value 가져오기</li>
</ul>
<h3 id="예시-함수-본체에서-파라미터-사용"><a class="header" href="#예시-함수-본체에서-파라미터-사용">예시: 함수 본체에서 파라미터 사용</a></h3>
<p><strong>FunLang 소스:</strong></p>
<pre><code class="language-fsharp">let double x = x + x
</code></pre>
<p><strong>AST:</strong></p>
<pre><code class="language-fsharp">{
    name = "double"
    parameters = ["x"]
    body = BinOp(Var "x", Add, Var "x")
}
</code></pre>
<p><strong>컴파일 과정:</strong></p>
<ol>
<li>
<p><strong>함수 operation 생성</strong></p>
<pre><code class="language-fsharp">let funcOp = builder.CreateFuncOp("double", [| i32Type |], i32Type)
</code></pre>
</li>
<li>
<p><strong>Entry block 가져오기</strong></p>
<pre><code class="language-fsharp">let entryBlock = builder.GetFunctionEntryBlock(funcOp)
</code></pre>
</li>
<li>
<p><strong>파라미터를 환경에 추가</strong></p>
<pre><code class="language-fsharp">let arg0 = builder.GetFunctionBlockArg(entryBlock, 0)  // %arg0
let env = Map.ofList [("x", arg0)]
</code></pre>
</li>
<li>
<p><strong>본체 컴파일 (<code>x + x</code>)</strong></p>
<pre><code class="language-fsharp">builder.SetInsertionPointToEnd(entryBlock)

// BinOp(Var "x", Add, Var "x")
// Var "x" → 환경에서 조회 → %arg0
let lhs = env.["x"]  // %arg0
let rhs = env.["x"]  // %arg0
let sum = builder.CreateArithBinaryOp(ArithOp.Addi, lhs, rhs, i32Type)
</code></pre>
</li>
<li>
<p><strong>반환</strong></p>
<pre><code class="language-fsharp">builder.CreateFuncReturn(sum)
</code></pre>
</li>
</ol>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">func.func @double(%arg0: i32) -&gt; i32 {
  %0 = arith.addi %arg0, %arg0 : i32
  func.return %0 : i32
}
</code></pre>
<h3 id="let-바인딩-vs-함수-파라미터-구분"><a class="header" href="#let-바인딩-vs-함수-파라미터-구분">Let 바인딩 vs 함수 파라미터 구분</a></h3>
<p>함수 본체 내부에서 let 바인딩과 파라미터를 모두 사용할 수 있다:</p>
<p><strong>FunLang 소스:</strong></p>
<pre><code class="language-fsharp">let compute x y =
    let doubled = x + x in
    doubled + y
</code></pre>
<p><strong>환경 변화 추적:</strong></p>
<pre><code class="language-fsharp">// 1. 초기 환경 (파라미터만)
env = { "x" -&gt; %arg0, "y" -&gt; %arg1 }

// 2. Let 바인딩 처리
// let doubled = x + x
let doubledValue = arith.addi %arg0, %arg0
env = { "x" -&gt; %arg0, "y" -&gt; %arg1, "doubled" -&gt; %0 }

// 3. 본체 표현식 (doubled + y)
let result = arith.addi %0, %arg1
</code></pre>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">func.func @compute(%arg0: i32, %arg1: i32) -&gt; i32 {
  %doubled = arith.addi %arg0, %arg0 : i32   // let doubled = x + x
  %result = arith.addi %doubled, %arg1 : i32 // doubled + y
  func.return %result : i32
}
</code></pre>
<p><strong>결론:</strong> 파라미터와 let 바인딩 모두 <strong>환경을 통해 관리</strong>된다. 차이점은 value의 출처뿐이다 (block argument vs 컴파일된 표현식).</p>
<h2 id="코드-생성-함수-정의"><a class="header" href="#코드-생성-함수-정의">코드 생성: 함수 정의</a></h2>
<p>이제 FunLang 함수 정의 (FunDef)를 MLIR func.func 연산으로 컴파일하는 <code>compileFuncDef</code> 함수를 작성한다.</p>
<h3 id="compilefuncdef-시그니처"><a class="header" href="#compilefuncdef-시그니처">compileFuncDef 시그니처</a></h3>
<pre><code class="language-fsharp">let compileFuncDef (builder: OpBuilder) (funcDef: FunDef) : unit =
    // ...
</code></pre>
<p><strong>입력:</strong></p>
<ul>
<li><code>builder</code>: OpBuilder (MLIR IR 생성 도구)</li>
<li><code>funcDef</code>: FunDef (FunLang 함수 정의)</li>
</ul>
<p><strong>출력:</strong></p>
<ul>
<li><code>unit</code> (모듈에 함수를 추가하는 부수 효과)</li>
</ul>
<h3 id="단계별-구현"><a class="header" href="#단계별-구현">단계별 구현</a></h3>
<p><strong>Step 1: 타입 준비</strong></p>
<p>파라미터 타입과 반환 타입을 준비한다. Phase 3에서는 모든 값이 i32다.</p>
<pre><code class="language-fsharp">let i32Type = builder.I32Type()
let paramTypes = Array.create funcDef.parameters.Length i32Type
let resultType = i32Type
</code></pre>
<p><strong>Step 2: 함수 operation 생성</strong></p>
<pre><code class="language-fsharp">let funcOp = builder.CreateFuncOp(funcDef.name, paramTypes, resultType)
</code></pre>
<p><strong>Step 3: Entry block 가져오기</strong></p>
<pre><code class="language-fsharp">let entryBlock = builder.GetFunctionEntryBlock(funcOp)
</code></pre>
<p><strong>Step 4: 초기 환경 구축 (파라미터 → block arguments)</strong></p>
<pre><code class="language-fsharp">let initialEnv =
    funcDef.parameters
    |&gt; List.mapi (fun i paramName -&gt;
        let arg = builder.GetFunctionBlockArg(entryBlock, i)
        (paramName, arg)
    )
    |&gt; Map.ofList
</code></pre>
<p><strong>Step 5: Insertion point 설정</strong></p>
<pre><code class="language-fsharp">builder.SetInsertionPointToEnd(entryBlock)
</code></pre>
<p><strong>Step 6: 본체 표현식 컴파일</strong></p>
<pre><code class="language-fsharp">let bodyValue = compileExpr builder initialEnv funcDef.body
</code></pre>
<p><code>compileExpr</code>는 Phase 2에서 작성한 함수다. 환경을 받아서 표현식을 컴파일한다.</p>
<p><strong>Step 7: func.return 삽입</strong></p>
<pre><code class="language-fsharp">builder.CreateFuncReturn(bodyValue)
</code></pre>
<p><strong>Step 8: 모듈에 함수 추가</strong></p>
<pre><code class="language-fsharp">builder.AddOperationToModule(funcOp)
</code></pre>
<h3 id="완전한-compilefuncdef-구현"><a class="header" href="#완전한-compilefuncdef-구현">완전한 compileFuncDef 구현</a></h3>
<pre><code class="language-fsharp">let compileFuncDef (builder: OpBuilder) (funcDef: FunDef) : unit =
    // 1. 타입 준비
    let i32Type = builder.I32Type()
    let paramTypes = Array.create funcDef.parameters.Length i32Type
    let resultType = i32Type

    // 2. 함수 operation 생성
    let funcOp = builder.CreateFuncOp(funcDef.name, paramTypes, resultType)

    // 3. Entry block 가져오기
    let entryBlock = builder.GetFunctionEntryBlock(funcOp)

    // 4. 초기 환경 구축 (파라미터 → block arguments)
    let initialEnv =
        funcDef.parameters
        |&gt; List.mapi (fun i paramName -&gt;
            let arg = builder.GetFunctionBlockArg(entryBlock, i)
            (paramName, arg)
        )
        |&gt; Map.ofList

    // 5. Insertion point 설정
    builder.SetInsertionPointToEnd(entryBlock)

    // 6. 본체 표현식 컴파일
    let bodyValue = compileExpr builder initialEnv funcDef.body

    // 7. func.return 삽입
    builder.CreateFuncReturn(bodyValue)

    // 8. 모듈에 함수 추가
    builder.AddOperationToModule(funcOp)
</code></pre>
<h3 id="예시-let-double-x--x--x"><a class="header" href="#예시-let-double-x--x--x">예시: let double x = x + x</a></h3>
<p><strong>FunDef:</strong></p>
<pre><code class="language-fsharp">{
    name = "double"
    parameters = ["x"]
    body = BinOp(Var "x", Add, Var "x")
}
</code></pre>
<p><strong>compileFuncDef 실행 과정:</strong></p>
<ol>
<li><code>paramTypes = [| i32Type |]</code>, <code>resultType = i32Type</code></li>
<li><code>funcOp = CreateFuncOp("double", [| i32 |], i32)</code></li>
<li><code>entryBlock = GetFunctionEntryBlock(funcOp)</code></li>
<li><code>arg0 = GetFunctionBlockArg(entryBlock, 0)</code>, <code>env = { "x" -&gt; %arg0 }</code></li>
<li><code>SetInsertionPointToEnd(entryBlock)</code></li>
<li><code>bodyValue = compileExpr builder env (BinOp(Var "x", Add, Var "x"))</code>
<ul>
<li><code>Var "x"</code> → <code>env.["x"]</code> → <code>%arg0</code></li>
<li><code>arith.addi %arg0, %arg0</code></li>
</ul>
</li>
<li><code>CreateFuncReturn(bodyValue)</code></li>
<li><code>AddOperationToModule(funcOp)</code></li>
</ol>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">func.func @double(%arg0: i32) -&gt; i32 {
  %0 = arith.addi %arg0, %arg0 : i32
  func.return %0 : i32
}
</code></pre>
<h3 id="예시-let-add-x-y--x--y"><a class="header" href="#예시-let-add-x-y--x--y">예시: let add x y = x + y</a></h3>
<p><strong>FunDef:</strong></p>
<pre><code class="language-fsharp">{
    name = "add"
    parameters = ["x"; "y"]
    body = BinOp(Var "x", Add, Var "y")
}
</code></pre>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">func.func @add(%arg0: i32, %arg1: i32) -&gt; i32 {
  %0 = arith.addi %arg0, %arg1 : i32
  func.return %0 : i32
}
</code></pre>
<h3 id="복잡한-예시-let-compute-x-y--x--x--y"><a class="header" href="#복잡한-예시-let-compute-x-y--x--x--y">복잡한 예시: let compute x y = (x + x) + y</a></h3>
<p><strong>FunDef:</strong></p>
<pre><code class="language-fsharp">{
    name = "compute"
    parameters = ["x"; "y"]
    body = BinOp(
        BinOp(Var "x", Add, Var "x"),
        Add,
        Var "y"
    )
}
</code></pre>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">func.func @compute(%arg0: i32, %arg1: i32) -&gt; i32 {
  %0 = arith.addi %arg0, %arg0 : i32      // x + x
  %1 = arith.addi %0, %arg1 : i32         // (x + x) + y
  func.return %1 : i32
}
</code></pre>
<p><code>compileExpr</code>가 재귀적으로 호출되어 중첩된 연산을 처리한다!</p>
<h2 id="코드-생성-함수-호출"><a class="header" href="#코드-생성-함수-호출">코드 생성: 함수 호출</a></h2>
<p>함수를 정의했으니 이제 호출할 수 있어야 한다. 함수 호출은 <code>App</code> 노드로 표현되며, <code>compileExpr</code>에 새로운 case를 추가한다.</p>
<h3 id="app-case-추가"><a class="header" href="#app-case-추가">App case 추가</a></h3>
<p><strong>compileExpr 확장:</strong></p>
<pre><code class="language-fsharp">let rec compileExpr (builder: OpBuilder) (env: Environment) (expr: Expr) : MlirValue =
    match expr with
    | Int n -&gt; builder.CreateConstant(n, builder.I32Type())
    | Bool b -&gt; builder.CreateConstant((if b then 1 else 0), builder.I1Type())
    | Var name -&gt;
        match Map.tryFind name env with
        | Some value -&gt; value
        | None -&gt; failwithf "Unbound variable: %s" name
    | BinOp(lhs, op, rhs) -&gt;
        let lhsValue = compileExpr builder env lhs
        let rhsValue = compileExpr builder env rhs
        builder.CreateArithBinaryOp(op, lhsValue, rhsValue, builder.I32Type())
    | Compare(lhs, op, rhs) -&gt;
        let lhsValue = compileExpr builder env lhs
        let rhsValue = compileExpr builder env rhs
        builder.CreateArithCompare(op, lhsValue, rhsValue)
    | Let(name, valueExpr, bodyExpr) -&gt;
        let value = compileExpr builder env valueExpr
        let newEnv = Map.add name value env
        compileExpr builder newEnv bodyExpr
    | If(condition, thenExpr, elseExpr) -&gt;
        let condValue = compileExpr builder env condition
        compileIfExpr builder env condValue thenExpr elseExpr
    | App(calleeName, argExprs) -&gt;                  // NEW: 함수 호출
        // Step 1: 인자 표현식들을 컴파일
        let argValues =
            argExprs
            |&gt; List.map (compileExpr builder env)
            |&gt; List.toArray

        // Step 2: 함수 호출 생성
        let resultType = builder.I32Type()
        builder.CreateFuncCall(calleeName, argValues, resultType)
</code></pre>
<h3 id="app-case-설명"><a class="header" href="#app-case-설명">App case 설명</a></h3>
<p><strong>Step 1: 인자 컴파일</strong></p>
<p>함수 호출 전에 모든 인자 표현식을 먼저 컴파일한다 (call-by-value 의미론).</p>
<pre><code class="language-fsharp">let argValues =
    argExprs
    |&gt; List.map (compileExpr builder env)
    |&gt; List.toArray
</code></pre>
<p><strong>예시:</strong></p>
<pre><code class="language-fsharp">// add (5 + 3) (10 * 2)
App("add", [
    BinOp(Int 5, Add, Int 3);
    BinOp(Int 10, Mul, Int 2)
])
</code></pre>
<p>인자 컴파일 결과:</p>
<ul>
<li><code>5 + 3</code> → <code>%0 = arith.addi ... (8)</code></li>
<li><code>10 * 2</code> → <code>%1 = arith.muli ... (20)</code></li>
<li><code>argValues = [| %0; %1 |]</code></li>
</ul>
<p><strong>Step 2: 함수 호출 생성</strong></p>
<pre><code class="language-fsharp">let resultType = builder.I32Type()
builder.CreateFuncCall(calleeName, argValues, resultType)
</code></pre>
<p><code>CreateFuncCall</code>이 <code>func.call</code> 연산을 생성하고 결과 SSA value를 반환한다.</p>
<h3 id="예시-double-5"><a class="header" href="#예시-double-5">예시: double 5</a></h3>
<p><strong>FunLang 표현식:</strong></p>
<pre><code class="language-fsharp">App("double", [Int 5])
</code></pre>
<p><strong>컴파일 과정:</strong></p>
<ol>
<li>인자 컴파일: <code>Int 5</code> → <code>%c5 = arith.constant 5 : i32</code></li>
<li>함수 호출: <code>CreateFuncCall("double", [| %c5 |], i32Type)</code></li>
</ol>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">%c5 = arith.constant 5 : i32
%0 = func.call @double(%c5) : (i32) -&gt; i32
</code></pre>
<h3 id="예시-add-10-20"><a class="header" href="#예시-add-10-20">예시: add 10 20</a></h3>
<p><strong>FunLang 표현식:</strong></p>
<pre><code class="language-fsharp">App("add", [Int 10; Int 20])
</code></pre>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">%c10 = arith.constant 10 : i32
%c20 = arith.constant 20 : i32
%0 = func.call @add(%c10, %c20) : (i32, i32) -&gt; i32
</code></pre>
<h3 id="중첩-호출-예시-double-add-3-4"><a class="header" href="#중첩-호출-예시-double-add-3-4">중첩 호출 예시: double (add 3 4)</a></h3>
<p><strong>FunLang 표현식:</strong></p>
<pre><code class="language-fsharp">App("double", [
    App("add", [Int 3; Int 4])
])
</code></pre>
<p><strong>컴파일 과정:</strong></p>
<ol>
<li>외부 호출의 인자 컴파일: <code>App("add", [Int 3; Int 4])</code>
<ul>
<li>내부 호출의 인자 컴파일: <code>Int 3</code> → <code>%c3</code>, <code>Int 4</code> → <code>%c4</code></li>
<li>내부 호출: <code>%inner = func.call @add(%c3, %c4)</code></li>
</ul>
</li>
<li>외부 호출: <code>%result = func.call @double(%inner)</code></li>
</ol>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">%c3 = arith.constant 3 : i32
%c4 = arith.constant 4 : i32
%inner = func.call @add(%c3, %c4) : (i32, i32) -&gt; i32
%result = func.call @double(%inner) : (i32) -&gt; i32
</code></pre>
<p>중첩 호출이 자연스럽게 처리된다!</p>
<h2 id="코드-생성-program-컴파일"><a class="header" href="#코드-생성-program-컴파일">코드 생성: Program 컴파일</a></h2>
<p>이제 전체 프로그램을 컴파일하는 <code>compileProgram</code> 함수를 작성한다. Program은 여러 함수 정의와 main 표현식으로 구성된다.</p>
<h3 id="compileprogram-시그니처"><a class="header" href="#compileprogram-시그니처">compileProgram 시그니처</a></h3>
<pre><code class="language-fsharp">let compileProgram (builder: OpBuilder) (program: Program) : unit =
    // ...
</code></pre>
<p><strong>입력:</strong></p>
<ul>
<li><code>builder</code>: OpBuilder</li>
<li><code>program</code>: Program (함수 정의 리스트 + main 표현식)</li>
</ul>
<p><strong>출력:</strong></p>
<ul>
<li><code>unit</code> (모듈에 함수들과 main을 추가)</li>
</ul>
<h3 id="단계별-구현-1"><a class="header" href="#단계별-구현-1">단계별 구현</a></h3>
<p><strong>Step 1: 모든 함수 정의 컴파일</strong></p>
<pre><code class="language-fsharp">// 함수 정의들을 모듈에 추가
program.functions
|&gt; List.iter (compileFuncDef builder)
</code></pre>
<p>각 FunDef를 <code>compileFuncDef</code>로 컴파일하여 모듈에 추가한다.</p>
<p><strong>Step 2: Main 함수 생성</strong></p>
<p>Main 표현식을 <code>@funlang_main</code> 함수로 컴파일한다. 이 함수가 프로그램의 진입점이 된다.</p>
<pre><code class="language-fsharp">// Main 함수 생성
let i32Type = builder.I32Type()
let mainFuncOp = builder.CreateFuncOp("funlang_main", [||], i32Type)
let mainBlock = builder.GetFunctionEntryBlock(mainFuncOp)
builder.SetInsertionPointToEnd(mainBlock)

// Main 표현식 컴파일 (빈 환경)
let resultValue = compileExpr builder Map.empty program.main

// Main 반환
builder.CreateFuncReturn(resultValue)
builder.AddOperationToModule(mainFuncOp)
</code></pre>
<p><strong>Step 3 (선택적): C main 함수 생성</strong></p>
<p>실행 가능한 바이너리를 만들려면 C의 <code>main</code> 함수가 필요하다. <code>runtime.c</code>에서 제공한다 (Chapter 09 참조).</p>
<pre><code class="language-c">// runtime.c
int funlang_main();

int main() {
    return funlang_main();
}
</code></pre>
<h3 id="완전한-compileprogram-구현"><a class="header" href="#완전한-compileprogram-구현">완전한 compileProgram 구현</a></h3>
<pre><code class="language-fsharp">let compileProgram (builder: OpBuilder) (program: Program) : unit =
    // 1. 모든 함수 정의 컴파일
    program.functions
    |&gt; List.iter (compileFuncDef builder)

    // 2. Main 함수 생성 (프로그램 진입점)
    let i32Type = builder.I32Type()
    let mainFuncOp = builder.CreateFuncOp("funlang_main", [||], i32Type)
    let mainBlock = builder.GetFunctionEntryBlock(mainFuncOp)
    builder.SetInsertionPointToEnd(mainBlock)

    // 3. Main 표현식 컴파일 (빈 환경 - 함수 파라미터 없음)
    let resultValue = compileExpr builder Map.empty program.main

    // 4. Main 반환
    builder.CreateFuncReturn(resultValue)
    builder.AddOperationToModule(mainFuncOp)
</code></pre>
<h3 id="함수-정의-순서와-심볼-테이블"><a class="header" href="#함수-정의-순서와-심볼-테이블">함수 정의 순서와 심볼 테이블</a></h3>
<p><strong>중요한 특성:</strong> 함수 정의 순서는 중요하지 않다!</p>
<p>MLIR 모듈의 심볼 테이블은 flat namespace다. 모든 <code>func.func</code> 연산이 모듈 로드 시 등록되므로, 정의 순서와 무관하게 호출할 수 있다.</p>
<p><strong>예시:</strong></p>
<pre><code class="language-fsharp">// 함수 정의 순서
let program = {
    functions = [
        { name = "bar"; parameters = []; body = App("foo", []) };  // foo를 호출
        { name = "foo"; parameters = []; body = Int 42 }           // foo 정의
    ]
    main = App("bar", [])
}
</code></pre>
<p><code>bar</code>가 <code>foo</code>를 호출하지만, <code>foo</code>는 나중에 정의된다. MLIR에서는 문제없다:</p>
<pre><code class="language-mlir">func.func @bar() -&gt; i32 {
  %0 = func.call @foo() : () -&gt; i32  // 전방 참조
  func.return %0 : i32
}

func.func @foo() -&gt; i32 {
  %c42 = arith.constant 42 : i32
  func.return %c42 : i32
}
</code></pre>
<h3 id="모든-함수가-모든-함수를-볼-수-있다"><a class="header" href="#모든-함수가-모든-함수를-볼-수-있다">모든 함수가 모든 함수를 볼 수 있다</a></h3>
<p>Flat namespace 덕분에 상호 재귀도 가능하다 (Chapter 11에서 자세히 다룸).</p>
<pre><code class="language-mlir">func.func @is_even(%n: i32) -&gt; i1 {
  // ... calls @is_odd ...
}

func.func @is_odd(%n: i32) -&gt; i1 {
  // ... calls @is_even ...
}
</code></pre>
<p>정의 순서와 무관하게 모든 함수가 서로를 참조할 수 있다.</p>
<h2 id="완전한-예시-여러-함수와-main"><a class="header" href="#완전한-예시-여러-함수와-main">완전한 예시: 여러 함수와 Main</a></h2>
<p>이제 완전한 프로그램 예시를 보자.</p>
<h3 id="funlang-소스"><a class="header" href="#funlang-소스">FunLang 소스</a></h3>
<pre><code class="language-fsharp">let square x = x * x
let sumSquares a b = square a + square b
sumSquares 3 4
</code></pre>
<p><strong>의미:</strong></p>
<ul>
<li><code>square 3</code> → 9</li>
<li><code>square 4</code> → 16</li>
<li><code>9 + 16</code> → 25</li>
</ul>
<h3 id="ast-표현"><a class="header" href="#ast-표현">AST 표현</a></h3>
<pre><code class="language-fsharp">let program = {
    functions = [
        { name = "square"
          parameters = ["x"]
          body = BinOp(Var "x", Mul, Var "x") };

        { name = "sumSquares"
          parameters = ["a"; "b"]
          body = BinOp(
              App("square", [Var "a"]),
              Add,
              App("square", [Var "b"])
          ) }
    ]
    main = App("sumSquares", [Int 3; Int 4])
}
</code></pre>
<h3 id="컴파일-과정"><a class="header" href="#컴파일-과정">컴파일 과정</a></h3>
<p><strong>1. square 함수 컴파일</strong></p>
<pre><code class="language-fsharp">compileFuncDef builder { name = "square"; parameters = ["x"]; body = ... }
</code></pre>
<p>생성된 MLIR IR:</p>
<pre><code class="language-mlir">func.func @square(%arg0: i32) -&gt; i32 {
  %0 = arith.muli %arg0, %arg0 : i32
  func.return %0 : i32
}
</code></pre>
<p><strong>2. sumSquares 함수 컴파일</strong></p>
<pre><code class="language-fsharp">compileFuncDef builder { name = "sumSquares"; parameters = ["a"; "b"]; body = ... }
</code></pre>
<p>본체 컴파일:</p>
<ul>
<li><code>App("square", [Var "a"])</code> → <code>%0 = func.call @square(%arg0)</code></li>
<li><code>App("square", [Var "b"])</code> → <code>%1 = func.call @square(%arg1)</code></li>
<li><code>BinOp(..., Add, ...)</code> → <code>%2 = arith.addi %0, %1</code></li>
</ul>
<p>생성된 MLIR IR:</p>
<pre><code class="language-mlir">func.func @sumSquares(%arg0: i32, %arg1: i32) -&gt; i32 {
  %0 = func.call @square(%arg0) : (i32) -&gt; i32
  %1 = func.call @square(%arg1) : (i32) -&gt; i32
  %2 = arith.addi %0, %1 : i32
  func.return %2 : i32
}
</code></pre>
<p><strong>3. Main 함수 컴파일</strong></p>
<pre><code class="language-fsharp">// main = App("sumSquares", [Int 3; Int 4])
</code></pre>
<p>생성된 MLIR IR:</p>
<pre><code class="language-mlir">func.func @funlang_main() -&gt; i32 {
  %c3 = arith.constant 3 : i32
  %c4 = arith.constant 4 : i32
  %0 = func.call @sumSquares(%c3, %c4) : (i32, i32) -&gt; i32
  func.return %0 : i32
}
</code></pre>
<h3 id="완전한-mlir-모듈"><a class="header" href="#완전한-mlir-모듈">완전한 MLIR 모듈</a></h3>
<pre><code class="language-mlir">module {
  func.func @square(%arg0: i32) -&gt; i32 {
    %0 = arith.muli %arg0, %arg0 : i32
    func.return %0 : i32
  }

  func.func @sumSquares(%arg0: i32, %arg1: i32) -&gt; i32 {
    %0 = func.call @square(%arg0) : (i32) -&gt; i32
    %1 = func.call @square(%arg1) : (i32) -&gt; i32
    %2 = arith.addi %0, %1 : i32
    func.return %2 : i32
  }

  func.func @funlang_main() -&gt; i32 {
    %c3 = arith.constant 3 : i32
    %c4 = arith.constant 4 : i32
    %0 = func.call @sumSquares(%c3, %c4) : (i32, i32) -&gt; i32
    func.return %0 : i32
  }
}
</code></pre>
<h3 id="lowering-to-llvm-dialect"><a class="header" href="#lowering-to-llvm-dialect">Lowering to LLVM Dialect</a></h3>
<p>MLIR의 <code>--convert-func-to-llvm</code> 패스를 적용하면 LLVM 다이얼렉트로 변환된다:</p>
<pre><code class="language-bash">mlir-opt --convert-func-to-llvm \
         --convert-arith-to-llvm \
         --convert-scf-to-cf \
         --convert-cf-to-llvm \
         input.mlir -o lowered.mlir
</code></pre>
<p><strong>Lowered MLIR (LLVM dialect):</strong></p>
<pre><code class="language-mlir">module {
  llvm.func @square(%arg0: i32) -&gt; i32 {
    %0 = llvm.mul %arg0, %arg0 : i32
    llvm.return %0 : i32
  }

  llvm.func @sumSquares(%arg0: i32, %arg1: i32) -&gt; i32 {
    %0 = llvm.call @square(%arg0) : (i32) -&gt; i32
    %1 = llvm.call @square(%arg1) : (i32) -&gt; i32
    %2 = llvm.add %0, %1 : i32
    llvm.return %2 : i32
  }

  llvm.func @funlang_main() -&gt; i32 {
    %c3 = llvm.mlir.constant(3 : i32) : i32
    %c4 = llvm.mlir.constant(4 : i32) : i32
    %0 = llvm.call @sumSquares(%c3, %c4) : (i32, i32) -&gt; i32
    llvm.return %0 : i32
  }
}
</code></pre>
<p><code>func.*</code> 연산이 <code>llvm.*</code> 연산으로 변환되었다!</p>
<h3 id="llvm-ir-변환"><a class="header" href="#llvm-ir-변환">LLVM IR 변환</a></h3>
<pre><code class="language-bash">mlir-translate --mlir-to-llvmir lowered.mlir -o output.ll
</code></pre>
<p><strong>LLVM IR:</strong></p>
<pre><code class="language-llvm">define i32 @square(i32 %0) {
  %2 = mul i32 %0, %0
  ret i32 %2
}

define i32 @sumSquares(i32 %0, i32 %1) {
  %3 = call i32 @square(i32 %0)
  %4 = call i32 @square(i32 %1)
  %5 = add i32 %3, %4
  ret i32 %5
}

define i32 @funlang_main() {
  %1 = call i32 @sumSquares(i32 3, i32 4)
  ret i32 %1
}
</code></pre>
<h3 id="컴파일과-실행"><a class="header" href="#컴파일과-실행">컴파일과 실행</a></h3>
<pre><code class="language-bash"># LLVM IR을 object file로 컴파일
llc -filetype=obj output.ll -o funlang.o

# runtime.c와 링크
cc runtime.c funlang.o -o program

# 실행
./program
echo $?  # 25 (3*3 + 4*4)
</code></pre>
<p>프로그램이 실행되어 <code>25</code>를 반환한다!</p>
<h2 id="호출-규약-calling-convention"><a class="header" href="#호출-규약-calling-convention">호출 규약 (Calling Convention)</a></h2>
<p>함수 호출이 실제로 어떻게 동작하는지 이해하려면 **호출 규약(calling convention)**을 알아야 한다.</p>
<h3 id="호출-규약이란"><a class="header" href="#호출-규약이란">호출 규약이란?</a></h3>
<p><strong>호출 규약</strong>은 함수 호출 시 인자, 반환 값, 레지스터, 스택이 어떻게 관리되는지 정의하는 규칙이다.</p>
<p><strong>규약에 포함되는 내용:</strong></p>
<ol>
<li><strong>인자 전달 방법</strong>: 레지스터? 스택? 어떤 순서?</li>
<li><strong>반환 값 위치</strong>: 어느 레지스터에 반환 값을 넣는가?</li>
<li><strong>레지스터 보존</strong>: 어떤 레지스터는 호출 전후에 보존되어야 하는가?</li>
<li><strong>스택 프레임</strong>: 스택을 어떻게 정리하는가?</li>
</ol>
<h3 id="c-호출-규약-x86-64-system-v-abi"><a class="header" href="#c-호출-규약-x86-64-system-v-abi">C 호출 규약 (x86-64 System V ABI)</a></h3>
<p>MLIR/LLVM은 기본적으로 <strong>C 호출 규약</strong>을 사용한다. x86-64 Linux에서는 <strong>System V ABI</strong>다.</p>
<p><strong>인자 전달 (x86-64 System V ABI):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>인자 순서</th><th>정수/포인터</th><th>부동소수점</th></tr>
</thead>
<tbody>
<tr><td>1번째</td><td>RDI</td><td>XMM0</td></tr>
<tr><td>2번째</td><td>RSI</td><td>XMM1</td></tr>
<tr><td>3번째</td><td>RDX</td><td>XMM2</td></tr>
<tr><td>4번째</td><td>RCX</td><td>XMM3</td></tr>
<tr><td>5번째</td><td>R8</td><td>XMM4</td></tr>
<tr><td>6번째</td><td>R9</td><td>XMM5</td></tr>
<tr><td>7번째 이상</td><td>스택</td><td>스택</td></tr>
</tbody>
</table>
</div>
<p><strong>예시: <code>add(10, 20)</code> 호출</strong></p>
<pre><code class="language-asm">mov edi, 10      ; 첫 번째 인자 (RDI의 하위 32비트)
mov esi, 20      ; 두 번째 인자 (RSI의 하위 32비트)
call add         ; 함수 호출
; 반환 값은 EAX (RAX의 하위 32비트)에 저장됨
</code></pre>
<p><strong>반환 값:</strong></p>
<ul>
<li>정수/포인터: RAX (32비트 정수는 EAX)</li>
<li>부동소수점: XMM0</li>
</ul>
<p><strong>예시: <code>add</code> 함수 반환</strong></p>
<pre><code class="language-asm">add:
    mov eax, edi
    add eax, esi   ; eax = edi + esi
    ret            ; eax에 반환 값
</code></pre>
<h3 id="llvm이-호출-규약을-처리한다"><a class="header" href="#llvm이-호출-규약을-처리한다">LLVM이 호출 규약을 처리한다</a></h3>
<p><strong>핵심 통찰력:</strong> 우리는 호출 규약을 직접 구현하지 않는다. LLVM이 자동으로 처리한다!</p>
<p><strong>MLIR func 다이얼렉트 코드:</strong></p>
<pre><code class="language-mlir">func.func @add(%arg0: i32, %arg1: i32) -&gt; i32 {
  %0 = arith.addi %arg0, %arg1 : i32
  func.return %0 : i32
}
</code></pre>
<p><strong>LLVM이 생성하는 네이티브 코드 (x86-64):</strong></p>
<pre><code class="language-asm">add:
    ; 프롤로그 (스택 프레임 설정) - 단순 함수는 생략 가능
    lea eax, [rdi + rsi]  ; eax = edi + esi (최적화됨)
    ret
</code></pre>
<p>LLVM이 자동으로:</p>
<ol>
<li>파라미터를 적절한 레지스터에 배치 (EDI, ESI)</li>
<li>반환 값을 EAX에 배치</li>
<li>최적화 적용 (lea 사용)</li>
<li>에필로그 생략 (단순 함수)</li>
</ol>
<h3 id="플랫폼별-차이"><a class="header" href="#플랫폼별-차이">플랫폼별 차이</a></h3>
<p>호출 규약은 플랫폼마다 다르다:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>플랫폼</th><th>호출 규약</th><th>인자 전달</th></tr>
</thead>
<tbody>
<tr><td>Linux x86-64</td><td>System V ABI</td><td>RDI, RSI, RDX, RCX, R8, R9, 스택</td></tr>
<tr><td>Windows x86-64</td><td>Microsoft x64</td><td>RCX, RDX, R8, R9, 스택</td></tr>
<tr><td>ARM64</td><td>AAPCS64</td><td>X0-X7, 스택</td></tr>
<tr><td>x86-32</td><td>cdecl</td><td>스택 (오른쪽부터)</td></tr>
</tbody>
</table>
</div>
<p><strong>LLVM의 역할:</strong> 동일한 LLVM IR을 각 플랫폼에 맞게 변환한다. 우리는 신경 쓸 필요 없다!</p>
<h3 id="왜-c-호출-규약을-사용하는가"><a class="header" href="#왜-c-호출-규약을-사용하는가">왜 C 호출 규약을 사용하는가?</a></h3>
<p><strong>장점:</strong></p>
<ol>
<li><strong>C 라이브러리와 상호 운용</strong>: printf, malloc 같은 C 함수를 호출할 수 있다.</li>
<li><strong>시스템 콜 호환성</strong>: OS 시스템 콜이 C 규약을 따른다.</li>
<li><strong>디버거 지원</strong>: GDB 같은 디버거가 C 호출 규약을 이해한다.</li>
<li><strong>ABI 안정성</strong>: 표준 ABI로 다른 언어와 링크 가능.</li>
</ol>
<p><strong>단점 (Phase 3에서는 해당 없음):</strong></p>
<ul>
<li>Tail call optimization이 보장되지 않음 (Chapter 11에서 다룸)</li>
<li>클로저 전달이 비효율적일 수 있음 (Phase 4에서 다룸)</li>
</ul>
<p>Phase 3에서는 C 호출 규약이 완벽하게 작동한다. 단순한 값 전달과 반환만 있기 때문이다.</p>
<h3 id="스택-프레임-관리"><a class="header" href="#스택-프레임-관리">스택 프레임 관리</a></h3>
<p>함수 호출 시 **스택 프레임(stack frame)**이 생성된다.</p>
<p><strong>스택 프레임 구조 (x86-64):</strong></p>
<pre><code>High address
┌─────────────────┐
│ 인자 7, 8, ...  │  (레지스터에 들어가지 않는 인자들)
├─────────────────┤
│ 반환 주소       │  (call 명령어가 push)
├─────────────────┤
│ 이전 RBP        │  (함수 프롤로그가 push)
├─────────────────┤  ← RBP (base pointer)
│ 지역 변수       │
├─────────────────┤
│ 임시 값         │
└─────────────────┘  ← RSP (stack pointer)
Low address
</code></pre>
<p><strong>함수 프롤로그 (진입 시):</strong></p>
<pre><code class="language-asm">push rbp           ; 이전 프레임 포인터 저장
mov rbp, rsp       ; 새 프레임 포인터 설정
sub rsp, 32        ; 지역 변수를 위한 공간 할당
</code></pre>
<p><strong>함수 에필로그 (종료 시):</strong></p>
<pre><code class="language-asm">mov rsp, rbp       ; 스택 포인터 복원
pop rbp            ; 이전 프레임 포인터 복원
ret                ; 반환
</code></pre>
<p><strong>LLVM의 역할:</strong> 이 모든 것을 자동으로 생성한다. 우리는 <code>func.func</code>와 <code>func.return</code>만 작성하면 된다!</p>
<h3 id="tail-call-optimization-미리보기"><a class="header" href="#tail-call-optimization-미리보기">Tail Call Optimization (미리보기)</a></h3>
<p><strong>Tail call</strong>은 함수의 마지막 연산이 다른 함수 호출인 경우다:</p>
<pre><code class="language-fsharp">let factorial_tail n acc =
    if n &lt;= 1 then acc
    else factorial_tail (n - 1) (n * acc)  // Tail call!
</code></pre>
<p>일반 호출과 tail call의 차이:</p>
<p><strong>일반 호출 (스택 프레임 누적):</strong></p>
<pre><code>factorial_tail(5, 1)
  → factorial_tail(4, 5)
    → factorial_tail(3, 20)
      → factorial_tail(2, 60)
        → factorial_tail(1, 120)
          → 120
</code></pre>
<p>5개의 스택 프레임이 누적된다.</p>
<p><strong>Tail call optimization (스택 프레임 재사용):</strong></p>
<pre><code>factorial_tail(5, 1)
→ factorial_tail(4, 5)  (같은 프레임 재사용)
→ factorial_tail(3, 20)
→ factorial_tail(2, 60)
→ factorial_tail(1, 120)
→ 120
</code></pre>
<p>1개의 스택 프레임만 사용한다!</p>
<p><strong>Chapter 11에서 자세히 다룬다.</strong> Tail call optimization은 재귀 함수를 효율적으로 만드는 핵심 기술이다.</p>
<h2 id="일반적인-오류"><a class="header" href="#일반적인-오류">일반적인 오류</a></h2>
<p>함수를 처음 구현할 때 흔히 겪는 오류들을 살펴본다.</p>
<h3 id="오류-1-함수를-찾을-수-없음"><a class="header" href="#오류-1-함수를-찾을-수-없음">오류 1: 함수를 찾을 수 없음</a></h3>
<p><strong>증상:</strong></p>
<pre><code>error: 'func.call' op symbol reference '@foo' not found in symbol table
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>함수 이름 오타</li>
<li>함수가 정의되지 않음</li>
<li>함수를 모듈에 추가하지 않음</li>
</ul>
<p><strong>예시 (잘못된 코드):</strong></p>
<pre><code class="language-fsharp">// 'add' 함수를 정의했지만 'addd'로 호출
let program = {
    functions = [ { name = "add"; parameters = ["x"; "y"]; body = ... } ]
    main = App("addd", [Int 10; Int 20])  // 오타!
}
</code></pre>
<p><strong>해결 방법:</strong></p>
<ol>
<li><strong>함수 이름 확인</strong>: 정의와 호출 시 이름이 일치하는가?</li>
<li><strong>함수 정의 확인</strong>: <code>compileFuncDef</code>가 호출되었는가?</li>
<li><strong>모듈 추가 확인</strong>: <code>AddOperationToModule</code>이 호출되었는가?</li>
</ol>
<pre><code class="language-fsharp">// 올바른 코드
let program = {
    functions = [ { name = "add"; parameters = ["x"; "y"]; body = ... } ]
    main = App("add", [Int 10; Int 20])  // 일치!
}
</code></pre>
<h3 id="오류-2-인자-개수-불일치"><a class="header" href="#오류-2-인자-개수-불일치">오류 2: 인자 개수 불일치</a></h3>
<p><strong>증상:</strong></p>
<pre><code>error: 'func.call' op incorrect number of operands: expected 2 but got 1
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>함수 호출 시 인자 개수가 정의와 다름</li>
</ul>
<p><strong>예시 (잘못된 코드):</strong></p>
<pre><code class="language-fsharp">// add는 2개의 파라미터를 받는다
let addDef = { name = "add"; parameters = ["x"; "y"]; body = ... }

// 하지만 1개만 전달
let call = App("add", [Int 10])  // 오류!
</code></pre>
<p><strong>해결 방법:</strong></p>
<p>함수 정의의 파라미터 개수와 호출 시 인자 개수를 일치시킨다.</p>
<pre><code class="language-fsharp">// 올바른 코드
let call = App("add", [Int 10; Int 20])  // 2개 인자
</code></pre>
<p><strong>디버깅 팁:</strong></p>
<p>함수 시그니처를 확인하는 유틸리티를 추가한다:</p>
<pre><code class="language-fsharp">let checkFunctionArity (funcDef: FunDef) (argCount: int) =
    if argCount &lt;&gt; funcDef.parameters.Length then
        failwithf "Function %s expects %d arguments but got %d"
            funcDef.name
            funcDef.parameters.Length
            argCount
</code></pre>
<h3 id="오류-3-타입-불일치"><a class="header" href="#오류-3-타입-불일치">오류 3: 타입 불일치</a></h3>
<p><strong>증상:</strong></p>
<pre><code>error: 'func.call' op operand type mismatch: expected 'i32' but got 'i1'
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>함수 파라미터 타입과 인자 타입이 다름</li>
<li>Phase 3에서는 모든 값이 i32이므로 비교 결과(i1)를 함수에 전달할 때 발생</li>
</ul>
<p><strong>예시 (잘못된 코드):</strong></p>
<pre><code class="language-fsharp">// compute는 i32를 받는다
let computeDef = { name = "compute"; parameters = ["x"]; body = ... }

// 하지만 i1 (비교 결과)를 전달
let cond = Compare(Int 10, Gt, Int 5)  // i1 타입
let call = App("compute", [cond])      // 타입 불일치!
</code></pre>
<p><strong>해결 방법:</strong></p>
<p>Phase 3에서는 모든 함수 파라미터가 i32다. 비교 결과를 전달하려면 i1을 i32로 확장한다:</p>
<pre><code class="language-fsharp">// 비교 결과를 i32로 확장
let cond = Compare(Int 10, Gt, Int 5)  // i1
let condExtended = If(cond, Int 1, Int 0)  // i32
let call = App("compute", [condExtended])
</code></pre>
<p>또는 컴파일러가 자동으로 확장하도록 구현:</p>
<pre><code class="language-fsharp">let rec compileExpr builder env expr =
    match expr with
    | App(name, args) -&gt;
        let argValues =
            args
            |&gt; List.map (fun argExpr -&gt;
                let value = compileExpr builder env argExpr
                // i1 타입이면 i32로 확장
                if mlirTypeEqual (mlirValueGetType value) (builder.I1Type()) then
                    builder.CreateArithExtension(value, builder.I32Type())
                else
                    value
            )
            |&gt; List.toArray
        builder.CreateFuncCall(name, argValues, builder.I32Type())
</code></pre>
<h3 id="오류-4-funcreturn-누락"><a class="header" href="#오류-4-funcreturn-누락">오류 4: func.return 누락</a></h3>
<p><strong>증상:</strong></p>
<pre><code>error: 'func.func' op block must be terminated with a func.return operation
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>함수 본체가 종결자(terminator) 없이 끝남</li>
<li><code>func.return</code>을 추가하지 않음</li>
</ul>
<p><strong>예시 (잘못된 코드):</strong></p>
<pre><code class="language-fsharp">let compileFuncDef builder funcDef =
    let funcOp = builder.CreateFuncOp(...)
    let entryBlock = builder.GetFunctionEntryBlock(funcOp)
    builder.SetInsertionPointToEnd(entryBlock)

    // 본체 컴파일
    let bodyValue = compileExpr builder env funcDef.body

    // func.return 누락!
    builder.AddOperationToModule(funcOp)
</code></pre>
<p><strong>해결 방법:</strong></p>
<p>항상 <code>func.return</code>을 추가한다:</p>
<pre><code class="language-fsharp">let compileFuncDef builder funcDef =
    // ...
    let bodyValue = compileExpr builder env funcDef.body
    builder.CreateFuncReturn(bodyValue)  // 추가!
    builder.AddOperationToModule(funcOp)
</code></pre>
<h3 id="오류-5-파라미터와-let-바인딩-혼동"><a class="header" href="#오류-5-파라미터와-let-바인딩-혼동">오류 5: 파라미터와 let 바인딩 혼동</a></h3>
<p><strong>증상:</strong></p>
<pre><code>error: use of value '%arg0' requires an operation that dominates it
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>파라미터를 일반 변수처럼 처리함</li>
<li>환경에 파라미터를 추가하지 않음</li>
</ul>
<p><strong>예시 (잘못된 코드):</strong></p>
<pre><code class="language-fsharp">let compileFuncDef builder funcDef =
    // ...
    let entryBlock = builder.GetFunctionEntryBlock(funcOp)
    builder.SetInsertionPointToEnd(entryBlock)

    // 파라미터를 환경에 추가하지 않음!
    let env = Map.empty
    let bodyValue = compileExpr builder env funcDef.body  // Var "x"를 찾지 못함
</code></pre>
<p><strong>해결 방법:</strong></p>
<p>파라미터를 환경에 추가한다:</p>
<pre><code class="language-fsharp">let compileFuncDef builder funcDef =
    // ...
    let entryBlock = builder.GetFunctionEntryBlock(funcOp)

    // 파라미터를 환경에 추가
    let initialEnv =
        funcDef.parameters
        |&gt; List.mapi (fun i name -&gt;
            let arg = builder.GetFunctionBlockArg(entryBlock, i)
            (name, arg)
        )
        |&gt; Map.ofList

    builder.SetInsertionPointToEnd(entryBlock)
    let bodyValue = compileExpr builder initialEnv funcDef.body
    builder.CreateFuncReturn(bodyValue)
</code></pre>
<p><strong>핵심 원칙:</strong> 파라미터는 block arguments다. 환경에 추가하여 이름으로 참조할 수 있게 한다.</p>
<h2 id="장-요약-4"><a class="header" href="#장-요약-4">장 요약</a></h2>
<p>이 장에서 FunLang에 <strong>함수</strong>를 추가했다.</p>
<p><strong>배운 내용:</strong></p>
<ol>
<li>
<p><strong>MLIR func 다이얼렉트</strong></p>
<ul>
<li><code>func.func</code>: 함수 정의</li>
<li><code>func.call</code>: 함수 호출</li>
<li><code>func.return</code>: 함수 반환</li>
<li>모듈 레벨 심볼 테이블</li>
</ul>
</li>
<li>
<p><strong>AST 확장</strong></p>
<ul>
<li><code>FunDef</code>: 함수 정의 (이름, 파라미터, 본체)</li>
<li><code>App</code>: 함수 호출 (함수 이름, 인자 리스트)</li>
<li><code>Program</code>: 함수 정의 리스트 + main 표현식</li>
</ul>
</li>
<li>
<p><strong>P/Invoke 바인딩</strong></p>
<ul>
<li>Function type API (<code>mlirFunctionTypeGet</code>)</li>
<li>Symbol reference (<code>mlirFlatSymbolRefAttrGet</code>)</li>
<li>Block arguments (<code>mlirBlockGetArgument</code>)</li>
</ul>
</li>
<li>
<p><strong>OpBuilder 확장</strong></p>
<ul>
<li><code>CreateFuncOp</code>: 함수 생성</li>
<li><code>GetFunctionEntryBlock</code>: entry block 가져오기</li>
<li><code>GetFunctionBlockArg</code>: 파라미터 가져오기</li>
<li><code>CreateFuncCall</code>: 함수 호출</li>
<li><code>CreateFuncReturn</code>: 함수 반환</li>
</ul>
</li>
<li>
<p><strong>함수 파라미터와 Block Arguments</strong></p>
<ul>
<li>파라미터는 block arguments로 표현</li>
<li>Entry block의 arguments로 자동 생성</li>
<li>환경에 추가하여 이름으로 참조</li>
</ul>
</li>
<li>
<p><strong>코드 생성</strong></p>
<ul>
<li><code>compileFuncDef</code>: 함수 정의 컴파일</li>
<li><code>compileExpr</code>의 <code>App</code> case: 함수 호출 컴파일</li>
<li><code>compileProgram</code>: 전체 프로그램 컴파일</li>
</ul>
</li>
<li>
<p><strong>호출 규약 (Calling Convention)</strong></p>
<ul>
<li>C 호출 규약 (System V ABI)</li>
<li>인자 전달: 레지스터 → 스택</li>
<li>반환 값: RAX 레지스터</li>
<li>LLVM이 자동 처리</li>
</ul>
</li>
</ol>
<p><strong>독자가 할 수 있는 것:</strong></p>
<ul>
<li>다중 함수 정의를 포함한 FunLang 프로그램 작성</li>
<li>함수 호출과 중첩 호출 컴파일</li>
<li>생성된 MLIR IR 확인</li>
<li>네이티브 바이너리로 컴파일 및 실행</li>
</ul>
<p><strong>다음 단계 (Chapter 11):</strong></p>
<ul>
<li><strong>재귀(Recursion)</strong>: 함수가 자기 자신을 호출</li>
<li><strong>상호 재귀(Mutual Recursion)</strong>: 두 함수가 서로를 호출</li>
<li><strong>Tail Call Optimization</strong>: 재귀를 효율적으로 만들기</li>
</ul>
<p>함수는 코드 재사용과 모듈화의 핵심이다. Phase 3은 함수의 기초를 확립했다. 다음 장에서는 재귀로 함수의 표현력을 극대화한다!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-11-재귀-recursion"><a class="header" href="#chapter-11-재귀-recursion">Chapter 11: 재귀 (Recursion)</a></h1>
<h2 id="소개-11"><a class="header" href="#소개-11">소개</a></h2>
<p>함수형 프로그래밍에서 **재귀(recursion)**는 단순한 기법이 아니라 <strong>필수 도구</strong>다. 명령형 언어가 loop을 쓰는 곳에 함수형 언어는 재귀를 쓴다.</p>
<pre><code class="language-fsharp">// 명령형 스타일 (loop)
let sum_to n =
    let mutable result = 0
    for i in 1 to n do
        result &lt;- result + i
    result

// 함수형 스타일 (recursion)
let rec sum_to n =
    if n &lt;= 0 then 0
    else n + sum_to (n - 1)
</code></pre>
<p><strong>왜 재귀인가?</strong></p>
<p>순수 함수형 언어에는 mutable 변수가 없다. 값은 불변이고, 상태는 함수 파라미터를 통해 전달된다. Loop은 카운터 변수를 변경하는데, 이것은 mutation이다. 재귀는 mutation 없이 반복을 표현할 수 있다.</p>
<p>FunLang은 순수 함수형 언어다. Loop 구문이 없다. 모든 반복은 재귀로 표현된다.</p>
<p><strong>재귀의 본질: 자기 참조(Self-reference)</strong></p>
<p>재귀 함수는 <strong>자기 자신을 호출</strong>한다:</p>
<pre><code class="language-fsharp">let rec factorial n =
    if n &lt;= 1 then 1
    else n * factorial (n - 1)
           // ↑ 자기 자신을 호출!
</code></pre>
<p><code>factorial</code> 함수가 본체 내부에서 <code>factorial</code>을 호출한다. 이것이 가능하려면:</p>
<ul>
<li>함수 이름이 본체에서 보여야 한다 (scope 문제)</li>
<li>무한 재귀를 방지할 기저 사례(base case)가 필요하다</li>
</ul>
<p><strong>Chapter 11의 범위:</strong></p>
<p>이 장에서 다루는 것:</p>
<ol>
<li><strong>재귀 함수 (Recursive functions)</strong>: 자기 자신을 호출하는 함수 (factorial, fibonacci)</li>
<li><strong>상호 재귀 (Mutual recursion)</strong>: 두 함수가 서로를 호출 (is_even, is_odd)</li>
<li><strong>스택 프레임 (Stack frames)</strong>: 재귀 호출이 스택 메모리를 어떻게 사용하는가</li>
<li><strong>꼬리 호출 최적화 (Tail call optimization)</strong>: 스택 오버플로우를 방지하는 기법</li>
</ol>
<p>이 장을 마치면:</p>
<ul>
<li>factorial, fibonacci 같은 재귀 함수를 컴파일할 수 있다</li>
<li>상호 재귀가 모듈 레벨 심볼 테이블을 통해 작동하는 원리를 안다</li>
<li>스택 프레임이 어떻게 생성되고 소멸되는지 이해한다</li>
<li>꼬리 호출 최적화가 무엇이고 왜 중요한지 안다</li>
</ul>
<blockquote>
<p><strong>Preview:</strong> Phase 3 (Chapter 10-11)은 최상위 명명된 함수를 다룬다. Phase 4에서 클로저와 고차 함수를 추가할 것이다.</p>
</blockquote>
<h2 id="재귀가-mlir에서-작동하는-원리"><a class="header" href="#재귀가-mlir에서-작동하는-원리">재귀가 MLIR에서 작동하는 원리</a></h2>
<h3 id="모듈-레벨-심볼-테이블"><a class="header" href="#모듈-레벨-심볼-테이블">모듈 레벨 심볼 테이블</a></h3>
<p>Chapter 10에서 배운 것: MLIR 모듈은 <strong>flat symbol table</strong>을 가진다. 모든 <code>func.func</code> 연산이 모듈 레벨 심볼로 등록된다.</p>
<pre><code class="language-mlir">module {
  func.func @factorial(%n: i32) -&gt; i32 {
    // ...
  }

  func.func @fibonacci(%n: i32) -&gt; i32 {
    // ...
  }

  func.func @main() -&gt; i32 {
    // ...
  }
}
</code></pre>
<p><strong>핵심:</strong> 모든 함수가 서로에게 보인다. 정의 순서는 중요하지 않다.</p>
<ul>
<li><code>@factorial</code>은 <code>@fibonacci</code>를 호출할 수 있다</li>
<li><code>@fibonacci</code>는 <code>@factorial</code>을 호출할 수 있다</li>
<li><code>@factorial</code>은 <strong>자기 자신</strong>을 호출할 수 있다!</li>
</ul>
<p><strong>자기 참조 (Self-reference):</strong></p>
<pre><code class="language-mlir">func.func @factorial(%n: i32) -&gt; i32 {
  // ...
  %rec = func.call @factorial(%n_minus_1) : (i32) -&gt; i32
  //                 ↑ 자기 자신을 호출!
  // ...
}
</code></pre>
<p><code>@factorial</code> 함수가 내부에서 <code>func.call @factorial</code>을 실행한다. 이것은 **심볼 참조(symbol reference)**다:</p>
<ul>
<li><code>@factorial</code>이라는 심볼이 모듈에 존재하는가? <strong>예</strong> (자기 자신)</li>
<li>타입이 <code>(i32) -&gt; i32</code>가 맞는가? <strong>예</strong></li>
<li>호출 가능한가? <strong>예</strong></li>
</ul>
<p>MLIR verifier는 심볼 존재를 확인하지만, “자기 자신 호출“을 금지하지 않는다. 재귀가 자연스럽게 작동한다.</p>
<h3 id="interpreter-vs-compiler의-차이"><a class="header" href="#interpreter-vs-compiler의-차이">Interpreter vs Compiler의 차이</a></h3>
<p><strong>Interpreter에서 재귀 (LangTutorial FunLang):</strong></p>
<pre><code class="language-fsharp">// AST
LetRec("factorial",
       Lambda(["n"],
              If(BinOp(Var "n", Le, Num 1),
                 Num 1,
                 BinOp(Var "n",
                       Mul,
                       App(Var "factorial", [BinOp(Var "n", Sub, Num 1)])))))

// Interpreter evaluation
let rec eval env ast =
    match ast with
    | LetRec(name, Lambda(params, body), rest) -&gt;
        // 1. 재귀 환경 생성: env에 함수 자신을 추가
        let rec_env = env.Add(name, RecursiveClosure(params, body, rec_env))
        // 2. 본체 평가
        eval rec_env body
</code></pre>
<p>Interpreter는 **환경(environment)**에 함수를 바인딩한다. <code>LetRec</code>은 “재귀 바인딩“을 만든다 - 함수 본체가 평가되기 전에 환경에 자기 자신이 포함된다.</p>
<p><strong>Compiler에서 재귀 (FunLang MLIR):</strong></p>
<pre><code class="language-fsharp">// 컴파일
let compileFuncDef builder moduleDef (FunDef(name, params, body)) =
    // 1. 함수 생성 (func.func @name)
    let funcOp = builder.CreateFuncOp(name, paramTypes, returnType)

    // 2. 본체 컴파일
    let bodyValue = compileExpr builder env body

    // 3. 반환
    builder.CreateFuncReturn(bodyValue)

    // 4. 모듈에 추가
    moduleDef.AddFunction(funcOp)
</code></pre>
<p>Compiler는 <strong>심볼 테이블</strong>을 사용한다:</p>
<ul>
<li>함수가 <code>func.func</code> 연산으로 모듈에 추가되면, 심볼 <code>@name</code>이 등록된다</li>
<li>본체를 컴파일할 때 <code>func.call @name</code>을 만나면, 심볼 테이블에서 <code>@name</code>을 찾는다</li>
<li>심볼이 존재하므로 (자기 자신) 호출이 성공한다</li>
</ul>
<p><strong>차이점:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>측면</th><th>Interpreter</th><th>Compiler</th></tr>
</thead>
<tbody>
<tr><td>함수 저장</td><td>환경 (Map&lt;string, Value&gt;)</td><td>모듈 심볼 테이블</td></tr>
<tr><td>재귀 메커니즘</td><td>재귀 클로저 (self-reference in closure)</td><td>심볼 참조 (symbol reference)</td></tr>
<tr><td>평가 시점</td><td>런타임 (함수 호출할 때마다 환경 검색)</td><td>컴파일 타임 (심볼 확인) + 런타임 (call instruction)</td></tr>
<tr><td>Forward declaration</td><td>불필요 (LetRec이 재귀 환경 생성)</td><td>불필요 (모듈 레벨 심볼은 정의 순서 무관)</td></tr>
</tbody>
</table>
</div>
<p><strong>핵심:</strong> Interpreter는 환경을 사용하고, Compiler는 심볼을 사용한다. 둘 다 재귀를 지원하지만, 메커니즘이 다르다.</p>
<h3 id="컴파일-타임-심볼-확인"><a class="header" href="#컴파일-타임-심볼-확인">컴파일 타임 심볼 확인</a></h3>
<p>MLIR은 <strong>static symbol resolution</strong>을 수행한다:</p>
<pre><code class="language-mlir">// 잘못된 IR - verifier가 거부
func.func @foo(%n: i32) -&gt; i32 {
  %result = func.call @bar(%n) : (i32) -&gt; i32
  //                     ↑ @bar가 모듈에 없음!
  func.return %result : i32
}
</code></pre>
<p>MLIR verifier (<code>mlirOperationVerify</code>)는 심볼 참조를 검증한다:</p>
<ul>
<li><code>@bar</code> 심볼이 모듈에 존재하는가?</li>
<li>타입이 <code>(i32) -&gt; i32</code>와 호환되는가?</li>
</ul>
<p>검증 실패 시 에러:</p>
<pre><code>error: 'func.call' op 'bar' does not reference a valid function
</code></pre>
<p><strong>재귀 함수는 자연스럽게 통과:</strong></p>
<pre><code class="language-mlir">func.func @factorial(%n: i32) -&gt; i32 {
  // ...
  %rec = func.call @factorial(%n_minus_1) : (i32) -&gt; i32
  // ✓ @factorial은 모듈에 존재 (자기 자신)
  // ✓ 타입 (i32) -&gt; i32 일치
  // ...
}
</code></pre>
<p>Verifier는 심볼 존재만 확인한다. “자기 자신 호출“을 특별히 처리하지 않는다.</p>
<h3 id="mlir-ir-예시-factorial-자기-참조"><a class="header" href="#mlir-ir-예시-factorial-자기-참조">MLIR IR 예시: Factorial 자기 참조</a></h3>
<pre><code class="language-mlir">module {
  func.func @factorial(%arg0: i32) -&gt; i32 {
    %c1 = arith.constant 1 : i32
    %cmp = arith.cmpi sle, %arg0, %c1 : i32
    %result = scf.if %cmp -&gt; (i32) {
      scf.yield %c1 : i32
    } else {
      %n_minus_1 = arith.subi %arg0, %c1 : i32
      %rec = func.call @factorial(%n_minus_1) : (i32) -&gt; i32
      //                ↑ 자기 자신 호출
      %product = arith.muli %arg0, %rec : i32
      scf.yield %product : i32
    }
    func.return %result : i32
  }
}
</code></pre>
<p><strong>실행 시퀀스 (factorial 5):</strong></p>
<ol>
<li><code>@factorial</code>이 5로 호출됨</li>
<li>조건 확인: <code>5 &lt;= 1</code>? → false</li>
<li>else 블록 실행:
<ul>
<li><code>n_minus_1 = 5 - 1 = 4</code></li>
<li><code>rec = func.call @factorial(4)</code> ← <strong>재귀 호출</strong></li>
</ul>
</li>
<li>이제 <strong>새로운 스택 프레임</strong>에서 <code>@factorial(4)</code> 실행</li>
<li>조건 확인: <code>4 &lt;= 1</code>? → false</li>
<li>else 블록 실행:
<ul>
<li><code>n_minus_1 = 4 - 1 = 3</code></li>
<li><code>rec = func.call @factorial(3)</code> ← <strong>재귀 호출</strong></li>
</ul>
</li>
<li>… (계속)</li>
</ol>
<p>재귀 호출마다 새로운 스택 프레임이 생성된다. 각 프레임은 독립적인 <code>%arg0</code>, <code>%n_minus_1</code>, <code>%rec</code> 값을 가진다.</p>
<p><strong>핵심:</strong> 심볼 참조 <code>@factorial</code>은 컴파일 타임에 확인되고, 런타임에 <code>call</code> instruction으로 실행된다. LLVM이 스택 프레임 관리를 처리한다.</p>
<h2 id="재귀-함수-factorial"><a class="header" href="#재귀-함수-factorial">재귀 함수: Factorial</a></h2>
<h3 id="factorial-정의"><a class="header" href="#factorial-정의">Factorial 정의</a></h3>
<p><strong>수학적 정의:</strong></p>
<pre><code>factorial(n) = n! = n × (n-1) × (n-2) × ... × 2 × 1

예시:
  5! = 5 × 4 × 3 × 2 × 1 = 120
  3! = 3 × 2 × 1 = 6
  1! = 1
  0! = 1 (정의에 의해)
</code></pre>
<p><strong>재귀적 정의:</strong></p>
<pre><code>factorial(n) = {
  1                        if n &lt;= 1  (base case)
  n × factorial(n - 1)     if n &gt; 1   (recursive case)
}
</code></pre>
<p>기저 사례(base case): <code>n &lt;= 1</code>일 때 <code>1</code> 반환. 재귀 종료 조건.
재귀 사례(recursive case): <code>n × factorial(n - 1)</code>. 자기 자신을 더 작은 입력으로 호출.</p>
<p><strong>FunLang 소스:</strong></p>
<pre><code class="language-fsharp">let rec factorial n =
    if n &lt;= 1 then 1
    else n * factorial (n - 1)
</code></pre>
<h3 id="ast-표현-1"><a class="header" href="#ast-표현-1">AST 표현</a></h3>
<p>Chapter 10에서 정의한 AST:</p>
<pre><code class="language-fsharp">type Expr =
    | Num of int
    | Var of string
    | BinOp of Expr * Operator * Expr
    | If of Expr * Expr * Expr
    | Let of string * Expr * Expr
    | App of string * Expr list    // 함수 호출

type FunDef =
    | FunDef of string * string list * Expr

type Program =
    | Program of FunDef list * Expr
</code></pre>
<p><strong>factorial의 AST:</strong></p>
<pre><code class="language-fsharp">FunDef("factorial",
       ["n"],
       If(BinOp(Var "n", Le, Num 1),
          Num 1,
          BinOp(Var "n",
                Mul,
                App("factorial", [BinOp(Var "n", Sub, Num 1)]))))
</code></pre>
<p><strong>주목할 점:</strong></p>
<ul>
<li><code>App("factorial", ...)</code>: 함수 호출. 자기 자신을 호출한다.</li>
<li>기존 AST로 충분하다. <code>LetRec</code> 같은 새로운 AST 노드가 필요 없다.</li>
<li><code>FunDef</code>는 이미 모듈 레벨 함수를 표현한다. 이름으로 자기 참조가 가능하다.</li>
</ul>
<h3 id="컴파일-전략"><a class="header" href="#컴파일-전략">컴파일 전략</a></h3>
<p><strong>Chapter 10의 compileFuncDef 재사용:</strong></p>
<pre><code class="language-fsharp">let compileFuncDef (builder: OpBuilder) (moduleDef: ModuleOp) (FunDef(name, params, body)) =
    // 1. 함수 타입 생성
    let paramTypes = List.replicate params.Length builder.GetI32Type()
    let returnType = builder.GetI32Type()
    let funcType = builder.GetFunctionType(paramTypes, returnType)

    // 2. func.func 생성
    let funcOp = builder.CreateFuncOp(name, funcType)

    // 3. Entry block 생성 및 파라미터 가져오기
    let entryBlock = funcOp.GetEntryBlock()
    builder.SetInsertionPointToEnd(entryBlock)

    // 4. 환경 구축: 파라미터를 환경에 추가
    let env =
        params
        |&gt; List.mapi (fun i paramName -&gt;
            let argValue = entryBlock.GetArgument(i)
            (paramName, argValue))
        |&gt; Map.ofList

    // 5. 본체 컴파일
    let bodyValue = compileExpr builder env body

    // 6. 반환
    builder.CreateFuncReturn(bodyValue)

    // 7. 모듈에 추가
    moduleDef.AddFunction(funcOp)
</code></pre>
<p><strong>재귀 호출 처리 (compileExpr의 App case):</strong></p>
<pre><code class="language-fsharp">let rec compileExpr (builder: OpBuilder) (env: Map&lt;string, MlirValue&gt;) (expr: Expr) =
    match expr with
    | App(funcName, args) -&gt;
        // 1. 인자 컴파일
        let argValues = args |&gt; List.map (compileExpr builder env)

        // 2. 함수 호출
        builder.CreateFuncCall(funcName, argValues)
    // ... other cases
</code></pre>
<p><strong>핵심:</strong></p>
<ul>
<li><code>App("factorial", [arg])</code>를 만나면 <code>CreateFuncCall("factorial", [argValue])</code></li>
<li><code>CreateFuncCall</code>은 <code>func.call @factorial(%arg) : (i32) -&gt; i32</code> 생성</li>
<li>심볼 <code>@factorial</code>이 모듈에 존재 (자기 자신)</li>
<li>재귀 호출 완료!</li>
</ul>
<p><strong>재귀 함수 컴파일에 특별한 처리가 필요 없다.</strong> 일반 함수 호출과 동일하게 처리된다.</p>
<h3 id="완전한-mlir-ir-출력"><a class="header" href="#완전한-mlir-ir-출력">완전한 MLIR IR 출력</a></h3>
<pre><code class="language-mlir">module {
  func.func @factorial(%arg0: i32) -&gt; i32 {
    // if n &lt;= 1
    %c1 = arith.constant 1 : i32
    %cmp = arith.cmpi sle, %arg0, %c1 : i32

    // scf.if with two branches
    %result = scf.if %cmp -&gt; (i32) {
      // then: return 1
      scf.yield %c1 : i32
    } else {
      // else: return n * factorial(n - 1)

      // n - 1
      %n_minus_1 = arith.subi %arg0, %c1 : i32

      // factorial(n - 1) - 재귀 호출!
      %rec = func.call @factorial(%n_minus_1) : (i32) -&gt; i32

      // n * factorial(n - 1)
      %product = arith.muli %arg0, %rec : i32

      scf.yield %product : i32
    }

    func.return %result : i32
  }
}
</code></pre>
<p><strong>구조:</strong></p>
<ol>
<li><strong>조건 평가:</strong> <code>%cmp = arith.cmpi sle, %arg0, %c1</code> (n &lt;= 1?)</li>
<li><strong>scf.if 분기:</strong>
<ul>
<li><strong>then 블록:</strong> <code>scf.yield %c1</code> (기저 사례: 1 반환)</li>
<li><strong>else 블록:</strong>
<ul>
<li><code>%n_minus_1 = arith.subi %arg0, %c1</code> (n - 1 계산)</li>
<li><code>%rec = func.call @factorial(%n_minus_1)</code> (<strong>재귀 호출</strong>)</li>
<li><code>%product = arith.muli %arg0, %rec</code> (n * 재귀 결과)</li>
<li><code>scf.yield %product</code> (재귀 사례: n * factorial(n-1))</li>
</ul>
</li>
</ul>
</li>
<li><strong>반환:</strong> <code>func.return %result</code></li>
</ol>
<h3 id="단계별-실행-추적"><a class="header" href="#단계별-실행-추적">단계별 실행 추적</a></h3>
<p><strong>factorial 5 실행 과정:</strong></p>
<pre><code>1. factorial(5) 호출
   ├─ 조건: 5 &lt;= 1? → false
   ├─ else 블록 진입
   ├─ n_minus_1 = 5 - 1 = 4
   ├─ factorial(4) 호출 ← 재귀
   │  ├─ 조건: 4 &lt;= 1? → false
   │  ├─ else 블록 진입
   │  ├─ n_minus_1 = 4 - 1 = 3
   │  ├─ factorial(3) 호출 ← 재귀
   │  │  ├─ 조건: 3 &lt;= 1? → false
   │  │  ├─ else 블록 진입
   │  │  ├─ n_minus_1 = 3 - 1 = 2
   │  │  ├─ factorial(2) 호출 ← 재귀
   │  │  │  ├─ 조건: 2 &lt;= 1? → false
   │  │  │  ├─ else 블록 진입
   │  │  │  ├─ n_minus_1 = 2 - 1 = 1
   │  │  │  ├─ factorial(1) 호출 ← 재귀
   │  │  │  │  ├─ 조건: 1 &lt;= 1? → true
   │  │  │  │  └─ then 블록: return 1 ← 기저 사례!
   │  │  │  ├─ rec = 1
   │  │  │  ├─ product = 2 * 1 = 2
   │  │  │  └─ return 2
   │  │  ├─ rec = 2
   │  │  ├─ product = 3 * 2 = 6
   │  │  └─ return 6
   │  ├─ rec = 6
   │  ├─ product = 4 * 6 = 24
   │  └─ return 24
   ├─ rec = 24
   ├─ product = 5 * 24 = 120
   └─ return 120

최종 결과: 120
</code></pre>
<p><strong>호출 깊이 (Call depth):</strong> 5</p>
<p>각 재귀 호출은 새로운 스택 프레임을 생성한다. <code>factorial(5)</code>는 5개의 스택 프레임을 사용한다.</p>
<h3 id="lowered-llvm-ir"><a class="header" href="#lowered-llvm-ir">Lowered LLVM IR</a></h3>
<p>MLIR IR을 LLVM IR로 변환하면 (<code>mlir-opt --convert-scf-to-cf --convert-func-to-llvm --convert-arith-to-llvm</code>):</p>
<pre><code class="language-llvm">define i32 @factorial(i32 %0) {
entry:
  %1 = icmp sle i32 %0, 1
  br i1 %1, label %then, label %else

then:
  br label %merge

else:
  %2 = sub i32 %0, 1
  %3 = call i32 @factorial(i32 %2)  ; 재귀 호출 (call instruction)
  %4 = mul i32 %0, %3
  br label %merge

merge:
  %5 = phi i32 [ 1, %then ], [ %4, %else ]
  ret i32 %5
}
</code></pre>
<p><strong>주목할 점:</strong></p>
<ul>
<li><code>call i32 @factorial(i32 %2)</code>: LLVM IR의 재귀 호출</li>
<li>각 호출은 스택 프레임을 생성한다 (LLVM runtime이 처리)</li>
<li>PHI 노드 (<code>phi i32 [ 1, %then ], [ %4, %else ]</code>)는 scf.if의 lowering 결과</li>
</ul>
<p><strong>Native 코드로 컴파일:</strong></p>
<pre><code class="language-bash">mlir-translate --mlir-to-llvmir factorial.mlir &gt; factorial.ll
llc -filetype=obj factorial.ll -o factorial.o
gcc -o factorial factorial.o runtime.o -lgc
./factorial
</code></pre>
<h2 id="재귀-함수-fibonacci"><a class="header" href="#재귀-함수-fibonacci">재귀 함수: Fibonacci</a></h2>
<h3 id="fibonacci-정의"><a class="header" href="#fibonacci-정의">Fibonacci 정의</a></h3>
<p><strong>수학적 정의:</strong></p>
<pre><code>fibonacci(n) = {
  n                                if n &lt;= 1  (base case)
  fibonacci(n-1) + fibonacci(n-2)  if n &gt; 1   (recursive case)
}

수열:
  fib(0) = 0
  fib(1) = 1
  fib(2) = fib(1) + fib(0) = 1 + 0 = 1
  fib(3) = fib(2) + fib(1) = 1 + 1 = 2
  fib(4) = fib(3) + fib(2) = 2 + 1 = 3
  fib(5) = fib(4) + fib(3) = 3 + 2 = 5
  fib(6) = fib(5) + fib(4) = 5 + 3 = 8
</code></pre>
<p><strong>FunLang 소스:</strong></p>
<pre><code class="language-fsharp">let rec fib n =
    if n &lt;= 1 then n
    else fib (n - 1) + fib (n - 2)
</code></pre>
<h3 id="double-recursion-패턴"><a class="header" href="#double-recursion-패턴">Double Recursion 패턴</a></h3>
<p>Factorial은 <strong>단일 재귀(single recursion)</strong>: 한 번만 자기 자신을 호출.
Fibonacci는 <strong>이중 재귀(double recursion)</strong>: 두 번 자기 자신을 호출.</p>
<pre><code class="language-fsharp">fib (n - 1) + fib (n - 2)
//  ↑             ↑
// 첫 번째 호출   두 번째 호출
</code></pre>
<p><strong>함의:</strong></p>
<ul>
<li>각 재귀 호출이 또 다른 두 개의 호출을 만든다</li>
<li>호출 트리가 <strong>지수적으로 증가</strong>한다</li>
</ul>
<p><strong>fib(5)의 호출 트리:</strong></p>
<pre><code>                    fib(5)
                   /      \
              fib(4)      fib(3)
             /     \      /     \
        fib(3)   fib(2) fib(2) fib(1)
        /   \    /   \  /   \
    fib(2) fib(1) fib(1) fib(0) fib(1) fib(0)
    /   \
fib(1) fib(0)
</code></pre>
<p><strong>호출 횟수:</strong> <code>fib(5)</code>를 계산하기 위해 15번의 함수 호출이 발생한다.</p>
<p><strong>시간 복잡도:</strong> O(2^n) - 지수 시간. <code>fib(30)</code> ≈ 20억 번 호출!</p>
<h3 id="컴파일-두-개의-funccall"><a class="header" href="#컴파일-두-개의-funccall">컴파일: 두 개의 func.call</a></h3>
<pre><code class="language-mlir">func.func @fib(%arg0: i32) -&gt; i32 {
  // if n &lt;= 1
  %c1 = arith.constant 1 : i32
  %cmp = arith.cmpi sle, %arg0, %c1 : i32

  %result = scf.if %cmp -&gt; (i32) {
    // then: return n
    scf.yield %arg0 : i32
  } else {
    // else: return fib(n-1) + fib(n-2)

    // n - 1
    %n_minus_1 = arith.subi %arg0, %c1 : i32

    // fib(n - 1) - 첫 번째 재귀 호출
    %fib_n_1 = func.call @fib(%n_minus_1) : (i32) -&gt; i32

    // n - 2
    %c2 = arith.constant 2 : i32
    %n_minus_2 = arith.subi %arg0, %c2 : i32

    // fib(n - 2) - 두 번째 재귀 호출
    %fib_n_2 = func.call @fib(%n_minus_2) : (i32) -&gt; i32

    // fib(n-1) + fib(n-2)
    %sum = arith.addi %fib_n_1, %fib_n_2 : i32

    scf.yield %sum : i32
  }

  func.return %result : i32
}
</code></pre>
<p><strong>구조:</strong></p>
<ul>
<li><strong>else 블록에서 두 번의 func.call:</strong>
<ul>
<li><code>%fib_n_1 = func.call @fib(%n_minus_1)</code></li>
<li><code>%fib_n_2 = func.call @fib(%n_minus_2)</code></li>
</ul>
</li>
<li><strong>각 호출은 독립적:</strong> <code>%fib_n_1</code>이 완료된 후 <code>%fib_n_2</code> 실행</li>
<li><strong>결과를 더함:</strong> <code>%sum = arith.addi %fib_n_1, %fib_n_2</code></li>
</ul>
<p><strong>실행 순서 (eager evaluation):</strong></p>
<ol>
<li><code>%n_minus_1</code> 계산</li>
<li><code>func.call @fib(%n_minus_1)</code> 실행 → 결과를 <code>%fib_n_1</code>에 저장</li>
<li><code>%n_minus_2</code> 계산</li>
<li><code>func.call @fib(%n_minus_2)</code> 실행 → 결과를 <code>%fib_n_2</code>에 저장</li>
<li><code>%sum = %fib_n_1 + %fib_n_2</code> 계산</li>
</ol>
<h3 id="성능-문제"><a class="header" href="#성능-문제">성능 문제</a></h3>
<p><strong>지수 시간 복잡도:</strong></p>
<pre><code>fib(10) ≈ 177 호출
fib(20) ≈ 21,891 호출
fib(30) ≈ 2,692,537 호출
fib(40) ≈ 331,160,281 호출 (3억 번!)
</code></pre>
<p><strong>왜 느린가?</strong></p>
<p>중복 계산이 많다. <code>fib(5)</code>를 계산할 때 <code>fib(3)</code>을 두 번 계산하고, <code>fib(2)</code>를 세 번 계산한다.</p>
<pre><code>fib(5)
├─ fib(4)
│  ├─ fib(3) ← 첫 번째 fib(3)
│  └─ fib(2)
└─ fib(3) ← 두 번째 fib(3) (중복!)
   ├─ fib(2) ← 중복!
   └─ fib(1)
</code></pre>
<p><strong>최적화 방법 (Phase 3 범위 밖):</strong></p>
<ul>
<li><strong>Memoization:</strong> 이미 계산한 값을 저장 (hashtable 사용)</li>
<li><strong>Dynamic Programming:</strong> Bottom-up 방식으로 계산</li>
<li><strong>Tail recursion:</strong> 꼬리 재귀로 변환 (accumulator 사용)</li>
</ul>
<p>이 장에서는 <strong>순진한 재귀 구현</strong>만 다룬다. 최적화는 나중 단계에서 배운다.</p>
<p><strong>교훈:</strong> 재귀는 우아하지만, 항상 효율적이지는 않다. 알고리즘 선택이 중요하다.</p>
<h2 id="스택-프레임-관리-1"><a class="header" href="#스택-프레임-관리-1">스택 프레임 관리</a></h2>
<h3 id="스택-프레임이란"><a class="header" href="#스택-프레임이란">스택 프레임이란?</a></h3>
<p><strong>스택 프레임(stack frame)</strong> (또는 <strong>activation record</strong>)은 함수 호출에 필요한 정보를 저장하는 메모리 영역이다.</p>
<p><strong>스택 프레임에 포함되는 것:</strong></p>
<ol>
<li><strong>반환 주소(return address)</strong>: 함수가 끝나면 돌아갈 위치</li>
<li><strong>함수 파라미터</strong>: 호출자가 전달한 인자</li>
<li><strong>지역 변수</strong>: 함수 내부에서 선언된 변수</li>
<li><strong>저장된 레지스터</strong>: 호출 전 레지스터 상태 (ABI가 요구)</li>
<li><strong>임시 값</strong>: 중간 계산 결과 (SSA values)</li>
</ol>
<p><strong>함수 호출 시 스택 프레임 생성:</strong></p>
<pre><code>main()
  |
  ├─ factorial(5) 호출
  │    ├─ 스택 프레임 생성
  │    │    - return address: main의 다음 instruction
  │    │    - arg0 = 5
  │    │    - 지역 변수 공간
  │    ├─ factorial(4) 호출
  │    │    ├─ 새로운 스택 프레임 생성
  │    │    │    - return address: factorial(5)의 다음 instruction
  │    │    │    - arg0 = 4
  │    │    ├─ factorial(3) 호출
  │    │    │    └─ 또 다른 스택 프레임...
</code></pre>
<p><strong>스택 성장 방향:</strong></p>
<p>대부분의 플랫폼에서 스택은 <strong>아래로 성장</strong>한다 (높은 주소 → 낮은 주소):</p>
<pre><code>높은 주소
   ↓
 [main의 스택 프레임]
 [factorial(5)의 스택 프레임]  ← SP (Stack Pointer) 이동
 [factorial(4)의 스택 프레임]  ← SP 이동
 [factorial(3)의 스택 프레임]  ← SP 이동
 [factorial(2)의 스택 프레임]
 [factorial(1)의 스택 프레임]  ← SP (현재 위치)
   ↓
낮은 주소
</code></pre>
<p><strong>Stack Pointer (SP)</strong>: 스택의 현재 끝을 가리키는 레지스터. 함수 호출 시 SP가 아래로 이동.</p>
<h3 id="재귀-호출과-스택-깊이"><a class="header" href="#재귀-호출과-스택-깊이">재귀 호출과 스택 깊이</a></h3>
<p><strong>재귀 호출마다 새로운 스택 프레임:</strong></p>
<pre><code class="language-fsharp">factorial(5)
  ├─ 스택 프레임 1: arg0=5, return_addr=main
  ├─ factorial(4) 호출
  │  ├─ 스택 프레임 2: arg0=4, return_addr=factorial(5)
  │  ├─ factorial(3) 호출
  │  │  ├─ 스택 프레임 3: arg0=3, return_addr=factorial(4)
  │  │  ├─ factorial(2) 호출
  │  │  │  ├─ 스택 프레임 4: arg0=2, return_addr=factorial(3)
  │  │  │  ├─ factorial(1) 호출
  │  │  │  │  └─ 스택 프레임 5: arg0=1, return_addr=factorial(2)
  │  │  │  │     ├─ 기저 사례: return 1
  │  │  │  │     └─ 스택 프레임 5 소멸
  │  │  │  ├─ 반환값 1 받음, 2*1=2 계산, return 2
  │  │  │  └─ 스택 프레임 4 소멸
  │  │  ├─ 반환값 2 받음, 3*2=6 계산, return 6
  │  │  └─ 스택 프레임 3 소멸
  │  ├─ 반환값 6 받음, 4*6=24 계산, return 24
  │  └─ 스택 프레임 2 소멸
  ├─ 반환값 24 받음, 5*24=120 계산, return 120
  └─ 스택 프레임 1 소멸
</code></pre>
<p><strong>최대 스택 깊이:</strong> <code>factorial(5)</code>는 5개의 스택 프레임이 동시에 존재한다 (기저 사례에 도달했을 때).</p>
<p><strong>일반화:</strong> <code>factorial(n)</code>의 최대 스택 깊이는 <code>n</code>.</p>
<h3 id="스택-크기-제한"><a class="header" href="#스택-크기-제한">스택 크기 제한</a></h3>
<p><strong>운영체제는 스택 크기를 제한한다:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>플랫폼</th><th>기본 스택 크기</th></tr>
</thead>
<tbody>
<tr><td>Linux (x86-64)</td><td>8 MB</td></tr>
<tr><td>macOS</td><td>8 MB</td></tr>
<tr><td>Windows</td><td>1 MB</td></tr>
</tbody>
</table>
</div>
<p><strong>왜 제한이 필요한가?</strong></p>
<ul>
<li>무한 재귀를 방지</li>
<li>메모리 보호 (스택이 다른 메모리 영역을 침범하지 않도록)</li>
</ul>
<p><strong>스택 오버플로우(Stack Overflow):</strong></p>
<p>재귀 깊이가 너무 크면 스택 크기 한계에 도달한다:</p>
<pre><code class="language-fsharp">factorial(100000)
  ├─ 100,000개의 스택 프레임 필요
  ├─ 각 프레임이 ~64 bytes라고 가정
  ├─ 총 스택 사용: 100,000 * 64 = 6.4 MB
  └─ Linux에서는 OK (8MB 한계), Windows에서는 실패 (1MB 한계)
</code></pre>
<p><strong>스택 오버플로우 에러:</strong></p>
<pre><code class="language-bash">./factorial
Segmentation fault (core dumped)
# 또는
Stack overflow error
</code></pre>
<p><strong>해결책:</strong></p>
<ol>
<li><strong>재귀 깊이 제한:</strong> 입력 크기를 제한</li>
<li><strong>꼬리 호출 최적화(Tail Call Optimization):</strong> 스택 프레임 재사용</li>
<li><strong>반복(Iteration)으로 변환:</strong> Loop 사용 (함수형 언어에서는 덜 선호)</li>
<li><strong>Trampoline 기법:</strong> 재귀를 CPS(Continuation-Passing Style)로 변환</li>
</ol>
<p>이 장 후반부에서 꼬리 호출 최적화를 다룬다.</p>
<h3 id="llvm의-스택-프레임-관리"><a class="header" href="#llvm의-스택-프레임-관리">LLVM의 스택 프레임 관리</a></h3>
<p><strong>LLVM은 스택 프레임을 자동으로 관리한다:</strong></p>
<ol>
<li>
<p><strong>함수 프롤로그(prologue):</strong></p>
<ul>
<li>스택 포인터(SP) 감소 (스택 공간 할당)</li>
<li>프레임 포인터(FP) 저장</li>
<li>필요한 레지스터 저장 (callee-saved registers)</li>
</ul>
</li>
<li>
<p><strong>함수 에필로그(epilogue):</strong></p>
<ul>
<li>저장된 레지스터 복원</li>
<li>프레임 포인터 복원</li>
<li>스택 포인터 증가 (스택 공간 해제)</li>
<li>반환 (ret instruction)</li>
</ul>
</li>
</ol>
<p><strong>예시 (x86-64 어셈블리):</strong></p>
<pre><code class="language-asm">factorial:
  ; Prologue
  push    rbp              ; 이전 프레임 포인터 저장
  mov     rbp, rsp         ; 새로운 프레임 포인터 설정
  sub     rsp, 16          ; 지역 변수를 위한 스택 공간 할당

  ; Function body
  ; ... (factorial 계산)

  ; Epilogue
  add     rsp, 16          ; 스택 공간 해제
  pop     rbp              ; 이전 프레임 포인터 복원
  ret                      ; 반환 주소로 점프
</code></pre>
<p><strong>FunLang 컴파일러는 스택 관리를 직접 하지 않는다:</strong></p>
<ul>
<li>MLIR <code>func</code> 다이얼렉트로 함수 정의</li>
<li>LLVM이 lowering 과정에서 프롤로그/에필로그 생성</li>
<li>플랫폼별 calling convention 자동 적용 (System V ABI for Linux, Microsoft x64 for Windows)</li>
</ul>
<p><strong>이점:</strong></p>
<ul>
<li>플랫폼 독립적인 코드</li>
<li>ABI 호환성 자동 보장</li>
<li>최적화 (tail call elimination, frame pointer omission)</li>
</ul>
<h3 id="visualization-factorial-5의-스택"><a class="header" href="#visualization-factorial-5의-스택">Visualization: factorial 5의 스택</a></h3>
<p><strong>시간별 스택 상태:</strong></p>
<pre><code>시간 T1: main에서 factorial(5) 호출
┌──────────────────────┐
│ factorial(5)         │ ← SP
│  - arg0 = 5          │
│  - ret_addr = main+X │
├──────────────────────┤
│ main                 │
└──────────────────────┘

시간 T2: factorial(5)에서 factorial(4) 호출
┌──────────────────────┐
│ factorial(4)         │ ← SP
│  - arg0 = 4          │
│  - ret_addr = f(5)+Y │
├──────────────────────┤
│ factorial(5)         │
│  - arg0 = 5          │
├──────────────────────┤
│ main                 │
└──────────────────────┘

시간 T3: factorial(1) 도달 (최대 깊이)
┌──────────────────────┐
│ factorial(1)         │ ← SP (최대 깊이)
│  - arg0 = 1          │
├──────────────────────┤
│ factorial(2)         │
│  - arg0 = 2          │
├──────────────────────┤
│ factorial(3)         │
│  - arg0 = 3          │
├──────────────────────┤
│ factorial(4)         │
│  - arg0 = 4          │
├──────────────────────┤
│ factorial(5)         │
│  - arg0 = 5          │
├──────────────────────┤
│ main                 │
└──────────────────────┘

시간 T4: factorial(1) 반환 후 (1 반환)
┌──────────────────────┐
│ factorial(2)         │ ← SP
│  - arg0 = 2          │
│  - rec = 1           │
├──────────────────────┤
│ factorial(3)         │
├──────────────────────┤
│ factorial(4)         │
├──────────────────────┤
│ factorial(5)         │
├──────────────────────┤
│ main                 │
└──────────────────────┘

...

시간 T_final: 모든 호출 반환 완료
┌──────────────────────┐
│ main                 │ ← SP
│  - result = 120      │
└──────────────────────┘
</code></pre>
<p><strong>핵심:</strong></p>
<ul>
<li>재귀 호출마다 스택이 <strong>성장</strong>한다</li>
<li>기저 사례에 도달하면 스택이 <strong>수축</strong>하기 시작한다</li>
<li>각 반환은 이전 스택 프레임을 복원한다</li>
</ul>
<h3 id="스택-vs-힙"><a class="header" href="#스택-vs-힙">스택 vs 힙</a></h3>
<p><strong>Phase 2에서 배운 것:</strong></p>
<ul>
<li><strong>스택(Stack):</strong> 함수 로컬 값, LIFO, 자동 해제</li>
<li><strong>힙(Heap):</strong> 탈출하는 값(closures, data structures), 수동/GC 해제</li>
</ul>
<p><strong>Phase 3에서 함수는 스택만 사용:</strong></p>
<ul>
<li>파라미터: 스택 또는 레지스터 (calling convention)</li>
<li>반환 값: 레지스터 (작은 값) 또는 스택 (큰 구조체)</li>
<li>지역 변수: SSA values (레지스터 또는 스택 스필링)</li>
</ul>
<p><strong>Phase 4에서 클로저는 힙 사용:</strong></p>
<ul>
<li>클로저 환경: 힙에 할당 (GC_malloc)</li>
<li>클로저 포인터: 스택에 저장</li>
</ul>
<p><strong>연결:</strong></p>
<ul>
<li>Chapter 9 (Boehm GC)는 Phase 4를 위한 준비였다</li>
<li>Phase 3 함수는 GC를 사용하지 않는다 (메모리 할당 없음)</li>
<li>Phase 4 클로저에서 GC가 활성화된다</li>
</ul>
<h2 id="왜-스택-오버플로우가-발생하는가"><a class="header" href="#왜-스택-오버플로우가-발생하는가">왜 스택 오버플로우가 발생하는가</a></h2>
<h3 id="깊은-재귀의-위험"><a class="header" href="#깊은-재귀의-위험">깊은 재귀의 위험</a></h3>
<p><strong>문제:</strong></p>
<pre><code class="language-fsharp">factorial(100000)
</code></pre>
<p>이 호출은 100,000개의 스택 프레임을 생성한다. 각 프레임이 64 bytes라면:</p>
<pre><code>100,000 frames × 64 bytes/frame = 6,400,000 bytes = 6.4 MB
</code></pre>
<p>Linux 기본 스택 크기가 8 MB이므로 <strong>아슬아슬하게 성공</strong>할 수 있다. Windows (1 MB)에서는 <strong>확실히 실패</strong>한다.</p>
<p><strong>실제 테스트:</strong></p>
<pre><code class="language-bash"># factorial 100000 컴파일 및 실행
./factorial 100000
Segmentation fault
</code></pre>
<p><strong>왜 Segmentation fault?</strong></p>
<p>스택 포인터(SP)가 스택 크기 한계를 넘어서 <strong>guard page</strong>에 도달한다. Guard page는 스택 오버플로우 감지를 위한 특수 메모리 페이지로, 접근 시 segfault를 발생시킨다.</p>
<h3 id="최적화-없는-재귀"><a class="header" href="#최적화-없는-재귀">최적화 없는 재귀</a></h3>
<p><strong>일반 재귀 (Non-tail recursion):</strong></p>
<pre><code class="language-fsharp">let rec factorial n =
    if n &lt;= 1 then 1
    else n * factorial (n - 1)
         // ↑ 재귀 호출 후 곱셈이 남아있음
</code></pre>
<p>재귀 호출 후에 <strong>추가 작업</strong>(곱셈)이 있으므로:</p>
<ul>
<li>재귀 호출이 반환될 때까지 <strong>현재 스택 프레임을 유지</strong>해야 한다</li>
<li>반환 값을 받아서 <code>n</code>과 곱해야 한다</li>
<li>따라서 스택 프레임을 재사용할 수 없다</li>
</ul>
<p><strong>스택 프레임 누적:</strong></p>
<pre><code>factorial(5) 스택 프레임 유지 (n=5 저장 필요)
  factorial(4) 스택 프레임 유지 (n=4 저장 필요)
    factorial(3) 스택 프레임 유지 (n=3 저장 필요)
      factorial(2) 스택 프레임 유지 (n=2 저장 필요)
        factorial(1) 스택 프레임 생성
          return 1
        return 2 (= 2 * 1)
      return 6 (= 3 * 2)
    return 24 (= 4 * 6)
  return 120 (= 5 * 24)
</code></pre>
<p>모든 프레임이 동시에 존재해야 한다.</p>
<p><strong>결론:</strong> 일반 재귀는 스택 크기에 제한받는다.</p>
<h3 id="예시-factorial-100000은-왜-실패하는가"><a class="header" href="#예시-factorial-100000은-왜-실패하는가">예시: factorial 100000은 왜 실패하는가</a></h3>
<pre><code>스택 크기: 8 MB = 8,388,608 bytes
필요한 스택: 100,000 frames × 64 bytes = 6,400,000 bytes

6,400,000 &lt; 8,388,608 → 이론적으로 가능
</code></pre>
<p>하지만 실제로는:</p>
<ul>
<li><strong>다른 함수 프레임:</strong> main, runtime initialization</li>
<li><strong>스택 정렬 (alignment):</strong> 16-byte 정렬 요구사항</li>
<li><strong>추가 오버헤드:</strong> 레지스터 저장, guard page</li>
</ul>
<p>실제 사용 가능한 스택이 줄어든다. 그래서 6.4 MB도 실패할 수 있다.</p>
<p><strong>안전한 한계:</strong></p>
<p>대부분의 시스템에서 <strong>~5,000 - 10,000 깊이</strong>가 안전하다. 그 이상은 스택 오버플로우 위험.</p>
<p><strong>교훈:</strong> 깊은 재귀는 위험하다. 꼬리 호출 최적화가 필요하다.</p>
<h2 id="상호-재귀-mutual-recursion"><a class="header" href="#상호-재귀-mutual-recursion">상호 재귀 (Mutual Recursion)</a></h2>
<h3 id="상호-재귀란"><a class="header" href="#상호-재귀란">상호 재귀란?</a></h3>
<p>**상호 재귀(mutual recursion)**는 두 개 이상의 함수가 서로를 호출하는 패턴이다.</p>
<pre><code class="language-fsharp">// 함수 A가 함수 B를 호출하고,
// 함수 B가 함수 A를 호출한다.

let rec is_even n =
    if n = 0 then true
    else is_odd (n - 1)

let rec is_odd n =
    if n = 0 then false
    else is_even (n - 1)
</code></pre>
<p><strong>차이점:</strong></p>
<ul>
<li><strong>단순 재귀:</strong> 함수가 자기 자신을 호출 (<code>factorial</code> → <code>factorial</code>)</li>
<li><strong>상호 재귀:</strong> 함수 A가 함수 B를 호출, 함수 B가 함수 A를 호출 (<code>is_even</code> ⇄ <code>is_odd</code>)</li>
</ul>
<p><strong>왜 필요한가?</strong></p>
<p>어떤 문제는 자연스럽게 상호 재귀로 표현된다:</p>
<ul>
<li>짝수/홀수 판정</li>
<li>문법 파서 (expression → term → factor → expression)</li>
<li>상태 기계 (state A → state B → state A)</li>
</ul>
<h3 id="예시-is_even과-is_odd"><a class="header" href="#예시-is_even과-is_odd">예시: is_even과 is_odd</a></h3>
<p><strong>수학적 정의:</strong></p>
<pre><code>is_even(n) = {
  true                 if n = 0
  is_odd(n - 1)        if n &gt; 0
}

is_odd(n) = {
  false                if n = 0
  is_even(n - 1)       if n &gt; 0
}
</code></pre>
<p><strong>직관:</strong></p>
<ul>
<li>0은 짝수</li>
<li>n이 짝수인지 확인하려면: n-1이 홀수인지 확인</li>
<li>n이 홀수인지 확인하려면: n-1이 짝수인지 확인</li>
</ul>
<p><strong>FunLang 소스:</strong></p>
<pre><code class="language-fsharp">let rec is_even n =
    if n = 0 then true
    else is_odd (n - 1)

let rec is_odd n =
    if n = 0 then false
    else is_even (n - 1)
</code></pre>
<p><strong>실행 예시 (is_even 4):</strong></p>
<pre><code>is_even(4)
  ├─ 4 = 0? → false
  ├─ is_odd(3) 호출
  │  ├─ 3 = 0? → false
  │  ├─ is_even(2) 호출
  │  │  ├─ 2 = 0? → false
  │  │  ├─ is_odd(1) 호출
  │  │  │  ├─ 1 = 0? → false
  │  │  │  ├─ is_even(0) 호출
  │  │  │  │  ├─ 0 = 0? → true
  │  │  │  │  └─ return true
  │  │  │  └─ return true (is_even(0) = true)
  │  │  └─ return true (is_odd(1) = true)
  │  └─ return true (is_even(2) = true)
  └─ return true (is_odd(3) = true)

최종 결과: true (4는 짝수)
</code></pre>
<p><strong>호출 시퀀스:</strong> is_even → is_odd → is_even → is_odd → is_even</p>
<h3 id="모듈-레벨-심볼-테이블의-역할"><a class="header" href="#모듈-레벨-심볼-테이블의-역할">모듈 레벨 심볼 테이블의 역할</a></h3>
<p><strong>핵심:</strong> MLIR 모듈은 flat symbol namespace를 가진다. 모든 함수가 동시에 보인다.</p>
<pre><code class="language-mlir">module {
  func.func @is_even(%n: i32) -&gt; i1 { ... }
  func.func @is_odd(%n: i32) -&gt; i1 { ... }
}
</code></pre>
<p><strong>중요한 점:</strong></p>
<ul>
<li><strong>정의 순서는 무관:</strong> <code>is_even</code>이 먼저 정의되든, <code>is_odd</code>가 먼저 정의되든 상관없다.</li>
<li><strong>Forward declaration 불필요:</strong> C에서는 forward declaration이 필요하지만, MLIR에서는 필요 없다.</li>
<li><strong>모든 함수가 서로에게 보임:</strong> <code>is_even</code> 본체에서 <code>is_odd</code>를 참조할 수 있고, <code>is_odd</code> 본체에서 <code>is_even</code>을 참조할 수 있다.</li>
</ul>
<p><strong>C와 비교:</strong></p>
<pre><code class="language-c">// C에서는 forward declaration 필요
int is_odd(int n);  // forward declaration

int is_even(int n) {
    if (n == 0) return 1;
    else return is_odd(n - 1);
}

int is_odd(int n) {
    if (n == 0) return 0;
    else return is_even(n - 1);
}
</code></pre>
<p><strong>MLIR/FunLang에서는 불필요:</strong></p>
<pre><code class="language-mlir">// 정의 순서 무관 - 둘 다 작동
module {
  func.func @is_even(%n: i32) -&gt; i1 { ... func.call @is_odd ... }
  func.func @is_odd(%n: i32) -&gt; i1 { ... func.call @is_even ... }
}
</code></pre>
<h3 id="컴파일-크로스-참조-처리"><a class="header" href="#컴파일-크로스-참조-처리">컴파일: 크로스 참조 처리</a></h3>
<p><strong>상호 재귀 함수 컴파일:</strong></p>
<pre><code class="language-fsharp">let compileProgram (builder: OpBuilder) (moduleDef: ModuleOp) (Program(funcs, mainExpr)) =
    // 1. 모든 함수 정의를 모듈에 추가
    funcs |&gt; List.iter (compileFuncDef builder moduleDef)

    // 2. Main 표현식 컴파일
    let mainValue = compileExpr builder Map.empty mainExpr
    ...
</code></pre>
<p><strong>핵심 아이디어:</strong></p>
<ol>
<li><strong>모든 함수를 먼저 컴파일:</strong> 모듈에 <code>func.func</code> 연산 추가</li>
<li><strong>심볼 등록 자동:</strong> MLIR이 각 함수를 심볼 테이블에 등록</li>
<li><strong>본체 컴파일 시 심볼 참조:</strong> <code>func.call @is_odd</code> → 심볼 테이블에서 찾기</li>
</ol>
<p><strong>두 가지 접근법:</strong></p>
<p><strong>접근법 1: 순차 컴파일 (FunLang 사용)</strong></p>
<pre><code class="language-fsharp">// 함수를 하나씩 컴파일
funcs |&gt; List.iter (fun funcDef -&gt;
    compileFuncDef builder moduleDef funcDef
)
</code></pre>
<ul>
<li><code>is_even</code> 컴파일 시 본체에서 <code>func.call @is_odd</code> 생성</li>
<li><code>@is_odd</code> 심볼이 아직 등록 안 됨 → <strong>문제 없음!</strong></li>
<li>MLIR verifier는 <strong>모든 함수가 컴파일된 후</strong> 실행됨</li>
<li>Verifier가 실행될 때는 <code>@is_odd</code>도 이미 등록되어 있음</li>
</ul>
<p><strong>접근법 2: 스텁 먼저 생성 (대안)</strong></p>
<pre><code class="language-fsharp">// 1단계: 모든 함수 헤더만 생성 (body 없음)
funcs |&gt; List.iter (fun (FunDef(name, params, _)) -&gt;
    let funcOp = builder.CreateFuncStub(name, paramTypes, returnType)
    moduleDef.AddFunction(funcOp)
)

// 2단계: 모든 함수 본체 채우기
funcs |&gt; List.iter (fun (FunDef(name, params, body)) -&gt;
    let funcOp = moduleDef.GetFunction(name)
    compileFuncBody builder funcOp params body
)
</code></pre>
<ul>
<li>더 명시적이지만 복잡함</li>
<li>FunLang은 접근법 1 사용 (더 간단)</li>
</ul>
<p><strong>왜 작동하는가?</strong></p>
<p>MLIR의 <strong>lazy verification</strong>:</p>
<ul>
<li>함수를 컴파일하는 동안 심볼 참조는 검증하지 않음</li>
<li>모듈이 완성된 후 <code>mlirOperationVerify()</code>를 호출</li>
<li>그때 모든 심볼 참조 확인</li>
</ul>
<h3 id="완전한-mlir-ir-출력-1"><a class="header" href="#완전한-mlir-ir-출력-1">완전한 MLIR IR 출력</a></h3>
<pre><code class="language-mlir">module {
  // is_even 함수
  func.func @is_even(%arg0: i32) -&gt; i1 {
    %c0 = arith.constant 0 : i32
    %is_zero = arith.cmpi eq, %arg0, %c0 : i32

    %result = scf.if %is_zero -&gt; (i1) {
      // then: return true
      %true = arith.constant 1 : i1
      scf.yield %true : i1
    } else {
      // else: return is_odd(n - 1)
      %c1 = arith.constant 1 : i32
      %n_minus_1 = arith.subi %arg0, %c1 : i32

      // is_odd 호출 (상호 재귀!)
      %odd_result = func.call @is_odd(%n_minus_1) : (i32) -&gt; i1

      scf.yield %odd_result : i1
    }

    func.return %result : i1
  }

  // is_odd 함수
  func.func @is_odd(%arg0: i32) -&gt; i1 {
    %c0 = arith.constant 0 : i32
    %is_zero = arith.cmpi eq, %arg0, %c0 : i32

    %result = scf.if %is_zero -&gt; (i1) {
      // then: return false
      %false = arith.constant 0 : i1
      scf.yield %false : i1
    } else {
      // else: return is_even(n - 1)
      %c1 = arith.constant 1 : i32
      %n_minus_1 = arith.subi %arg0, %c1 : i32

      // is_even 호출 (상호 재귀!)
      %even_result = func.call @is_even(%n_minus_1) : (i32) -&gt; i1

      scf.yield %even_result : i1
    }

    func.return %result : i1
  }

  // Main 함수
  func.func @funlang_main() -&gt; i32 {
    %c4 = arith.constant 4 : i32
    %result_i1 = func.call @is_even(%c4) : (i32) -&gt; i1

    // i1 → i32 확장 (main 반환용)
    %result_i32 = arith.extui %result_i1 : i1 to i32

    func.return %result_i32 : i32
  }
}
</code></pre>
<p><strong>주목할 점:</strong></p>
<ul>
<li><code>@is_even</code>이 <code>func.call @is_odd</code> 사용</li>
<li><code>@is_odd</code>가 <code>func.call @is_even</code> 사용</li>
<li><strong>순환 참조(cyclic call graph)</strong> 형성</li>
<li>MLIR verifier가 허용 (심볼이 모두 존재)</li>
</ul>
<h3 id="실행-추적"><a class="header" href="#실행-추적">실행 추적</a></h3>
<p><strong>is_even(4) 호출:</strong></p>
<pre><code>is_even(4)
  ├─ 4 = 0? → false
  ├─ else 블록: is_odd(4 - 1) = is_odd(3)
  │  ├─ 3 = 0? → false
  │  ├─ else 블록: is_even(3 - 1) = is_even(2)
  │  │  ├─ 2 = 0? → false
  │  │  ├─ else 블록: is_odd(2 - 1) = is_odd(1)
  │  │  │  ├─ 1 = 0? → false
  │  │  │  ├─ else 블록: is_even(1 - 1) = is_even(0)
  │  │  │  │  ├─ 0 = 0? → true
  │  │  │  │  └─ then 블록: return true
  │  │  │  ├─ odd_result = true
  │  │  │  └─ return true
  │  │  ├─ even_result = true
  │  │  └─ return true
  │  ├─ odd_result = true
  │  └─ return true
  ├─ even_result = true
  └─ return true (i1), 확장하여 1 (i32) 반환
</code></pre>
<p><strong>호출 스택 깊이:</strong> 5 (is_even → is_odd → is_even → is_odd → is_even)</p>
<p><strong>상호 재귀의 스택 프레임:</strong></p>
<pre><code>┌──────────────────────┐
│ is_even(0)           │ ← 최대 깊이 (기저 사례)
├──────────────────────┤
│ is_odd(1)            │
├──────────────────────┤
│ is_even(2)           │
├──────────────────────┤
│ is_odd(3)            │
├──────────────────────┤
│ is_even(4)           │ ← 최초 호출
├──────────────────────┤
│ funlang_main         │
└──────────────────────┘
</code></pre>
<p>스택 프레임이 번갈아가며 생성된다: is_even → is_odd → is_even → …</p>
<h3 id="verifier의-심볼-검증"><a class="header" href="#verifier의-심볼-검증">Verifier의 심볼 검증</a></h3>
<p><strong>MLIR verifier는 모듈 완성 후 실행:</strong></p>
<pre><code class="language-fsharp">// 컴파일러 코드
let compileProgram moduleDef funcs mainExpr =
    // 1. 모든 함수 컴파일
    funcs |&gt; List.iter (compileFuncDef builder moduleDef)

    // 2. Main 컴파일
    let mainFunc = compileMain builder mainExpr
    moduleDef.AddFunction(mainFunc)

    // 3. Verify (모든 함수 추가 후)
    if not (mlirOperationVerify(moduleDef.GetOperation())) then
        failwith "Module verification failed"
</code></pre>
<p><strong>Verification 과정:</strong></p>
<ol>
<li><strong>심볼 수집:</strong> 모듈의 모든 <code>func.func</code> 연산에서 심볼 추출 (<code>@is_even</code>, <code>@is_odd</code>)</li>
<li><strong>심볼 참조 확인:</strong> 각 <code>func.call</code> 연산의 callee 확인
<ul>
<li><code>func.call @is_odd</code> → <code>@is_odd</code> 심볼이 존재하는가? <strong>예</strong></li>
<li><code>func.call @is_even</code> → <code>@is_even</code> 심볼이 존재하는가? <strong>예</strong></li>
</ul>
</li>
<li><strong>타입 검증:</strong> 호출 타입과 함수 타입 일치 확인
<ul>
<li><code>@is_even: (i32) -&gt; i1</code></li>
<li><code>func.call @is_even(%n_minus_1) : (i32) -&gt; i1</code> → <strong>일치</strong></li>
</ul>
</li>
</ol>
<p><strong>실패 케이스 (존재하지 않는 함수 호출):</strong></p>
<pre><code class="language-mlir">func.func @foo(%n: i32) -&gt; i1 {
  %result = func.call @nonexistent(%n) : (i32) -&gt; i1
  //                    ↑ 모듈에 없음
  func.return %result : i1
}
</code></pre>
<p>Verifier 에러:</p>
<pre><code>error: 'func.call' op 'nonexistent' does not reference a valid function
</code></pre>
<p><strong>상호 재귀는 통과:</strong> 모든 심볼이 존재하므로 검증 성공.</p>
<h3 id="funlang-interpreter와의-차이"><a class="header" href="#funlang-interpreter와의-차이">FunLang Interpreter와의 차이</a></h3>
<p><strong>Interpreter에서 상호 재귀:</strong></p>
<pre><code class="language-fsharp">// FunLang interpreter (LangTutorial)
let rec eval env ast =
    match ast with
    | LetRec(funcs, body) -&gt;
        // 재귀 환경 생성: 모든 함수를 env에 추가
        let rec_env =
            funcs |&gt; List.fold (fun e (name, func) -&gt;
                e.Add(name, RecursiveClosure(func, rec_env))
            ) env
        eval rec_env body
</code></pre>
<p><strong>문제:</strong></p>
<ul>
<li>환경이 재귀적으로 정의됨 (<code>rec_env</code>가 자기 자신을 참조)</li>
<li>F#의 <code>let rec</code> 또는 명시적인 mutation 필요</li>
</ul>
<p><strong>Compiler는 더 간단:</strong></p>
<ul>
<li>모듈 심볼 테이블이 자연스럽게 flat namespace 제공</li>
<li>순환 참조를 허용</li>
<li>Lazy verification으로 정의 순서 무관</li>
</ul>
<h2 id="꼬리-재귀와-꼬리-호출-최적화"><a class="header" href="#꼬리-재귀와-꼬리-호출-최적화">꼬리 재귀와 꼬리 호출 최적화</a></h2>
<h3 id="꼬리-위치-tail-position"><a class="header" href="#꼬리-위치-tail-position">꼬리 위치 (Tail Position)</a></h3>
<p>**꼬리 위치(tail position)**는 함수에서 <strong>마지막으로 실행되는 표현식의 위치</strong>다.</p>
<pre><code class="language-fsharp">let rec factorial n =
    if n &lt;= 1 then
        1           // ← 꼬리 위치 (then 분기의 마지막)
    else
        n * factorial (n - 1)
        //  ↑ factorial 호출은 꼬리 위치가 아님!
        //    호출 후 곱셈이 남아있음
</code></pre>
<p><strong>꼬리 위치 판단:</strong></p>
<ul>
<li>then 분기의 <code>1</code>: <strong>꼬리 위치</strong> (분기의 마지막 값)</li>
<li><code>factorial (n - 1)</code> 호출: <strong>꼬리 위치 아님</strong> (호출 후 <code>n *</code> 곱셈이 실행됨)</li>
<li><code>n * factorial(...)</code> 전체: <strong>꼬리 위치</strong> (else 분기의 마지막 값)</li>
</ul>
<p><strong>일반 규칙:</strong></p>
<p>함수 본체에서:</p>
<ul>
<li><code>if</code> then/else 각 분기의 마지막 표현식: 꼬리 위치</li>
<li><code>let x = ... in &lt;expr&gt;</code>: <code>&lt;expr&gt;</code>이 꼬리 위치</li>
<li>함수의 최상위 표현식: 꼬리 위치</li>
</ul>
<p><strong>꼬리 호출(tail call):</strong> 꼬리 위치에 있는 함수 호출.</p>
<pre><code class="language-fsharp">let rec countdown n =
    if n &lt;= 0 then
        0           // ← 꼬리 위치, 값 (호출 아님)
    else
        countdown (n - 1)
        // ↑ 꼬리 위치에 있는 호출 → 꼬리 호출!
</code></pre>
<p><code>countdown (n - 1)</code>은 else 분기의 마지막이고, 호출 후 추가 작업이 없다. <strong>꼬리 호출</strong>이다.</p>
<h3 id="꼬리-호출-최적화-tail-call-optimization"><a class="header" href="#꼬리-호출-최적화-tail-call-optimization">꼬리 호출 최적화 (Tail Call Optimization)</a></h3>
<p>**꼬리 호출 최적화(TCO, Tail Call Optimization)**는 꼬리 호출을 **점프(jump)**로 변환하여 스택 프레임을 재사용하는 최적화다.</p>
<p><strong>일반 재귀 (TCO 없음):</strong></p>
<pre><code>factorial(5)
  ├─ 스택 프레임 1 생성
  ├─ factorial(4) 호출
  │  ├─ 스택 프레임 2 생성
  │  ├─ factorial(3) 호출
  │  │  └─ ... (스택 누적)
  │  ├─ 반환 후 n * result 계산 ← 추가 작업
  │  └─ 스택 프레임 2 해제
  ├─ 반환 후 n * result 계산
  └─ 스택 프레임 1 해제
</code></pre>
<p><strong>꼬리 재귀 (TCO 사용):</strong></p>
<pre><code>countdown(5)
  ├─ 스택 프레임 1 생성
  ├─ countdown(4) 호출 → 점프로 변환!
  │    (스택 프레임 1 재사용, n 값만 업데이트)
  ├─ countdown(3) 호출 → 점프
  ├─ countdown(2) 호출 → 점프
  ├─ countdown(1) 호출 → 점프
  ├─ countdown(0) 호출 → 점프
  └─ 기저 사례: return 0
     (스택 프레임 1 해제)
</code></pre>
<p><strong>핵심 차이:</strong></p>
<ul>
<li><strong>일반 재귀:</strong> 각 호출마다 스택 프레임 생성. 깊이 N → N개 프레임.</li>
<li><strong>꼬리 재귀 + TCO:</strong> 단일 스택 프레임 재사용. 깊이 N → 1개 프레임.</li>
</ul>
<p><strong>왜 가능한가?</strong></p>
<p>꼬리 호출은 “호출 후 돌아올 필요가 없다”:</p>
<ul>
<li>현재 함수는 호출 결과를 그대로 반환</li>
<li>현재 스택 프레임에 남은 작업이 없음</li>
<li>따라서 현재 프레임을 버리고, 새 프레임으로 점프할 수 있음</li>
</ul>
<h3 id="꼬리-재귀-변환-factorial"><a class="header" href="#꼬리-재귀-변환-factorial">꼬리 재귀 변환: Factorial</a></h3>
<p><strong>일반 재귀 factorial (non-tail):</strong></p>
<pre><code class="language-fsharp">let rec factorial n =
    if n &lt;= 1 then 1
    else n * factorial (n - 1)
         // ↑ 호출 후 곱셈 → 꼬리 호출 아님
</code></pre>
<p><strong>꼬리 재귀 factorial:</strong></p>
<pre><code class="language-fsharp">let rec factorial_tail n acc =
    if n &lt;= 1 then acc
    else factorial_tail (n - 1) (n * acc)
         // ↑ 호출이 마지막 → 꼬리 호출!
</code></pre>
<p><strong>차이점:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>측면</th><th>일반 재귀</th><th>꼬리 재귀</th></tr>
</thead>
<tbody>
<tr><td>Accumulator</td><td>없음</td><td><code>acc</code> 파라미터</td></tr>
<tr><td>곱셈 위치</td><td>호출 <strong>후</strong> (<code>n * result</code>)</td><td>호출 <strong>전</strong> (<code>n * acc</code>)</td></tr>
<tr><td>반환값</td><td>재귀 호출 결과를 변환</td><td>재귀 호출 결과 그대로</td></tr>
<tr><td>꼬리 호출</td><td>아님</td><td>맞음</td></tr>
</tbody>
</table>
</div>
<p><strong>Accumulator 패턴:</strong></p>
<p>꼬리 재귀는 <strong>accumulator</strong>를 사용하여 중간 결과를 전달한다:</p>
<pre><code>factorial_tail(5, 1)
  → factorial_tail(4, 5*1=5)
    → factorial_tail(3, 4*5=20)
      → factorial_tail(2, 3*20=60)
        → factorial_tail(1, 2*60=120)
          → return 120
</code></pre>
<p><strong>Wrapper 함수:</strong></p>
<p>사용자는 accumulator를 모르므로, wrapper 함수 제공:</p>
<pre><code class="language-fsharp">let factorial n =
    factorial_tail n 1
</code></pre>
<h3 id="mlirllvm에서-tco"><a class="header" href="#mlirllvm에서-tco">MLIR/LLVM에서 TCO</a></h3>
<p><strong>LLVM의 꼬리 호출 최적화:</strong></p>
<p>LLVM은 특정 조건에서 꼬리 호출을 최적화할 수 있다:</p>
<ol>
<li><strong>함수 속성 (function attribute):</strong> <code>"tailcc"</code> calling convention</li>
<li><strong>최적화 플래그:</strong> <code>-tailcallopt</code></li>
<li><strong>타겟 지원:</strong> 플랫폼이 TCO를 지원해야 함 (대부분의 x86-64, ARM은 지원)</li>
</ol>
<p><strong>MLIR IR에서 꼬리 호출 표시:</strong></p>
<p>MLIR <code>func</code> 다이얼렉트는 TCO를 명시적으로 표시하는 속성이 없다. 대신:</p>
<ul>
<li>LLVM dialect로 낮춘 후 <code>tail</code> 속성 추가</li>
<li>또는 LLVM 최적화 패스에 의존</li>
</ul>
<p><strong>Lowered LLVM IR (꼬리 호출 속성):</strong></p>
<pre><code class="language-llvm">define i32 @factorial_tail(i32 %n, i32 %acc) {
entry:
  %cmp = icmp sle i32 %n, 1
  br i1 %cmp, label %base, label %rec

base:
  ret i32 %acc

rec:
  %n_minus_1 = sub i32 %n, 1
  %new_acc = mul i32 %n, %acc
  ; tail 키워드 → TCO 힌트
  %result = tail call i32 @factorial_tail(i32 %n_minus_1, i32 %new_acc)
  ret i32 %result
}
</code></pre>
<p><strong><code>tail call</code>의 의미:</strong></p>
<ul>
<li>“이 호출은 꼬리 호출입니다”</li>
<li>LLVM 최적화 패스가 이를 점프로 변환 가능</li>
<li><code>-tailcallopt</code> 플래그와 함께 사용</li>
</ul>
<p><strong>FunLang Phase 3에서 TCO:</strong></p>
<p>Phase 3에서는 <strong>TCO를 보장하지 않는다</strong>:</p>
<ul>
<li>교육 목적: 재귀의 기본 개념 먼저 이해</li>
<li>LLVM이 자동으로 최적화할 <strong>수</strong> 있지만, 보장되지 않음</li>
<li>Phase 7 (최적화)에서 명시적 TCO 지원 추가 예정</li>
</ul>
<p><strong>현재 동작:</strong></p>
<pre><code class="language-fsharp">// FunLang 소스
let rec factorial_tail n acc =
    if n &lt;= 1 then acc
    else factorial_tail (n - 1) (n * acc)

// MLIR IR
func.func @factorial_tail(%arg0: i32, %arg1: i32) -&gt; i32 {
  // ... if 조건
  %result = scf.if %cmp -&gt; (i32) {
    scf.yield %arg1 : i32
  } else {
    %n_minus_1 = arith.subi %arg0, %c1 : i32
    %new_acc = arith.muli %arg0, %arg1 : i32
    %rec = func.call @factorial_tail(%n_minus_1, %new_acc) : (i32, i32) -&gt; i32
    // ↑ 일반 func.call (tail 속성 없음)
    scf.yield %rec : i32
  }
  func.return %result : i32
}
</code></pre>
<p><strong>LLVM이 최적화할 수 있음 (보장 안 됨):</strong></p>
<ul>
<li>LLVM <code>-O2</code> 또는 <code>-O3</code> 최적화 레벨</li>
<li>일부 경우 자동으로 TCO 적용</li>
<li>하지만 C calling convention에서는 보장되지 않음</li>
</ul>
<h3 id="tco-활성화-방법-preview"><a class="header" href="#tco-활성화-방법-preview">TCO 활성화 방법 (Preview)</a></h3>
<p><strong>Phase 7에서 다룰 내용 (Preview):</strong></p>
<ol>
<li><strong><code>tailcc</code> calling convention 사용:</strong></li>
</ol>
<pre><code class="language-llvm">define tailcc i32 @factorial_tail(i32 %n, i32 %acc) {
  ; tailcc = 꼬리 호출 최적화에 특화된 calling convention
  ...
  %result = tail call tailcc i32 @factorial_tail(i32 %n_minus_1, i32 %new_acc)
  ret i32 %result
}
</code></pre>
<ol start="2">
<li><strong>Compiler 플래그:</strong></li>
</ol>
<pre><code class="language-bash">llc -tailcallopt factorial.ll -o factorial.s
</code></pre>
<ol start="3">
<li><strong>함수 속성:</strong></li>
</ol>
<p>MLIR에서 LLVM dialect로 낮출 때 함수 속성 추가:</p>
<ul>
<li><code>llvm.func @factorial_tail ... attributes { tail = true }</code></li>
</ul>
<p><strong>현재 (Phase 3):</strong></p>
<ul>
<li>꼬리 재귀 패턴을 이해</li>
<li>accumulator 사용법 배우기</li>
<li>LLVM의 자동 최적화에 의존</li>
<li>Phase 7에서 명시적 제어 추가</li>
</ul>
<h2 id="코드-생성-업데이트"><a class="header" href="#코드-생성-업데이트">코드 생성 업데이트</a></h2>
<h3 id="compilefuncdef-재사용"><a class="header" href="#compilefuncdef-재사용">compileFuncDef 재사용</a></h3>
<p><strong>좋은 소식:</strong> 재귀 함수를 위한 특별한 코드 생성이 <strong>필요 없다</strong>.</p>
<p>Chapter 10의 <code>compileFuncDef</code>를 그대로 사용:</p>
<pre><code class="language-fsharp">let compileFuncDef (builder: OpBuilder) (moduleDef: ModuleOp) (FunDef(name, params, body)) =
    // 1. 함수 타입 생성
    let paramTypes = List.replicate params.Length builder.GetI32Type()
    let returnType = builder.GetI32Type()
    let funcType = builder.GetFunctionType(paramTypes, returnType)

    // 2. func.func 생성
    let funcOp = builder.CreateFuncOp(name, funcType)

    // 3. Entry block에서 파라미터 가져오기
    let entryBlock = funcOp.GetEntryBlock()
    builder.SetInsertionPointToEnd(entryBlock)

    let env =
        params
        |&gt; List.mapi (fun i paramName -&gt;
            let argValue = entryBlock.GetArgument(i)
            (paramName, argValue))
        |&gt; Map.ofList

    // 4. 본체 컴파일
    let bodyValue = compileExpr builder env body

    // 5. 반환
    builder.CreateFuncReturn(bodyValue)

    // 6. 모듈에 추가
    moduleDef.AddFunction(funcOp)
</code></pre>
<p><strong>재귀 호출은 자동으로 처리:</strong></p>
<p><code>compileExpr</code>의 <code>App</code> case:</p>
<pre><code class="language-fsharp">| App(funcName, args) -&gt;
    let argValues = args |&gt; List.map (compileExpr builder env)
    builder.CreateFuncCall(funcName, argValues)
</code></pre>
<ul>
<li><code>App("factorial", [Num 5])</code> → <code>func.call @factorial(%c5) : (i32) -&gt; i32</code></li>
<li><code>App("factorial", [BinOp(...)])</code> → <code>func.call @factorial(%n_minus_1) : (i32) -&gt; i32</code></li>
</ul>
<p><strong>자기 참조가 자연스럽게 작동:</strong></p>
<ul>
<li><code>@factorial</code> 심볼이 모듈에 이미 존재 (본체 컴파일 중이지만 함수 자체는 이미 추가됨)</li>
<li><code>CreateFuncCall</code>이 심볼 참조 생성</li>
<li>Verifier가 나중에 확인</li>
</ul>
<h3 id="상호-재귀-처리"><a class="header" href="#상호-재귀-처리">상호 재귀 처리</a></h3>
<p><strong>상호 재귀도 특별한 처리 불필요:</strong></p>
<pre><code class="language-fsharp">let compileProgram (builder: OpBuilder) (moduleDef: ModuleOp) (Program(funcs, mainExpr)) =
    // 모든 함수 컴파일
    funcs |&gt; List.iter (compileFuncDef builder moduleDef)

    // Main 표현식 컴파일
    // ...
</code></pre>
<p><strong>순서:</strong></p>
<ol>
<li>
<p><code>is_even</code> 컴파일:</p>
<ul>
<li><code>func.func @is_even</code> 생성, 모듈에 추가</li>
<li>본체에서 <code>func.call @is_odd</code> 생성 (아직 <code>@is_odd</code> 없음 - OK!)</li>
</ul>
</li>
<li>
<p><code>is_odd</code> 컴파일:</p>
<ul>
<li><code>func.func @is_odd</code> 생성, 모듈에 추가</li>
<li>본체에서 <code>func.call @is_even</code> 생성 (<code>@is_even</code> 이미 존재)</li>
</ul>
</li>
<li>
<p>Verification:</p>
<ul>
<li><code>@is_even</code>의 <code>func.call @is_odd</code> → <code>@is_odd</code> 존재 확인 ✓</li>
<li><code>@is_odd</code>의 <code>func.call @is_even</code> → <code>@is_even</code> 존재 확인 ✓</li>
</ul>
</li>
</ol>
<p><strong>핵심:</strong> MLIR의 lazy verification 덕분에 순서 무관.</p>
<h3 id="compileprogram-전체-구조"><a class="header" href="#compileprogram-전체-구조">compileProgram 전체 구조</a></h3>
<p><strong>다중 함수 + Main 표현식:</strong></p>
<pre><code class="language-fsharp">let compileProgram (builder: OpBuilder) (moduleDef: ModuleOp) (Program(funcs, mainExpr)) =
    // 1. 모든 함수 정의 컴파일
    funcs |&gt; List.iter (fun funcDef -&gt;
        compileFuncDef builder moduleDef funcDef
    )

    // 2. Main 함수 생성
    let mainFuncType = builder.GetFunctionType([], builder.GetI32Type())
    let mainFunc = builder.CreateFuncOp("funlang_main", mainFuncType)

    let mainBlock = mainFunc.GetEntryBlock()
    builder.SetInsertionPointToEnd(mainBlock)

    // 3. Main 표현식 컴파일
    let mainValue = compileExpr builder Map.empty mainExpr

    // 4. Main 반환
    builder.CreateFuncReturn(mainValue)

    moduleDef.AddFunction(mainFunc)

    // 5. Verification
    if not (mlirOperationVerify(moduleDef.GetOperation())) then
        failwith "Module verification failed"

    moduleDef
</code></pre>
<p><strong>프로그램 구조:</strong></p>
<pre><code class="language-fsharp">Program([
    FunDef("factorial", ["n"], &lt;body&gt;),
    FunDef("fibonacci", ["n"], &lt;body&gt;),
    FunDef("is_even", ["n"], &lt;body&gt;),
    FunDef("is_odd", ["n"], &lt;body&gt;)
], App("factorial", [Num 5]))
</code></pre>
<p><strong>생성된 MLIR:</strong></p>
<pre><code class="language-mlir">module {
  func.func @factorial(%arg0: i32) -&gt; i32 { ... }
  func.func @fibonacci(%arg0: i32) -&gt; i32 { ... }
  func.func @is_even(%arg0: i32) -&gt; i1 { ... }
  func.func @is_odd(%arg0: i32) -&gt; i1 { ... }

  func.func @funlang_main() -&gt; i32 {
    %c5 = arith.constant 5 : i32
    %result = func.call @factorial(%c5) : (i32) -&gt; i32
    func.return %result : i32
  }
}
</code></pre>
<h2 id="완전한-예시-여러-재귀-함수"><a class="header" href="#완전한-예시-여러-재귀-함수">완전한 예시: 여러 재귀 함수</a></h2>
<h3 id="프로그램-소스"><a class="header" href="#프로그램-소스">프로그램 소스</a></h3>
<pre><code class="language-fsharp">// 함수 정의들
let rec factorial n =
    if n &lt;= 1 then 1
    else n * factorial (n - 1)

let rec fibonacci n =
    if n &lt;= 1 then n
    else fibonacci (n - 1) + fibonacci (n - 2)

let rec is_even n =
    if n = 0 then true
    else is_odd (n - 1)

let rec is_odd n =
    if n = 0 then false
    else is_even (n - 1)

// Main 표현식
let result_fact = factorial 5 in
let result_fib = fibonacci 6 in
let result_even = is_even 4 in
result_fact + result_fib + result_even
</code></pre>
<h3 id="ast-표현-간략"><a class="header" href="#ast-표현-간략">AST 표현 (간략)</a></h3>
<pre><code class="language-fsharp">Program([
    FunDef("factorial", ["n"], &lt;factorial_body&gt;),
    FunDef("fibonacci", ["n"], &lt;fibonacci_body&gt;),
    FunDef("is_even", ["n"], &lt;is_even_body&gt;),
    FunDef("is_odd", ["n"], &lt;is_odd_body&gt;)
],
Let("result_fact", App("factorial", [Num 5]),
Let("result_fib", App("fibonacci", [Num 6]),
Let("result_even", App("is_even", [Num 4]),
BinOp(
    BinOp(Var "result_fact", Add, Var "result_fib"),
    Add,
    Var "result_even"
)))))
</code></pre>
<h3 id="생성된-mlir-ir-전체"><a class="header" href="#생성된-mlir-ir-전체">생성된 MLIR IR (전체)</a></h3>
<pre><code class="language-mlir">module {
  // factorial 함수
  func.func @factorial(%arg0: i32) -&gt; i32 {
    %c1 = arith.constant 1 : i32
    %cmp = arith.cmpi sle, %arg0, %c1 : i32
    %result = scf.if %cmp -&gt; (i32) {
      scf.yield %c1 : i32
    } else {
      %n_minus_1 = arith.subi %arg0, %c1 : i32
      %rec = func.call @factorial(%n_minus_1) : (i32) -&gt; i32
      %product = arith.muli %arg0, %rec : i32
      scf.yield %product : i32
    }
    func.return %result : i32
  }

  // fibonacci 함수
  func.func @fibonacci(%arg0: i32) -&gt; i32 {
    %c1 = arith.constant 1 : i32
    %cmp = arith.cmpi sle, %arg0, %c1 : i32
    %result = scf.if %cmp -&gt; (i32) {
      scf.yield %arg0 : i32
    } else {
      %n_minus_1 = arith.subi %arg0, %c1 : i32
      %fib_n_1 = func.call @fibonacci(%n_minus_1) : (i32) -&gt; i32
      %c2 = arith.constant 2 : i32
      %n_minus_2 = arith.subi %arg0, %c2 : i32
      %fib_n_2 = func.call @fibonacci(%n_minus_2) : (i32) -&gt; i32
      %sum = arith.addi %fib_n_1, %fib_n_2 : i32
      scf.yield %sum : i32
    }
    func.return %result : i32
  }

  // is_even 함수
  func.func @is_even(%arg0: i32) -&gt; i1 {
    %c0 = arith.constant 0 : i32
    %is_zero = arith.cmpi eq, %arg0, %c0 : i32
    %result = scf.if %is_zero -&gt; (i1) {
      %true = arith.constant 1 : i1
      scf.yield %true : i1
    } else {
      %c1 = arith.constant 1 : i32
      %n_minus_1 = arith.subi %arg0, %c1 : i32
      %odd_result = func.call @is_odd(%n_minus_1) : (i32) -&gt; i1
      scf.yield %odd_result : i1
    }
    func.return %result : i1
  }

  // is_odd 함수
  func.func @is_odd(%arg0: i32) -&gt; i1 {
    %c0 = arith.constant 0 : i32
    %is_zero = arith.cmpi eq, %arg0, %c0 : i32
    %result = scf.if %is_zero -&gt; (i1) {
      %false = arith.constant 0 : i1
      scf.yield %false : i1
    } else {
      %c1 = arith.constant 1 : i32
      %n_minus_1 = arith.subi %arg0, %c1 : i32
      %even_result = func.call @is_even(%n_minus_1) : (i32) -&gt; i1
      scf.yield %even_result : i1
    }
    func.return %result : i1
  }

  // Main 함수
  func.func @funlang_main() -&gt; i32 {
    // result_fact = factorial(5)
    %c5 = arith.constant 5 : i32
    %result_fact = func.call @factorial(%c5) : (i32) -&gt; i32

    // result_fib = fibonacci(6)
    %c6 = arith.constant 6 : i32
    %result_fib = func.call @fibonacci(%c6) : (i32) -&gt; i32

    // result_even = is_even(4)
    %c4 = arith.constant 4 : i32
    %result_even_i1 = func.call @is_even(%c4) : (i32) -&gt; i1
    %result_even = arith.extui %result_even_i1 : i1 to i32

    // result_fact + result_fib + result_even
    %sum1 = arith.addi %result_fact, %result_fib : i32
    %sum2 = arith.addi %sum1, %result_even : i32

    func.return %sum2 : i32
  }
}
</code></pre>
<h3 id="컴파일-및-실행"><a class="header" href="#컴파일-및-실행">컴파일 및 실행</a></h3>
<pre><code class="language-bash"># 1. MLIR 파일 저장
echo "&lt;위 MLIR IR&gt;" &gt; recursion_example.mlir

# 2. Lowering passes 적용
mlir-opt \
  --convert-scf-to-cf \
  --convert-func-to-llvm \
  --convert-arith-to-llvm \
  recursion_example.mlir \
  -o lowered.mlir

# 3. LLVM IR로 변환
mlir-translate --mlir-to-llvmir lowered.mlir -o recursion.ll

# 4. Object file 생성
llc -filetype=obj recursion.ll -o recursion.o

# 5. Runtime과 링크
gcc -o recursion recursion.o runtime.o -lgc

# 6. 실행
./recursion
# 출력: 129
# (factorial(5)=120, fibonacci(6)=8, is_even(4)=1, 120+8+1=129)
</code></pre>
<h3 id="실행-결과-분석"><a class="header" href="#실행-결과-분석">실행 결과 분석</a></h3>
<p><strong>계산 과정:</strong></p>
<ol>
<li><code>factorial(5)</code> = 120</li>
<li><code>fibonacci(6)</code> = 8</li>
<li><code>is_even(4)</code> = true = 1 (i32로 확장)</li>
<li>120 + 8 + 1 = 129</li>
</ol>
<p><strong>스택 사용:</strong></p>
<ul>
<li><code>factorial(5)</code>: 최대 5개 스택 프레임</li>
<li><code>fibonacci(6)</code>: 최대 6개 스택 프레임 (하지만 호출 트리가 넓음)</li>
<li><code>is_even(4)</code>: 최대 5개 스택 프레임 (is_even/is_odd 번갈아가며)</li>
</ul>
<p><strong>총 호출 횟수:</strong></p>
<ul>
<li><code>factorial(5)</code>: 5번</li>
<li><code>fibonacci(6)</code>: 25번 (지수 복잡도!)</li>
<li><code>is_even(4)</code> + <code>is_odd</code>: 5번</li>
</ul>
<h2 id="성능-고려사항"><a class="header" href="#성능-고려사항">성능 고려사항</a></h2>
<h3 id="재귀-vs-반복-성능"><a class="header" href="#재귀-vs-반복-성능">재귀 vs 반복 성능</a></h3>
<p><strong>재귀의 오버헤드:</strong></p>
<ol>
<li>
<p><strong>함수 호출 비용:</strong></p>
<ul>
<li>스택 프레임 생성/소멸</li>
<li>레지스터 저장/복원</li>
<li>점프 instruction (call/ret)</li>
</ul>
</li>
<li>
<p><strong>스택 메모리 사용:</strong></p>
<ul>
<li>깊이 N → N개 스택 프레임</li>
<li>각 프레임 ~64-128 bytes</li>
<li>캐시 미스 가능성</li>
</ul>
</li>
<li>
<p><strong>분기 예측:</strong></p>
<ul>
<li>재귀 호출은 간접 분기</li>
<li>CPU 분기 예측기가 학습하기 어려움</li>
</ul>
</li>
</ol>
<p><strong>반복(Loop)의 이점:</strong></p>
<ol>
<li>
<p><strong>함수 호출 없음:</strong></p>
<ul>
<li>단일 스택 프레임</li>
<li>레지스터 할당 효율적</li>
</ul>
</li>
<li>
<p><strong>명령어 수 감소:</strong></p>
<ul>
<li>직접 점프 (conditional branch)</li>
<li>예측 가능한 패턴</li>
</ul>
</li>
<li>
<p><strong>메모리 효율:</strong></p>
<ul>
<li>스택 사용 최소</li>
</ul>
</li>
</ol>
<p><strong>언제 재귀가 괜찮은가?</strong></p>
<ol>
<li>
<p><strong>얕은 재귀 (shallow recursion):</strong></p>
<ul>
<li>깊이 &lt; 100: 성능 차이 미미</li>
<li>예: 균형 트리 탐색 (깊이 ~log N)</li>
</ul>
</li>
<li>
<p><strong>꼬리 재귀 + TCO:</strong></p>
<ul>
<li>컴파일러가 loop으로 변환</li>
<li>성능이 반복과 동일</li>
</ul>
</li>
<li>
<p><strong>알고리즘이 본질적으로 재귀적:</strong></p>
<ul>
<li>트리 순회, 퀵소트, 병합정렬</li>
<li>재귀로 작성하는 것이 자연스럽고 명확</li>
</ul>
</li>
</ol>
<p><strong>언제 재귀를 피해야 하는가?</strong></p>
<ol>
<li>
<p><strong>깊은 재귀 (deep recursion):</strong></p>
<ul>
<li>깊이 &gt; 10,000: 스택 오버플로우 위험</li>
<li>예: naive fibonacci</li>
</ul>
</li>
<li>
<p><strong>중복 계산:</strong></p>
<ul>
<li>Fibonacci 같은 지수 복잡도</li>
<li>Memoization 또는 DP로 해결</li>
</ul>
</li>
<li>
<p><strong>성능이 중요한 경우:</strong></p>
<ul>
<li>내부 루프 (hot path)</li>
<li>반복으로 작성 또는 TCO 보장</li>
</ul>
</li>
</ol>
<h3 id="스택-프레임-오버헤드"><a class="header" href="#스택-프레임-오버헤드">스택 프레임 오버헤드</a></h3>
<p><strong>스택 프레임 구조 (x86-64):</strong></p>
<pre><code>┌──────────────────────┐
│ Return address       │ 8 bytes
├──────────────────────┤
│ Saved rbp (frame ptr)│ 8 bytes
├──────────────────────┤
│ Local variables      │ Variable
├──────────────────────┤
│ Saved registers      │ Variable (callee-saved)
├──────────────────────┤
│ Padding (alignment)  │ 0-15 bytes (16-byte align)
└──────────────────────┘
</code></pre>
<p><strong>최소 크기:</strong> ~16 bytes (return address + rbp)
<strong>일반적 크기:</strong> 64-128 bytes (지역 변수, 레지스터 저장 포함)</p>
<p><strong>호출 비용:</strong></p>
<ul>
<li><code>call</code> instruction: ~1-2 CPU cycles (분기 예측 성공 시)</li>
<li>스택 프레임 setup: ~5-10 instructions (push rbp, mov, sub)</li>
<li>스택 프레임 teardown: ~5-10 instructions (mov, pop, ret)</li>
<li><strong>총:</strong> ~20-30 instructions per call</li>
</ul>
<p><strong>비교 (factorial 1000):</strong></p>
<ul>
<li><strong>재귀:</strong> 1,000 함수 호출 × 30 instructions = 30,000 instructions</li>
<li><strong>반복:</strong> ~5 instructions per iteration × 1,000 = 5,000 instructions</li>
</ul>
<p><strong>6배 차이!</strong> 하지만 절대 시간은 여전히 작음 (~수 마이크로초).</p>
<h3 id="llvm-최적화-기회"><a class="header" href="#llvm-최적화-기회">LLVM 최적화 기회</a></h3>
<p><strong>LLVM이 재귀에 적용하는 최적화:</strong></p>
<ol>
<li>
<p><strong>Tail Call Elimination (TCO):</strong></p>
<ul>
<li>꼬리 재귀 → loop 변환</li>
<li>스택 사용 O(1)</li>
</ul>
</li>
<li>
<p><strong>Inlining:</strong></p>
<ul>
<li>작은 재귀 함수를 호출 사이트에 인라인</li>
<li>함수 호출 오버헤드 제거</li>
</ul>
</li>
<li>
<p><strong>Constant Folding:</strong></p>
<ul>
<li>컴파일 타임에 계산 가능한 재귀 (예: <code>factorial(5)</code>) → 상수 120</li>
</ul>
</li>
<li>
<p><strong>Loop Optimization:</strong></p>
<ul>
<li>재귀를 loop으로 변환 후 loop unrolling, vectorization 적용</li>
</ul>
</li>
</ol>
<p><strong>예시 (LLVM -O3):</strong></p>
<pre><code class="language-fsharp">// 소스
let rec factorial n =
    if n &lt;= 1 then 1
    else n * factorial (n - 1)

let result = factorial 5
</code></pre>
<p><strong>LLVM -O3 최적화 후:</strong></p>
<pre><code class="language-llvm">define i32 @funlang_main() {
  ret i32 120  ; 컴파일 타임에 계산됨!
}
</code></pre>
<p><strong>변수 입력 (factorial n, n이 런타임 값):</strong></p>
<p>LLVM은 재귀를 그대로 유지하지만, 레지스터 할당과 분기 예측을 최적화.</p>
<h3 id="phase-7-최적화-preview"><a class="header" href="#phase-7-최적화-preview">Phase 7 최적화 Preview</a></h3>
<p><strong>Phase 7에서 다룰 내용:</strong></p>
<ol>
<li>
<p><strong>명시적 TCO 지원:</strong></p>
<ul>
<li><code>tailcc</code> calling convention</li>
<li>꼬리 재귀 자동 감지 및 변환</li>
</ul>
</li>
<li>
<p><strong>Inlining 제어:</strong></p>
<ul>
<li>작은 함수 자동 인라인</li>
<li><code>inline</code> 힌트</li>
</ul>
</li>
<li>
<p><strong>Memoization:</strong></p>
<ul>
<li>함수 결과 캐싱 (fibonacci 최적화)</li>
</ul>
</li>
<li>
<p><strong>Loop 변환:</strong></p>
<ul>
<li>재귀 → 반복 자동 변환 (특정 패턴)</li>
</ul>
</li>
</ol>
<p><strong>현재 (Phase 3):</strong></p>
<ul>
<li>재귀의 기본 개념과 제약 이해</li>
<li>성능 트레이드오프 인지</li>
<li>LLVM의 기본 최적화에 의존</li>
</ul>
<h2 id="일반적인-오류-1"><a class="header" href="#일반적인-오류-1">일반적인 오류</a></h2>
<h3 id="error-1-무한-재귀-기저-사례-누락"><a class="header" href="#error-1-무한-재귀-기저-사례-누락">Error 1: 무한 재귀 (기저 사례 누락)</a></h3>
<p><strong>문제:</strong></p>
<pre><code class="language-fsharp">let rec infinite_loop n =
    infinite_loop (n - 1)
    // 기저 사례가 없음!
</code></pre>
<p><strong>증상:</strong></p>
<pre><code class="language-bash">./program
Segmentation fault (core dumped)
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>재귀 종료 조건이 없음</li>
<li>스택이 무한히 성장</li>
<li>스택 오버플로우</li>
</ul>
<p><strong>해결:</strong></p>
<pre><code class="language-fsharp">let rec countdown n =
    if n &lt;= 0 then 0  // ← 기저 사례 추가
    else countdown (n - 1)
</code></pre>
<p><strong>디버깅 팁:</strong></p>
<ul>
<li>모든 재귀 함수에 기저 사례가 있는지 확인</li>
<li>“언제 재귀가 멈추는가?” 질문</li>
</ul>
<h3 id="error-2-스택-오버플로우-깊은-재귀"><a class="header" href="#error-2-스택-오버플로우-깊은-재귀">Error 2: 스택 오버플로우 (깊은 재귀)</a></h3>
<p><strong>문제:</strong></p>
<pre><code class="language-fsharp">let rec sum_to n =
    if n &lt;= 0 then 0
    else n + sum_to (n - 1)

let result = sum_to 100000  // 깊이 100,000!
</code></pre>
<p><strong>증상:</strong></p>
<pre><code class="language-bash">./program
Segmentation fault (core dumped)
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>재귀 깊이 &gt; 스택 크기</li>
<li>100,000 프레임 × 64 bytes = 6.4 MB &gt; 일부 플랫폼 한계</li>
</ul>
<p><strong>해결:</strong></p>
<ol>
<li><strong>꼬리 재귀로 변환:</strong></li>
</ol>
<pre><code class="language-fsharp">let rec sum_to_tail n acc =
    if n &lt;= 0 then acc
    else sum_to_tail (n - 1) (n + acc)

let sum_to n = sum_to_tail n 0
</code></pre>
<ol start="2">
<li><strong>입력 크기 제한:</strong></li>
</ol>
<pre><code class="language-fsharp">if n &gt; 10000 then
    failwith "Input too large"
else
    sum_to n
</code></pre>
<ol start="3">
<li><strong>반복으로 변환:</strong></li>
</ol>
<pre><code class="language-fsharp">// FunLang은 loop 없지만, LLVM이 TCO로 변환 가능
</code></pre>
<h3 id="error-3-심볼을-찾을-수-없음-타이포"><a class="header" href="#error-3-심볼을-찾을-수-없음-타이포">Error 3: 심볼을 찾을 수 없음 (타이포)</a></h3>
<p><strong>문제:</strong></p>
<pre><code class="language-fsharp">let rec factorial n =
    if n &lt;= 1 then 1
    else n * factorail (n - 1)  // typo: factorail
</code></pre>
<p><strong>증상 (MLIR verification):</strong></p>
<pre><code>error: 'func.call' op 'factorail' does not reference a valid function
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>함수 이름 오타</li>
<li>심볼 <code>@factorail</code>이 모듈에 없음</li>
</ul>
<p><strong>해결:</strong></p>
<ul>
<li>함수 이름 철자 확인</li>
<li>IDE의 자동완성 사용</li>
</ul>
<h3 id="error-4-인자-순서-오류-상호-재귀"><a class="header" href="#error-4-인자-순서-오류-상호-재귀">Error 4: 인자 순서 오류 (상호 재귀)</a></h3>
<p><strong>문제:</strong></p>
<pre><code class="language-fsharp">let rec is_even n =
    if n = 0 then true
    else is_odd n  // ← (n - 1) 빠뜨림!

let rec is_odd n =
    if n = 0 then false
    else is_even n  // ← 똑같은 오류
</code></pre>
<p><strong>증상:</strong></p>
<pre><code class="language-bash">./program
Segmentation fault (core dumped)
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>무한 재귀: is_even(4) → is_odd(4) → is_even(4) → …</li>
<li>인자가 감소하지 않음</li>
</ul>
<p><strong>해결:</strong></p>
<pre><code class="language-fsharp">let rec is_even n =
    if n = 0 then true
    else is_odd (n - 1)  // ← (n - 1) 추가

let rec is_odd n =
    if n = 0 then false
    else is_even (n - 1)
</code></pre>
<h3 id="error-5-꼬리-위치가-아닌-곳에서-tco-기대"><a class="header" href="#error-5-꼬리-위치가-아닌-곳에서-tco-기대">Error 5: 꼬리 위치가 아닌 곳에서 TCO 기대</a></h3>
<p><strong>문제:</strong></p>
<pre><code class="language-fsharp">let rec factorial n =
    if n &lt;= 1 then 1
    else n * factorial (n - 1)
    //       ↑ 꼬리 위치 아님 (곱셈 후 실행)

// TCO가 적용될 것으로 기대하지만, 실제로는 안 됨
</code></pre>
<p><strong>증상:</strong></p>
<ul>
<li>깊은 재귀에서 스택 오버플로우</li>
<li>TCO가 적용되지 않음</li>
</ul>
<p><strong>원인:</strong></p>
<ul>
<li>재귀 호출 후 추가 작업 (<code>n *</code>)</li>
<li>꼬리 호출이 아님</li>
</ul>
<p><strong>해결:</strong></p>
<pre><code class="language-fsharp">// accumulator 패턴으로 변환
let rec factorial_tail n acc =
    if n &lt;= 1 then acc
    else factorial_tail (n - 1) (n * acc)
    //   ↑ 꼬리 위치! (호출이 마지막)
</code></pre>
<h3 id="디버깅-팁"><a class="header" href="#디버깅-팁">디버깅 팁</a></h3>
<ol>
<li><strong>Print 디버깅:</strong></li>
</ol>
<pre><code class="language-fsharp">let rec factorial n =
    // 디버깅: 함수 호출 출력
    print_int n;
    if n &lt;= 1 then 1
    else n * factorial (n - 1)
</code></pre>
<ol start="2">
<li><strong>기저 사례 먼저 확인:</strong></li>
</ol>
<p>재귀 함수를 작성할 때:</p>
<ul>
<li>먼저 기저 사례 작성</li>
<li>그 다음 재귀 사례 작성</li>
</ul>
<ol start="3">
<li><strong>작은 입력으로 테스트:</strong></li>
</ol>
<pre><code class="language-fsharp">// factorial 100000 전에 factorial 5 먼저 테스트
</code></pre>
<ol start="4">
<li><strong>스택 크기 늘리기 (임시 해결):</strong></li>
</ol>
<pre><code class="language-bash"># Linux에서 스택 크기 늘리기
ulimit -s 16384  # 16 MB
./program
</code></pre>
<ol start="5">
<li><strong>MLIR IR 검증:</strong></li>
</ol>
<pre><code class="language-bash">mlir-opt --verify-diagnostics program.mlir
</code></pre>
<h2 id="요약-및-phase-3-완료"><a class="header" href="#요약-및-phase-3-완료">요약 및 Phase 3 완료</a></h2>
<h3 id="chapter-11-요약"><a class="header" href="#chapter-11-요약">Chapter 11 요약</a></h3>
<p><strong>배운 내용:</strong></p>
<ol>
<li>
<p><strong>재귀의 기본:</strong></p>
<ul>
<li>자기 자신을 호출하는 함수</li>
<li>기저 사례 + 재귀 사례</li>
<li>예시: factorial, fibonacci</li>
</ul>
</li>
<li>
<p><strong>MLIR에서 재귀:</strong></p>
<ul>
<li>모듈 레벨 심볼 테이블</li>
<li>자기 참조 (<code>func.call @factorial</code> inside <code>@factorial</code>)</li>
<li>심볼 확인은 컴파일 타임, 호출은 런타임</li>
</ul>
</li>
<li>
<p><strong>상호 재귀:</strong></p>
<ul>
<li>두 함수가 서로 호출 (is_even, is_odd)</li>
<li>Forward declaration 불필요</li>
<li>Flat symbol namespace 덕분에 자연스럽게 작동</li>
</ul>
</li>
<li>
<p><strong>스택 프레임:</strong></p>
<ul>
<li>각 재귀 호출마다 스택 프레임 생성</li>
<li>깊이 N → N개 프레임</li>
<li>스택 크기 제한 (8 MB Linux, 1 MB Windows)</li>
</ul>
</li>
<li>
<p><strong>꼬리 호출 최적화:</strong></p>
<ul>
<li>꼬리 위치 = 함수의 마지막 표현식</li>
<li>꼬리 호출 = 꼬리 위치의 함수 호출</li>
<li>TCO = 꼬리 호출을 점프로 변환, 스택 재사용</li>
<li>Accumulator 패턴으로 꼬리 재귀 변환</li>
</ul>
</li>
<li>
<p><strong>성능:</strong></p>
<ul>
<li>재귀는 오버헤드 있음 (함수 호출, 스택)</li>
<li>얕은 재귀는 괜찮음</li>
<li>깊은 재귀는 TCO 필요</li>
<li>LLVM 최적화 활용</li>
</ul>
</li>
<li>
<p><strong>일반적인 오류:</strong></p>
<ul>
<li>무한 재귀 (기저 사례 누락)</li>
<li>스택 오버플로우 (깊은 재귀)</li>
<li>타이포 (심볼 참조 실패)</li>
<li>인자 오류 (상호 재귀)</li>
<li>꼬리 위치 오해</li>
</ul>
</li>
</ol>
<h3 id="phase-3-완료"><a class="header" href="#phase-3-완료">Phase 3 완료!</a></h3>
<p><strong>Phase 3 목표:</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""> 최상위 명명된 함수 (Chapter 10)</li>
<li><input disabled="" type="checkbox" checked=""> 함수 파라미터와 호출 (Chapter 10)</li>
<li><input disabled="" type="checkbox" checked=""> 재귀 함수 (Chapter 11)</li>
<li><input disabled="" type="checkbox" checked=""> 상호 재귀 (Chapter 11)</li>
<li><input disabled="" type="checkbox" checked=""> 스택 프레임 관리 (Chapter 11)</li>
<li><input disabled="" type="checkbox" checked=""> 꼬리 호출 최적화 개념 (Chapter 11)</li>
</ul>
<p><strong>Phase 3에서 구축한 것:</strong></p>
<ol>
<li>
<p><strong>func 다이얼렉트 통합:</strong></p>
<ul>
<li><code>func.func</code>, <code>func.call</code>, <code>func.return</code> 연산</li>
<li>P/Invoke 바인딩 및 OpBuilder 메서드</li>
</ul>
</li>
<li>
<p><strong>함수 컴파일 인프라:</strong></p>
<ul>
<li><code>compileFuncDef</code>: AST → func.func</li>
<li><code>compileProgram</code>: 다중 함수 + main</li>
<li>환경 관리 (파라미터를 block arguments로)</li>
</ul>
</li>
<li>
<p><strong>재귀 지원:</strong></p>
<ul>
<li>자기 참조 (심볼 테이블)</li>
<li>상호 재귀 (lazy verification)</li>
<li>스택 기반 실행 모델</li>
</ul>
</li>
<li>
<p><strong>Calling convention:</strong></p>
<ul>
<li>C calling convention (System V ABI)</li>
<li>LLVM의 자동 프롤로그/에필로그 생성</li>
</ul>
</li>
</ol>
<p><strong>Phase 3에서 제외된 것 (Phase 4로 연기):</strong></p>
<ul>
<li><strong>클로저:</strong> 환경을 캡처하는 함수</li>
<li><strong>고차 함수:</strong> 함수를 인자로 받거나 반환</li>
<li><strong>익명 함수:</strong> Lambda 표현식</li>
<li><strong>힙 할당:</strong> 클로저 환경 (GC_malloc 사용)</li>
</ul>
<h3 id="phase-4-preview"><a class="header" href="#phase-4-preview">Phase 4 Preview</a></h3>
<p><strong>Phase 4: 클로저와 고차 함수</strong></p>
<p><strong>목표:</strong></p>
<ol>
<li>
<p><strong>Lambda 표현식:</strong></p>
<pre><code class="language-fsharp">let add_n n = fun x -&gt; x + n
</code></pre>
</li>
<li>
<p><strong>환경 캡처:</strong></p>
<pre><code class="language-fsharp">let make_counter () =
    let count = ref 0 in
    fun () -&gt; (count := !count + 1; !count)
</code></pre>
</li>
<li>
<p><strong>고차 함수:</strong></p>
<pre><code class="language-fsharp">let map f list = ...
let result = map (fun x -&gt; x * 2) [1; 2; 3]
</code></pre>
</li>
<li>
<p><strong>클로저 변환:</strong></p>
<ul>
<li>자유 변수 분석</li>
<li>환경을 힙에 할당 (GC_malloc)</li>
<li>클로저 = (function pointer, environment pointer)</li>
</ul>
</li>
<li>
<p><strong>Heap 사용:</strong></p>
<ul>
<li>Chapter 9 (Boehm GC) 활성화</li>
<li>memref 다이얼렉트 (alloc, load, store)</li>
</ul>
</li>
</ol>
<p><strong>연결:</strong></p>
<ul>
<li>Phase 3: 스택 기반 함수 (파라미터만 사용)</li>
<li>Phase 4: 힙 기반 클로저 (파라미터 + 캡처된 환경)</li>
</ul>
<h3 id="다음-단계-3"><a class="header" href="#다음-단계-3">다음 단계</a></h3>
<p><strong>완성된 컴파일러 능력:</strong></p>
<p>Phase 3 완료 후 FunLang 컴파일러는 다음을 지원한다:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""> 산술 및 비교 연산 (Chapter 06)</li>
<li><input disabled="" type="checkbox" checked=""> Let 바인딩과 변수 (Chapter 07)</li>
<li><input disabled="" type="checkbox" checked=""> If/then/else 제어 흐름 (Chapter 08)</li>
<li><input disabled="" type="checkbox" checked=""> 메모리 관리 (Boehm GC 통합, Chapter 09)</li>
<li><input disabled="" type="checkbox" checked=""> 함수 정의 및 호출 (Chapter 10)</li>
<li><input disabled="" type="checkbox" checked=""> 재귀 및 상호 재귀 (Chapter 11)</li>
</ul>
<p><strong>아직 지원하지 않는 것:</strong></p>
<ul>
<li><input disabled="" type="checkbox"> 클로저 및 lambda</li>
<li><input disabled="" type="checkbox"> 고차 함수</li>
<li><input disabled="" type="checkbox"> 패턴 매칭</li>
<li><input disabled="" type="checkbox"> 대수적 데이터 타입 (ADT)</li>
<li><input disabled="" type="checkbox"> 리스트, 튜플 등 데이터 구조</li>
<li><input disabled="" type="checkbox"> 타입 시스템 (현재 모두 i32)</li>
</ul>
<p><strong>학습 경로:</strong></p>
<pre><code>Phase 1 (Foundation): MLIR 기초, P/Invoke
  ↓
Phase 2 (Core Language): 표현식, 제어 흐름, 메모리
  ↓
Phase 3 (Functions): 함수, 재귀, 스택 ← 현재 위치
  ↓
Phase 4 (Closures): 클로저, 고차 함수, 힙
  ↓
Phase 5 (Data Structures): 리스트, 튜플, ADT
  ↓
Phase 6 (Type System): 타입 추론, 다형성
  ↓
Phase 7 (Optimization): 인라인, TCO, 최적화 패스
</code></pre>
<p><strong>축하합니다!</strong> Phase 3를 완료했습니다. FunLang 컴파일러는 이제 재귀 함수를 포함한 완전한 프로그램을 네이티브 코드로 컴파일할 수 있습니다.</p>
<p><strong>다음 장 (Phase 4)에서:</strong> 클로저와 환경 캡처를 추가하여 진정한 함수형 프로그래밍 기능을 구현할 것입니다.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="appendix-커스텀-mlir-dialect-등록"><a class="header" href="#appendix-커스텀-mlir-dialect-등록">Appendix: 커스텀 MLIR Dialect 등록</a></h1>
<h2 id="소개-12"><a class="header" href="#소개-12">소개</a></h2>
<p>Chapter 01-05에서는 MLIR의 빌트인 dialect를 사용했다:</p>
<ul>
<li><code>arith</code>: 산술 연산</li>
<li><code>func</code>: 함수 정의와 호출</li>
<li><code>scf</code>: 구조적 제어 흐름 (if/while)</li>
<li><code>llvm</code>: LLVM IR 타입과 operation</li>
</ul>
<p>이 dialect들은 강력하지만 범용적이다. FunLang과 같은 도메인별 언어의 경우 언어의 의미를 직접 표현하는 <strong>커스텀 dialect</strong>가 유용하다.</p>
<p>예를 들어 FunLang 클로저를 고려해 본다:</p>
<pre><code class="language-fsharp">let make_adder x =
    fun y -&gt; x + y
</code></pre>
<p>빌트인 dialect만 사용하면 클로저를 즉시 struct, 함수 포인터, 환경 캡처로 낮춰야 한다. 하지만 커스텀 dialect를 사용하면 이렇게 표현할 수 있다:</p>
<pre><code class="language-mlir">%closure = funlang.make_closure @lambda_body, %x : (!funlang.closure)
%result = funlang.apply %closure, %y : (i32)
</code></pre>
<p>높은 수준에서 의미가 명확하다. 그런 다음 낮추기 pass에서 구현 세부사항 (struct 레이아웃, malloc 호출 등)으로 점진적으로 변환한다.</p>
<p>이 appendix는 다음을 다룬다:</p>
<ol>
<li>커스텀 dialect를 C++에서 정의하는 방법</li>
<li>C API shim으로 F#에 노출하는 방법</li>
<li>Phase 5에서 사용할 아키텍처</li>
</ol>
<blockquote>
<p><strong>아키텍처 노트:</strong> 커스텀 dialect 등록은 Phase 5의 주제다. 이 appendix는 미리 보기와 기술적 기초를 제공한다.</p>
</blockquote>
<h2 id="c-api가-커스텀-dialect를-등록할-수-없는-이유"><a class="header" href="#c-api가-커스텀-dialect를-등록할-수-없는-이유">C API가 커스텀 Dialect를 등록할 수 없는 이유</a></h2>
<p>MLIR C API (<code>mlir-c/IR.h</code>)는 빌트인 dialect를 <strong>로드</strong>하는 함수를 제공한다:</p>
<pre><code class="language-c">// C API에 있음 - 빌트인 dialect 로드
MlirDialectHandle mlirGetDialectHandle__arith__();
void mlirDialectHandleRegisterDialect(MlirDialectHandle handle, MlirContext ctx);
</code></pre>
<p>하지만 <strong>새</strong> dialect를 <strong>정의</strong>하는 함수는 없다. 커스텀 dialect 정의는 C++ 코드를 요구한다:</p>
<pre><code class="language-cpp">// C++만 가능 - 새 dialect 정의
class FunLangDialect : public mlir::Dialect {
public:
  FunLangDialect(mlir::MLIRContext *context);
  static constexpr llvm::StringLiteral getDialectNamespace() {
    return llvm::StringLiteral("funlang");
  }
  // ... operation, type, attribute 정의 ...
};
</code></pre>
<p><strong>왜 C API에 없나?</strong></p>
<p>Dialect 정의는 C++ 클래스 상속, 템플릿, TableGen 생성 코드를 사용한다. 이것들은 C FFI 경계를 넘을 수 없다. C API는 <strong>이미 정의된</strong> dialect의 핸들만 다룰 수 있다.</p>
<p><strong>해결책:</strong> C++에서 dialect를 정의하고 등록을 위한 <strong>C API shim</strong>을 작성한다. F#은 이 shim을 P/Invoke로 호출한다.</p>
<h2 id="c-래퍼-접근법"><a class="header" href="#c-래퍼-접근법">C++ 래퍼 접근법</a></h2>
<p>아키텍처:</p>
<pre><code>┌─────────────────────────────────────────┐
│ F# Compiler (Compiler.fs)              │
│                                         │
│ ctx.LoadCustomDialect("funlang")        │
└────────────────┬────────────────────────┘
                 │ P/Invoke
                 ▼
┌─────────────────────────────────────────┐
│ C API Shim (funlang_dialect.c)         │
│                                         │
│ void funlangRegisterDialect(MlirContext)│
└────────────────┬────────────────────────┘
                 │ Call C++ API
                 ▼
┌─────────────────────────────────────────┐
│ C++ Dialect (FunLangDialect.cpp)       │
│                                         │
│ class FunLangDialect : public Dialect { │
│   // operation, type 정의               │
│ }                                       │
└─────────────────────────────────────────┘
</code></pre>
<p>C++ dialect을 공유 라이브러리 (<code>libFunLangDialect.so</code>)로 컴파일하고 F#이 로드한다.</p>
<h2 id="최소-커스텀-dialect-in-c"><a class="header" href="#최소-커스텀-dialect-in-c">최소 커스텀 Dialect in C++</a></h2>
<p>C++ 파일 <code>funlang_dialect.cpp</code>를 만든다:</p>
<pre><code class="language-cpp">// funlang_dialect.cpp - 최소 FunLang MLIR Dialect
#include "mlir/IR/Dialect.h"
#include "mlir/IR/MLIRContext.h"
#include "mlir/IR/Builders.h"
#include "mlir/IR/DialectRegistry.h"
#include "mlir-c/IR.h"

namespace mlir {
namespace funlang {

/// FunLang Dialect 정의
class FunLangDialect : public Dialect {
public:
  /// Context에 FunLang dialect 등록
  explicit FunLangDialect(MLIRContext *context)
      : Dialect(getDialectNamespace(), context,
                mlir::TypeID::get&lt;FunLangDialect&gt;()) {
    // 여기서 operation, type, attribute를 등록할 것
    // Phase 5에서 구현
  }

  /// Dialect 네임스페이스 반환 ("funlang")
  static constexpr llvm::StringLiteral getDialectNamespace() {
    return llvm::StringLiteral("funlang");
  }
};

} // namespace funlang
} // namespace mlir

// C API shim - F#에서 호출 가능
extern "C" {

/// FunLang dialect를 MLIR context에 등록
void funlangRegisterDialect(MlirContext ctx) {
  mlir::MLIRContext *context = unwrap(ctx);
  mlir::DialectRegistry registry;
  registry.insert&lt;mlir::funlang::FunLangDialect&gt;();
  context-&gt;appendDialectRegistry(registry);
  context-&gt;loadDialect&lt;mlir::funlang::FunLangDialect&gt;();
}

} // extern "C"
</code></pre>
<p><strong>Line-by-line 설명:</strong></p>
<ol>
<li><strong><code>#include "mlir/IR/Dialect.h"</code></strong>: MLIR dialect 기본 클래스</li>
<li><strong><code>namespace mlir::funlang</code></strong>: 네임스페이스 충돌 방지</li>
<li><strong><code>class FunLangDialect : public Dialect</code></strong>: 커스텀 dialect 정의. <code>Dialect</code>는 MLIR 기본 클래스</li>
<li><strong><code>explicit FunLangDialect(MLIRContext *context)</code></strong>: 생성자. Context에 dialect 등록</li>
<li><strong><code>getDialectNamespace()</code></strong>: Dialect 이름 반환. MLIR IR에서 <code>funlang.operation_name</code>으로 사용됨</li>
<li><strong><code>extern "C" { ... }</code></strong>: C linkage - name mangling 방지, F# P/Invoke 가능</li>
<li><strong><code>void funlangRegisterDialect(MlirContext ctx)</code></strong>: C API shim. F#이 호출할 함수</li>
<li><strong><code>unwrap(ctx)</code></strong>: MLIR C API 유틸리티 - <code>MlirContext</code> (불투명 핸들)을 C++ <code>MLIRContext*</code>로 변환</li>
<li><strong><code>registry.insert&lt;FunLangDialect&gt;()</code></strong>: Registry에 dialect 추가</li>
<li><strong><code>context-&gt;appendDialectRegistry(registry)</code></strong>: Context에 registry 추가</li>
<li><strong><code>context-&gt;loadDialect&lt;FunLangDialect&gt;()</code></strong>: Dialect 즉시 로드 (lazy loading 아님)</li>
</ol>
<blockquote>
<p><strong>설계 결정:</strong> 이 dialect는 아직 operation이나 type을 정의하지 않는다. Phase 5에서 <code>funlang.closure</code>, <code>funlang.apply</code> 같은 operation을 추가할 것이다.</p>
</blockquote>
<h2 id="c-라이브러리-빌드"><a class="header" href="#c-라이브러리-빌드">C++ 라이브러리 빌드</a></h2>
<p><code>CMakeLists.txt</code>를 작성한다:</p>
<pre><code class="language-cmake"># CMakeLists.txt - FunLang Dialect 빌드
cmake_minimum_required(VERSION 3.20)
project(FunLangDialect)

# LLVM/MLIR 찾기
find_package(MLIR REQUIRED CONFIG)
list(APPEND CMAKE_MODULE_PATH "${MLIR_CMAKE_DIR}")
include(AddLLVM)
include(AddMLIR)

# Include 디렉토리
include_directories(${MLIR_INCLUDE_DIRS})

# FunLangDialect 공유 라이브러리
add_library(FunLangDialect SHARED
  funlang_dialect.cpp
)

# MLIR 라이브러리 링크
target_link_libraries(FunLangDialect
  PRIVATE
    MLIRIR
    MLIRDialect
)

# 설치
install(TARGETS FunLangDialect
  LIBRARY DESTINATION lib
)
</code></pre>
<p><strong>빌드:</strong></p>
<pre><code class="language-bash"># CMake 설정
cmake -S . -B build \
  -DMLIR_DIR=$HOME/mlir-install/lib/cmake/mlir \
  -DCMAKE_BUILD_TYPE=Release

# 빌드
cmake --build build

# 설치
cmake --build build --target install
</code></pre>
<p>이렇게 하면 <code>libFunLangDialect.so</code> (Linux), <code>libFunLangDialect.dylib</code> (macOS), 또는 <code>FunLangDialect.dll</code> (Windows)가 생성된다.</p>
<h2 id="f에서-사용"><a class="header" href="#f에서-사용">F#에서 사용</a></h2>
<p><code>MlirBindings.fs</code>에 P/Invoke 선언 추가:</p>
<pre><code class="language-fsharp">// MlirBindings.fs에 추가

module MlirNative =
    // ... 기존 바인딩 ...

    /// FunLang 커스텀 dialect 등록 (C++ shim 호출)
    [&lt;DllImport("FunLangDialect", CallingConvention = CallingConvention.Cdecl)&gt;]
    extern void funlangRegisterDialect(MlirContext ctx)
</code></pre>
<p><code>MlirWrapper.fs</code>의 <code>Context</code> 클래스에 메서드 추가:</p>
<pre><code class="language-fsharp">type Context() =
    let mutable handle = MlirNative.mlirContextCreate()
    let mutable disposed = false

    member _.Handle = handle

    /// 빌트인 dialect 로드
    member _.LoadDialect(dialect: string) =
        if disposed then
            raise (ObjectDisposedException("Context"))

        MlirStringRef.WithString dialect (fun nameRef -&gt;
            MlirNative.mlirContextGetOrLoadDialect(handle, nameRef)
            |&gt; ignore)

    /// 커스텀 FunLang dialect 로드
    member _.LoadFunLangDialect() =
        if disposed then
            raise (ObjectDisposedException("Context"))

        MlirNative.funlangRegisterDialect(handle)

    // ... IDisposable 구현 ...
</code></pre>
<p><strong>사용:</strong></p>
<pre><code class="language-fsharp">use ctx = new Context()
ctx.LoadDialect("arith")
ctx.LoadDialect("func")
ctx.LoadFunLangDialect()  // 커스텀 dialect 로드

// 이제 funlang.* operation 사용 가능 (Phase 5에서 정의)
</code></pre>
<h2 id="커스텀-operation-추가-미리-보기"><a class="header" href="#커스텀-operation-추가-미리-보기">커스텀 Operation 추가 (미리 보기)</a></h2>
<p>Phase 5에서 FunLang dialect에 operation을 추가한다. 미리 보기:</p>
<p><strong>TableGen 정의 (FunLangOps.td):</strong></p>
<pre><code class="language-tablegen">// FunLangOps.td - FunLang operation 정의 (TableGen)
include "mlir/IR/OpBase.td"

def FunLang_Dialect : Dialect {
  let name = "funlang";
  let cppNamespace = "::mlir::funlang";
}

class FunLang_Op&lt;string mnemonic, list&lt;Trait&gt; traits = []&gt;
    : Op&lt;FunLang_Dialect, mnemonic, traits&gt;;

// funlang.make_closure operation
def FunLang_MakeClosureOp : FunLang_Op&lt;"make_closure"&gt; {
  let summary = "Create a closure capturing environment";
  let arguments = (ins
    FlatSymbolRefAttr:$callee,
    Variadic&lt;AnyType&gt;:$captured
  );
  let results = (outs AnyType:$result);
}

// funlang.apply operation
def FunLang_ApplyOp : FunLang_Op&lt;"apply"&gt; {
  let summary = "Apply a closure to arguments";
  let arguments = (ins
    AnyType:$closure,
    Variadic&lt;AnyType&gt;:$args
  );
  let results = (outs AnyType:$result);
}
</code></pre>
<p><strong>생성된 C++ 코드:</strong></p>
<p>TableGen은 위 정의에서 C++ 클래스를 생성한다:</p>
<pre><code class="language-cpp">// 생성됨: FunLangOps.h.inc
class MakeClosureOp : public Op&lt;MakeClosureOp, /* traits */&gt; {
public:
  static StringRef getOperationName() { return "funlang.make_closure"; }
  // ... getter/setter, verifier ...
};

class ApplyOp : public Op&lt;ApplyOp, /* traits */&gt; {
public:
  static StringRef getOperationName() { return "funlang.apply"; }
  // ... getter/setter, verifier ...
};
</code></pre>
<p><strong>Dialect에 등록:</strong></p>
<pre><code class="language-cpp">// funlang_dialect.cpp 업데이트
FunLangDialect::FunLangDialect(MLIRContext *context)
    : Dialect(/*...*/) {
  // Operation 등록
  addOperations&lt;
    MakeClosureOp,
    ApplyOp
  &gt;();
}
</code></pre>
<p><strong>F#에서 사용:</strong></p>
<pre><code class="language-fsharp">// 커스텀 operation 생성 (Phase 5에서 OpBuilder 확장)
let closureOp = builder.CreateMakeClosure("lambda_body", [| xValue |], loc)
let resultOp = builder.CreateApply(closureOp, [| yValue |], loc)
</code></pre>
<p><strong>생성된 MLIR IR:</strong></p>
<pre><code class="language-mlir">%closure = funlang.make_closure @lambda_body, %x : (!funlang.closure)
%result = funlang.apply %closure, %y : (i32)
</code></pre>
<p>Phase 5에서 이 operation들을 <code>scf</code>, <code>memref</code>, <code>llvm</code> dialect로 낮추는 pass를 작성할 것이다.</p>
<h2 id="커스텀-dialect를-사용할-때-vs-빌트인-사용"><a class="header" href="#커스텀-dialect를-사용할-때-vs-빌트인-사용">커스텀 Dialect를 사용할 때 vs. 빌트인 사용</a></h2>
<p><strong>커스텀 dialect를 사용해야 하는 경우:</strong></p>
<ol>
<li><strong>도메인별 의미</strong>: FunLang 클로저, 패턴 매칭, 리스트 cons는 커스텀 operation으로 더 명확하다</li>
<li><strong>점진적 낮추기</strong>: 높은 수준에서 시작하여 여러 pass를 통해 낮춘다</li>
<li><strong>최적화 기회</strong>: 커스텀 operation의 패턴 매칭 최적화 작성 가능</li>
<li><strong>가독성</strong>: <code>funlang.make_closure</code>가 15줄의 <code>llvm.call</code>, <code>memref.alloc</code>, <code>memref.store</code>보다 이해하기 쉽다</li>
</ol>
<p><strong>빌트인 dialect를 사용해야 하는 경우:</strong></p>
<ol>
<li><strong>단순한 언어</strong>: 산술과 함수만 있으면 <code>arith</code> + <code>func</code>로 충분하다</li>
<li><strong>빠른 프로토타이핑</strong>: 커스텀 dialect는 C++ 빌드 시스템이 필요하다</li>
<li><strong>MLIR 학습</strong>: 빌트인 dialect로 시작하면 개념을 빠르게 배울 수 있다</li>
</ol>
<p><strong>FunLang의 경우:</strong> Phase 1-4는 빌트인 dialect를 사용한다. Phase 5는 클로저와 고급 기능을 위해 커스텀 dialect를 도입한다.</p>
<h2 id="요약"><a class="header" href="#요약">요약</a></h2>
<p>이 appendix에서 다음을 배웠다:</p>
<ol>
<li><strong>C API 제한</strong>: MLIR C API는 커스텀 dialect 정의를 지원하지 않는다 - C++ 필요</li>
<li><strong>C++ 래퍼 패턴</strong>: C++에서 dialect를 정의하고 <code>extern "C"</code> shim으로 노출</li>
<li><strong>F# 통합</strong>: P/Invoke로 shim 호출, 빌트인 dialect처럼 사용</li>
<li><strong>TableGen</strong>: Operation 정의를 위한 MLIR의 코드 생성 도구</li>
<li><strong>점진적 낮추기</strong>: 커스텀 operation → 표준 dialect → LLVM</li>
</ol>
<p><strong>Phase 5 미리 보기:</strong></p>
<ul>
<li>FunLang dialect 정의 (<code>funlang.closure</code>, <code>funlang.apply</code>, <code>funlang.match</code>)</li>
<li>TableGen으로 operation 생성</li>
<li>낮추기 pass 작성 (pattern rewrite 사용)</li>
<li>이전 chapter들을 커스텀 dialect 사용으로 리팩터링</li>
</ul>
<p><strong>리소스:</strong></p>
<ul>
<li><a href="https://mlir.llvm.org/docs/DefiningDialects/">MLIR Dialect 정의 가이드</a></li>
<li><a href="https://mlir.llvm.org/docs/OpDefinitions/">MLIR TableGen 참조</a></li>
<li><a href="https://mlir.llvm.org/docs/CAPI/">MLIR C API 문서</a></li>
</ul>
<hr>
<p><strong>이것으로 Phase 1이 완료되었다!</strong> Chapter 00-05와 이 appendix를 통해 MLIR 기반 컴파일러 구축을 위한 완전한 기초를 갖추었다. Phase 2에서 FunLang의 더 많은 기능을 컴파일하기 시작할 것이다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
