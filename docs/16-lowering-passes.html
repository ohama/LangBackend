<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chapter 16: Lowering Passes - LangBackend Tutorial</title>


        <!-- Custom HTML head -->

        <meta name="description" content="MLIR 기반 FunLang 컴파일러 백엔드 튜토리얼">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-e7b79bcf.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-744e4df7.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">LangBackend Tutorial</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/ohama/LangBackend" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>
                        <a href="https://github.com/ohama/LangBackend/edit/master/tutorial/./16-lowering-passes.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <span class=fa-svg id="git-edit-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M421.7 220.3l-11.3 11.3-22.6 22.6-205 205c-6.6 6.6-14.8 11.5-23.8 14.1L30.8 511c-8.4 2.5-17.5 .2-23.7-6.1S-1.5 489.7 1 481.2L38.7 353.1c2.6-9 7.5-17.2 14.1-23.8l205-205 22.6-22.6 11.3-11.3 33.9 33.9 62.1 62.1 33.9 33.9zM96 353.9l-9.3 9.3c-.9 .9-1.6 2.1-2 3.4l-25.3 86 86-25.3c1.3-.4 2.5-1.1 3.4-2l9.3-9.3H112c-8.8 0-16-7.2-16-16V353.9zM453.3 19.3l39.4 39.4c25 25 25 65.5 0 90.5l-14.5 14.5-22.6 22.6-11.3 11.3-33.9-33.9-62.1-62.1L314.3 67.7l11.3-11.3 22.6-22.6 14.5-14.5c25-25 65.5-25 90.5 0z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="chapter-16-lowering-passes-lowering-passes"><a class="header" href="#chapter-16-lowering-passes-lowering-passes">Chapter 16: Lowering Passes (Lowering Passes)</a></h1>
<h2 id="소개"><a class="header" href="#소개">소개</a></h2>
<p><strong>Phase 5의 여정이 완성된다.</strong> Chapter 14에서 커스텀 dialect의 <strong>이론</strong>을 다뤘고, Chapter 15에서 FunLang operations를 <strong>정의</strong>했다. 이제 마지막 퍼즐 조각: <strong>lowering</strong>이다.</p>
<h3 id="chapter-14-15-복습"><a class="header" href="#chapter-14-15-복습">Chapter 14-15 복습</a></h3>
<p><strong>Chapter 14: Custom Dialect Design</strong></p>
<ul>
<li>Progressive lowering 철학 (FunLang → Func/SCF → LLVM)</li>
<li>TableGen ODS로 operation 정의</li>
<li>C API shim pattern으로 F# 연결</li>
<li>FunLang dialect 설계 방향</li>
</ul>
<p><strong>Chapter 15: Custom Operations</strong></p>
<ul>
<li><code>funlang.closure</code> operation: 클로저 생성 추상화</li>
<li><code>funlang.apply</code> operation: 클로저 호출 추상화</li>
<li><code>!funlang.closure</code> custom type: 타입 안전성</li>
<li>F# integration: C API → P/Invoke → OpBuilder extensions</li>
</ul>
<p><strong>현재 상태:</strong></p>
<pre><code class="language-mlir">// Phase 5 FunLang dialect (Chapter 15)
func.func @make_adder(%n: i32) -&gt; !funlang.closure {
    %closure = funlang.closure @lambda_adder, %n : !funlang.closure
    func.return %closure : !funlang.closure
}

func.func @lambda_adder(%env: !llvm.ptr, %x: i32) -&gt; i32 {
    // 환경에서 n 로드
    %n_slot = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
    %n = llvm.load %n_slot : !llvm.ptr -&gt; i32
    %result = arith.addi %x, %n : i32
    func.return %result : i32
}
</code></pre>
<p><strong>문제:</strong> <code>funlang.closure</code>는 high-level operation이다. LLVM backend는 이걸 이해 못한다. <strong>Lowering pass</strong>가 필요하다.</p>
<h3 id="lowering-pass란"><a class="header" href="#lowering-pass란">Lowering Pass란?</a></h3>
<p><strong>Lowering pass</strong>는 high-level operation을 low-level operation으로 변환하는 MLIR transformation이다.</p>
<p><strong>FunLang의 Progressive Lowering:</strong></p>
<pre><code>1. FunLang dialect (Chapter 15)
   funlang.closure, funlang.apply
   ↓
2. Func + SCF + MemRef (중간 추상화)
   func.func, scf.if, memref.alloca
   ↓
3. LLVM dialect (Chapter 12-13 패턴)
   llvm.call, llvm.getelementptr, llvm.store
   ↓
4. LLVM IR (MLIR → LLVM translation)
   call @GC_malloc, getelementptr, store
</code></pre>
<p><strong>Chapter 16의 scope:</strong> FunLang dialect → LLVM dialect (Step 1 → 3)</p>
<p><strong>왜 직접 LLVM dialect로?</strong></p>
<p>Phase 5에서는 간단한 클로저만 다룬다. 중간 dialect(SCF, MemRef)를 거칠 필요가 없다. <strong>직접 lowering</strong>이 효율적이다.</p>
<blockquote>
<p><strong>Phase 6 preview:</strong> 패턴 매칭 (<code>funlang.match</code>)은 복잡한 제어 흐름을 포함한다. 그때는 SCF dialect를 거쳐서 lowering한다.</p>
</blockquote>
<h3 id="lowering-목표"><a class="header" href="#lowering-목표">Lowering 목표</a></h3>
<p><strong>Before lowering (FunLang dialect):</strong></p>
<pre><code class="language-mlir">%closure = funlang.closure @lambda, %n : !funlang.closure
%result = funlang.apply %closure(%x) : (i32) -&gt; i32
</code></pre>
<p><strong>After lowering (LLVM dialect):</strong></p>
<pre><code class="language-mlir">// funlang.closure → GC_malloc + getelementptr + store
%env_size = arith.constant 16 : i64
%env = llvm.call @GC_malloc(%env_size) : (i64) -&gt; !llvm.ptr
%fn_ptr = llvm.mlir.addressof @lambda : !llvm.ptr
%slot0 = llvm.getelementptr %env[0] : (!llvm.ptr) -&gt; !llvm.ptr
llvm.store %fn_ptr, %slot0 : !llvm.ptr, !llvm.ptr
%slot1 = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
llvm.store %n, %slot1 : i32, !llvm.ptr

// funlang.apply → getelementptr + load + llvm.call
%fn_ptr_addr = llvm.getelementptr %env[0] : (!llvm.ptr) -&gt; !llvm.ptr
%fn_ptr = llvm.load %fn_ptr_addr : !llvm.ptr -&gt; !llvm.ptr
%result = llvm.call %fn_ptr(%env, %x) : (!llvm.ptr, i32) -&gt; i32
</code></pre>
<p><strong>Lowering은 Chapter 12-13의 패턴을 재사용한다.</strong> 수동으로 작성하던 코드를, 이제 compiler pass가 자동으로 생성한다.</p>
<h3 id="chapter-16-목표"><a class="header" href="#chapter-16-목표">Chapter 16 목표</a></h3>
<p>이 장을 마치면:</p>
<ol>
<li>
<p><strong>DialectConversion framework 이해</strong></p>
<ul>
<li><code>ConversionTarget</code>: 어떤 dialect가 합법적인가?</li>
<li><code>RewritePatternSet</code>: 어떻게 변환하는가?</li>
<li><code>TypeConverter</code>: 타입은 어떻게 변환하는가?</li>
</ul>
</li>
<li>
<p><strong>ConversionPattern 작성 능력</strong></p>
<ul>
<li><code>ClosureOpLowering</code>: <code>funlang.closure</code> → LLVM operations</li>
<li><code>ApplyOpLowering</code>: <code>funlang.apply</code> → LLVM operations</li>
</ul>
</li>
<li>
<p><strong>DRR (Declarative Rewrite Rules) 이해</strong></p>
<ul>
<li>TableGen 기반 패턴 매칭</li>
<li>최적화 패턴 작성 (empty closure, known closure inlining)</li>
</ul>
</li>
<li>
<p><strong>Complete lowering pass 구현</strong></p>
<ul>
<li>Pass 등록 및 실행</li>
<li>C API shim 작성</li>
<li>F#에서 pass 호출</li>
</ul>
</li>
<li>
<p><strong>End-to-end 이해</strong></p>
<ul>
<li>FunLang source → LLVM IR → executable</li>
<li>전체 컴파일 파이프라인</li>
</ul>
</li>
</ol>
<p><strong>성공 기준:</strong></p>
<pre><code class="language-fsharp">// F# source
let makeAdder n = fun x -&gt; x + n
let add5 = makeAdder 5
let result = add5 10   // 15

// Compile and run
let mlir = compileFunLang source
let mlir' = lowerFunLangToLLVM mlir  // &lt;- Chapter 16!
let llvmir = translateToLLVMIR mlir'
let executable = compileAndLink llvmir
runExecutable executable  // Prints: 15
</code></pre>
<p><strong>Chapter 16 roadmap:</strong></p>
<ol>
<li><strong>DialectConversion Framework</strong> (350+ lines)</li>
<li><strong>ClosureOp Lowering Pattern</strong> (450+ lines)</li>
<li><strong>ApplyOp Lowering Pattern</strong> (350+ lines)</li>
<li><strong>TypeConverter for FunLang Types</strong> (250+ lines)</li>
<li><strong>Declarative Rewrite Rules (DRR)</strong> (300+ lines)</li>
<li><strong>Complete Lowering Pass</strong> (250+ lines)</li>
<li><strong>End-to-End Example</strong> (200+ lines)</li>
<li><strong>Common Errors</strong> (100+ lines)</li>
<li><strong>Summary</strong> (50+ lines)</li>
</ol>
<hr>
<h2 id="dialectconversion-framework"><a class="header" href="#dialectconversion-framework">DialectConversion Framework</a></h2>
<p>MLIR의 <strong>DialectConversion framework</strong>는 dialect 간 변환을 위한 인프라다. 핵심 개념 3가지:</p>
<ol>
<li><strong>ConversionTarget</strong>: 변환 후 허용되는 operations</li>
<li><strong>RewritePatternSet</strong>: 변환 규칙 집합</li>
<li><strong>TypeConverter</strong>: 타입 변환 규칙</li>
</ol>
<h3 id="conversiontarget-legal-vs-illegal-operations"><a class="header" href="#conversiontarget-legal-vs-illegal-operations">ConversionTarget: Legal vs Illegal Operations</a></h3>
<p><strong>ConversionTarget</strong>은 “변환 후 어떤 operations가 남아도 되는가?“를 정의한다.</p>
<pre><code class="language-cpp">ConversionTarget target(getContext());

// Legal: 이 dialects의 operations는 변환 후에도 OK
target.addLegalDialect&lt;LLVM::LLVMDialect&gt;();
target.addLegalDialect&lt;func::FuncDialect&gt;();
target.addLegalDialect&lt;arith::ArithDialect&gt;();

// Illegal: 이 dialects의 operations는 반드시 변환되어야 함
target.addIllegalDialect&lt;funlang::FunLangDialect&gt;();
</code></pre>
<p><strong>의미:</strong></p>
<ul>
<li><strong>Legal dialect</strong>: 최종 IR에 존재해도 된다</li>
<li><strong>Illegal dialect</strong>: 최종 IR에 존재하면 안 된다 (변환 필수)</li>
</ul>
<p><strong>예시: FunLangToLLVM pass</strong></p>
<pre><code class="language-cpp">ConversionTarget target(getContext());

// Legal: LLVM operations는 OK (최종 목표)
target.addLegalDialect&lt;LLVM::LLVMDialect&gt;();

// Legal: func operations는 OK (func.func, func.return 필요)
target.addLegalDialect&lt;func::FuncDialect&gt;();

// Legal: arith operations는 OK (상수, 산술 연산)
target.addLegalDialect&lt;arith::ArithDialect&gt;();

// Illegal: FunLang operations는 반드시 lowering되어야 함
target.addIllegalDialect&lt;funlang::FunLangDialect&gt;();
</code></pre>
<p><strong>변환 후:</strong></p>
<pre><code class="language-mlir">// OK - func.func (legal)
func.func @foo() {
    // OK - arith.constant (legal)
    %c = arith.constant 10 : i32

    // OK - llvm.call (legal)
    %ptr = llvm.call @GC_malloc(...) : (...) -&gt; !llvm.ptr

    // ERROR - funlang.closure (illegal!)
    %closure = funlang.closure @bar : !funlang.closure
}
</code></pre>
<p><code>funlang.closure</code>가 남아있으면 <strong>conversion failure</strong>다.</p>
<h3 id="addlegalop-vs-addillegalop-fine-grained-control"><a class="header" href="#addlegalop-vs-addillegalop-fine-grained-control">addLegalOp vs addIllegalOp: Fine-grained Control</a></h3>
<p>Dialect 전체가 아니라 <strong>특정 operation</strong>만 제어할 수도 있다.</p>
<pre><code class="language-cpp">// FuncDialect 전체가 아니라 특정 operations만 legal
target.addLegalOp&lt;func::FuncOp, func::ReturnOp&gt;();

// 특정 operation만 illegal
target.addIllegalOp&lt;funlang::ClosureOp, funlang::ApplyOp&gt;();
</code></pre>
<p><strong>사용 사례:</strong> Partial lowering (일부만 변환)</p>
<pre><code class="language-cpp">// SCF dialect 중 일부는 legal (scf.while은 그대로 둠)
target.addLegalDialect&lt;scf::SCFDialect&gt;();
target.addIllegalOp&lt;scf::IfOp&gt;();  // scf.if만 lowering
</code></pre>
<h3 id="adddynamicallylegalop-conditional-legality"><a class="header" href="#adddynamicallylegalop-conditional-legality">addDynamicallyLegalOp: Conditional Legality</a></h3>
<p><strong>Dynamic legality</strong>: 런타임에 판단한다.</p>
<pre><code class="language-cpp">target.addDynamicallyLegalOp&lt;func::CallOp&gt;(
    [](func::CallOp op) {
        // FunLang 타입을 사용하는 call은 illegal (변환 필요)
        return !llvm::any_of(op.getOperandTypes(), [](Type type) {
            return type.isa&lt;funlang::ClosureType&gt;();
        });
    }
);
</code></pre>
<p><strong>의미:</strong> <code>func.call</code>이 <code>!funlang.closure</code> 타입을 사용하면 illegal (lowering 필요). 그렇지 않으면 legal (그대로 둠).</p>
<p><strong>사용 사례:</strong> 타입 의존적 변환</p>
<pre><code class="language-mlir">// Legal (i32 타입만 사용)
%result = func.call @add(%x, %y) : (i32, i32) -&gt; i32

// Illegal (funlang.closure 타입 사용)
%result = func.call @apply(%closure, %x) : (!funlang.closure, i32) -&gt; i32
</code></pre>
<h3 id="rewritepatternset-변환-규칙-집합"><a class="header" href="#rewritepatternset-변환-규칙-집합">RewritePatternSet: 변환 규칙 집합</a></h3>
<p><strong>RewritePatternSet</strong>은 “어떻게 변환하는가?“를 정의한다.</p>
<pre><code class="language-cpp">RewritePatternSet patterns(&amp;getContext());

// ConversionPattern 추가
patterns.add&lt;ClosureOpLowering&gt;(&amp;getContext());
patterns.add&lt;ApplyOpLowering&gt;(&amp;getContext());

// 여러 patterns를 한 번에 추가
patterns.add&lt;ClosureOpLowering, ApplyOpLowering, MatchOpLowering&gt;(&amp;getContext());
</code></pre>
<p><strong>Pattern의 역할:</strong></p>
<ul>
<li>특정 operation을 매치한다 (<code>funlang.closure</code>)</li>
<li>새로운 operations로 교체한다 (LLVM operations)</li>
</ul>
<h3 id="applypartialconversion-vs-applyfullconversion"><a class="header" href="#applypartialconversion-vs-applyfullconversion">applyPartialConversion vs applyFullConversion</a></h3>
<p>변환을 실행하는 방법 2가지:</p>
<p><strong>1. applyPartialConversion: 부분 변환</strong></p>
<pre><code class="language-cpp">if (failed(applyPartialConversion(moduleOp, target, std::move(patterns)))) {
    signalPassFailure();
}
</code></pre>
<ul>
<li><strong>일부 illegal operations가 남아도 OK</strong> (변환 패턴이 없으면 그냥 둠)</li>
<li><strong>사용 사례:</strong> Multi-stage lowering (여러 pass로 나눔)</li>
</ul>
<p><strong>2. applyFullConversion: 완전 변환</strong></p>
<pre><code class="language-cpp">if (failed(applyFullConversion(moduleOp, target, std::move(patterns)))) {
    signalPassFailure();
}
</code></pre>
<ul>
<li><strong>모든 illegal operations를 변환해야 함</strong> (하나라도 남으면 failure)</li>
<li><strong>사용 사례:</strong> Final lowering pass (더 이상 illegal operations 없어야 함)</li>
</ul>
<p><strong>FunLangToLLVM pass: Partial conversion 사용</strong></p>
<pre><code class="language-cpp">// Partial conversion: 다른 dialect의 operations는 나중에 lowering
if (failed(applyPartialConversion(getOperation(), target, std::move(patterns)))) {
    signalPassFailure();
}
</code></pre>
<p><strong>왜 Partial?</strong></p>
<ul>
<li><code>arith</code> operations는 나중에 별도 pass로 lowering (<code>--convert-arith-to-llvm</code>)</li>
<li><code>func</code> operations도 별도 pass로 lowering (<code>--convert-func-to-llvm</code>)</li>
<li>FunLang operations만 먼저 lowering</li>
</ul>
<h3 id="typeconverter-타입-변환"><a class="header" href="#typeconverter-타입-변환">TypeConverter: 타입 변환</a></h3>
<p><strong>TypeConverter</strong>는 “타입을 어떻게 변환하는가?“를 정의한다.</p>
<pre><code class="language-cpp">TypeConverter typeConverter;

// FunLang 타입 → LLVM 타입
typeConverter.addConversion([](funlang::ClosureType type) {
    return LLVM::LLVMPointerType::get(type.getContext());
});

typeConverter.addConversion([](funlang::ListType type) {
    return LLVM::LLVMPointerType::get(type.getContext());
});

// 기본 타입은 그대로
typeConverter.addConversion([](Type type) {
    return type;  // i32, i64 etc.
});
</code></pre>
<p><strong>변환 예시:</strong></p>
<pre><code class="language-mlir">// Before
%closure : !funlang.closure

// After
%closure : !llvm.ptr
</code></pre>
<p><strong>TypeConverter의 역할:</strong></p>
<ol>
<li>
<p><strong>Operation result types 변환</strong></p>
<pre><code class="language-cpp">Type resultType = typeConverter.convertType(op.getResult().getType());
</code></pre>
</li>
<li>
<p><strong>Function signatures 변환</strong></p>
<pre><code class="language-mlir">// Before
func.func @apply(%f: !funlang.closure) -&gt; i32

// After
func.func @apply(%f: !llvm.ptr) -&gt; i32
</code></pre>
</li>
<li>
<p><strong>Block arguments 변환</strong> (region 내부 타입)</p>
</li>
</ol>
<p><strong>Conversion patterns에서 TypeConverter 사용:</strong></p>
<pre><code class="language-cpp">struct ApplyOpLowering : public OpConversionPattern&lt;funlang::ApplyOp&gt; {
  using OpConversionPattern&lt;funlang::ApplyOp&gt;::OpConversionPattern;

  LogicalResult matchAndRewrite(
      funlang::ApplyOp op, OpAdaptor adaptor,
      ConversionPatternRewriter &amp;rewriter) const override {

    // TypeConverter를 통해 result type 변환
    Type resultType = getTypeConverter()-&gt;convertType(op.getResult().getType());

    // ...
  }
};
</code></pre>
<p><strong>ConversionPattern에 TypeConverter 전달:</strong></p>
<pre><code class="language-cpp">RewritePatternSet patterns(&amp;getContext());
patterns.add&lt;ApplyOpLowering&gt;(&amp;getContext(), typeConverter);
//                                           ^^^^^^^^^^^^^^
//                                           TypeConverter 전달
</code></pre>
<h3 id="변환-실패-처리"><a class="header" href="#변환-실패-처리">변환 실패 처리</a></h3>
<p>변환이 실패하면 pass가 실패를 알려야 한다.</p>
<pre><code class="language-cpp">void runOnOperation() override {
    // ...

    if (failed(applyPartialConversion(getOperation(), target, std::move(patterns)))) {
        // 변환 실패 시그널
        signalPassFailure();
        return;
    }
}
</code></pre>
<p><strong>실패 원인:</strong></p>
<ol>
<li><strong>Illegal operation이 남음</strong>: Pattern이 없거나 매치 실패</li>
<li><strong>타입 변환 실패</strong>: TypeConverter에 규칙 없음</li>
<li><strong>Pattern이 failure 반환</strong>: <code>matchAndRewrite</code>에서 <code>failure()</code> 리턴</li>
</ol>
<p><strong>디버깅:</strong></p>
<pre><code class="language-bash"># Verbose mode로 실행
mlir-opt --funlang-to-llvm --debug input.mlir

# 에러 메시지 예시:
# error: failed to legalize operation 'funlang.closure'
# note: see current operation: %0 = "funlang.closure"() ...
</code></pre>
<h3 id="dialectconversion-전체-흐름"><a class="header" href="#dialectconversion-전체-흐름">DialectConversion 전체 흐름</a></h3>
<p><strong>1. Target 정의:</strong></p>
<pre><code class="language-cpp">ConversionTarget target(getContext());
target.addLegalDialect&lt;LLVM::LLVMDialect&gt;();
target.addIllegalDialect&lt;funlang::FunLangDialect&gt;();
</code></pre>
<p><strong>2. TypeConverter 설정:</strong></p>
<pre><code class="language-cpp">TypeConverter typeConverter;
typeConverter.addConversion([](funlang::ClosureType type) {
    return LLVM::LLVMPointerType::get(type.getContext());
});
</code></pre>
<p><strong>3. Patterns 구성:</strong></p>
<pre><code class="language-cpp">RewritePatternSet patterns(&amp;getContext());
patterns.add&lt;ClosureOpLowering, ApplyOpLowering&gt;(&amp;getContext(), typeConverter);
</code></pre>
<p><strong>4. 변환 실행:</strong></p>
<pre><code class="language-cpp">if (failed(applyPartialConversion(getOperation(), target, std::move(patterns)))) {
    signalPassFailure();
}
</code></pre>
<p><strong>5. 검증:</strong></p>
<p>변환 후 IR에 illegal operations가 없는지 확인.</p>
<pre><code class="language-mlir">// 변환 전
%closure = funlang.closure @foo : !funlang.closure

// 변환 후
%env = llvm.call @GC_malloc(...) : (...) -&gt; !llvm.ptr
// ... (LLVM operations only)
</code></pre>
<hr>
<h2 id="closureop-lowering-pattern"><a class="header" href="#closureop-lowering-pattern">ClosureOp Lowering Pattern</a></h2>
<p><strong><code>funlang.closure</code>를 LLVM dialect로 lowering한다.</strong> Chapter 12의 클로저 생성 패턴을 재사용한다.</p>
<h3 id="chapter-12-복습-클로저-생성-패턴"><a class="header" href="#chapter-12-복습-클로저-생성-패턴">Chapter 12 복습: 클로저 생성 패턴</a></h3>
<p><strong>Closure 구조 (Chapter 12):</strong></p>
<pre><code>Environment layout (heap-allocated):
+--------+----------+----------+-----+
| fn_ptr | var1     | var2     | ... |
+--------+----------+----------+-----+
  slot 0   slot 1     slot 2
  8 bytes  variable   variable
</code></pre>
<p><strong>클로저 생성 MLIR (Chapter 12):</strong></p>
<pre><code class="language-mlir">func.func @make_adder(%n: i32) -&gt; !llvm.ptr {
    // 1. 환경 크기 계산: 8 (fn_ptr) + 8 (n)
    %env_size = arith.constant 16 : i64

    // 2. GC_malloc 호출
    %env = llvm.call @GC_malloc(%env_size) : (i64) -&gt; !llvm.ptr

    // 3. 함수 포인터 저장 (slot 0)
    %fn_ptr = llvm.mlir.addressof @lambda_adder : !llvm.ptr
    %slot0 = llvm.getelementptr %env[0] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %fn_ptr, %slot0 : !llvm.ptr, !llvm.ptr

    // 4. 캡처된 변수 n 저장 (slot 1)
    %slot1 = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %n, %slot1 : i32, !llvm.ptr

    // 5. 환경 포인터 반환
    func.return %env : !llvm.ptr
}
</code></pre>
<p><strong>Lowering 목표:</strong> <code>funlang.closure</code>를 위 패턴으로 확장한다.</p>
<h3 id="funlangclosure-operation-chapter-15-복습"><a class="header" href="#funlangclosure-operation-chapter-15-복습">funlang.closure Operation (Chapter 15 복습)</a></h3>
<p><strong>ODS 정의:</strong></p>
<pre><code class="language-tablegen">def FunLang_ClosureOp : FunLang_Op&lt;"closure", [Pure]&gt; {
  let summary = "Create a closure";

  let arguments = (ins
    FlatSymbolRefAttr:$callee,
    Variadic&lt;AnyType&gt;:$captured
  );

  let results = (outs FunLang_ClosureType:$result);

  let assemblyFormat = "$callee `,` $captured attr-dict `:` type($result)";
}
</code></pre>
<p><strong>사용 예시:</strong></p>
<pre><code class="language-mlir">// 캡처 변수 없음
%closure = funlang.closure @foo : !funlang.closure

// 캡처 변수 1개
%closure = funlang.closure @bar, %n : !funlang.closure

// 캡처 변수 여러 개
%closure = funlang.closure @baz, %x, %y, %z : !funlang.closure
</code></pre>
<h3 id="closureop-lowering-전략"><a class="header" href="#closureop-lowering-전략">ClosureOp Lowering 전략</a></h3>
<p><strong>입력:</strong> <code>funlang.closure @callee, %captured... : !funlang.closure</code></p>
<p><strong>출력:</strong> LLVM dialect operations</p>
<ol>
<li><strong>환경 크기 계산</strong>: <code>8 + (captured 개수 * 8)</code> bytes</li>
<li><strong>GC_malloc 호출</strong>: 환경 힙 할당</li>
<li><strong>함수 포인터 저장</strong>: <code>env[0] = @callee</code></li>
<li><strong>캡처 변수들 저장</strong>: <code>env[1] = captured[0]</code>, <code>env[2] = captured[1]</code>, …</li>
<li><strong>환경 포인터 반환</strong>: <code>!llvm.ptr</code></li>
</ol>
<h3 id="conversionpattern-구조"><a class="header" href="#conversionpattern-구조">ConversionPattern 구조</a></h3>
<p><strong>OpConversionPattern 템플릿:</strong></p>
<pre><code class="language-cpp">struct ClosureOpLowering : public OpConversionPattern&lt;funlang::ClosureOp&gt; {
  using OpConversionPattern&lt;funlang::ClosureOp&gt;::OpConversionPattern;

  LogicalResult matchAndRewrite(
      funlang::ClosureOp op,           // 원본 operation
      OpAdaptor adaptor,                // 변환된 operands
      ConversionPatternRewriter &amp;rewriter  // IR 수정 도구
  ) const override {

    // Lowering 로직 구현

    return success();  // 또는 failure()
  }
};
</code></pre>
<p><strong>핵심 파라미터:</strong></p>
<ol>
<li>
<p><strong><code>op</code></strong>: 원본 <code>funlang.closure</code> operation</p>
<ul>
<li><code>op.getLoc()</code>: source location</li>
<li><code>op.getCalleeAttr()</code>: 함수 심볼 (<code>@callee</code>)</li>
<li><code>op.getResult()</code>: result value</li>
</ul>
</li>
<li>
<p><strong><code>adaptor</code></strong>: 변환된 operands</p>
<ul>
<li><code>adaptor.getCaptured()</code>: 캡처된 변수들 (타입 이미 변환됨)</li>
</ul>
</li>
<li>
<p><strong><code>rewriter</code></strong>: IR 빌더</p>
<ul>
<li><code>rewriter.create&lt;...&gt;()</code>: 새 operation 생성</li>
<li><code>rewriter.replaceOp()</code>: 원본 operation 교체</li>
</ul>
</li>
</ol>
<h3 id="closureoplowering-구현-complete"><a class="header" href="#closureoplowering-구현-complete">ClosureOpLowering 구현 (Complete)</a></h3>
<pre><code class="language-cpp">struct ClosureOpLowering : public OpConversionPattern&lt;funlang::ClosureOp&gt; {
  using OpConversionPattern&lt;funlang::ClosureOp&gt;::OpConversionPattern;

  LogicalResult matchAndRewrite(
      funlang::ClosureOp op, OpAdaptor adaptor,
      ConversionPatternRewriter &amp;rewriter) const override {

    auto loc = op.getLoc();
    auto ctx = rewriter.getContext();

    // ==============================
    // 1. 환경 크기 계산
    // ==============================
    size_t numCaptured = adaptor.getCaptured().size();

    // fn_ptr (8 bytes) + captured vars (8 bytes each)
    // 단순화: 모든 변수를 8 bytes로 가정 (포인터 크기)
    size_t envSize = 8 + numCaptured * 8;

    auto i64Type = rewriter.getI64Type();
    auto envSizeConst = rewriter.create&lt;arith::ConstantOp&gt;(
        loc, i64Type, rewriter.getI64IntegerAttr(envSize));

    // ==============================
    // 2. GC_malloc 호출
    // ==============================
    auto ptrType = LLVM::LLVMPointerType::get(ctx);
    auto gcMalloc = rewriter.create&lt;LLVM::CallOp&gt;(
        loc, ptrType, "GC_malloc", ValueRange{envSizeConst});
    Value envPtr = gcMalloc.getResult(0);

    // ==============================
    // 3. 함수 포인터 저장 (env[0])
    // ==============================
    auto fnPtrAddr = rewriter.create&lt;LLVM::AddressOfOp&gt;(
        loc, ptrType, op.getCalleeAttr());

    auto slot0 = rewriter.create&lt;LLVM::GEPOp&gt;(
        loc, ptrType, ptrType, envPtr,
        ArrayRef&lt;LLVM::GEPArg&gt;{0});

    rewriter.create&lt;LLVM::StoreOp&gt;(loc, fnPtrAddr, slot0);

    // ==============================
    // 4. 캡처된 변수들 저장 (env[1..])
    // ==============================
    for (auto [idx, val] : llvm::enumerate(adaptor.getCaptured())) {
      auto slot = rewriter.create&lt;LLVM::GEPOp&gt;(
          loc, ptrType, ptrType, envPtr,
          ArrayRef&lt;LLVM::GEPArg&gt;{static_cast&lt;int32_t&gt;(idx + 1)});

      rewriter.create&lt;LLVM::StoreOp&gt;(loc, val, slot);
    }

    // ==============================
    // 5. 원본 operation 교체
    // ==============================
    rewriter.replaceOp(op, envPtr);
    return success();
  }
};
</code></pre>
<h3 id="코드-상세-설명"><a class="header" href="#코드-상세-설명">코드 상세 설명</a></h3>
<h4 id="1-환경-크기-계산"><a class="header" href="#1-환경-크기-계산">1. 환경 크기 계산</a></h4>
<pre><code class="language-cpp">size_t numCaptured = adaptor.getCaptured().size();
size_t envSize = 8 + numCaptured * 8;
</code></pre>
<ul>
<li><strong><code>adaptor.getCaptured()</code></strong>: 캡처된 변수들 (<code>ValueRange</code>)</li>
<li><strong>환경 레이아웃</strong>: <code>[fn_ptr(8), var1(8), var2(8), ...]</code></li>
<li><strong>단순화</strong>: 모든 변수를 8 bytes로 가정 (실제로는 타입별 크기 계산 필요)</li>
</ul>
<p><strong>arith.constant 생성:</strong></p>
<pre><code class="language-cpp">auto envSizeConst = rewriter.create&lt;arith::ConstantOp&gt;(
    loc, i64Type, rewriter.getI64IntegerAttr(envSize));
</code></pre>
<ul>
<li><strong><code>arith.constant 16 : i64</code></strong> 생성 (캡처 변수 1개일 때)</li>
<li><code>GC_malloc</code>에 전달할 인자</li>
</ul>
<h4 id="2-gc_malloc-호출"><a class="header" href="#2-gc_malloc-호출">2. GC_malloc 호출</a></h4>
<pre><code class="language-cpp">auto ptrType = LLVM::LLVMPointerType::get(ctx);
auto gcMalloc = rewriter.create&lt;LLVM::CallOp&gt;(
    loc, ptrType, "GC_malloc", ValueRange{envSizeConst});
Value envPtr = gcMalloc.getResult(0);
</code></pre>
<ul>
<li><strong><code>LLVM::CallOp</code></strong>: <code>llvm.call</code> operation 생성</li>
<li><strong>함수 이름</strong>: <code>"GC_malloc"</code> (string, external function)</li>
<li><strong>인자</strong>: <code>ValueRange{envSizeConst}</code> (환경 크기)</li>
<li><strong>반환 타입</strong>: <code>!llvm.ptr</code></li>
</ul>
<p><strong>생성된 MLIR:</strong></p>
<pre><code class="language-mlir">%0 = llvm.call @GC_malloc(%env_size) : (i64) -&gt; !llvm.ptr
</code></pre>
<h4 id="3-함수-포인터-저장"><a class="header" href="#3-함수-포인터-저장">3. 함수 포인터 저장</a></h4>
<pre><code class="language-cpp">auto fnPtrAddr = rewriter.create&lt;LLVM::AddressOfOp&gt;(
    loc, ptrType, op.getCalleeAttr());
</code></pre>
<ul>
<li><strong><code>LLVM::AddressOfOp</code></strong>: <code>llvm.mlir.addressof</code> operation</li>
<li><strong>심볼</strong>: <code>op.getCalleeAttr()</code> (예: <code>@lambda_adder</code>)</li>
<li><strong>타입</strong>: <code>!llvm.ptr</code></li>
</ul>
<p><strong>생성된 MLIR:</strong></p>
<pre><code class="language-mlir">%fn_ptr = llvm.mlir.addressof @lambda_adder : !llvm.ptr
</code></pre>
<p><strong>GEPOp으로 slot 0 주소 계산:</strong></p>
<pre><code class="language-cpp">auto slot0 = rewriter.create&lt;LLVM::GEPOp&gt;(
    loc, ptrType, ptrType, envPtr,
    ArrayRef&lt;LLVM::GEPArg&gt;{0});
</code></pre>
<ul>
<li><strong><code>LLVM::GEPOp</code></strong>: <code>llvm.getelementptr</code> operation</li>
<li><strong>베이스 포인터</strong>: <code>envPtr</code></li>
<li><strong>인덱스</strong>: <code>{0}</code> (첫 번째 슬롯)</li>
<li><strong>타입</strong>: <code>!llvm.ptr</code> (opaque pointer, LLVM 15+)</li>
</ul>
<p><strong>생성된 MLIR:</strong></p>
<pre><code class="language-mlir">%slot0 = llvm.getelementptr %env[0] : (!llvm.ptr) -&gt; !llvm.ptr
</code></pre>
<p><strong>함수 포인터 저장:</strong></p>
<pre><code class="language-cpp">rewriter.create&lt;LLVM::StoreOp&gt;(loc, fnPtrAddr, slot0);
</code></pre>
<p><strong>생성된 MLIR:</strong></p>
<pre><code class="language-mlir">llvm.store %fn_ptr, %slot0 : !llvm.ptr, !llvm.ptr
</code></pre>
<h4 id="4-캡처된-변수들-저장"><a class="header" href="#4-캡처된-변수들-저장">4. 캡처된 변수들 저장</a></h4>
<pre><code class="language-cpp">for (auto [idx, val] : llvm::enumerate(adaptor.getCaptured())) {
  auto slot = rewriter.create&lt;LLVM::GEPOp&gt;(
      loc, ptrType, ptrType, envPtr,
      ArrayRef&lt;LLVM::GEPArg&gt;{static_cast&lt;int32_t&gt;(idx + 1)});

  rewriter.create&lt;LLVM::StoreOp&gt;(loc, val, slot);
}
</code></pre>
<ul>
<li><strong><code>llvm::enumerate</code></strong>: <code>(index, value)</code> 쌍으로 순회</li>
<li><strong>인덱스</strong>: <code>idx + 1</code> (slot 0은 함수 포인터, slot 1부터 변수)</li>
<li><strong>각 변수를 GEP + store</strong></li>
</ul>
<p><strong>캡처 변수 2개일 때 생성된 MLIR:</strong></p>
<pre><code class="language-mlir">// 첫 번째 변수 (%n)
%slot1 = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
llvm.store %n, %slot1 : i32, !llvm.ptr

// 두 번째 변수 (%m)
%slot2 = llvm.getelementptr %env[2] : (!llvm.ptr) -&gt; !llvm.ptr
llvm.store %m, %slot2 : i32, !llvm.ptr
</code></pre>
<h4 id="5-원본-operation-교체"><a class="header" href="#5-원본-operation-교체">5. 원본 operation 교체</a></h4>
<pre><code class="language-cpp">rewriter.replaceOp(op, envPtr);
return success();
</code></pre>
<ul>
<li><strong><code>rewriter.replaceOp(op, envPtr)</code></strong>: <code>funlang.closure</code>를 <code>envPtr</code>로 교체</li>
<li><strong>SSA value 대체</strong>: <code>%closure</code>를 사용하던 곳이 이제 <code>%envPtr</code> 사용</li>
<li><strong><code>return success()</code></strong>: 변환 성공</li>
</ul>
<p><strong>Before:</strong></p>
<pre><code class="language-mlir">%closure = funlang.closure @lambda, %n : !funlang.closure
%result = funlang.apply %closure(%x) : (i32) -&gt; i32
</code></pre>
<p><strong>After:</strong></p>
<pre><code class="language-mlir">%env_size = arith.constant 16 : i64
%envPtr = llvm.call @GC_malloc(%env_size) : (i64) -&gt; !llvm.ptr
%fn_ptr = llvm.mlir.addressof @lambda : !llvm.ptr
%slot0 = llvm.getelementptr %envPtr[0] : (!llvm.ptr) -&gt; !llvm.ptr
llvm.store %fn_ptr, %slot0 : !llvm.ptr, !llvm.ptr
%slot1 = llvm.getelementptr %envPtr[1] : (!llvm.ptr) -&gt; !llvm.ptr
llvm.store %n, %slot1 : i32, !llvm.ptr

// %closure가 %envPtr로 교체됨
%result = funlang.apply %envPtr(%x) : (i32) -&gt; i32
</code></pre>
<h3 id="opadaptor의-역할"><a class="header" href="#opadaptor의-역할">OpAdaptor의 역할</a></h3>
<p>**<code>OpAdaptor</code>**는 <strong>변환된 operands</strong>를 제공한다.</p>
<p><strong>왜 필요한가?</strong></p>
<p>Conversion이 여러 단계로 이뤄질 때, operands의 타입이 이미 변환됐을 수 있다.</p>
<p><strong>예시:</strong></p>
<pre><code class="language-mlir">// Before
%captured = funlang.some_op : !funlang.closure
%closure = funlang.closure @foo, %captured : !funlang.closure

// After first pattern
%captured_lowered = ... : !llvm.ptr  // 이미 lowering됨!
%closure = funlang.closure @foo, %captured_lowered : !funlang.closure
</code></pre>
<p><code>ClosureOpLowering</code>이 실행될 때:</p>
<ul>
<li><code>op.getCaptured()[0]</code>는 원본 타입 (<code>!funlang.closure</code>)</li>
<li><code>adaptor.getCaptured()[0]</code>는 변환된 타입 (<code>!llvm.ptr</code>)</li>
</ul>
<p><strong>ConversionPattern에서는 항상 <code>adaptor</code> 사용:</strong></p>
<pre><code class="language-cpp">// 잘못됨!
for (Value val : op.getCaptured()) { ... }  // 원본 타입

// 올바름
for (Value val : adaptor.getCaptured()) { ... }  // 변환된 타입
</code></pre>
<h3 id="conversionpatternrewriter의-역할"><a class="header" href="#conversionpatternrewriter의-역할">ConversionPatternRewriter의 역할</a></h3>
<p>**<code>ConversionPatternRewriter</code>**는 <strong>IR 수정 인터페이스</strong>다.</p>
<p><strong>주요 메서드:</strong></p>
<pre><code class="language-cpp">// Operation 생성
auto newOp = rewriter.create&lt;SomeOp&gt;(loc, ...);

// Operation 교체
rewriter.replaceOp(oldOp, newValue);

// Operation 삭제
rewriter.eraseOp(op);

// 타입 변환
Type newType = rewriter.getTypeConverter()-&gt;convertType(oldType);

// 상수 생성 헬퍼
auto i32Type = rewriter.getI32Type();
auto attr = rewriter.getI32IntegerAttr(42);
</code></pre>
<p><strong>왜 일반 <code>OpBuilder</code>가 아닌가?</strong></p>
<p>Conversion framework는 <strong>transactional semantics</strong>를 제공한다:</p>
<ul>
<li>변환 실패 시 모든 변경 롤백</li>
<li>Operand mapping 자동 처리</li>
<li>Type conversion tracking</li>
</ul>
<p><strong>일반 rewriter 사용 금지:</strong></p>
<pre><code class="language-cpp">// 잘못됨!
OpBuilder builder(op.getContext());
builder.setInsertionPoint(op);
builder.create&lt;...&gt;(...);

// 올바름
rewriter.setInsertionPoint(op);
rewriter.create&lt;...&gt;(...);
</code></pre>
<h3 id="closureoplowering-테스트"><a class="header" href="#closureoplowering-테스트">ClosureOpLowering 테스트</a></h3>
<p><strong>입력 MLIR:</strong></p>
<pre><code class="language-mlir">func.func @test(%n: i32) -&gt; !funlang.closure {
    %closure = funlang.closure @lambda, %n : !funlang.closure
    func.return %closure : !funlang.closure
}
</code></pre>
<p><strong>Lowering pass 실행:</strong></p>
<pre><code class="language-bash">mlir-opt --funlang-to-llvm test.mlir
</code></pre>
<p><strong>출력 MLIR:</strong></p>
<pre><code class="language-mlir">func.func @test(%n: i32) -&gt; !llvm.ptr {
    %c16 = arith.constant 16 : i64
    %0 = llvm.call @GC_malloc(%c16) : (i64) -&gt; !llvm.ptr
    %1 = llvm.mlir.addressof @lambda : !llvm.ptr
    %2 = llvm.getelementptr %0[0] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %1, %2 : !llvm.ptr, !llvm.ptr
    %3 = llvm.getelementptr %0[1] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %n, %3 : i32, !llvm.ptr
    func.return %0 : !llvm.ptr
}
</code></pre>
<p><strong>검증:</strong></p>
<ol>
<li><code>funlang.closure</code> 사라짐 ✓</li>
<li><code>GC_malloc</code> 호출 있음 ✓</li>
<li>함수 포인터 저장 있음 ✓</li>
<li>캡처 변수 저장 있음 ✓</li>
<li>반환 타입 <code>!llvm.ptr</code> ✓</li>
</ol>
<h3 id="c-api-shim-preview"><a class="header" href="#c-api-shim-preview">C API Shim (Preview)</a></h3>
<p>Lowering pass를 F#에서 사용하려면 <strong>C API shim</strong>이 필요하다.</p>
<p><strong>C++ Pass 등록:</strong></p>
<pre><code class="language-cpp">// FunLangPasses.cpp
void registerFunLangToLLVMPass() {
  PassRegistration&lt;FunLangToLLVMPass&gt;(
      "funlang-to-llvm",
      "Lower FunLang dialect to LLVM dialect");
}

// C API shim
extern "C" void mlirFunLangRegisterToLLVMPass() {
  registerFunLangToLLVMPass();
}

extern "C" void mlirFunLangRunToLLVMPass(MlirModule module) {
  ModuleOp moduleOp = unwrap(module);
  PassManager pm(moduleOp.getContext());
  pm.addPass(std::make_unique&lt;FunLangToLLVMPass&gt;());
  if (failed(pm.run(moduleOp))) {
    llvm::errs() &lt;&lt; "FunLangToLLVM pass failed\n";
  }
}
</code></pre>
<p><strong>F# P/Invoke:</strong></p>
<pre><code class="language-fsharp">[&lt;DllImport("funlang-dialect", CallingConvention = CallingConvention.Cdecl)&gt;]
extern void mlirFunLangRegisterToLLVMPass()

[&lt;DllImport("funlang-dialect", CallingConvention = CallingConvention.Cdecl)&gt;]
extern void mlirFunLangRunToLLVMPass(MlirModule module)

// 사용
let lowerToLLVM (module_: MlirModule) =
    mlirFunLangRunToLLVMPass(module_)
</code></pre>
<p><strong>전체 pass pipeline 구성:</strong></p>
<pre><code class="language-fsharp">let compileToLLVM (mlir: MlirModule) =
    // 1. FunLang → LLVM
    mlirFunLangRunToLLVMPass(mlir)

    // 2. Arith → LLVM
    mlirRunArithToLLVMPass(mlir)

    // 3. Func → LLVM
    mlirRunFuncToLLVMPass(mlir)

    // 4. LLVM dialect → LLVM IR
    mlirTranslateToLLVMIR(mlir)
</code></pre>
<p><strong>Section 2와 3 요약:</strong></p>
<ul>
<li><strong>DialectConversion framework</strong>: Target + Patterns + TypeConverter</li>
<li><strong>ClosureOpLowering</strong>: <code>funlang.closure</code> → GC_malloc + GEP + store 패턴</li>
<li><strong>OpAdaptor</strong>: 변환된 operands 제공</li>
<li><strong>ConversionPatternRewriter</strong>: IR 수정 인터페이스</li>
<li><strong>C API shim</strong>: F#에서 pass 실행</li>
</ul>
<p><strong>다음 Section:</strong> <code>funlang.apply</code> lowering pattern 구현</p>
<hr>
<h2 id="applyop-lowering-pattern"><a class="header" href="#applyop-lowering-pattern">ApplyOp Lowering Pattern</a></h2>
<p><strong><code>funlang.apply</code>를 LLVM dialect로 lowering한다.</strong> Chapter 13의 간접 호출 패턴을 재사용한다.</p>
<h3 id="chapter-13-복습-간접-호출-패턴"><a class="header" href="#chapter-13-복습-간접-호출-패턴">Chapter 13 복습: 간접 호출 패턴</a></h3>
<p><strong>Closure application (Chapter 13):</strong></p>
<pre><code class="language-mlir">func.func @apply(%f: !llvm.ptr, %x: i32) -&gt; i32 {
    // 1. 환경에서 함수 포인터 로드 (env[0])
    %fn_ptr_addr = llvm.getelementptr %f[0] : (!llvm.ptr) -&gt; !llvm.ptr
    %fn_ptr = llvm.load %fn_ptr_addr : !llvm.ptr -&gt; !llvm.ptr

    // 2. 간접 호출 (fn_ptr를 통해 호출)
    // 첫 번째 인자: 환경 포인터 (%f)
    // 나머지 인자: 실제 인자 (%x)
    %result = llvm.call %fn_ptr(%f, %x) : (!llvm.ptr, i32) -&gt; i32

    func.return %result : i32
}
</code></pre>
<p><strong>핵심 단계:</strong></p>
<ol>
<li><strong>함수 포인터 추출</strong>: <code>env[0]</code>에서 로드</li>
<li><strong>인자 구성</strong>: <code>[환경 포인터, 실제 인자들]</code></li>
<li><strong>간접 호출</strong>: <code>llvm.call %fn_ptr(...)</code></li>
</ol>
<h3 id="funlangapply-operation-chapter-15-복습"><a class="header" href="#funlangapply-operation-chapter-15-복습">funlang.apply Operation (Chapter 15 복습)</a></h3>
<p><strong>ODS 정의:</strong></p>
<pre><code class="language-tablegen">def FunLang_ApplyOp : FunLang_Op&lt;"apply"&gt; {
  let summary = "Apply a closure to arguments";

  let arguments = (ins
    FunLang_ClosureType:$closure,
    Variadic&lt;AnyType&gt;:$args
  );

  let results = (outs AnyType:$result);

  let assemblyFormat = [{
    $closure `(` $args `)` attr-dict `:` functional-type($args, $result)
  }];
}
</code></pre>
<p><strong>사용 예시:</strong></p>
<pre><code class="language-mlir">// 인자 1개
%result = funlang.apply %closure(%x) : (i32) -&gt; i32

// 인자 여러 개
%result = funlang.apply %closure(%x, %y) : (i32, i32) -&gt; i32

// 인자 없음 (thunk)
%result = funlang.apply %closure() : () -&gt; i32
</code></pre>
<h3 id="applyop-lowering-전략"><a class="header" href="#applyop-lowering-전략">ApplyOp Lowering 전략</a></h3>
<p><strong>입력:</strong> <code>%result = funlang.apply %closure(%args...) : (...) -&gt; result_type</code></p>
<p><strong>출력:</strong> LLVM dialect operations</p>
<ol>
<li><strong>함수 포인터 추출</strong>: <code>env[0]</code>에서 로드</li>
<li><strong>인자 리스트 구성</strong>: <code>[closure, args...]</code></li>
<li><strong>간접 호출</strong>: <code>llvm.call %fn_ptr(...)</code></li>
<li><strong>결과 반환</strong>: <code>result_type</code>로 변환</li>
</ol>
<h3 id="applyoplowering-구현-complete"><a class="header" href="#applyoplowering-구현-complete">ApplyOpLowering 구현 (Complete)</a></h3>
<pre><code class="language-cpp">struct ApplyOpLowering : public OpConversionPattern&lt;funlang::ApplyOp&gt; {
  using OpConversionPattern&lt;funlang::ApplyOp&gt;::OpConversionPattern;

  LogicalResult matchAndRewrite(
      funlang::ApplyOp op, OpAdaptor adaptor,
      ConversionPatternRewriter &amp;rewriter) const override {

    auto loc = op.getLoc();
    auto ctx = rewriter.getContext();
    auto ptrType = LLVM::LLVMPointerType::get(ctx);

    // ==============================
    // 1. 함수 포인터 추출 (env[0])
    // ==============================
    Value closure = adaptor.getClosure();

    auto slot0 = rewriter.create&lt;LLVM::GEPOp&gt;(
        loc, ptrType, ptrType, closure,
        ArrayRef&lt;LLVM::GEPArg&gt;{0});

    auto fnPtr = rewriter.create&lt;LLVM::LoadOp&gt;(loc, ptrType, slot0);

    // ==============================
    // 2. 인자 리스트 구성
    // ==============================
    SmallVector&lt;Value&gt; callArgs;

    // 첫 번째 인자: 환경 포인터 (클로저 자체)
    callArgs.push_back(closure);

    // 나머지 인자: 실제 인자들
    callArgs.append(adaptor.getArgs().begin(), adaptor.getArgs().end());

    // ==============================
    // 3. 결과 타입 변환
    // ==============================
    Type resultType = getTypeConverter()-&gt;convertType(op.getResult().getType());

    // ==============================
    // 4. 간접 호출
    // ==============================
    auto call = rewriter.create&lt;LLVM::CallOp&gt;(
        loc, resultType, fnPtr, callArgs);

    // ==============================
    // 5. 원본 operation 교체
    // ==============================
    rewriter.replaceOp(op, call.getResult(0));
    return success();
  }
};
</code></pre>
<h3 id="코드-상세-설명-1"><a class="header" href="#코드-상세-설명-1">코드 상세 설명</a></h3>
<h4 id="1-함수-포인터-추출"><a class="header" href="#1-함수-포인터-추출">1. 함수 포인터 추출</a></h4>
<pre><code class="language-cpp">Value closure = adaptor.getClosure();

auto slot0 = rewriter.create&lt;LLVM::GEPOp&gt;(
    loc, ptrType, ptrType, closure,
    ArrayRef&lt;LLVM::GEPArg&gt;{0});

auto fnPtr = rewriter.create&lt;LLVM::LoadOp&gt;(loc, ptrType, slot0);
</code></pre>
<ul>
<li><strong><code>adaptor.getClosure()</code></strong>: 클로저 포인터 (이미 <code>!llvm.ptr</code>로 변환됨)</li>
<li><strong>GEP</strong>: <code>closure[0]</code> 주소 계산 (함수 포인터 슬롯)</li>
<li><strong>Load</strong>: 함수 포인터 로드</li>
</ul>
<p><strong>생성된 MLIR:</strong></p>
<pre><code class="language-mlir">%slot0 = llvm.getelementptr %closure[0] : (!llvm.ptr) -&gt; !llvm.ptr
%fn_ptr = llvm.load %slot0 : !llvm.ptr -&gt; !llvm.ptr
</code></pre>
<h4 id="2-인자-리스트-구성"><a class="header" href="#2-인자-리스트-구성">2. 인자 리스트 구성</a></h4>
<pre><code class="language-cpp">SmallVector&lt;Value&gt; callArgs;
callArgs.push_back(closure);  // 환경 포인터
callArgs.append(adaptor.getArgs().begin(), adaptor.getArgs().end());
</code></pre>
<ul>
<li><strong>첫 번째 인자</strong>: 클로저 자체 (환경 포인터)</li>
<li><strong>나머지 인자</strong>: 실제 application 인자들</li>
</ul>
<p><strong>예시:</strong></p>
<pre><code class="language-mlir">// funlang.apply %closure(%x, %y)
// callArgs = [%closure, %x, %y]
</code></pre>
<p><strong>왜 closure를 첫 번째 인자로?</strong></p>
<p>Lifted function은 환경 포인터를 첫 번째 파라미터로 받는다:</p>
<pre><code class="language-mlir">func.func @lambda_adder(%env: !llvm.ptr, %x: i32) -&gt; i32 {
    // %env에서 캡처된 변수 접근
    ...
}
</code></pre>
<h4 id="3-결과-타입-변환"><a class="header" href="#3-결과-타입-변환">3. 결과 타입 변환</a></h4>
<pre><code class="language-cpp">Type resultType = getTypeConverter()-&gt;convertType(op.getResult().getType());
</code></pre>
<ul>
<li><strong><code>getTypeConverter()</code></strong>: Pattern에 연결된 TypeConverter</li>
<li><strong><code>convertType()</code></strong>: FunLang 타입 → LLVM 타입</li>
</ul>
<p><strong>변환 예시:</strong></p>
<pre><code class="language-cpp">// funlang.closure → !llvm.ptr
!funlang.closure  -&gt;  !llvm.ptr

// 기본 타입은 그대로
i32  -&gt;  i32
i64  -&gt;  i64
</code></pre>
<p><strong>왜 필요한가?</strong></p>
<p>함수가 클로저를 반환할 수 있다:</p>
<pre><code class="language-mlir">// funlang.apply의 결과가 또 다른 클로저
%closure2 = funlang.apply %closure(%x) : (i32) -&gt; !funlang.closure

// Lowering 후
%closure2 = llvm.call %fn_ptr(%closure, %x) : (!llvm.ptr, i32) -&gt; !llvm.ptr
</code></pre>
<h4 id="4-간접-호출"><a class="header" href="#4-간접-호출">4. 간접 호출</a></h4>
<pre><code class="language-cpp">auto call = rewriter.create&lt;LLVM::CallOp&gt;(
    loc, resultType, fnPtr, callArgs);
</code></pre>
<ul>
<li><strong><code>LLVM::CallOp</code></strong>: <code>llvm.call</code> operation</li>
<li><strong>Callee</strong>: <code>fnPtr</code> (함수 포인터, <code>Value</code>)</li>
<li><strong>인자</strong>: <code>callArgs</code> (환경 + 실제 인자)</li>
<li><strong>반환 타입</strong>: <code>resultType</code></li>
</ul>
<p><strong>일반 호출 vs 간접 호출:</strong></p>
<pre><code class="language-mlir">// 일반 호출 (direct call)
%result = llvm.call @foo(%x) : (i32) -&gt; i32

// 간접 호출 (indirect call)
%result = llvm.call %fn_ptr(%x) : (i32) -&gt; i32
</code></pre>
<p><strong>생성된 MLIR:</strong></p>
<pre><code class="language-mlir">%result = llvm.call %fn_ptr(%closure, %x) : (!llvm.ptr, i32) -&gt; i32
</code></pre>
<h4 id="5-원본-operation-교체-1"><a class="header" href="#5-원본-operation-교체-1">5. 원본 operation 교체</a></h4>
<pre><code class="language-cpp">rewriter.replaceOp(op, call.getResult(0));
return success();
</code></pre>
<ul>
<li><strong><code>call.getResult(0)</code></strong>: <code>llvm.call</code>의 반환 값</li>
<li><strong>교체</strong>: <code>funlang.apply</code> 결과를 <code>llvm.call</code> 결과로 대체</li>
</ul>
<h3 id="applyoplowering-테스트"><a class="header" href="#applyoplowering-테스트">ApplyOpLowering 테스트</a></h3>
<p><strong>입력 MLIR:</strong></p>
<pre><code class="language-mlir">func.func @test(%closure: !funlang.closure, %x: i32) -&gt; i32 {
    %result = funlang.apply %closure(%x) : (i32) -&gt; i32
    func.return %result : i32
}
</code></pre>
<p><strong>Lowering pass 실행:</strong></p>
<pre><code class="language-bash">mlir-opt --funlang-to-llvm test.mlir
</code></pre>
<p><strong>출력 MLIR:</strong></p>
<pre><code class="language-mlir">func.func @test(%closure: !llvm.ptr, %x: i32) -&gt; i32 {
    %0 = llvm.getelementptr %closure[0] : (!llvm.ptr) -&gt; !llvm.ptr
    %1 = llvm.load %0 : !llvm.ptr -&gt; !llvm.ptr
    %2 = llvm.call %1(%closure, %x) : (!llvm.ptr, i32) -&gt; i32
    func.return %2 : i32
}
</code></pre>
<p><strong>검증:</strong></p>
<ol>
<li><code>funlang.apply</code> 사라짐 ✓</li>
<li>GEP + load로 함수 포인터 추출 ✓</li>
<li>간접 호출 (<code>llvm.call %fn_ptr</code>) ✓</li>
<li>인자 리스트 올바름 (<code>%closure, %x</code>) ✓</li>
</ol>
<h3 id="end-to-end-예시-makeadder"><a class="header" href="#end-to-end-예시-makeadder">End-to-End 예시: makeAdder</a></h3>
<p><strong>Phase 5 FunLang dialect:</strong></p>
<pre><code class="language-mlir">func.func @make_adder(%n: i32) -&gt; !funlang.closure {
    %closure = funlang.closure @lambda_adder, %n : !funlang.closure
    func.return %closure : !funlang.closure
}

func.func @lambda_adder(%env: !llvm.ptr, %x: i32) -&gt; i32 {
    %n_slot = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
    %n = llvm.load %n_slot : !llvm.ptr -&gt; i32
    %result = arith.addi %x, %n : i32
    func.return %result : i32
}

func.func @main() -&gt; i32 {
    %c5 = arith.constant 5 : i32
    %c10 = arith.constant 10 : i32

    // makeAdder 5
    %add5 = funlang.closure @lambda_adder, %c5 : !funlang.closure

    // add5 10
    %result = funlang.apply %add5(%c10) : (i32) -&gt; i32

    func.return %result : i32
}
</code></pre>
<p><strong>After FunLangToLLVM pass:</strong></p>
<pre><code class="language-mlir">func.func @make_adder(%n: i32) -&gt; !llvm.ptr {
    // ClosureOpLowering
    %c16 = arith.constant 16 : i64
    %env = llvm.call @GC_malloc(%c16) : (i64) -&gt; !llvm.ptr
    %fn_ptr = llvm.mlir.addressof @lambda_adder : !llvm.ptr
    %slot0 = llvm.getelementptr %env[0] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %fn_ptr, %slot0 : !llvm.ptr, !llvm.ptr
    %slot1 = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %n, %slot1 : i32, !llvm.ptr
    func.return %env : !llvm.ptr
}

func.func @lambda_adder(%env: !llvm.ptr, %x: i32) -&gt; i32 {
    %n_slot = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
    %n = llvm.load %n_slot : !llvm.ptr -&gt; i32
    %result = arith.addi %x, %n : i32
    func.return %result : i32
}

func.func @main() -&gt; i32 {
    %c5 = arith.constant 5 : i32
    %c10 = arith.constant 10 : i32

    // ClosureOpLowering
    %c16 = arith.constant 16 : i64
    %add5 = llvm.call @GC_malloc(%c16) : (i64) -&gt; !llvm.ptr
    %fn_ptr = llvm.mlir.addressof @lambda_adder : !llvm.ptr
    %slot0 = llvm.getelementptr %add5[0] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %fn_ptr, %slot0 : !llvm.ptr, !llvm.ptr
    %slot1 = llvm.getelementptr %add5[1] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %c5, %slot1 : i32, !llvm.ptr

    // ApplyOpLowering
    %fn_ptr_addr = llvm.getelementptr %add5[0] : (!llvm.ptr) -&gt; !llvm.ptr
    %fn_ptr_loaded = llvm.load %fn_ptr_addr : !llvm.ptr -&gt; !llvm.ptr
    %result = llvm.call %fn_ptr_loaded(%add5, %c10) : (!llvm.ptr, i32) -&gt; i32

    func.return %result : i32
}
</code></pre>
<p><strong>실행 흐름 추적:</strong></p>
<ol>
<li><code>%c5</code>, <code>%c10</code> 상수 생성</li>
<li><strong>Closure 생성</strong> (ClosureOpLowering):
<ul>
<li><code>GC_malloc(16)</code> → <code>%add5</code> (환경 포인터)</li>
<li><code>%add5[0] = @lambda_adder</code> (함수 포인터)</li>
<li><code>%add5[1] = 5</code> (캡처된 <code>n</code>)</li>
</ul>
</li>
<li><strong>Closure 호출</strong> (ApplyOpLowering):
<ul>
<li><code>%add5[0]</code> 로드 → <code>%fn_ptr_loaded</code> (함수 포인터)</li>
<li><code>llvm.call %fn_ptr_loaded(%add5, 10)</code></li>
</ul>
</li>
<li><strong>lambda_adder 실행</strong>:
<ul>
<li><code>%env[1]</code> 로드 → <code>%n = 5</code></li>
<li><code>10 + 5 = 15</code></li>
<li>반환: <code>15</code></li>
</ul>
</li>
</ol>
<hr>
<h2 id="typeconverter-for-funlang-types"><a class="header" href="#typeconverter-for-funlang-types">TypeConverter for FunLang Types</a></h2>
<p><strong>TypeConverter</strong>는 FunLang 타입을 LLVM 타입으로 변환한다.</p>
<h3 id="funlang-custom-types-chapter-15"><a class="header" href="#funlang-custom-types-chapter-15">FunLang Custom Types (Chapter 15)</a></h3>
<p><strong>1. funlang.closure:</strong></p>
<pre><code class="language-tablegen">def FunLang_ClosureType : FunLang_Type&lt;"Closure"&gt; {
  let mnemonic = "closure";
  let description = "FunLang closure type (function pointer + environment)";
}
</code></pre>
<p><strong>MLIR 표기:</strong> <code>!funlang.closure</code></p>
<p><strong>2. funlang.list (Phase 6 preview):</strong></p>
<pre><code class="language-tablegen">def FunLang_ListType : FunLang_Type&lt;"List"&gt; {
  let mnemonic = "list";
  let parameters = (ins "Type":$elementType);
  let assemblyFormat = "`&lt;` $elementType `&gt;`";
}
</code></pre>
<p><strong>MLIR 표기:</strong> <code>!funlang.list&lt;i32&gt;</code>, <code>!funlang.list&lt;!funlang.closure&gt;</code></p>
<h3 id="typeconverter-구성"><a class="header" href="#typeconverter-구성">TypeConverter 구성</a></h3>
<pre><code class="language-cpp">TypeConverter typeConverter;

// ==============================
// 1. FunLang 타입 변환
// ==============================

// funlang.closure → !llvm.ptr
typeConverter.addConversion([&amp;](funlang::ClosureType type) {
    return LLVM::LLVMPointerType::get(type.getContext());
});

// funlang.list&lt;T&gt; → !llvm.ptr
typeConverter.addConversion([&amp;](funlang::ListType type) {
    return LLVM::LLVMPointerType::get(type.getContext());
});

// ==============================
// 2. 기본 타입은 그대로
// ==============================
typeConverter.addConversion([](Type type) {
    // i32, i64, i1 등은 변환하지 않음
    return type;
});
</code></pre>
<p><strong>변환 예시:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td><code>!funlang.closure</code></td><td><code>!llvm.ptr</code></td></tr>
<tr><td><code>!funlang.list&lt;i32&gt;</code></td><td><code>!llvm.ptr</code></td></tr>
<tr><td><code>i32</code></td><td><code>i32</code></td></tr>
<tr><td><code>i64</code></td><td><code>i64</code></td></tr>
</tbody>
</table>
</div>
<h3 id="function-signature-변환"><a class="header" href="#function-signature-변환">Function Signature 변환</a></h3>
<p><strong>TypeConverter는 자동으로 function signatures를 변환한다.</strong></p>
<p><strong>Before:</strong></p>
<pre><code class="language-mlir">func.func @apply(%f: !funlang.closure, %x: i32) -&gt; i32 {
    %result = funlang.apply %f(%x) : (i32) -&gt; i32
    func.return %result : i32
}
</code></pre>
<p><strong>After:</strong></p>
<pre><code class="language-mlir">func.func @apply(%f: !llvm.ptr, %x: i32) -&gt; i32 {
    %0 = llvm.getelementptr %f[0] : (!llvm.ptr) -&gt; !llvm.ptr
    %1 = llvm.load %0 : !llvm.ptr -&gt; !llvm.ptr
    %2 = llvm.call %1(%f, %x) : (!llvm.ptr, i32) -&gt; i32
    func.return %2 : i32
}
</code></pre>
<p><strong>변환 지점:</strong></p>
<ul>
<li><strong>파라미터 타입</strong>: <code>%f: !funlang.closure</code> → <code>%f: !llvm.ptr</code></li>
<li><strong>반환 타입</strong>: 여기서는 <code>i32</code> (변환 없음)</li>
<li><strong>Operation result 타입</strong>: <code>funlang.apply</code> 결과 타입 변환</li>
</ul>
<h3 id="materialization-타입-변환-보조"><a class="header" href="#materialization-타입-변환-보조">Materialization: 타입 변환 보조</a></h3>
<p><strong>Materialization</strong>은 타입 변환 중간에 필요한 “접착제” operations을 삽입한다.</p>
<p><strong>사용 사례:</strong> Conversion이 여러 단계로 나뉠 때, 중간 타입 불일치 해결.</p>
<h4 id="source-materialization"><a class="header" href="#source-materialization">Source Materialization</a></h4>
<pre><code class="language-cpp">typeConverter.addSourceMaterialization(
    [](OpBuilder &amp;builder, Type resultType, ValueRange inputs, Location loc) -&gt; Value {
      // 원본 타입 (FunLang) → 중간 타입 변환
      if (resultType.isa&lt;funlang::ClosureType&gt;()) {
        return builder.create&lt;UnrealizedConversionCastOp&gt;(loc, resultType, inputs).getResult(0);
      }
      return nullptr;
    });
</code></pre>
<h4 id="target-materialization"><a class="header" href="#target-materialization">Target Materialization</a></h4>
<pre><code class="language-cpp">typeConverter.addTargetMaterialization(
    [](OpBuilder &amp;builder, Type resultType, ValueRange inputs, Location loc) -&gt; Value {
      // 중간 타입 → 대상 타입 (LLVM) 변환
      if (resultType.isa&lt;LLVM::LLVMPointerType&gt;()) {
        return builder.create&lt;UnrealizedConversionCastOp&gt;(loc, resultType, inputs).getResult(0);
      }
      return nullptr;
    });
</code></pre>
<h4 id="unrealized_conversion_cast"><a class="header" href="#unrealized_conversion_cast">unrealized_conversion_cast</a></h4>
<p><strong>Materialization이 생성하는 operation:</strong></p>
<pre><code class="language-mlir">%cast = builtin.unrealized_conversion_cast %input : !funlang.closure to !llvm.ptr
</code></pre>
<p><strong>의미:</strong> “이 타입 변환은 아직 완료되지 않았다”</p>
<p><strong>최종 lowering 후:</strong></p>
<ul>
<li>모든 <code>unrealized_conversion_cast</code>는 사라져야 한다</li>
<li>남아있으면 conversion failure</li>
</ul>
<p><strong>Phase 5에서는 단순한 변환이므로 materialization 불필요:</strong></p>
<ul>
<li><code>funlang.closure</code> → <code>!llvm.ptr</code> (direct mapping)</li>
<li>중간 타입 없음</li>
</ul>
<h3 id="타입-변환-체인"><a class="header" href="#타입-변환-체인">타입 변환 체인</a></h3>
<p><strong>Multi-stage lowering에서 타입 변환 체인:</strong></p>
<pre><code>Phase 5 FunLang dialect:
  !funlang.closure

Phase 5a (optional): High-level abstractions
  !funlang.env_ptr  (환경 포인터 전용 타입)

Phase 5b (final): LLVM dialect
  !llvm.ptr
</code></pre>
<p><strong>현재 Phase 5 (단순 버전):</strong></p>
<pre><code>!funlang.closure  →  !llvm.ptr  (direct)
</code></pre>
<p><strong>TypeConverter 체인 예시 (multi-stage):</strong></p>
<pre><code class="language-cpp">// Stage 1: FunLang → HighLevel
TypeConverter highLevelConverter;
highLevelConverter.addConversion([](funlang::ClosureType type) {
    return funlang::EnvPtrType::get(type.getContext());
});

// Stage 2: HighLevel → LLVM
TypeConverter llvmConverter;
llvmConverter.addConversion([](funlang::EnvPtrType type) {
    return LLVM::LLVMPointerType::get(type.getContext());
});
</code></pre>
<hr>
<h2 id="declarative-rewrite-rules-drr"><a class="header" href="#declarative-rewrite-rules-drr">Declarative Rewrite Rules (DRR)</a></h2>
<p>**DRR (Declarative Rewrite Rules)**은 <strong>TableGen 기반 패턴 매칭 시스템</strong>이다. C++ ConversionPattern보다 간단한 변환을 선언적으로 작성할 수 있다.</p>
<h3 id="drr이란"><a class="header" href="#drr이란">DRR이란?</a></h3>
<p><strong>DRR</strong>은 MLIR의 패턴 매칭 DSL이다:</p>
<ul>
<li><strong>입력</strong>: <code>.td</code> 파일에 패턴 작성</li>
<li><strong>출력</strong>: C++ 코드 자동 생성 (mlir-tblgen)</li>
<li><strong>용도</strong>: 최적화, 정규화, 간단한 lowering</li>
</ul>
<p><strong>DRR vs C++ ConversionPattern:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>DRR</th><th>C++ ConversionPattern</th></tr>
</thead>
<tbody>
<tr><td><strong>문법</strong></td><td>선언적 (TableGen)</td><td>명령형 (C++)</td></tr>
<tr><td><strong>복잡도</strong></td><td>간단한 패턴</td><td>복잡한 로직 가능</td></tr>
<tr><td><strong>제어 흐름</strong></td><td>없음 (순수 매칭)</td><td>if/for/while 가능</td></tr>
<tr><td><strong>타입 안전성</strong></td><td>컴파일 타임</td><td>런타임 검증</td></tr>
<tr><td><strong>디버깅</strong></td><td>어려움</td><td>쉬움 (breakpoint)</td></tr>
</tbody>
</table>
</div>
<p><strong>언제 DRR을 사용하는가?</strong></p>
<ul>
<li>✓ 1:1 operation 변환 (A → B)</li>
<li>✓ 간단한 패턴 매칭 (조건 1-2개)</li>
<li>✓ 최적화 패턴 (constant folding, peephole)</li>
</ul>
<p><strong>언제 C++를 사용하는가?</strong></p>
<ul>
<li>✓ 복잡한 변환 로직 (ClosureOpLowering처럼 여러 ops 생성)</li>
<li>✓ 동적 계산 (환경 크기 계산)</li>
<li>✓ 제어 흐름 (for loop으로 캡처 변수 처리)</li>
</ul>
<h3 id="drr-문법-기초"><a class="header" href="#drr-문법-기초">DRR 문법 기초</a></h3>
<p><strong>Pat (Pattern) 정의:</strong></p>
<pre><code class="language-tablegen">def PatternName : Pat&lt;
  (SourcePattern),   // 매치할 패턴
  (TargetPattern),   // 교체할 패턴
  [(Constraint)]     // 추가 제약 (optional)
&gt;;
</code></pre>
<p><strong>예시: 상수 폴딩</strong></p>
<pre><code class="language-tablegen">def AddZero : Pat&lt;
  (Arith_AddIOp $x, (Arith_ConstantOp ConstantAttr&lt;I32Attr, "0"&gt;)),
  (replaceWithValue $x)
&gt;;
</code></pre>
<p><strong>의미:</strong> <code>x + 0</code> → <code>x</code></p>
<h3 id="drr-예시-1-empty-closure-최적화"><a class="header" href="#drr-예시-1-empty-closure-최적화">DRR 예시 1: Empty Closure 최적화</a></h3>
<p><strong>최적화 목표:</strong></p>
<p>캡처 변수가 없는 클로저는 함수 포인터만 필요하다. 환경 할당 불필요.</p>
<p><strong>Before:</strong></p>
<pre><code class="language-mlir">// 캡처 없음
%closure = funlang.closure @foo : !funlang.closure

// Lowering 후 (불필요한 GC_malloc!)
%env = llvm.call @GC_malloc(%c8) : (i64) -&gt; !llvm.ptr
%fn_ptr = llvm.mlir.addressof @foo : !llvm.ptr
llvm.store %fn_ptr, %env[0] : !llvm.ptr
</code></pre>
<p><strong>After (최적화):</strong></p>
<pre><code class="language-mlir">// 함수 포인터만 사용
%fn_ptr = llvm.mlir.addressof @foo : !llvm.ptr

// apply에서 직접 함수 포인터 사용
%result = llvm.call @foo(%null_env, %x) : (!llvm.ptr, i32) -&gt; i32
</code></pre>
<p><strong>DRR 패턴:</strong></p>
<pre><code class="language-tablegen">def SimplifyEmptyClosure : Pat&lt;
  // Match: funlang.closure with no captured variables
  (FunLang_ClosureOp:$result $callee, (variadic)),

  // Replace: function reference (Phase 6에 FuncRefOp 추가 필요)
  (FunLang_FuncRefOp $callee),

  // Constraint: captured variables must be empty
  [(Constraint&lt;CPred&lt;"$0.empty()"&gt;, "$result.getCaptured()"&gt;)]
&gt;;
</code></pre>
<p><strong>설명:</strong></p>
<ul>
<li><strong><code>(variadic)</code></strong>: 가변 인자 (0개 이상)</li>
<li><strong><code>CPred&lt;"$0.empty()"&gt;</code></strong>: C++ predicate - 첫 번째 인자가 비어있는가?</li>
<li><strong><code>FuncRefOp</code></strong>: 함수 참조만 담는 operation (Phase 6에서 추가 예정)</li>
</ul>
<h3 id="drr-예시-2-known-closure-inlining"><a class="header" href="#drr-예시-2-known-closure-inlining">DRR 예시 2: Known Closure Inlining</a></h3>
<p><strong>최적화 목표:</strong></p>
<p>클로저 생성 직후 호출하면 인라인 가능.</p>
<p><strong>Before:</strong></p>
<pre><code class="language-mlir">// 클로저 생성 후 즉시 호출
%closure = funlang.closure @lambda, %n : !funlang.closure
%result = funlang.apply %closure(%x) : (i32) -&gt; i32
</code></pre>
<p><strong>After (최적화):</strong></p>
<pre><code class="language-mlir">// 직접 호출 (환경 할당 불필요)
%result = func.call @lambda(%n, %x) : (i32, i32) -&gt; i32
</code></pre>
<p><strong>DRR 패턴:</strong></p>
<pre><code class="language-tablegen">def InlineKnownApply : Pat&lt;
  // Match: apply (closure @callee, $captures) ($args)
  (FunLang_ApplyOp
    (FunLang_ClosureOp:$closure $callee, $captures),
    $args),

  // Replace: direct call @callee (concat $captures and $args)
  (Func_CallOp $callee, (ConcatValues $captures, $args))
&gt;;
</code></pre>
<p><strong>설명:</strong></p>
<ul>
<li><strong><code>$captures</code></strong>: 캡처된 변수들 (variadic)</li>
<li><strong><code>$args</code></strong>: apply 인자들 (variadic)</li>
<li><strong><code>ConcatValues</code></strong>: 두 리스트 합치기 (DRR helper)</li>
<li><strong><code>Func_CallOp</code></strong>: 직접 호출 operation</li>
</ul>
<p><strong>제약:</strong></p>
<p>이 패턴은 <strong>클로저가 escape하지 않을 때만</strong> 안전하다:</p>
<pre><code class="language-mlir">// OK: 즉시 호출
%result = funlang.apply (funlang.closure @f, %n) (%x)

// NOT OK: 클로저가 반환됨 (인라인 불가!)
func.func @make_adder(%n: i32) -&gt; !funlang.closure {
    %closure = funlang.closure @f, %n : !funlang.closure
    func.return %closure  // Escape!
}
</code></pre>
<p><strong>DRR로 escape 검사 불가 → C++ ConversionPattern 필요</strong></p>
<h3 id="drr-예시-3-constant-propagation"><a class="header" href="#drr-예시-3-constant-propagation">DRR 예시 3: Constant Propagation</a></h3>
<p><strong>최적화 목표:</strong></p>
<p>클로저가 상수만 캡처하면 compile-time에 처리 가능.</p>
<p><strong>Before:</strong></p>
<pre><code class="language-mlir">%c5 = arith.constant 5 : i32
%closure = funlang.closure @lambda, %c5 : !funlang.closure
</code></pre>
<p><strong>After (최적화):</strong></p>
<pre><code class="language-mlir">// lambda 함수 내부에서 %c5를 직접 사용하도록 인라인
// (복잡한 변환이므로 DRR보다 C++가 적합)
</code></pre>
<p><strong>DRR 한계:</strong></p>
<ul>
<li>함수 본문 수정 필요 (DRR은 local pattern만 매칭)</li>
<li>Whole-program analysis 필요 (DRR은 single operation 매칭)</li>
</ul>
<p><strong>결론:</strong> 이런 최적화는 <strong>C++ pass</strong>로 구현해야 함.</p>
<h3 id="mlir-tblgen으로-drr-컴파일"><a class="header" href="#mlir-tblgen으로-drr-컴파일">mlir-tblgen으로 DRR 컴파일</a></h3>
<p><strong>1. DRR 패턴 작성:</strong></p>
<pre><code class="language-tablegen">// FunLangPatterns.td
include "mlir/IR/PatternBase.td"
include "FunLangOps.td"

def SimplifyEmptyClosure : Pat&lt;
  (FunLang_ClosureOp:$result $callee, (variadic)),
  (FunLang_FuncRefOp $callee),
  [(Constraint&lt;CPred&lt;"$0.empty()"&gt;, "$result.getCaptured()"&gt;)]
&gt;;
</code></pre>
<p><strong>2. mlir-tblgen 실행:</strong></p>
<pre><code class="language-bash">mlir-tblgen -gen-rewriters FunLangPatterns.td -o FunLangPatterns.cpp.inc
</code></pre>
<p><strong>3. 생성된 C++ 코드:</strong></p>
<pre><code class="language-cpp">// FunLangPatterns.cpp.inc
struct SimplifyEmptyClosure : public RewritePattern {
  SimplifyEmptyClosure(MLIRContext *context)
      : RewritePattern(ClosureOp::getOperationName(), 1, context) {}

  LogicalResult matchAndRewrite(Operation *op, PatternRewriter &amp;rewriter) const override {
    auto closureOp = cast&lt;ClosureOp&gt;(op);

    // Constraint: captured variables empty
    if (!closureOp.getCaptured().empty())
      return failure();

    // Rewrite: create FuncRefOp
    rewriter.replaceOpWithNewOp&lt;FuncRefOp&gt;(op, closureOp.getCalleeAttr());
    return success();
  }
};
</code></pre>
<p><strong>4. Pass에 등록:</strong></p>
<pre><code class="language-cpp">void populateFunLangOptimizationPatterns(RewritePatternSet &amp;patterns) {
  patterns.add&lt;SimplifyEmptyClosure&gt;(patterns.getContext());
  // ... other patterns
}
</code></pre>
<h3 id="drr-vs-c-conversionpattern-비교-요약"><a class="header" href="#drr-vs-c-conversionpattern-비교-요약">DRR vs C++ ConversionPattern 비교 요약</a></h3>
<p><strong>ClosureOpLowering을 DRR로 작성하면?</strong></p>
<pre><code class="language-tablegen">// 불가능! DRR로는 표현 못함
def LowerClosure : Pat&lt;
  (FunLang_ClosureOp $callee, $captured),
  (??? 어떻게 for loop을 표현?)  // 캡처 변수 개수만큼 GEP + store
&gt;;
</code></pre>
<p><strong>왜 불가능?</strong></p>
<ul>
<li>DRR은 <strong>fixed-size patterns</strong>만 매칭</li>
<li>가변 개수의 operations 생성 불가 (for loop 없음)</li>
<li>동적 계산 불가 (환경 크기 계산)</li>
</ul>
<p><strong>결론:</strong></p>
<ul>
<li><strong>DRR</strong>: 간단한 최적화 패턴 (peephole, constant folding)</li>
<li><strong>C++ ConversionPattern</strong>: 복잡한 lowering (ClosureOp, ApplyOp)</li>
</ul>
<hr>
<h2 id="complete-lowering-pass"><a class="header" href="#complete-lowering-pass">Complete Lowering Pass</a></h2>
<p><strong>FunLangToLLVMPass</strong>는 FunLang dialect를 LLVM dialect로 lowering하는 완전한 pass다.</p>
<h3 id="pass-정의"><a class="header" href="#pass-정의">Pass 정의</a></h3>
<pre><code class="language-cpp">// FunLangToLLVMPass.cpp
#include "mlir/Conversion/LLVMCommon/Pattern.h"
#include "mlir/Dialect/LLVMIR/LLVMDialect.h"
#include "mlir/Dialect/Func/IR/FuncOps.h"
#include "mlir/Pass/Pass.h"
#include "mlir/Transforms/DialectConversion.h"
#include "FunLang/FunLangDialect.h"
#include "FunLang/FunLangOps.h"

namespace {

struct FunLangToLLVMPass
    : public PassWrapper&lt;FunLangToLLVMPass, OperationPass&lt;ModuleOp&gt;&gt; {

  // ==============================
  // Pass metadata
  // ==============================
  StringRef getArgument() const final {
    return "funlang-to-llvm";
  }

  StringRef getDescription() const final {
    return "Lower FunLang dialect to LLVM dialect";
  }

  // ==============================
  // Dependent dialects
  // ==============================
  void getDependentDialects(DialectRegistry &amp;registry) const override {
    registry.insert&lt;LLVM::LLVMDialect&gt;();
    registry.insert&lt;func::FuncDialect&gt;();
    registry.insert&lt;arith::ArithDialect&gt;();
  }

  // ==============================
  // Pass execution
  // ==============================
  void runOnOperation() override {
    // Get module operation
    ModuleOp module = getOperation();
    MLIRContext *ctx = &amp;getContext();

    // ------------------------------
    // 1. Setup ConversionTarget
    // ------------------------------
    ConversionTarget target(*ctx);

    // Legal: LLVM, func, arith dialects
    target.addLegalDialect&lt;LLVM::LLVMDialect&gt;();
    target.addLegalDialect&lt;func::FuncDialect&gt;();
    target.addLegalDialect&lt;arith::ArithDialect&gt;();

    // Illegal: FunLang dialect (must be lowered)
    target.addIllegalDialect&lt;funlang::FunLangDialect&gt;();

    // ------------------------------
    // 2. Setup TypeConverter
    // ------------------------------
    TypeConverter typeConverter;

    // FunLang types → LLVM types
    typeConverter.addConversion([&amp;](funlang::ClosureType type) {
      return LLVM::LLVMPointerType::get(ctx);
    });

    typeConverter.addConversion([&amp;](funlang::ListType type) {
      return LLVM::LLVMPointerType::get(ctx);
    });

    // Default: keep type as-is (i32, i64, etc.)
    typeConverter.addConversion([](Type type) {
      return type;
    });

    // ------------------------------
    // 3. Setup RewritePatternSet
    // ------------------------------
    RewritePatternSet patterns(ctx);

    // Add lowering patterns
    patterns.add&lt;ClosureOpLowering&gt;(ctx, typeConverter);
    patterns.add&lt;ApplyOpLowering&gt;(ctx, typeConverter);

    // ------------------------------
    // 4. Apply conversion
    // ------------------------------
    if (failed(applyPartialConversion(module, target, std::move(patterns)))) {
      signalPassFailure();
      return;
    }
  }
};

} // namespace

// ==============================
// Pass registration
// ==============================
void registerFunLangToLLVMPass() {
  PassRegistration&lt;FunLangToLLVMPass&gt;();
}
</code></pre>
<h3 id="pass-구성-요소-설명"><a class="header" href="#pass-구성-요소-설명">Pass 구성 요소 설명</a></h3>
<h4 id="1-passwrapper-템플릿"><a class="header" href="#1-passwrapper-템플릿">1. PassWrapper 템플릿</a></h4>
<pre><code class="language-cpp">struct FunLangToLLVMPass
    : public PassWrapper&lt;FunLangToLLVMPass, OperationPass&lt;ModuleOp&gt;&gt; {
</code></pre>
<ul>
<li><strong><code>PassWrapper&lt;Self, Base&gt;</code></strong>: CRTP 패턴</li>
<li><strong><code>OperationPass&lt;ModuleOp&gt;</code></strong>: Module 레벨 pass (전체 IR 처리)</li>
</ul>
<p><strong>다른 pass 레벨:</strong></p>
<ul>
<li><code>OperationPass&lt;func::FuncOp&gt;</code>: Function 레벨 (함수별 처리)</li>
<li><code>OperationPass&lt;&gt;</code>: 모든 operation에 대해</li>
</ul>
<h4 id="2-getdependentdialects"><a class="header" href="#2-getdependentdialects">2. getDependentDialects</a></h4>
<pre><code class="language-cpp">void getDependentDialects(DialectRegistry &amp;registry) const override {
  registry.insert&lt;LLVM::LLVMDialect&gt;();
  registry.insert&lt;func::FuncDialect&gt;();
  registry.insert&lt;arith::ArithDialect&gt;();
}
</code></pre>
<p><strong>역할:</strong> Pass가 사용할 dialects를 등록한다.</p>
<p><strong>왜 필요?</strong></p>
<ul>
<li>MLIR은 lazy dialect loading 사용</li>
<li>Pass가 <code>LLVM::CallOp</code>을 생성하려면 <code>LLVMDialect</code> 로드 필요</li>
<li>명시적 등록으로 dependency 보장</li>
</ul>
<h4 id="3-runonoperation"><a class="header" href="#3-runonoperation">3. runOnOperation</a></h4>
<pre><code class="language-cpp">void runOnOperation() override {
  ModuleOp module = getOperation();
  // ... conversion logic
}
</code></pre>
<p><strong>역할:</strong> Pass의 핵심 로직.</p>
<p><strong>실행 흐름:</strong></p>
<ol>
<li>Target 설정 (legal/illegal dialects)</li>
<li>TypeConverter 설정 (타입 변환 규칙)</li>
<li>Patterns 구성 (lowering patterns)</li>
<li>Conversion 실행 (applyPartialConversion)</li>
<li>실패 시 signalPassFailure()</li>
</ol>
<h3 id="pass-등록"><a class="header" href="#pass-등록">Pass 등록</a></h3>
<pre><code class="language-cpp">void registerFunLangToLLVMPass() {
  PassRegistration&lt;FunLangToLLVMPass&gt;();
}

// 초기화 함수에서 호출
void registerFunLangPasses() {
  registerFunLangToLLVMPass();
  // ... other passes
}
</code></pre>
<p><strong>등록 후 사용:</strong></p>
<pre><code class="language-bash">mlir-opt --funlang-to-llvm input.mlir -o output.mlir
</code></pre>
<h3 id="c-api-shim"><a class="header" href="#c-api-shim">C API Shim</a></h3>
<p><strong>C++ pass를 F#에서 사용하려면 C API가 필요하다.</strong></p>
<pre><code class="language-cpp">// FunLangCAPI.cpp
#include "mlir-c/IR.h"
#include "mlir/CAPI/Wrap.h"
#include "mlir/Pass/PassManager.h"
#include "FunLangPasses.h"

extern "C" {

// Pass 등록
MLIR_CAPI_EXPORTED void mlirFunLangRegisterToLLVMPass() {
  registerFunLangToLLVMPass();
}

// Pass 실행
MLIR_CAPI_EXPORTED void mlirFunLangRunToLLVMPass(MlirModule module) {
  ModuleOp moduleOp = unwrap(module);
  MLIRContext *ctx = moduleOp.getContext();

  PassManager pm(ctx);
  pm.addPass(std::make_unique&lt;FunLangToLLVMPass&gt;());

  if (failed(pm.run(moduleOp))) {
    llvm::errs() &lt;&lt; "FunLangToLLVMPass failed\n";
  }
}

} // extern "C"
</code></pre>
<p><strong>헬퍼 함수:</strong></p>
<pre><code class="language-cpp">// Wrap/unwrap helpers (MLIR-C API)
static inline ModuleOp unwrap(MlirModule module) {
  return ::mlir::unwrap(module);
}

static inline MlirModule wrap(ModuleOp module) {
  return ::mlir::wrap(module);
}
</code></pre>
<h3 id="f-pinvoke"><a class="header" href="#f-pinvoke">F# P/Invoke</a></h3>
<pre><code class="language-fsharp">// Mlir.FunLang.fs
module Mlir.FunLang

open System.Runtime.InteropServices

// ==============================
// P/Invoke declarations
// ==============================

[&lt;DllImport("funlang-dialect", CallingConvention = CallingConvention.Cdecl)&gt;]
extern void mlirFunLangRegisterToLLVMPass()

[&lt;DllImport("funlang-dialect", CallingConvention = CallingConvention.Cdecl)&gt;]
extern void mlirFunLangRunToLLVMPass(MlirModule module)

// ==============================
// F# wrapper functions
// ==============================

/// Initialize FunLang passes (call once at startup)
let initializePasses () =
    mlirFunLangRegisterToLLVMPass()

/// Lower FunLang dialect to LLVM dialect
let lowerToLLVM (module_: MlirModule) =
    mlirFunLangRunToLLVMPass(module_)
</code></pre>
<h3 id="f에서-pass-사용"><a class="header" href="#f에서-pass-사용">F#에서 Pass 사용</a></h3>
<pre><code class="language-fsharp">// CompilerPipeline.fs
open Mlir
open Mlir.FunLang

// 초기화 (프로그램 시작 시 1회)
FunLang.initializePasses()

// 컴파일 파이프라인
let compileToExecutable (source: string) =
    // 1. Parse &amp; build AST
    let ast = Parser.parse source

    // 2. Generate FunLang dialect MLIR
    use ctx = Mlir.createContext()
    use module_ = Mlir.createModule(ctx)
    use builder = Mlir.createOpBuilder(ctx)

    // ... code generation (Chapter 15)

    // 3. Lower FunLang → LLVM
    FunLang.lowerToLLVM(module_)

    // 4. Lower other dialects → LLVM
    Mlir.runPass(module_, "convert-arith-to-llvm")
    Mlir.runPass(module_, "convert-func-to-llvm")

    // 5. Translate LLVM dialect → LLVM IR
    let llvmIR = Mlir.translateToLLVMIR(module_)

    // 6. Compile &amp; link
    let objFile = LLVMCompiler.compile(llvmIR)
    let executable = Linker.link([objFile; "runtime.o"], "gc")

    executable
</code></pre>
<hr>
<h2 id="end-to-end-example"><a class="header" href="#end-to-end-example">End-to-End Example</a></h2>
<p><strong>makeAdder 함수를 전체 파이프라인으로 추적한다.</strong></p>
<h3 id="source-code"><a class="header" href="#source-code">Source Code</a></h3>
<pre><code class="language-fsharp">// FunLang source
let makeAdder n =
    fun x -&gt; x + n

let add5 = makeAdder 5
let result = add5 10
</code></pre>
<h3 id="stage-1-ast"><a class="header" href="#stage-1-ast">Stage 1: AST</a></h3>
<pre><code class="language-fsharp">type Expr =
    | Let of string * Expr * Expr
    | Lambda of string * Expr
    | App of Expr * Expr
    | BinOp of Operator * Expr * Expr
    | Var of string
    | Const of int

// makeAdder AST
Let ("makeAdder",
     Lambda ("n", Lambda ("x", BinOp (Add, Var "x", Var "n"))),
     Let ("add5",
          App (Var "makeAdder", Const 5),
          Let ("result",
               App (Var "add5", Const 10),
               Var "result")))
</code></pre>
<h3 id="stage-2-funlang-dialect-mlir-chapter-15"><a class="header" href="#stage-2-funlang-dialect-mlir-chapter-15">Stage 2: FunLang Dialect MLIR (Chapter 15)</a></h3>
<pre><code class="language-mlir">module {
  // lifted lambda: fun x -&gt; x + n
  func.func @lambda_adder(%env: !llvm.ptr, %x: i32) -&gt; i32 {
    // Load captured n from env[1]
    %n_slot = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
    %n = llvm.load %n_slot : !llvm.ptr -&gt; i32

    // x + n
    %result = arith.addi %x, %n : i32
    func.return %result : i32
  }

  // makeAdder function
  func.func @makeAdder(%n: i32) -&gt; !funlang.closure {
    %closure = funlang.closure @lambda_adder, %n : !funlang.closure
    func.return %closure : !funlang.closure
  }

  // main function
  func.func @funlang_main() -&gt; i32 {
    %c5 = arith.constant 5 : i32
    %c10 = arith.constant 10 : i32

    // makeAdder 5
    %add5 = funlang.closure @lambda_adder, %c5 : !funlang.closure

    // add5 10
    %result = funlang.apply %add5(%c10) : (i32) -&gt; i32

    func.return %result : i32
  }
}
</code></pre>
<h3 id="stage-3-after-funlangtollvm-pass-chapter-16"><a class="header" href="#stage-3-after-funlangtollvm-pass-chapter-16">Stage 3: After FunLangToLLVM Pass (Chapter 16)</a></h3>
<pre><code class="language-mlir">module {
  // lambda_adder (unchanged)
  func.func @lambda_adder(%env: !llvm.ptr, %x: i32) -&gt; i32 {
    %n_slot = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
    %n = llvm.load %n_slot : !llvm.ptr -&gt; i32
    %result = arith.addi %x, %n : i32
    func.return %result : i32
  }

  // makeAdder (funlang.closure lowered)
  func.func @makeAdder(%n: i32) -&gt; !llvm.ptr {
    %c16 = arith.constant 16 : i64
    %env = llvm.call @GC_malloc(%c16) : (i64) -&gt; !llvm.ptr
    %fn_ptr = llvm.mlir.addressof @lambda_adder : !llvm.ptr
    %slot0 = llvm.getelementptr %env[0] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %fn_ptr, %slot0 : !llvm.ptr, !llvm.ptr
    %slot1 = llvm.getelementptr %env[1] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %n, %slot1 : i32, !llvm.ptr
    func.return %env : !llvm.ptr
  }

  // main (both funlang operations lowered)
  func.func @funlang_main() -&gt; i32 {
    %c5 = arith.constant 5 : i32
    %c10 = arith.constant 10 : i32

    // ClosureOpLowering
    %c16 = arith.constant 16 : i64
    %add5 = llvm.call @GC_malloc(%c16) : (i64) -&gt; !llvm.ptr
    %fn_ptr = llvm.mlir.addressof @lambda_adder : !llvm.ptr
    %slot0 = llvm.getelementptr %add5[0] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %fn_ptr, %slot0 : !llvm.ptr, !llvm.ptr
    %slot1 = llvm.getelementptr %add5[1] : (!llvm.ptr) -&gt; !llvm.ptr
    llvm.store %c5, %slot1 : i32, !llvm.ptr

    // ApplyOpLowering
    %fn_ptr_addr = llvm.getelementptr %add5[0] : (!llvm.ptr) -&gt; !llvm.ptr
    %fn_ptr_loaded = llvm.load %fn_ptr_addr : !llvm.ptr -&gt; !llvm.ptr
    %result = llvm.call %fn_ptr_loaded(%add5, %c10) : (!llvm.ptr, i32) -&gt; i32

    func.return %result : i32
  }
}
</code></pre>
<h3 id="stage-4-after-convert-arith-to-llvm"><a class="header" href="#stage-4-after-convert-arith-to-llvm">Stage 4: After convert-arith-to-llvm</a></h3>
<pre><code class="language-mlir">// arith.constant → llvm.mlir.constant
%c5 = llvm.mlir.constant(5 : i32) : i32
%c10 = llvm.mlir.constant(10 : i32) : i32
%c16 = llvm.mlir.constant(16 : i64) : i64

// arith.addi → llvm.add
%result = llvm.add %x, %n : i32
</code></pre>
<h3 id="stage-5-after-convert-func-to-llvm"><a class="header" href="#stage-5-after-convert-func-to-llvm">Stage 5: After convert-func-to-llvm</a></h3>
<pre><code class="language-mlir">// func.func → llvm.func
llvm.func @lambda_adder(%env: !llvm.ptr, %x: i32) -&gt; i32 {
  ...
  llvm.return %result : i32
}

// func.call → llvm.call (already indirect, no change)
%result = llvm.call %fn_ptr_loaded(%add5, %c10) : (!llvm.ptr, i32) -&gt; i32
</code></pre>
<h3 id="stage-6-llvm-ir-mlir-translate-mlir-to-llvmir"><a class="header" href="#stage-6-llvm-ir-mlir-translate-mlir-to-llvmir">Stage 6: LLVM IR (mlir-translate –mlir-to-llvmir)</a></h3>
<pre><code class="language-llvm">define i32 @lambda_adder(ptr %env, i32 %x) {
  %n_slot = getelementptr ptr, ptr %env, i32 1
  %n = load i32, ptr %n_slot
  %result = add i32 %x, %n
  ret i32 %result
}

define ptr @makeAdder(i32 %n) {
  %env = call ptr @GC_malloc(i64 16)
  %fn_ptr = ptrtoint ptr @lambda_adder to i64
  %slot0 = getelementptr ptr, ptr %env, i32 0
  store i64 %fn_ptr, ptr %slot0
  %slot1 = getelementptr ptr, ptr %env, i32 1
  store i32 %n, ptr %slot1
  ret ptr %env
}

define i32 @funlang_main() {
  %c5 = 5
  %c10 = 10

  ; Closure creation
  %add5 = call ptr @GC_malloc(i64 16)
  %fn_ptr = ptrtoint ptr @lambda_adder to i64
  %slot0 = getelementptr ptr, ptr %add5, i32 0
  store i64 %fn_ptr, ptr %slot0
  %slot1 = getelementptr ptr, ptr %add5, i32 1
  store i32 %c5, ptr %slot1

  ; Closure application
  %fn_ptr_addr = getelementptr ptr, ptr %add5, i32 0
  %fn_ptr_loaded = load ptr, ptr %fn_ptr_addr
  %result = call i32 %fn_ptr_loaded(ptr %add5, i32 %c10)

  ret i32 %result
}
</code></pre>
<h3 id="stage-7-native-code-llc--object-file--executable"><a class="header" href="#stage-7-native-code-llc--object-file--executable">Stage 7: Native Code (llc → object file → executable)</a></h3>
<pre><code class="language-bash"># LLVM IR → object file
llc output.ll -o output.o -filetype=obj

# Link with runtime
clang output.o runtime.o -lgc -o program

# Run
./program
# Output: 15
</code></pre>
<h3 id="컴파일-파이프라인-다이어그램"><a class="header" href="#컴파일-파이프라인-다이어그램">컴파일 파이프라인 다이어그램</a></h3>
<pre><code>┌─────────────────┐
│  FunLang Source │  let makeAdder n = fun x -&gt; x + n
└────────┬────────┘
         │ Parser
         ▼
┌─────────────────┐
│       AST       │  Lambda, App, BinOp nodes
└────────┬────────┘
         │ CodeGen (Chapter 15)
         ▼
┌─────────────────┐
│ FunLang Dialect │  funlang.closure, funlang.apply
│      MLIR       │
└────────┬────────┘
         │ FunLangToLLVM Pass (Chapter 16) ★
         ▼
┌─────────────────┐
│  LLVM Dialect   │  llvm.call, llvm.getelementptr, llvm.store
│      MLIR       │
└────────┬────────┘
         │ convert-arith-to-llvm
         │ convert-func-to-llvm
         ▼
┌─────────────────┐
│  LLVM Dialect   │  All dialects → LLVM dialect
│ (fully lowered) │
└────────┬────────┘
         │ mlir-translate --mlir-to-llvmir
         ▼
┌─────────────────┐
│    LLVM IR      │  %.1 = call ptr @GC_malloc(i64 16)
└────────┬────────┘
         │ llc
         ▼
┌─────────────────┐
│  Object File    │  .o binary
└────────┬────────┘
         │ clang (link)
         ▼
┌─────────────────┐
│   Executable    │  ./program
└─────────────────┘
</code></pre>
<hr>
<h2 id="common-errors"><a class="header" href="#common-errors">Common Errors</a></h2>
<p>Lowering pass 구현 중 자주 발생하는 에러와 해결 방법.</p>
<h3 id="error-1-illegal-operation-remaining"><a class="header" href="#error-1-illegal-operation-remaining">Error 1: Illegal Operation Remaining</a></h3>
<p><strong>증상:</strong></p>
<pre><code>error: failed to legalize operation 'funlang.closure' that was explicitly marked illegal
note: see current operation: %0 = "funlang.closure"() {callee = @foo, ...}
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>Pattern이 등록되지 않음</li>
<li>Pattern이 매치 실패 (<code>matchAndRewrite</code>에서 <code>failure()</code> 리턴)</li>
<li>Target에 illegal로 설정했지만 pattern 없음</li>
</ul>
<p><strong>해결:</strong></p>
<ol>
<li><strong>Pattern 등록 확인:</strong></li>
</ol>
<pre><code class="language-cpp">RewritePatternSet patterns(ctx);
patterns.add&lt;ClosureOpLowering&gt;(ctx, typeConverter);  // 추가했는가?
</code></pre>
<ol start="2">
<li><strong>Pattern 매치 조건 확인:</strong></li>
</ol>
<pre><code class="language-cpp">LogicalResult matchAndRewrite(...) const override {
  // 디버그 출력
  llvm::errs() &lt;&lt; "ClosureOpLowering matched\n";

  // ... lowering logic

  return success();  // failure() 리턴하지 않았는가?
}
</code></pre>
<ol start="3">
<li><strong>Target 설정 확인:</strong></li>
</ol>
<pre><code class="language-cpp">target.addIllegalDialect&lt;funlang::FunLangDialect&gt;();  // Illegal로 설정
</code></pre>
<h3 id="error-2-type-conversion-failure"><a class="header" href="#error-2-type-conversion-failure">Error 2: Type Conversion Failure</a></h3>
<p><strong>증상:</strong></p>
<pre><code>error: type conversion failed for block argument #0
note: see current operation: func.func @foo(%arg0: !funlang.closure) -&gt; i32
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>TypeConverter에 변환 규칙 없음</li>
<li>변환 규칙이 <code>nullptr</code> 리턴</li>
</ul>
<p><strong>해결:</strong></p>
<ol>
<li><strong>TypeConverter에 규칙 추가:</strong></li>
</ol>
<pre><code class="language-cpp">typeConverter.addConversion([&amp;](funlang::ClosureType type) {
    return LLVM::LLVMPointerType::get(ctx);
});
</code></pre>
<ol start="2">
<li><strong>변환 실패 체크:</strong></li>
</ol>
<pre><code class="language-cpp">typeConverter.addConversion([&amp;](funlang::ClosureType type) -&gt; std::optional&lt;Type&gt; {
    if (!isConvertible(type))
        return std::nullopt;  // 변환 불가

    return LLVM::LLVMPointerType::get(ctx);
});
</code></pre>
<h3 id="error-3-wrong-operand-types"><a class="header" href="#error-3-wrong-operand-types">Error 3: Wrong Operand Types</a></h3>
<p><strong>증상:</strong></p>
<pre><code>error: 'llvm.store' op types mismatch between stored value and pointee type
note: stored value: i32, pointee type: !llvm.ptr
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>Store operation에 타입 불일치</li>
<li>GEP 결과를 잘못 사용</li>
</ul>
<p><strong>해결:</strong></p>
<ol>
<li><strong>Store 타입 확인:</strong></li>
</ol>
<pre><code class="language-cpp">// 잘못됨: i32를 !llvm.ptr 슬롯에 저장
rewriter.create&lt;LLVM::StoreOp&gt;(loc, i32Value, ptrSlot);

// 올바름: 타입 일치
rewriter.create&lt;LLVM::StoreOp&gt;(loc, i32Value, i32Slot);
</code></pre>
<ol start="2">
<li><strong>GEP 사용 확인:</strong></li>
</ol>
<pre><code class="language-mlir">// 올바른 GEP 패턴
%slot = llvm.getelementptr %ptr[1] : (!llvm.ptr) -&gt; !llvm.ptr
</code></pre>
<h3 id="error-4-pass-not-registered"><a class="header" href="#error-4-pass-not-registered">Error 4: Pass Not Registered</a></h3>
<p><strong>증상:</strong></p>
<pre><code class="language-bash">$ mlir-opt --funlang-to-llvm test.mlir
error: unknown command line flag '--funlang-to-llvm'
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>Pass 등록 함수가 호출되지 않음</li>
</ul>
<p><strong>해결:</strong></p>
<ol>
<li><strong>Pass 등록 확인:</strong></li>
</ol>
<pre><code class="language-cpp">// 초기화 코드에서 호출
void initializeMLIR() {
  registerFunLangDialect();
  registerFunLangToLLVMPass();  // 등록 함수 호출
}
</code></pre>
<ol start="2">
<li><strong>C API shim 확인:</strong></li>
</ol>
<pre><code class="language-cpp">extern "C" void mlirFunLangRegisterToLLVMPass() {
  registerFunLangToLLVMPass();
}
</code></pre>
<ol start="3">
<li><strong>F# 초기화 확인:</strong></li>
</ol>
<pre><code class="language-fsharp">// 프로그램 시작 시 호출
FunLang.initializePasses()
</code></pre>
<h3 id="error-5-segmentation-fault-in-pattern"><a class="header" href="#error-5-segmentation-fault-in-pattern">Error 5: Segmentation Fault in Pattern</a></h3>
<p><strong>증상:</strong></p>
<pre><code>Segmentation fault (core dumped)
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li><code>rewriter</code> 대신 일반 builder 사용</li>
<li>Null pointer dereference</li>
<li>Use-after-free (op 삭제 후 접근)</li>
</ul>
<p><strong>해결:</strong></p>
<ol>
<li><strong>항상 <code>rewriter</code> 사용:</strong></li>
</ol>
<pre><code class="language-cpp">// 잘못됨!
OpBuilder builder(ctx);
builder.create&lt;...&gt;();

// 올바름
rewriter.create&lt;...&gt;();
</code></pre>
<ol start="2">
<li><strong>Op 삭제 후 접근 금지:</strong></li>
</ol>
<pre><code class="language-cpp">// 잘못됨!
rewriter.replaceOp(op, newValue);
auto attr = op.getAttr("foo");  // Use-after-free!

// 올바름
auto attr = op.getAttr("foo");  // 먼저 읽기
rewriter.replaceOp(op, newValue);
</code></pre>
<ol start="3">
<li><strong>Null 체크:</strong></li>
</ol>
<pre><code class="language-cpp">Value closure = adaptor.getClosure();
if (!closure) {
  return failure();
}
</code></pre>
<hr>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p><strong>Chapter 16에서 배운 것:</strong></p>
<h3 id="1-dialectconversion-framework"><a class="header" href="#1-dialectconversion-framework">1. DialectConversion Framework</a></h3>
<ul>
<li><strong>ConversionTarget</strong>: Legal/illegal operations 정의</li>
<li><strong>RewritePatternSet</strong>: 변환 규칙 집합</li>
<li><strong>TypeConverter</strong>: 타입 변환 규칙</li>
<li><strong>applyPartialConversion</strong>: 부분 변환 실행</li>
</ul>
<h3 id="2-closureop-lowering-pattern"><a class="header" href="#2-closureop-lowering-pattern">2. ClosureOp Lowering Pattern</a></h3>
<ul>
<li><code>funlang.closure</code> → GC_malloc + GEP + store</li>
<li>Chapter 12 클로저 생성 패턴 재사용</li>
<li>OpAdaptor로 변환된 operands 접근</li>
<li>ConversionPatternRewriter로 IR 수정</li>
</ul>
<h3 id="3-applyop-lowering-pattern"><a class="header" href="#3-applyop-lowering-pattern">3. ApplyOp Lowering Pattern</a></h3>
<ul>
<li><code>funlang.apply</code> → GEP + load + llvm.call (indirect)</li>
<li>Chapter 13 간접 호출 패턴 재사용</li>
<li>인자 리스트 구성 (환경 포인터 + 실제 인자)</li>
<li>TypeConverter로 결과 타입 변환</li>
</ul>
<h3 id="4-typeconverter-for-funlang-types"><a class="header" href="#4-typeconverter-for-funlang-types">4. TypeConverter for FunLang Types</a></h3>
<ul>
<li><code>!funlang.closure</code> → <code>!llvm.ptr</code></li>
<li><code>!funlang.list&lt;T&gt;</code> → <code>!llvm.ptr</code></li>
<li>Function signatures 자동 변환</li>
<li>Materialization (optional)</li>
</ul>
<h3 id="5-declarative-rewrite-rules-drr"><a class="header" href="#5-declarative-rewrite-rules-drr">5. Declarative Rewrite Rules (DRR)</a></h3>
<ul>
<li>TableGen 기반 패턴 매칭</li>
<li>간단한 최적화 패턴 (empty closure, known closure inlining)</li>
<li>DRR vs C++ ConversionPattern 비교</li>
<li>mlir-tblgen으로 C++ 코드 생성</li>
</ul>
<h3 id="6-complete-lowering-pass"><a class="header" href="#6-complete-lowering-pass">6. Complete Lowering Pass</a></h3>
<ul>
<li>FunLangToLLVMPass 구현</li>
<li>Pass 등록 및 실행</li>
<li>C API shim for F# integration</li>
<li>F# wrapper functions</li>
</ul>
<h3 id="7-end-to-end-example"><a class="header" href="#7-end-to-end-example">7. End-to-End Example</a></h3>
<ul>
<li>makeAdder: FunLang source → LLVM IR → executable</li>
<li>전체 컴파일 파이프라인 추적</li>
<li>각 단계별 IR 확인</li>
</ul>
<h3 id="8-common-errors"><a class="header" href="#8-common-errors">8. Common Errors</a></h3>
<ul>
<li>Illegal operation remaining</li>
<li>Type conversion failure</li>
<li>Wrong operand types</li>
<li>Pass not registered</li>
<li>Segmentation fault</li>
</ul>
<p><strong>Phase 5 완료!</strong></p>
<ul>
<li><strong>Chapter 14</strong>: Custom dialect design theory</li>
<li><strong>Chapter 15</strong>: Custom operations implementation (funlang.closure, funlang.apply)</li>
<li><strong>Chapter 16</strong>: Lowering passes (FunLangToLLVM)</li>
</ul>
<p><strong>코드 압축 효과:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Before (Phase 4)</th><th>After (Phase 5)</th></tr>
</thead>
<tbody>
<tr><td><strong>Closure creation</strong></td><td>12 lines</td><td>1 line</td></tr>
<tr><td><strong>Closure application</strong></td><td>8 lines</td><td>1 line</td></tr>
<tr><td><strong>Compiler code</strong></td><td>~200 lines</td><td>~100 lines</td></tr>
<tr><td><strong>타입 안전성</strong></td><td><code>!llvm.ptr</code> (opaque)</td><td><code>!funlang.closure</code> (typed)</td></tr>
<tr><td><strong>최적화 가능성</strong></td><td>어려움</td><td>쉬움 (DRR patterns)</td></tr>
</tbody>
</table>
</div>
<p><strong>Phase 6 Preview: Pattern Matching</strong></p>
<p>다음 Phase에서는 <strong>패턴 매칭</strong>을 추가한다:</p>
<pre><code class="language-fsharp">// List operations
let rec length list =
    match list with
    | [] -&gt; 0
    | head :: tail -&gt; 1 + length tail
</code></pre>
<p><strong>새로운 operations:</strong></p>
<ul>
<li><code>funlang.match</code>: 패턴 매칭</li>
<li><code>funlang.nil</code>: 빈 리스트</li>
<li><code>funlang.cons</code>: 리스트 생성</li>
<li><code>funlang.list_head</code>, <code>funlang.list_tail</code>: 리스트 접근</li>
</ul>
<p><strong>새로운 lowering patterns:</strong></p>
<ul>
<li><code>funlang.match</code> → <code>scf.if</code> + <code>llvm.switch</code> (복잡한 제어 흐름)</li>
<li>SCF dialect를 거친 multi-stage lowering</li>
</ul>
<p><strong>Phase 5와 Phase 6의 차이:</strong></p>
<ul>
<li><strong>Phase 5</strong>: FunLang → LLVM (direct lowering)</li>
<li><strong>Phase 6</strong>: FunLang → SCF → LLVM (multi-stage lowering)</li>
</ul>
<p><strong>Chapter 16 완료!</strong> 이제 custom dialect를 설계하고, operations를 정의하고, lowering passes를 구현할 수 있다. FunLang 컴파일러는 high-level 추상화와 low-level 성능을 모두 제공한다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="15-custom-operations.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="appendix-custom-dialect.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="15-custom-operations.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="appendix-custom-dialect.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
