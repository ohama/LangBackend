<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chapter 11: 재귀 - LangBackend Tutorial</title>


        <!-- Custom HTML head -->

        <meta name="description" content="MLIR 기반 FunLang 컴파일러 백엔드 튜토리얼">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-d8498b13.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-1fa1ad07.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">LangBackend Tutorial</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/ohama/LangBackend" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>
                        <a href="https://github.com/ohama/LangBackend/edit/master/tutorial/./11-recursion.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <span class=fa-svg id="git-edit-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M421.7 220.3l-11.3 11.3-22.6 22.6-205 205c-6.6 6.6-14.8 11.5-23.8 14.1L30.8 511c-8.4 2.5-17.5 .2-23.7-6.1S-1.5 489.7 1 481.2L38.7 353.1c2.6-9 7.5-17.2 14.1-23.8l205-205 22.6-22.6 11.3-11.3 33.9 33.9 62.1 62.1 33.9 33.9zM96 353.9l-9.3 9.3c-.9 .9-1.6 2.1-2 3.4l-25.3 86 86-25.3c1.3-.4 2.5-1.1 3.4-2l9.3-9.3H112c-8.8 0-16-7.2-16-16V353.9zM453.3 19.3l39.4 39.4c25 25 25 65.5 0 90.5l-14.5 14.5-22.6 22.6-11.3 11.3-33.9-33.9-62.1-62.1L314.3 67.7l11.3-11.3 22.6-22.6 14.5-14.5c25-25 65.5-25 90.5 0z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="chapter-11-재귀-recursion"><a class="header" href="#chapter-11-재귀-recursion">Chapter 11: 재귀 (Recursion)</a></h1>
<h2 id="소개"><a class="header" href="#소개">소개</a></h2>
<p>함수형 프로그래밍에서 **재귀(recursion)**는 단순한 기법이 아니라 <strong>필수 도구</strong>다. 명령형 언어가 loop을 쓰는 곳에 함수형 언어는 재귀를 쓴다.</p>
<pre><code class="language-fsharp">// 명령형 스타일 (loop)
let sum_to n =
    let mutable result = 0
    for i in 1 to n do
        result &lt;- result + i
    result

// 함수형 스타일 (recursion)
let rec sum_to n =
    if n &lt;= 0 then 0
    else n + sum_to (n - 1)
</code></pre>
<p><strong>왜 재귀인가?</strong></p>
<p>순수 함수형 언어에는 mutable 변수가 없다. 값은 불변이고, 상태는 함수 파라미터를 통해 전달된다. Loop은 카운터 변수를 변경하는데, 이것은 mutation이다. 재귀는 mutation 없이 반복을 표현할 수 있다.</p>
<p>FunLang은 순수 함수형 언어다. Loop 구문이 없다. 모든 반복은 재귀로 표현된다.</p>
<p><strong>재귀의 본질: 자기 참조(Self-reference)</strong></p>
<p>재귀 함수는 <strong>자기 자신을 호출</strong>한다:</p>
<pre><code class="language-fsharp">let rec factorial n =
    if n &lt;= 1 then 1
    else n * factorial (n - 1)
           // ↑ 자기 자신을 호출!
</code></pre>
<p><code>factorial</code> 함수가 본체 내부에서 <code>factorial</code>을 호출한다. 이것이 가능하려면:</p>
<ul>
<li>함수 이름이 본체에서 보여야 한다 (scope 문제)</li>
<li>무한 재귀를 방지할 기저 사례(base case)가 필요하다</li>
</ul>
<p><strong>Chapter 11의 범위:</strong></p>
<p>이 장에서 다루는 것:</p>
<ol>
<li><strong>재귀 함수 (Recursive functions)</strong>: 자기 자신을 호출하는 함수 (factorial, fibonacci)</li>
<li><strong>상호 재귀 (Mutual recursion)</strong>: 두 함수가 서로를 호출 (is_even, is_odd)</li>
<li><strong>스택 프레임 (Stack frames)</strong>: 재귀 호출이 스택 메모리를 어떻게 사용하는가</li>
<li><strong>꼬리 호출 최적화 (Tail call optimization)</strong>: 스택 오버플로우를 방지하는 기법</li>
</ol>
<p>이 장을 마치면:</p>
<ul>
<li>factorial, fibonacci 같은 재귀 함수를 컴파일할 수 있다</li>
<li>상호 재귀가 모듈 레벨 심볼 테이블을 통해 작동하는 원리를 안다</li>
<li>스택 프레임이 어떻게 생성되고 소멸되는지 이해한다</li>
<li>꼬리 호출 최적화가 무엇이고 왜 중요한지 안다</li>
</ul>
<blockquote>
<p><strong>Preview:</strong> Phase 3 (Chapter 10-11)은 최상위 명명된 함수를 다룬다. Phase 4에서 클로저와 고차 함수를 추가할 것이다.</p>
</blockquote>
<h2 id="재귀가-mlir에서-작동하는-원리"><a class="header" href="#재귀가-mlir에서-작동하는-원리">재귀가 MLIR에서 작동하는 원리</a></h2>
<h3 id="모듈-레벨-심볼-테이블"><a class="header" href="#모듈-레벨-심볼-테이블">모듈 레벨 심볼 테이블</a></h3>
<p>Chapter 10에서 배운 것: MLIR 모듈은 <strong>flat symbol table</strong>을 가진다. 모든 <code>func.func</code> 연산이 모듈 레벨 심볼로 등록된다.</p>
<pre><code class="language-mlir">module {
  func.func @factorial(%n: i32) -&gt; i32 {
    // ...
  }

  func.func @fibonacci(%n: i32) -&gt; i32 {
    // ...
  }

  func.func @main() -&gt; i32 {
    // ...
  }
}
</code></pre>
<p><strong>핵심:</strong> 모든 함수가 서로에게 보인다. 정의 순서는 중요하지 않다.</p>
<ul>
<li><code>@factorial</code>은 <code>@fibonacci</code>를 호출할 수 있다</li>
<li><code>@fibonacci</code>는 <code>@factorial</code>을 호출할 수 있다</li>
<li><code>@factorial</code>은 <strong>자기 자신</strong>을 호출할 수 있다!</li>
</ul>
<p><strong>자기 참조 (Self-reference):</strong></p>
<pre><code class="language-mlir">func.func @factorial(%n: i32) -&gt; i32 {
  // ...
  %rec = func.call @factorial(%n_minus_1) : (i32) -&gt; i32
  //                 ↑ 자기 자신을 호출!
  // ...
}
</code></pre>
<p><code>@factorial</code> 함수가 내부에서 <code>func.call @factorial</code>을 실행한다. 이것은 **심볼 참조(symbol reference)**다:</p>
<ul>
<li><code>@factorial</code>이라는 심볼이 모듈에 존재하는가? <strong>예</strong> (자기 자신)</li>
<li>타입이 <code>(i32) -&gt; i32</code>가 맞는가? <strong>예</strong></li>
<li>호출 가능한가? <strong>예</strong></li>
</ul>
<p>MLIR verifier는 심볼 존재를 확인하지만, “자기 자신 호출“을 금지하지 않는다. 재귀가 자연스럽게 작동한다.</p>
<h3 id="interpreter-vs-compiler의-차이"><a class="header" href="#interpreter-vs-compiler의-차이">Interpreter vs Compiler의 차이</a></h3>
<p><strong>Interpreter에서 재귀 (LangTutorial FunLang):</strong></p>
<pre><code class="language-fsharp">// AST
LetRec("factorial",
       Lambda(["n"],
              If(BinOp(Var "n", Le, Num 1),
                 Num 1,
                 BinOp(Var "n",
                       Mul,
                       App(Var "factorial", [BinOp(Var "n", Sub, Num 1)])))))

// Interpreter evaluation
let rec eval env ast =
    match ast with
    | LetRec(name, Lambda(params, body), rest) -&gt;
        // 1. 재귀 환경 생성: env에 함수 자신을 추가
        let rec_env = env.Add(name, RecursiveClosure(params, body, rec_env))
        // 2. 본체 평가
        eval rec_env body
</code></pre>
<p>Interpreter는 **환경(environment)**에 함수를 바인딩한다. <code>LetRec</code>은 “재귀 바인딩“을 만든다 - 함수 본체가 평가되기 전에 환경에 자기 자신이 포함된다.</p>
<p><strong>Compiler에서 재귀 (FunLang MLIR):</strong></p>
<pre><code class="language-fsharp">// 컴파일
let compileFuncDef builder moduleDef (FunDef(name, params, body)) =
    // 1. 함수 생성 (func.func @name)
    let funcOp = builder.CreateFuncOp(name, paramTypes, returnType)

    // 2. 본체 컴파일
    let bodyValue = compileExpr builder env body

    // 3. 반환
    builder.CreateFuncReturn(bodyValue)

    // 4. 모듈에 추가
    moduleDef.AddFunction(funcOp)
</code></pre>
<p>Compiler는 <strong>심볼 테이블</strong>을 사용한다:</p>
<ul>
<li>함수가 <code>func.func</code> 연산으로 모듈에 추가되면, 심볼 <code>@name</code>이 등록된다</li>
<li>본체를 컴파일할 때 <code>func.call @name</code>을 만나면, 심볼 테이블에서 <code>@name</code>을 찾는다</li>
<li>심볼이 존재하므로 (자기 자신) 호출이 성공한다</li>
</ul>
<p><strong>차이점:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>측면</th><th>Interpreter</th><th>Compiler</th></tr>
</thead>
<tbody>
<tr><td>함수 저장</td><td>환경 (Map&lt;string, Value&gt;)</td><td>모듈 심볼 테이블</td></tr>
<tr><td>재귀 메커니즘</td><td>재귀 클로저 (self-reference in closure)</td><td>심볼 참조 (symbol reference)</td></tr>
<tr><td>평가 시점</td><td>런타임 (함수 호출할 때마다 환경 검색)</td><td>컴파일 타임 (심볼 확인) + 런타임 (call instruction)</td></tr>
<tr><td>Forward declaration</td><td>불필요 (LetRec이 재귀 환경 생성)</td><td>불필요 (모듈 레벨 심볼은 정의 순서 무관)</td></tr>
</tbody>
</table>
</div>
<p><strong>핵심:</strong> Interpreter는 환경을 사용하고, Compiler는 심볼을 사용한다. 둘 다 재귀를 지원하지만, 메커니즘이 다르다.</p>
<h3 id="컴파일-타임-심볼-확인"><a class="header" href="#컴파일-타임-심볼-확인">컴파일 타임 심볼 확인</a></h3>
<p>MLIR은 <strong>static symbol resolution</strong>을 수행한다:</p>
<pre><code class="language-mlir">// 잘못된 IR - verifier가 거부
func.func @foo(%n: i32) -&gt; i32 {
  %result = func.call @bar(%n) : (i32) -&gt; i32
  //                     ↑ @bar가 모듈에 없음!
  func.return %result : i32
}
</code></pre>
<p>MLIR verifier (<code>mlirOperationVerify</code>)는 심볼 참조를 검증한다:</p>
<ul>
<li><code>@bar</code> 심볼이 모듈에 존재하는가?</li>
<li>타입이 <code>(i32) -&gt; i32</code>와 호환되는가?</li>
</ul>
<p>검증 실패 시 에러:</p>
<pre><code>error: 'func.call' op 'bar' does not reference a valid function
</code></pre>
<p><strong>재귀 함수는 자연스럽게 통과:</strong></p>
<pre><code class="language-mlir">func.func @factorial(%n: i32) -&gt; i32 {
  // ...
  %rec = func.call @factorial(%n_minus_1) : (i32) -&gt; i32
  // ✓ @factorial은 모듈에 존재 (자기 자신)
  // ✓ 타입 (i32) -&gt; i32 일치
  // ...
}
</code></pre>
<p>Verifier는 심볼 존재만 확인한다. “자기 자신 호출“을 특별히 처리하지 않는다.</p>
<h3 id="mlir-ir-예시-factorial-자기-참조"><a class="header" href="#mlir-ir-예시-factorial-자기-참조">MLIR IR 예시: Factorial 자기 참조</a></h3>
<pre><code class="language-mlir">module {
  func.func @factorial(%arg0: i32) -&gt; i32 {
    %c1 = arith.constant 1 : i32
    %cmp = arith.cmpi sle, %arg0, %c1 : i32
    %result = scf.if %cmp -&gt; (i32) {
      scf.yield %c1 : i32
    } else {
      %n_minus_1 = arith.subi %arg0, %c1 : i32
      %rec = func.call @factorial(%n_minus_1) : (i32) -&gt; i32
      //                ↑ 자기 자신 호출
      %product = arith.muli %arg0, %rec : i32
      scf.yield %product : i32
    }
    func.return %result : i32
  }
}
</code></pre>
<p><strong>실행 시퀀스 (factorial 5):</strong></p>
<ol>
<li><code>@factorial</code>이 5로 호출됨</li>
<li>조건 확인: <code>5 &lt;= 1</code>? → false</li>
<li>else 블록 실행:
<ul>
<li><code>n_minus_1 = 5 - 1 = 4</code></li>
<li><code>rec = func.call @factorial(4)</code> ← <strong>재귀 호출</strong></li>
</ul>
</li>
<li>이제 <strong>새로운 스택 프레임</strong>에서 <code>@factorial(4)</code> 실행</li>
<li>조건 확인: <code>4 &lt;= 1</code>? → false</li>
<li>else 블록 실행:
<ul>
<li><code>n_minus_1 = 4 - 1 = 3</code></li>
<li><code>rec = func.call @factorial(3)</code> ← <strong>재귀 호출</strong></li>
</ul>
</li>
<li>… (계속)</li>
</ol>
<p>재귀 호출마다 새로운 스택 프레임이 생성된다. 각 프레임은 독립적인 <code>%arg0</code>, <code>%n_minus_1</code>, <code>%rec</code> 값을 가진다.</p>
<p><strong>핵심:</strong> 심볼 참조 <code>@factorial</code>은 컴파일 타임에 확인되고, 런타임에 <code>call</code> instruction으로 실행된다. LLVM이 스택 프레임 관리를 처리한다.</p>
<h2 id="재귀-함수-factorial"><a class="header" href="#재귀-함수-factorial">재귀 함수: Factorial</a></h2>
<h3 id="factorial-정의"><a class="header" href="#factorial-정의">Factorial 정의</a></h3>
<p><strong>수학적 정의:</strong></p>
<pre><code>factorial(n) = n! = n × (n-1) × (n-2) × ... × 2 × 1

예시:
  5! = 5 × 4 × 3 × 2 × 1 = 120
  3! = 3 × 2 × 1 = 6
  1! = 1
  0! = 1 (정의에 의해)
</code></pre>
<p><strong>재귀적 정의:</strong></p>
<pre><code>factorial(n) = {
  1                        if n &lt;= 1  (base case)
  n × factorial(n - 1)     if n &gt; 1   (recursive case)
}
</code></pre>
<p>기저 사례(base case): <code>n &lt;= 1</code>일 때 <code>1</code> 반환. 재귀 종료 조건.
재귀 사례(recursive case): <code>n × factorial(n - 1)</code>. 자기 자신을 더 작은 입력으로 호출.</p>
<p><strong>FunLang 소스:</strong></p>
<pre><code class="language-fsharp">let rec factorial n =
    if n &lt;= 1 then 1
    else n * factorial (n - 1)
</code></pre>
<h3 id="ast-표현"><a class="header" href="#ast-표현">AST 표현</a></h3>
<p>Chapter 10에서 정의한 AST:</p>
<pre><code class="language-fsharp">type Expr =
    | Num of int
    | Var of string
    | BinOp of Expr * Operator * Expr
    | If of Expr * Expr * Expr
    | Let of string * Expr * Expr
    | App of string * Expr list    // 함수 호출

type FunDef =
    | FunDef of string * string list * Expr

type Program =
    | Program of FunDef list * Expr
</code></pre>
<p><strong>factorial의 AST:</strong></p>
<pre><code class="language-fsharp">FunDef("factorial",
       ["n"],
       If(BinOp(Var "n", Le, Num 1),
          Num 1,
          BinOp(Var "n",
                Mul,
                App("factorial", [BinOp(Var "n", Sub, Num 1)]))))
</code></pre>
<p><strong>주목할 점:</strong></p>
<ul>
<li><code>App("factorial", ...)</code>: 함수 호출. 자기 자신을 호출한다.</li>
<li>기존 AST로 충분하다. <code>LetRec</code> 같은 새로운 AST 노드가 필요 없다.</li>
<li><code>FunDef</code>는 이미 모듈 레벨 함수를 표현한다. 이름으로 자기 참조가 가능하다.</li>
</ul>
<h3 id="컴파일-전략"><a class="header" href="#컴파일-전략">컴파일 전략</a></h3>
<p><strong>Chapter 10의 compileFuncDef 재사용:</strong></p>
<pre><code class="language-fsharp">let compileFuncDef (builder: OpBuilder) (moduleDef: ModuleOp) (FunDef(name, params, body)) =
    // 1. 함수 타입 생성
    let paramTypes = List.replicate params.Length builder.GetI32Type()
    let returnType = builder.GetI32Type()
    let funcType = builder.GetFunctionType(paramTypes, returnType)

    // 2. func.func 생성
    let funcOp = builder.CreateFuncOp(name, funcType)

    // 3. Entry block 생성 및 파라미터 가져오기
    let entryBlock = funcOp.GetEntryBlock()
    builder.SetInsertionPointToEnd(entryBlock)

    // 4. 환경 구축: 파라미터를 환경에 추가
    let env =
        params
        |&gt; List.mapi (fun i paramName -&gt;
            let argValue = entryBlock.GetArgument(i)
            (paramName, argValue))
        |&gt; Map.ofList

    // 5. 본체 컴파일
    let bodyValue = compileExpr builder env body

    // 6. 반환
    builder.CreateFuncReturn(bodyValue)

    // 7. 모듈에 추가
    moduleDef.AddFunction(funcOp)
</code></pre>
<p><strong>재귀 호출 처리 (compileExpr의 App case):</strong></p>
<pre><code class="language-fsharp">let rec compileExpr (builder: OpBuilder) (env: Map&lt;string, MlirValue&gt;) (expr: Expr) =
    match expr with
    | App(funcName, args) -&gt;
        // 1. 인자 컴파일
        let argValues = args |&gt; List.map (compileExpr builder env)

        // 2. 함수 호출
        builder.CreateFuncCall(funcName, argValues)
    // ... other cases
</code></pre>
<p><strong>핵심:</strong></p>
<ul>
<li><code>App("factorial", [arg])</code>를 만나면 <code>CreateFuncCall("factorial", [argValue])</code></li>
<li><code>CreateFuncCall</code>은 <code>func.call @factorial(%arg) : (i32) -&gt; i32</code> 생성</li>
<li>심볼 <code>@factorial</code>이 모듈에 존재 (자기 자신)</li>
<li>재귀 호출 완료!</li>
</ul>
<p><strong>재귀 함수 컴파일에 특별한 처리가 필요 없다.</strong> 일반 함수 호출과 동일하게 처리된다.</p>
<h3 id="완전한-mlir-ir-출력"><a class="header" href="#완전한-mlir-ir-출력">완전한 MLIR IR 출력</a></h3>
<pre><code class="language-mlir">module {
  func.func @factorial(%arg0: i32) -&gt; i32 {
    // if n &lt;= 1
    %c1 = arith.constant 1 : i32
    %cmp = arith.cmpi sle, %arg0, %c1 : i32

    // scf.if with two branches
    %result = scf.if %cmp -&gt; (i32) {
      // then: return 1
      scf.yield %c1 : i32
    } else {
      // else: return n * factorial(n - 1)

      // n - 1
      %n_minus_1 = arith.subi %arg0, %c1 : i32

      // factorial(n - 1) - 재귀 호출!
      %rec = func.call @factorial(%n_minus_1) : (i32) -&gt; i32

      // n * factorial(n - 1)
      %product = arith.muli %arg0, %rec : i32

      scf.yield %product : i32
    }

    func.return %result : i32
  }
}
</code></pre>
<p><strong>구조:</strong></p>
<ol>
<li><strong>조건 평가:</strong> <code>%cmp = arith.cmpi sle, %arg0, %c1</code> (n &lt;= 1?)</li>
<li><strong>scf.if 분기:</strong>
<ul>
<li><strong>then 블록:</strong> <code>scf.yield %c1</code> (기저 사례: 1 반환)</li>
<li><strong>else 블록:</strong>
<ul>
<li><code>%n_minus_1 = arith.subi %arg0, %c1</code> (n - 1 계산)</li>
<li><code>%rec = func.call @factorial(%n_minus_1)</code> (<strong>재귀 호출</strong>)</li>
<li><code>%product = arith.muli %arg0, %rec</code> (n * 재귀 결과)</li>
<li><code>scf.yield %product</code> (재귀 사례: n * factorial(n-1))</li>
</ul>
</li>
</ul>
</li>
<li><strong>반환:</strong> <code>func.return %result</code></li>
</ol>
<h3 id="단계별-실행-추적"><a class="header" href="#단계별-실행-추적">단계별 실행 추적</a></h3>
<p><strong>factorial 5 실행 과정:</strong></p>
<pre><code>1. factorial(5) 호출
   ├─ 조건: 5 &lt;= 1? → false
   ├─ else 블록 진입
   ├─ n_minus_1 = 5 - 1 = 4
   ├─ factorial(4) 호출 ← 재귀
   │  ├─ 조건: 4 &lt;= 1? → false
   │  ├─ else 블록 진입
   │  ├─ n_minus_1 = 4 - 1 = 3
   │  ├─ factorial(3) 호출 ← 재귀
   │  │  ├─ 조건: 3 &lt;= 1? → false
   │  │  ├─ else 블록 진입
   │  │  ├─ n_minus_1 = 3 - 1 = 2
   │  │  ├─ factorial(2) 호출 ← 재귀
   │  │  │  ├─ 조건: 2 &lt;= 1? → false
   │  │  │  ├─ else 블록 진입
   │  │  │  ├─ n_minus_1 = 2 - 1 = 1
   │  │  │  ├─ factorial(1) 호출 ← 재귀
   │  │  │  │  ├─ 조건: 1 &lt;= 1? → true
   │  │  │  │  └─ then 블록: return 1 ← 기저 사례!
   │  │  │  ├─ rec = 1
   │  │  │  ├─ product = 2 * 1 = 2
   │  │  │  └─ return 2
   │  │  ├─ rec = 2
   │  │  ├─ product = 3 * 2 = 6
   │  │  └─ return 6
   │  ├─ rec = 6
   │  ├─ product = 4 * 6 = 24
   │  └─ return 24
   ├─ rec = 24
   ├─ product = 5 * 24 = 120
   └─ return 120

최종 결과: 120
</code></pre>
<p><strong>호출 깊이 (Call depth):</strong> 5</p>
<p>각 재귀 호출은 새로운 스택 프레임을 생성한다. <code>factorial(5)</code>는 5개의 스택 프레임을 사용한다.</p>
<h3 id="lowered-llvm-ir"><a class="header" href="#lowered-llvm-ir">Lowered LLVM IR</a></h3>
<p>MLIR IR을 LLVM IR로 변환하면 (<code>mlir-opt --convert-scf-to-cf --convert-func-to-llvm --convert-arith-to-llvm</code>):</p>
<pre><code class="language-llvm">define i32 @factorial(i32 %0) {
entry:
  %1 = icmp sle i32 %0, 1
  br i1 %1, label %then, label %else

then:
  br label %merge

else:
  %2 = sub i32 %0, 1
  %3 = call i32 @factorial(i32 %2)  ; 재귀 호출 (call instruction)
  %4 = mul i32 %0, %3
  br label %merge

merge:
  %5 = phi i32 [ 1, %then ], [ %4, %else ]
  ret i32 %5
}
</code></pre>
<p><strong>주목할 점:</strong></p>
<ul>
<li><code>call i32 @factorial(i32 %2)</code>: LLVM IR의 재귀 호출</li>
<li>각 호출은 스택 프레임을 생성한다 (LLVM runtime이 처리)</li>
<li>PHI 노드 (<code>phi i32 [ 1, %then ], [ %4, %else ]</code>)는 scf.if의 lowering 결과</li>
</ul>
<p><strong>Native 코드로 컴파일:</strong></p>
<pre><code class="language-bash">mlir-translate --mlir-to-llvmir factorial.mlir &gt; factorial.ll
llc -filetype=obj factorial.ll -o factorial.o
gcc -o factorial factorial.o runtime.o -lgc
./factorial
</code></pre>
<h2 id="재귀-함수-fibonacci"><a class="header" href="#재귀-함수-fibonacci">재귀 함수: Fibonacci</a></h2>
<h3 id="fibonacci-정의"><a class="header" href="#fibonacci-정의">Fibonacci 정의</a></h3>
<p><strong>수학적 정의:</strong></p>
<pre><code>fibonacci(n) = {
  n                                if n &lt;= 1  (base case)
  fibonacci(n-1) + fibonacci(n-2)  if n &gt; 1   (recursive case)
}

수열:
  fib(0) = 0
  fib(1) = 1
  fib(2) = fib(1) + fib(0) = 1 + 0 = 1
  fib(3) = fib(2) + fib(1) = 1 + 1 = 2
  fib(4) = fib(3) + fib(2) = 2 + 1 = 3
  fib(5) = fib(4) + fib(3) = 3 + 2 = 5
  fib(6) = fib(5) + fib(4) = 5 + 3 = 8
</code></pre>
<p><strong>FunLang 소스:</strong></p>
<pre><code class="language-fsharp">let rec fib n =
    if n &lt;= 1 then n
    else fib (n - 1) + fib (n - 2)
</code></pre>
<h3 id="double-recursion-패턴"><a class="header" href="#double-recursion-패턴">Double Recursion 패턴</a></h3>
<p>Factorial은 <strong>단일 재귀(single recursion)</strong>: 한 번만 자기 자신을 호출.
Fibonacci는 <strong>이중 재귀(double recursion)</strong>: 두 번 자기 자신을 호출.</p>
<pre><code class="language-fsharp">fib (n - 1) + fib (n - 2)
//  ↑             ↑
// 첫 번째 호출   두 번째 호출
</code></pre>
<p><strong>함의:</strong></p>
<ul>
<li>각 재귀 호출이 또 다른 두 개의 호출을 만든다</li>
<li>호출 트리가 <strong>지수적으로 증가</strong>한다</li>
</ul>
<p><strong>fib(5)의 호출 트리:</strong></p>
<pre><code>                    fib(5)
                   /      \
              fib(4)      fib(3)
             /     \      /     \
        fib(3)   fib(2) fib(2) fib(1)
        /   \    /   \  /   \
    fib(2) fib(1) fib(1) fib(0) fib(1) fib(0)
    /   \
fib(1) fib(0)
</code></pre>
<p><strong>호출 횟수:</strong> <code>fib(5)</code>를 계산하기 위해 15번의 함수 호출이 발생한다.</p>
<p><strong>시간 복잡도:</strong> O(2^n) - 지수 시간. <code>fib(30)</code> ≈ 20억 번 호출!</p>
<h3 id="컴파일-두-개의-funccall"><a class="header" href="#컴파일-두-개의-funccall">컴파일: 두 개의 func.call</a></h3>
<pre><code class="language-mlir">func.func @fib(%arg0: i32) -&gt; i32 {
  // if n &lt;= 1
  %c1 = arith.constant 1 : i32
  %cmp = arith.cmpi sle, %arg0, %c1 : i32

  %result = scf.if %cmp -&gt; (i32) {
    // then: return n
    scf.yield %arg0 : i32
  } else {
    // else: return fib(n-1) + fib(n-2)

    // n - 1
    %n_minus_1 = arith.subi %arg0, %c1 : i32

    // fib(n - 1) - 첫 번째 재귀 호출
    %fib_n_1 = func.call @fib(%n_minus_1) : (i32) -&gt; i32

    // n - 2
    %c2 = arith.constant 2 : i32
    %n_minus_2 = arith.subi %arg0, %c2 : i32

    // fib(n - 2) - 두 번째 재귀 호출
    %fib_n_2 = func.call @fib(%n_minus_2) : (i32) -&gt; i32

    // fib(n-1) + fib(n-2)
    %sum = arith.addi %fib_n_1, %fib_n_2 : i32

    scf.yield %sum : i32
  }

  func.return %result : i32
}
</code></pre>
<p><strong>구조:</strong></p>
<ul>
<li><strong>else 블록에서 두 번의 func.call:</strong>
<ul>
<li><code>%fib_n_1 = func.call @fib(%n_minus_1)</code></li>
<li><code>%fib_n_2 = func.call @fib(%n_minus_2)</code></li>
</ul>
</li>
<li><strong>각 호출은 독립적:</strong> <code>%fib_n_1</code>이 완료된 후 <code>%fib_n_2</code> 실행</li>
<li><strong>결과를 더함:</strong> <code>%sum = arith.addi %fib_n_1, %fib_n_2</code></li>
</ul>
<p><strong>실행 순서 (eager evaluation):</strong></p>
<ol>
<li><code>%n_minus_1</code> 계산</li>
<li><code>func.call @fib(%n_minus_1)</code> 실행 → 결과를 <code>%fib_n_1</code>에 저장</li>
<li><code>%n_minus_2</code> 계산</li>
<li><code>func.call @fib(%n_minus_2)</code> 실행 → 결과를 <code>%fib_n_2</code>에 저장</li>
<li><code>%sum = %fib_n_1 + %fib_n_2</code> 계산</li>
</ol>
<h3 id="성능-문제"><a class="header" href="#성능-문제">성능 문제</a></h3>
<p><strong>지수 시간 복잡도:</strong></p>
<pre><code>fib(10) ≈ 177 호출
fib(20) ≈ 21,891 호출
fib(30) ≈ 2,692,537 호출
fib(40) ≈ 331,160,281 호출 (3억 번!)
</code></pre>
<p><strong>왜 느린가?</strong></p>
<p>중복 계산이 많다. <code>fib(5)</code>를 계산할 때 <code>fib(3)</code>을 두 번 계산하고, <code>fib(2)</code>를 세 번 계산한다.</p>
<pre><code>fib(5)
├─ fib(4)
│  ├─ fib(3) ← 첫 번째 fib(3)
│  └─ fib(2)
└─ fib(3) ← 두 번째 fib(3) (중복!)
   ├─ fib(2) ← 중복!
   └─ fib(1)
</code></pre>
<p><strong>최적화 방법 (Phase 3 범위 밖):</strong></p>
<ul>
<li><strong>Memoization:</strong> 이미 계산한 값을 저장 (hashtable 사용)</li>
<li><strong>Dynamic Programming:</strong> Bottom-up 방식으로 계산</li>
<li><strong>Tail recursion:</strong> 꼬리 재귀로 변환 (accumulator 사용)</li>
</ul>
<p>이 장에서는 <strong>순진한 재귀 구현</strong>만 다룬다. 최적화는 나중 단계에서 배운다.</p>
<p><strong>교훈:</strong> 재귀는 우아하지만, 항상 효율적이지는 않다. 알고리즘 선택이 중요하다.</p>
<h2 id="스택-프레임-관리"><a class="header" href="#스택-프레임-관리">스택 프레임 관리</a></h2>
<h3 id="스택-프레임이란"><a class="header" href="#스택-프레임이란">스택 프레임이란?</a></h3>
<p><strong>스택 프레임(stack frame)</strong> (또는 <strong>activation record</strong>)은 함수 호출에 필요한 정보를 저장하는 메모리 영역이다.</p>
<p><strong>스택 프레임에 포함되는 것:</strong></p>
<ol>
<li><strong>반환 주소(return address)</strong>: 함수가 끝나면 돌아갈 위치</li>
<li><strong>함수 파라미터</strong>: 호출자가 전달한 인자</li>
<li><strong>지역 변수</strong>: 함수 내부에서 선언된 변수</li>
<li><strong>저장된 레지스터</strong>: 호출 전 레지스터 상태 (ABI가 요구)</li>
<li><strong>임시 값</strong>: 중간 계산 결과 (SSA values)</li>
</ol>
<p><strong>함수 호출 시 스택 프레임 생성:</strong></p>
<pre><code>main()
  |
  ├─ factorial(5) 호출
  │    ├─ 스택 프레임 생성
  │    │    - return address: main의 다음 instruction
  │    │    - arg0 = 5
  │    │    - 지역 변수 공간
  │    ├─ factorial(4) 호출
  │    │    ├─ 새로운 스택 프레임 생성
  │    │    │    - return address: factorial(5)의 다음 instruction
  │    │    │    - arg0 = 4
  │    │    ├─ factorial(3) 호출
  │    │    │    └─ 또 다른 스택 프레임...
</code></pre>
<p><strong>스택 성장 방향:</strong></p>
<p>대부분의 플랫폼에서 스택은 <strong>아래로 성장</strong>한다 (높은 주소 → 낮은 주소):</p>
<pre><code>높은 주소
   ↓
 [main의 스택 프레임]
 [factorial(5)의 스택 프레임]  ← SP (Stack Pointer) 이동
 [factorial(4)의 스택 프레임]  ← SP 이동
 [factorial(3)의 스택 프레임]  ← SP 이동
 [factorial(2)의 스택 프레임]
 [factorial(1)의 스택 프레임]  ← SP (현재 위치)
   ↓
낮은 주소
</code></pre>
<p><strong>Stack Pointer (SP)</strong>: 스택의 현재 끝을 가리키는 레지스터. 함수 호출 시 SP가 아래로 이동.</p>
<h3 id="재귀-호출과-스택-깊이"><a class="header" href="#재귀-호출과-스택-깊이">재귀 호출과 스택 깊이</a></h3>
<p><strong>재귀 호출마다 새로운 스택 프레임:</strong></p>
<pre><code class="language-fsharp">factorial(5)
  ├─ 스택 프레임 1: arg0=5, return_addr=main
  ├─ factorial(4) 호출
  │  ├─ 스택 프레임 2: arg0=4, return_addr=factorial(5)
  │  ├─ factorial(3) 호출
  │  │  ├─ 스택 프레임 3: arg0=3, return_addr=factorial(4)
  │  │  ├─ factorial(2) 호출
  │  │  │  ├─ 스택 프레임 4: arg0=2, return_addr=factorial(3)
  │  │  │  ├─ factorial(1) 호출
  │  │  │  │  └─ 스택 프레임 5: arg0=1, return_addr=factorial(2)
  │  │  │  │     ├─ 기저 사례: return 1
  │  │  │  │     └─ 스택 프레임 5 소멸
  │  │  │  ├─ 반환값 1 받음, 2*1=2 계산, return 2
  │  │  │  └─ 스택 프레임 4 소멸
  │  │  ├─ 반환값 2 받음, 3*2=6 계산, return 6
  │  │  └─ 스택 프레임 3 소멸
  │  ├─ 반환값 6 받음, 4*6=24 계산, return 24
  │  └─ 스택 프레임 2 소멸
  ├─ 반환값 24 받음, 5*24=120 계산, return 120
  └─ 스택 프레임 1 소멸
</code></pre>
<p><strong>최대 스택 깊이:</strong> <code>factorial(5)</code>는 5개의 스택 프레임이 동시에 존재한다 (기저 사례에 도달했을 때).</p>
<p><strong>일반화:</strong> <code>factorial(n)</code>의 최대 스택 깊이는 <code>n</code>.</p>
<h3 id="스택-크기-제한"><a class="header" href="#스택-크기-제한">스택 크기 제한</a></h3>
<p><strong>운영체제는 스택 크기를 제한한다:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>플랫폼</th><th>기본 스택 크기</th></tr>
</thead>
<tbody>
<tr><td>Linux (x86-64)</td><td>8 MB</td></tr>
<tr><td>macOS</td><td>8 MB</td></tr>
<tr><td>Windows</td><td>1 MB</td></tr>
</tbody>
</table>
</div>
<p><strong>왜 제한이 필요한가?</strong></p>
<ul>
<li>무한 재귀를 방지</li>
<li>메모리 보호 (스택이 다른 메모리 영역을 침범하지 않도록)</li>
</ul>
<p><strong>스택 오버플로우(Stack Overflow):</strong></p>
<p>재귀 깊이가 너무 크면 스택 크기 한계에 도달한다:</p>
<pre><code class="language-fsharp">factorial(100000)
  ├─ 100,000개의 스택 프레임 필요
  ├─ 각 프레임이 ~64 bytes라고 가정
  ├─ 총 스택 사용: 100,000 * 64 = 6.4 MB
  └─ Linux에서는 OK (8MB 한계), Windows에서는 실패 (1MB 한계)
</code></pre>
<p><strong>스택 오버플로우 에러:</strong></p>
<pre><code class="language-bash">./factorial
Segmentation fault (core dumped)
# 또는
Stack overflow error
</code></pre>
<p><strong>해결책:</strong></p>
<ol>
<li><strong>재귀 깊이 제한:</strong> 입력 크기를 제한</li>
<li><strong>꼬리 호출 최적화(Tail Call Optimization):</strong> 스택 프레임 재사용</li>
<li><strong>반복(Iteration)으로 변환:</strong> Loop 사용 (함수형 언어에서는 덜 선호)</li>
<li><strong>Trampoline 기법:</strong> 재귀를 CPS(Continuation-Passing Style)로 변환</li>
</ol>
<p>이 장 후반부에서 꼬리 호출 최적화를 다룬다.</p>
<h3 id="llvm의-스택-프레임-관리"><a class="header" href="#llvm의-스택-프레임-관리">LLVM의 스택 프레임 관리</a></h3>
<p><strong>LLVM은 스택 프레임을 자동으로 관리한다:</strong></p>
<ol>
<li>
<p><strong>함수 프롤로그(prologue):</strong></p>
<ul>
<li>스택 포인터(SP) 감소 (스택 공간 할당)</li>
<li>프레임 포인터(FP) 저장</li>
<li>필요한 레지스터 저장 (callee-saved registers)</li>
</ul>
</li>
<li>
<p><strong>함수 에필로그(epilogue):</strong></p>
<ul>
<li>저장된 레지스터 복원</li>
<li>프레임 포인터 복원</li>
<li>스택 포인터 증가 (스택 공간 해제)</li>
<li>반환 (ret instruction)</li>
</ul>
</li>
</ol>
<p><strong>예시 (x86-64 어셈블리):</strong></p>
<pre><code class="language-asm">factorial:
  ; Prologue
  push    rbp              ; 이전 프레임 포인터 저장
  mov     rbp, rsp         ; 새로운 프레임 포인터 설정
  sub     rsp, 16          ; 지역 변수를 위한 스택 공간 할당

  ; Function body
  ; ... (factorial 계산)

  ; Epilogue
  add     rsp, 16          ; 스택 공간 해제
  pop     rbp              ; 이전 프레임 포인터 복원
  ret                      ; 반환 주소로 점프
</code></pre>
<p><strong>FunLang 컴파일러는 스택 관리를 직접 하지 않는다:</strong></p>
<ul>
<li>MLIR <code>func</code> 다이얼렉트로 함수 정의</li>
<li>LLVM이 lowering 과정에서 프롤로그/에필로그 생성</li>
<li>플랫폼별 calling convention 자동 적용 (System V ABI for Linux, Microsoft x64 for Windows)</li>
</ul>
<p><strong>이점:</strong></p>
<ul>
<li>플랫폼 독립적인 코드</li>
<li>ABI 호환성 자동 보장</li>
<li>최적화 (tail call elimination, frame pointer omission)</li>
</ul>
<h3 id="visualization-factorial-5의-스택"><a class="header" href="#visualization-factorial-5의-스택">Visualization: factorial 5의 스택</a></h3>
<p><strong>시간별 스택 상태:</strong></p>
<pre><code>시간 T1: main에서 factorial(5) 호출
┌──────────────────────┐
│ factorial(5)         │ ← SP
│  - arg0 = 5          │
│  - ret_addr = main+X │
├──────────────────────┤
│ main                 │
└──────────────────────┘

시간 T2: factorial(5)에서 factorial(4) 호출
┌──────────────────────┐
│ factorial(4)         │ ← SP
│  - arg0 = 4          │
│  - ret_addr = f(5)+Y │
├──────────────────────┤
│ factorial(5)         │
│  - arg0 = 5          │
├──────────────────────┤
│ main                 │
└──────────────────────┘

시간 T3: factorial(1) 도달 (최대 깊이)
┌──────────────────────┐
│ factorial(1)         │ ← SP (최대 깊이)
│  - arg0 = 1          │
├──────────────────────┤
│ factorial(2)         │
│  - arg0 = 2          │
├──────────────────────┤
│ factorial(3)         │
│  - arg0 = 3          │
├──────────────────────┤
│ factorial(4)         │
│  - arg0 = 4          │
├──────────────────────┤
│ factorial(5)         │
│  - arg0 = 5          │
├──────────────────────┤
│ main                 │
└──────────────────────┘

시간 T4: factorial(1) 반환 후 (1 반환)
┌──────────────────────┐
│ factorial(2)         │ ← SP
│  - arg0 = 2          │
│  - rec = 1           │
├──────────────────────┤
│ factorial(3)         │
├──────────────────────┤
│ factorial(4)         │
├──────────────────────┤
│ factorial(5)         │
├──────────────────────┤
│ main                 │
└──────────────────────┘

...

시간 T_final: 모든 호출 반환 완료
┌──────────────────────┐
│ main                 │ ← SP
│  - result = 120      │
└──────────────────────┘
</code></pre>
<p><strong>핵심:</strong></p>
<ul>
<li>재귀 호출마다 스택이 <strong>성장</strong>한다</li>
<li>기저 사례에 도달하면 스택이 <strong>수축</strong>하기 시작한다</li>
<li>각 반환은 이전 스택 프레임을 복원한다</li>
</ul>
<h3 id="스택-vs-힙"><a class="header" href="#스택-vs-힙">스택 vs 힙</a></h3>
<p><strong>Phase 2에서 배운 것:</strong></p>
<ul>
<li><strong>스택(Stack):</strong> 함수 로컬 값, LIFO, 자동 해제</li>
<li><strong>힙(Heap):</strong> 탈출하는 값(closures, data structures), 수동/GC 해제</li>
</ul>
<p><strong>Phase 3에서 함수는 스택만 사용:</strong></p>
<ul>
<li>파라미터: 스택 또는 레지스터 (calling convention)</li>
<li>반환 값: 레지스터 (작은 값) 또는 스택 (큰 구조체)</li>
<li>지역 변수: SSA values (레지스터 또는 스택 스필링)</li>
</ul>
<p><strong>Phase 4에서 클로저는 힙 사용:</strong></p>
<ul>
<li>클로저 환경: 힙에 할당 (GC_malloc)</li>
<li>클로저 포인터: 스택에 저장</li>
</ul>
<p><strong>연결:</strong></p>
<ul>
<li>Chapter 9 (Boehm GC)는 Phase 4를 위한 준비였다</li>
<li>Phase 3 함수는 GC를 사용하지 않는다 (메모리 할당 없음)</li>
<li>Phase 4 클로저에서 GC가 활성화된다</li>
</ul>
<h2 id="왜-스택-오버플로우가-발생하는가"><a class="header" href="#왜-스택-오버플로우가-발생하는가">왜 스택 오버플로우가 발생하는가</a></h2>
<h3 id="깊은-재귀의-위험"><a class="header" href="#깊은-재귀의-위험">깊은 재귀의 위험</a></h3>
<p><strong>문제:</strong></p>
<pre><code class="language-fsharp">factorial(100000)
</code></pre>
<p>이 호출은 100,000개의 스택 프레임을 생성한다. 각 프레임이 64 bytes라면:</p>
<pre><code>100,000 frames × 64 bytes/frame = 6,400,000 bytes = 6.4 MB
</code></pre>
<p>Linux 기본 스택 크기가 8 MB이므로 <strong>아슬아슬하게 성공</strong>할 수 있다. Windows (1 MB)에서는 <strong>확실히 실패</strong>한다.</p>
<p><strong>실제 테스트:</strong></p>
<pre><code class="language-bash"># factorial 100000 컴파일 및 실행
./factorial 100000
Segmentation fault
</code></pre>
<p><strong>왜 Segmentation fault?</strong></p>
<p>스택 포인터(SP)가 스택 크기 한계를 넘어서 <strong>guard page</strong>에 도달한다. Guard page는 스택 오버플로우 감지를 위한 특수 메모리 페이지로, 접근 시 segfault를 발생시킨다.</p>
<h3 id="최적화-없는-재귀"><a class="header" href="#최적화-없는-재귀">최적화 없는 재귀</a></h3>
<p><strong>일반 재귀 (Non-tail recursion):</strong></p>
<pre><code class="language-fsharp">let rec factorial n =
    if n &lt;= 1 then 1
    else n * factorial (n - 1)
         // ↑ 재귀 호출 후 곱셈이 남아있음
</code></pre>
<p>재귀 호출 후에 <strong>추가 작업</strong>(곱셈)이 있으므로:</p>
<ul>
<li>재귀 호출이 반환될 때까지 <strong>현재 스택 프레임을 유지</strong>해야 한다</li>
<li>반환 값을 받아서 <code>n</code>과 곱해야 한다</li>
<li>따라서 스택 프레임을 재사용할 수 없다</li>
</ul>
<p><strong>스택 프레임 누적:</strong></p>
<pre><code>factorial(5) 스택 프레임 유지 (n=5 저장 필요)
  factorial(4) 스택 프레임 유지 (n=4 저장 필요)
    factorial(3) 스택 프레임 유지 (n=3 저장 필요)
      factorial(2) 스택 프레임 유지 (n=2 저장 필요)
        factorial(1) 스택 프레임 생성
          return 1
        return 2 (= 2 * 1)
      return 6 (= 3 * 2)
    return 24 (= 4 * 6)
  return 120 (= 5 * 24)
</code></pre>
<p>모든 프레임이 동시에 존재해야 한다.</p>
<p><strong>결론:</strong> 일반 재귀는 스택 크기에 제한받는다.</p>
<h3 id="예시-factorial-100000은-왜-실패하는가"><a class="header" href="#예시-factorial-100000은-왜-실패하는가">예시: factorial 100000은 왜 실패하는가</a></h3>
<pre><code>스택 크기: 8 MB = 8,388,608 bytes
필요한 스택: 100,000 frames × 64 bytes = 6,400,000 bytes

6,400,000 &lt; 8,388,608 → 이론적으로 가능
</code></pre>
<p>하지만 실제로는:</p>
<ul>
<li><strong>다른 함수 프레임:</strong> main, runtime initialization</li>
<li><strong>스택 정렬 (alignment):</strong> 16-byte 정렬 요구사항</li>
<li><strong>추가 오버헤드:</strong> 레지스터 저장, guard page</li>
</ul>
<p>실제 사용 가능한 스택이 줄어든다. 그래서 6.4 MB도 실패할 수 있다.</p>
<p><strong>안전한 한계:</strong></p>
<p>대부분의 시스템에서 <strong>~5,000 - 10,000 깊이</strong>가 안전하다. 그 이상은 스택 오버플로우 위험.</p>
<p><strong>교훈:</strong> 깊은 재귀는 위험하다. 꼬리 호출 최적화가 필요하다.</p>
<h2 id="상호-재귀-mutual-recursion"><a class="header" href="#상호-재귀-mutual-recursion">상호 재귀 (Mutual Recursion)</a></h2>
<h3 id="상호-재귀란"><a class="header" href="#상호-재귀란">상호 재귀란?</a></h3>
<p>**상호 재귀(mutual recursion)**는 두 개 이상의 함수가 서로를 호출하는 패턴이다.</p>
<pre><code class="language-fsharp">// 함수 A가 함수 B를 호출하고,
// 함수 B가 함수 A를 호출한다.

let rec is_even n =
    if n = 0 then true
    else is_odd (n - 1)

let rec is_odd n =
    if n = 0 then false
    else is_even (n - 1)
</code></pre>
<p><strong>차이점:</strong></p>
<ul>
<li><strong>단순 재귀:</strong> 함수가 자기 자신을 호출 (<code>factorial</code> → <code>factorial</code>)</li>
<li><strong>상호 재귀:</strong> 함수 A가 함수 B를 호출, 함수 B가 함수 A를 호출 (<code>is_even</code> ⇄ <code>is_odd</code>)</li>
</ul>
<p><strong>왜 필요한가?</strong></p>
<p>어떤 문제는 자연스럽게 상호 재귀로 표현된다:</p>
<ul>
<li>짝수/홀수 판정</li>
<li>문법 파서 (expression → term → factor → expression)</li>
<li>상태 기계 (state A → state B → state A)</li>
</ul>
<h3 id="예시-is_even과-is_odd"><a class="header" href="#예시-is_even과-is_odd">예시: is_even과 is_odd</a></h3>
<p><strong>수학적 정의:</strong></p>
<pre><code>is_even(n) = {
  true                 if n = 0
  is_odd(n - 1)        if n &gt; 0
}

is_odd(n) = {
  false                if n = 0
  is_even(n - 1)       if n &gt; 0
}
</code></pre>
<p><strong>직관:</strong></p>
<ul>
<li>0은 짝수</li>
<li>n이 짝수인지 확인하려면: n-1이 홀수인지 확인</li>
<li>n이 홀수인지 확인하려면: n-1이 짝수인지 확인</li>
</ul>
<p><strong>FunLang 소스:</strong></p>
<pre><code class="language-fsharp">let rec is_even n =
    if n = 0 then true
    else is_odd (n - 1)

let rec is_odd n =
    if n = 0 then false
    else is_even (n - 1)
</code></pre>
<p><strong>실행 예시 (is_even 4):</strong></p>
<pre><code>is_even(4)
  ├─ 4 = 0? → false
  ├─ is_odd(3) 호출
  │  ├─ 3 = 0? → false
  │  ├─ is_even(2) 호출
  │  │  ├─ 2 = 0? → false
  │  │  ├─ is_odd(1) 호출
  │  │  │  ├─ 1 = 0? → false
  │  │  │  ├─ is_even(0) 호출
  │  │  │  │  ├─ 0 = 0? → true
  │  │  │  │  └─ return true
  │  │  │  └─ return true (is_even(0) = true)
  │  │  └─ return true (is_odd(1) = true)
  │  └─ return true (is_even(2) = true)
  └─ return true (is_odd(3) = true)

최종 결과: true (4는 짝수)
</code></pre>
<p><strong>호출 시퀀스:</strong> is_even → is_odd → is_even → is_odd → is_even</p>
<h3 id="모듈-레벨-심볼-테이블의-역할"><a class="header" href="#모듈-레벨-심볼-테이블의-역할">모듈 레벨 심볼 테이블의 역할</a></h3>
<p><strong>핵심:</strong> MLIR 모듈은 flat symbol namespace를 가진다. 모든 함수가 동시에 보인다.</p>
<pre><code class="language-mlir">module {
  func.func @is_even(%n: i32) -&gt; i1 { ... }
  func.func @is_odd(%n: i32) -&gt; i1 { ... }
}
</code></pre>
<p><strong>중요한 점:</strong></p>
<ul>
<li><strong>정의 순서는 무관:</strong> <code>is_even</code>이 먼저 정의되든, <code>is_odd</code>가 먼저 정의되든 상관없다.</li>
<li><strong>Forward declaration 불필요:</strong> C에서는 forward declaration이 필요하지만, MLIR에서는 필요 없다.</li>
<li><strong>모든 함수가 서로에게 보임:</strong> <code>is_even</code> 본체에서 <code>is_odd</code>를 참조할 수 있고, <code>is_odd</code> 본체에서 <code>is_even</code>을 참조할 수 있다.</li>
</ul>
<p><strong>C와 비교:</strong></p>
<pre><code class="language-c">// C에서는 forward declaration 필요
int is_odd(int n);  // forward declaration

int is_even(int n) {
    if (n == 0) return 1;
    else return is_odd(n - 1);
}

int is_odd(int n) {
    if (n == 0) return 0;
    else return is_even(n - 1);
}
</code></pre>
<p><strong>MLIR/FunLang에서는 불필요:</strong></p>
<pre><code class="language-mlir">// 정의 순서 무관 - 둘 다 작동
module {
  func.func @is_even(%n: i32) -&gt; i1 { ... func.call @is_odd ... }
  func.func @is_odd(%n: i32) -&gt; i1 { ... func.call @is_even ... }
}
</code></pre>
<h3 id="컴파일-크로스-참조-처리"><a class="header" href="#컴파일-크로스-참조-처리">컴파일: 크로스 참조 처리</a></h3>
<p><strong>상호 재귀 함수 컴파일:</strong></p>
<pre><code class="language-fsharp">let compileProgram (builder: OpBuilder) (moduleDef: ModuleOp) (Program(funcs, mainExpr)) =
    // 1. 모든 함수 정의를 모듈에 추가
    funcs |&gt; List.iter (compileFuncDef builder moduleDef)

    // 2. Main 표현식 컴파일
    let mainValue = compileExpr builder Map.empty mainExpr
    ...
</code></pre>
<p><strong>핵심 아이디어:</strong></p>
<ol>
<li><strong>모든 함수를 먼저 컴파일:</strong> 모듈에 <code>func.func</code> 연산 추가</li>
<li><strong>심볼 등록 자동:</strong> MLIR이 각 함수를 심볼 테이블에 등록</li>
<li><strong>본체 컴파일 시 심볼 참조:</strong> <code>func.call @is_odd</code> → 심볼 테이블에서 찾기</li>
</ol>
<p><strong>두 가지 접근법:</strong></p>
<p><strong>접근법 1: 순차 컴파일 (FunLang 사용)</strong></p>
<pre><code class="language-fsharp">// 함수를 하나씩 컴파일
funcs |&gt; List.iter (fun funcDef -&gt;
    compileFuncDef builder moduleDef funcDef
)
</code></pre>
<ul>
<li><code>is_even</code> 컴파일 시 본체에서 <code>func.call @is_odd</code> 생성</li>
<li><code>@is_odd</code> 심볼이 아직 등록 안 됨 → <strong>문제 없음!</strong></li>
<li>MLIR verifier는 <strong>모든 함수가 컴파일된 후</strong> 실행됨</li>
<li>Verifier가 실행될 때는 <code>@is_odd</code>도 이미 등록되어 있음</li>
</ul>
<p><strong>접근법 2: 스텁 먼저 생성 (대안)</strong></p>
<pre><code class="language-fsharp">// 1단계: 모든 함수 헤더만 생성 (body 없음)
funcs |&gt; List.iter (fun (FunDef(name, params, _)) -&gt;
    let funcOp = builder.CreateFuncStub(name, paramTypes, returnType)
    moduleDef.AddFunction(funcOp)
)

// 2단계: 모든 함수 본체 채우기
funcs |&gt; List.iter (fun (FunDef(name, params, body)) -&gt;
    let funcOp = moduleDef.GetFunction(name)
    compileFuncBody builder funcOp params body
)
</code></pre>
<ul>
<li>더 명시적이지만 복잡함</li>
<li>FunLang은 접근법 1 사용 (더 간단)</li>
</ul>
<p><strong>왜 작동하는가?</strong></p>
<p>MLIR의 <strong>lazy verification</strong>:</p>
<ul>
<li>함수를 컴파일하는 동안 심볼 참조는 검증하지 않음</li>
<li>모듈이 완성된 후 <code>mlirOperationVerify()</code>를 호출</li>
<li>그때 모든 심볼 참조 확인</li>
</ul>
<h3 id="완전한-mlir-ir-출력-1"><a class="header" href="#완전한-mlir-ir-출력-1">완전한 MLIR IR 출력</a></h3>
<pre><code class="language-mlir">module {
  // is_even 함수
  func.func @is_even(%arg0: i32) -&gt; i1 {
    %c0 = arith.constant 0 : i32
    %is_zero = arith.cmpi eq, %arg0, %c0 : i32

    %result = scf.if %is_zero -&gt; (i1) {
      // then: return true
      %true = arith.constant 1 : i1
      scf.yield %true : i1
    } else {
      // else: return is_odd(n - 1)
      %c1 = arith.constant 1 : i32
      %n_minus_1 = arith.subi %arg0, %c1 : i32

      // is_odd 호출 (상호 재귀!)
      %odd_result = func.call @is_odd(%n_minus_1) : (i32) -&gt; i1

      scf.yield %odd_result : i1
    }

    func.return %result : i1
  }

  // is_odd 함수
  func.func @is_odd(%arg0: i32) -&gt; i1 {
    %c0 = arith.constant 0 : i32
    %is_zero = arith.cmpi eq, %arg0, %c0 : i32

    %result = scf.if %is_zero -&gt; (i1) {
      // then: return false
      %false = arith.constant 0 : i1
      scf.yield %false : i1
    } else {
      // else: return is_even(n - 1)
      %c1 = arith.constant 1 : i32
      %n_minus_1 = arith.subi %arg0, %c1 : i32

      // is_even 호출 (상호 재귀!)
      %even_result = func.call @is_even(%n_minus_1) : (i32) -&gt; i1

      scf.yield %even_result : i1
    }

    func.return %result : i1
  }

  // Main 함수
  func.func @funlang_main() -&gt; i32 {
    %c4 = arith.constant 4 : i32
    %result_i1 = func.call @is_even(%c4) : (i32) -&gt; i1

    // i1 → i32 확장 (main 반환용)
    %result_i32 = arith.extui %result_i1 : i1 to i32

    func.return %result_i32 : i32
  }
}
</code></pre>
<p><strong>주목할 점:</strong></p>
<ul>
<li><code>@is_even</code>이 <code>func.call @is_odd</code> 사용</li>
<li><code>@is_odd</code>가 <code>func.call @is_even</code> 사용</li>
<li><strong>순환 참조(cyclic call graph)</strong> 형성</li>
<li>MLIR verifier가 허용 (심볼이 모두 존재)</li>
</ul>
<h3 id="실행-추적"><a class="header" href="#실행-추적">실행 추적</a></h3>
<p><strong>is_even(4) 호출:</strong></p>
<pre><code>is_even(4)
  ├─ 4 = 0? → false
  ├─ else 블록: is_odd(4 - 1) = is_odd(3)
  │  ├─ 3 = 0? → false
  │  ├─ else 블록: is_even(3 - 1) = is_even(2)
  │  │  ├─ 2 = 0? → false
  │  │  ├─ else 블록: is_odd(2 - 1) = is_odd(1)
  │  │  │  ├─ 1 = 0? → false
  │  │  │  ├─ else 블록: is_even(1 - 1) = is_even(0)
  │  │  │  │  ├─ 0 = 0? → true
  │  │  │  │  └─ then 블록: return true
  │  │  │  ├─ odd_result = true
  │  │  │  └─ return true
  │  │  ├─ even_result = true
  │  │  └─ return true
  │  ├─ odd_result = true
  │  └─ return true
  ├─ even_result = true
  └─ return true (i1), 확장하여 1 (i32) 반환
</code></pre>
<p><strong>호출 스택 깊이:</strong> 5 (is_even → is_odd → is_even → is_odd → is_even)</p>
<p><strong>상호 재귀의 스택 프레임:</strong></p>
<pre><code>┌──────────────────────┐
│ is_even(0)           │ ← 최대 깊이 (기저 사례)
├──────────────────────┤
│ is_odd(1)            │
├──────────────────────┤
│ is_even(2)           │
├──────────────────────┤
│ is_odd(3)            │
├──────────────────────┤
│ is_even(4)           │ ← 최초 호출
├──────────────────────┤
│ funlang_main         │
└──────────────────────┘
</code></pre>
<p>스택 프레임이 번갈아가며 생성된다: is_even → is_odd → is_even → …</p>
<h3 id="verifier의-심볼-검증"><a class="header" href="#verifier의-심볼-검증">Verifier의 심볼 검증</a></h3>
<p><strong>MLIR verifier는 모듈 완성 후 실행:</strong></p>
<pre><code class="language-fsharp">// 컴파일러 코드
let compileProgram moduleDef funcs mainExpr =
    // 1. 모든 함수 컴파일
    funcs |&gt; List.iter (compileFuncDef builder moduleDef)

    // 2. Main 컴파일
    let mainFunc = compileMain builder mainExpr
    moduleDef.AddFunction(mainFunc)

    // 3. Verify (모든 함수 추가 후)
    if not (mlirOperationVerify(moduleDef.GetOperation())) then
        failwith "Module verification failed"
</code></pre>
<p><strong>Verification 과정:</strong></p>
<ol>
<li><strong>심볼 수집:</strong> 모듈의 모든 <code>func.func</code> 연산에서 심볼 추출 (<code>@is_even</code>, <code>@is_odd</code>)</li>
<li><strong>심볼 참조 확인:</strong> 각 <code>func.call</code> 연산의 callee 확인
<ul>
<li><code>func.call @is_odd</code> → <code>@is_odd</code> 심볼이 존재하는가? <strong>예</strong></li>
<li><code>func.call @is_even</code> → <code>@is_even</code> 심볼이 존재하는가? <strong>예</strong></li>
</ul>
</li>
<li><strong>타입 검증:</strong> 호출 타입과 함수 타입 일치 확인
<ul>
<li><code>@is_even: (i32) -&gt; i1</code></li>
<li><code>func.call @is_even(%n_minus_1) : (i32) -&gt; i1</code> → <strong>일치</strong></li>
</ul>
</li>
</ol>
<p><strong>실패 케이스 (존재하지 않는 함수 호출):</strong></p>
<pre><code class="language-mlir">func.func @foo(%n: i32) -&gt; i1 {
  %result = func.call @nonexistent(%n) : (i32) -&gt; i1
  //                    ↑ 모듈에 없음
  func.return %result : i1
}
</code></pre>
<p>Verifier 에러:</p>
<pre><code>error: 'func.call' op 'nonexistent' does not reference a valid function
</code></pre>
<p><strong>상호 재귀는 통과:</strong> 모든 심볼이 존재하므로 검증 성공.</p>
<h3 id="funlang-interpreter와의-차이"><a class="header" href="#funlang-interpreter와의-차이">FunLang Interpreter와의 차이</a></h3>
<p><strong>Interpreter에서 상호 재귀:</strong></p>
<pre><code class="language-fsharp">// FunLang interpreter (LangTutorial)
let rec eval env ast =
    match ast with
    | LetRec(funcs, body) -&gt;
        // 재귀 환경 생성: 모든 함수를 env에 추가
        let rec_env =
            funcs |&gt; List.fold (fun e (name, func) -&gt;
                e.Add(name, RecursiveClosure(func, rec_env))
            ) env
        eval rec_env body
</code></pre>
<p><strong>문제:</strong></p>
<ul>
<li>환경이 재귀적으로 정의됨 (<code>rec_env</code>가 자기 자신을 참조)</li>
<li>F#의 <code>let rec</code> 또는 명시적인 mutation 필요</li>
</ul>
<p><strong>Compiler는 더 간단:</strong></p>
<ul>
<li>모듈 심볼 테이블이 자연스럽게 flat namespace 제공</li>
<li>순환 참조를 허용</li>
<li>Lazy verification으로 정의 순서 무관</li>
</ul>
<h2 id="꼬리-재귀와-꼬리-호출-최적화"><a class="header" href="#꼬리-재귀와-꼬리-호출-최적화">꼬리 재귀와 꼬리 호출 최적화</a></h2>
<h3 id="꼬리-위치-tail-position"><a class="header" href="#꼬리-위치-tail-position">꼬리 위치 (Tail Position)</a></h3>
<p>**꼬리 위치(tail position)**는 함수에서 <strong>마지막으로 실행되는 표현식의 위치</strong>다.</p>
<pre><code class="language-fsharp">let rec factorial n =
    if n &lt;= 1 then
        1           // ← 꼬리 위치 (then 분기의 마지막)
    else
        n * factorial (n - 1)
        //  ↑ factorial 호출은 꼬리 위치가 아님!
        //    호출 후 곱셈이 남아있음
</code></pre>
<p><strong>꼬리 위치 판단:</strong></p>
<ul>
<li>then 분기의 <code>1</code>: <strong>꼬리 위치</strong> (분기의 마지막 값)</li>
<li><code>factorial (n - 1)</code> 호출: <strong>꼬리 위치 아님</strong> (호출 후 <code>n *</code> 곱셈이 실행됨)</li>
<li><code>n * factorial(...)</code> 전체: <strong>꼬리 위치</strong> (else 분기의 마지막 값)</li>
</ul>
<p><strong>일반 규칙:</strong></p>
<p>함수 본체에서:</p>
<ul>
<li><code>if</code> then/else 각 분기의 마지막 표현식: 꼬리 위치</li>
<li><code>let x = ... in &lt;expr&gt;</code>: <code>&lt;expr&gt;</code>이 꼬리 위치</li>
<li>함수의 최상위 표현식: 꼬리 위치</li>
</ul>
<p><strong>꼬리 호출(tail call):</strong> 꼬리 위치에 있는 함수 호출.</p>
<pre><code class="language-fsharp">let rec countdown n =
    if n &lt;= 0 then
        0           // ← 꼬리 위치, 값 (호출 아님)
    else
        countdown (n - 1)
        // ↑ 꼬리 위치에 있는 호출 → 꼬리 호출!
</code></pre>
<p><code>countdown (n - 1)</code>은 else 분기의 마지막이고, 호출 후 추가 작업이 없다. <strong>꼬리 호출</strong>이다.</p>
<h3 id="꼬리-호출-최적화-tail-call-optimization"><a class="header" href="#꼬리-호출-최적화-tail-call-optimization">꼬리 호출 최적화 (Tail Call Optimization)</a></h3>
<p>**꼬리 호출 최적화(TCO, Tail Call Optimization)**는 꼬리 호출을 **점프(jump)**로 변환하여 스택 프레임을 재사용하는 최적화다.</p>
<p><strong>일반 재귀 (TCO 없음):</strong></p>
<pre><code>factorial(5)
  ├─ 스택 프레임 1 생성
  ├─ factorial(4) 호출
  │  ├─ 스택 프레임 2 생성
  │  ├─ factorial(3) 호출
  │  │  └─ ... (스택 누적)
  │  ├─ 반환 후 n * result 계산 ← 추가 작업
  │  └─ 스택 프레임 2 해제
  ├─ 반환 후 n * result 계산
  └─ 스택 프레임 1 해제
</code></pre>
<p><strong>꼬리 재귀 (TCO 사용):</strong></p>
<pre><code>countdown(5)
  ├─ 스택 프레임 1 생성
  ├─ countdown(4) 호출 → 점프로 변환!
  │    (스택 프레임 1 재사용, n 값만 업데이트)
  ├─ countdown(3) 호출 → 점프
  ├─ countdown(2) 호출 → 점프
  ├─ countdown(1) 호출 → 점프
  ├─ countdown(0) 호출 → 점프
  └─ 기저 사례: return 0
     (스택 프레임 1 해제)
</code></pre>
<p><strong>핵심 차이:</strong></p>
<ul>
<li><strong>일반 재귀:</strong> 각 호출마다 스택 프레임 생성. 깊이 N → N개 프레임.</li>
<li><strong>꼬리 재귀 + TCO:</strong> 단일 스택 프레임 재사용. 깊이 N → 1개 프레임.</li>
</ul>
<p><strong>왜 가능한가?</strong></p>
<p>꼬리 호출은 “호출 후 돌아올 필요가 없다”:</p>
<ul>
<li>현재 함수는 호출 결과를 그대로 반환</li>
<li>현재 스택 프레임에 남은 작업이 없음</li>
<li>따라서 현재 프레임을 버리고, 새 프레임으로 점프할 수 있음</li>
</ul>
<h3 id="꼬리-재귀-변환-factorial"><a class="header" href="#꼬리-재귀-변환-factorial">꼬리 재귀 변환: Factorial</a></h3>
<p><strong>일반 재귀 factorial (non-tail):</strong></p>
<pre><code class="language-fsharp">let rec factorial n =
    if n &lt;= 1 then 1
    else n * factorial (n - 1)
         // ↑ 호출 후 곱셈 → 꼬리 호출 아님
</code></pre>
<p><strong>꼬리 재귀 factorial:</strong></p>
<pre><code class="language-fsharp">let rec factorial_tail n acc =
    if n &lt;= 1 then acc
    else factorial_tail (n - 1) (n * acc)
         // ↑ 호출이 마지막 → 꼬리 호출!
</code></pre>
<p><strong>차이점:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>측면</th><th>일반 재귀</th><th>꼬리 재귀</th></tr>
</thead>
<tbody>
<tr><td>Accumulator</td><td>없음</td><td><code>acc</code> 파라미터</td></tr>
<tr><td>곱셈 위치</td><td>호출 <strong>후</strong> (<code>n * result</code>)</td><td>호출 <strong>전</strong> (<code>n * acc</code>)</td></tr>
<tr><td>반환값</td><td>재귀 호출 결과를 변환</td><td>재귀 호출 결과 그대로</td></tr>
<tr><td>꼬리 호출</td><td>아님</td><td>맞음</td></tr>
</tbody>
</table>
</div>
<p><strong>Accumulator 패턴:</strong></p>
<p>꼬리 재귀는 <strong>accumulator</strong>를 사용하여 중간 결과를 전달한다:</p>
<pre><code>factorial_tail(5, 1)
  → factorial_tail(4, 5*1=5)
    → factorial_tail(3, 4*5=20)
      → factorial_tail(2, 3*20=60)
        → factorial_tail(1, 2*60=120)
          → return 120
</code></pre>
<p><strong>Wrapper 함수:</strong></p>
<p>사용자는 accumulator를 모르므로, wrapper 함수 제공:</p>
<pre><code class="language-fsharp">let factorial n =
    factorial_tail n 1
</code></pre>
<h3 id="mlirllvm에서-tco"><a class="header" href="#mlirllvm에서-tco">MLIR/LLVM에서 TCO</a></h3>
<p><strong>LLVM의 꼬리 호출 최적화:</strong></p>
<p>LLVM은 특정 조건에서 꼬리 호출을 최적화할 수 있다:</p>
<ol>
<li><strong>함수 속성 (function attribute):</strong> <code>"tailcc"</code> calling convention</li>
<li><strong>최적화 플래그:</strong> <code>-tailcallopt</code></li>
<li><strong>타겟 지원:</strong> 플랫폼이 TCO를 지원해야 함 (대부분의 x86-64, ARM은 지원)</li>
</ol>
<p><strong>MLIR IR에서 꼬리 호출 표시:</strong></p>
<p>MLIR <code>func</code> 다이얼렉트는 TCO를 명시적으로 표시하는 속성이 없다. 대신:</p>
<ul>
<li>LLVM dialect로 낮춘 후 <code>tail</code> 속성 추가</li>
<li>또는 LLVM 최적화 패스에 의존</li>
</ul>
<p><strong>Lowered LLVM IR (꼬리 호출 속성):</strong></p>
<pre><code class="language-llvm">define i32 @factorial_tail(i32 %n, i32 %acc) {
entry:
  %cmp = icmp sle i32 %n, 1
  br i1 %cmp, label %base, label %rec

base:
  ret i32 %acc

rec:
  %n_minus_1 = sub i32 %n, 1
  %new_acc = mul i32 %n, %acc
  ; tail 키워드 → TCO 힌트
  %result = tail call i32 @factorial_tail(i32 %n_minus_1, i32 %new_acc)
  ret i32 %result
}
</code></pre>
<p><strong><code>tail call</code>의 의미:</strong></p>
<ul>
<li>“이 호출은 꼬리 호출입니다”</li>
<li>LLVM 최적화 패스가 이를 점프로 변환 가능</li>
<li><code>-tailcallopt</code> 플래그와 함께 사용</li>
</ul>
<p><strong>FunLang Phase 3에서 TCO:</strong></p>
<p>Phase 3에서는 <strong>TCO를 보장하지 않는다</strong>:</p>
<ul>
<li>교육 목적: 재귀의 기본 개념 먼저 이해</li>
<li>LLVM이 자동으로 최적화할 <strong>수</strong> 있지만, 보장되지 않음</li>
<li>Phase 7 (최적화)에서 명시적 TCO 지원 추가 예정</li>
</ul>
<p><strong>현재 동작:</strong></p>
<pre><code class="language-fsharp">// FunLang 소스
let rec factorial_tail n acc =
    if n &lt;= 1 then acc
    else factorial_tail (n - 1) (n * acc)

// MLIR IR
func.func @factorial_tail(%arg0: i32, %arg1: i32) -&gt; i32 {
  // ... if 조건
  %result = scf.if %cmp -&gt; (i32) {
    scf.yield %arg1 : i32
  } else {
    %n_minus_1 = arith.subi %arg0, %c1 : i32
    %new_acc = arith.muli %arg0, %arg1 : i32
    %rec = func.call @factorial_tail(%n_minus_1, %new_acc) : (i32, i32) -&gt; i32
    // ↑ 일반 func.call (tail 속성 없음)
    scf.yield %rec : i32
  }
  func.return %result : i32
}
</code></pre>
<p><strong>LLVM이 최적화할 수 있음 (보장 안 됨):</strong></p>
<ul>
<li>LLVM <code>-O2</code> 또는 <code>-O3</code> 최적화 레벨</li>
<li>일부 경우 자동으로 TCO 적용</li>
<li>하지만 C calling convention에서는 보장되지 않음</li>
</ul>
<h3 id="tco-활성화-방법-preview"><a class="header" href="#tco-활성화-방법-preview">TCO 활성화 방법 (Preview)</a></h3>
<p><strong>Phase 7에서 다룰 내용 (Preview):</strong></p>
<ol>
<li><strong><code>tailcc</code> calling convention 사용:</strong></li>
</ol>
<pre><code class="language-llvm">define tailcc i32 @factorial_tail(i32 %n, i32 %acc) {
  ; tailcc = 꼬리 호출 최적화에 특화된 calling convention
  ...
  %result = tail call tailcc i32 @factorial_tail(i32 %n_minus_1, i32 %new_acc)
  ret i32 %result
}
</code></pre>
<ol start="2">
<li><strong>Compiler 플래그:</strong></li>
</ol>
<pre><code class="language-bash">llc -tailcallopt factorial.ll -o factorial.s
</code></pre>
<ol start="3">
<li><strong>함수 속성:</strong></li>
</ol>
<p>MLIR에서 LLVM dialect로 낮출 때 함수 속성 추가:</p>
<ul>
<li><code>llvm.func @factorial_tail ... attributes { tail = true }</code></li>
</ul>
<p><strong>현재 (Phase 3):</strong></p>
<ul>
<li>꼬리 재귀 패턴을 이해</li>
<li>accumulator 사용법 배우기</li>
<li>LLVM의 자동 최적화에 의존</li>
<li>Phase 7에서 명시적 제어 추가</li>
</ul>
<h2 id="코드-생성-업데이트"><a class="header" href="#코드-생성-업데이트">코드 생성 업데이트</a></h2>
<h3 id="compilefuncdef-재사용"><a class="header" href="#compilefuncdef-재사용">compileFuncDef 재사용</a></h3>
<p><strong>좋은 소식:</strong> 재귀 함수를 위한 특별한 코드 생성이 <strong>필요 없다</strong>.</p>
<p>Chapter 10의 <code>compileFuncDef</code>를 그대로 사용:</p>
<pre><code class="language-fsharp">let compileFuncDef (builder: OpBuilder) (moduleDef: ModuleOp) (FunDef(name, params, body)) =
    // 1. 함수 타입 생성
    let paramTypes = List.replicate params.Length builder.GetI32Type()
    let returnType = builder.GetI32Type()
    let funcType = builder.GetFunctionType(paramTypes, returnType)

    // 2. func.func 생성
    let funcOp = builder.CreateFuncOp(name, funcType)

    // 3. Entry block에서 파라미터 가져오기
    let entryBlock = funcOp.GetEntryBlock()
    builder.SetInsertionPointToEnd(entryBlock)

    let env =
        params
        |&gt; List.mapi (fun i paramName -&gt;
            let argValue = entryBlock.GetArgument(i)
            (paramName, argValue))
        |&gt; Map.ofList

    // 4. 본체 컴파일
    let bodyValue = compileExpr builder env body

    // 5. 반환
    builder.CreateFuncReturn(bodyValue)

    // 6. 모듈에 추가
    moduleDef.AddFunction(funcOp)
</code></pre>
<p><strong>재귀 호출은 자동으로 처리:</strong></p>
<p><code>compileExpr</code>의 <code>App</code> case:</p>
<pre><code class="language-fsharp">| App(funcName, args) -&gt;
    let argValues = args |&gt; List.map (compileExpr builder env)
    builder.CreateFuncCall(funcName, argValues)
</code></pre>
<ul>
<li><code>App("factorial", [Num 5])</code> → <code>func.call @factorial(%c5) : (i32) -&gt; i32</code></li>
<li><code>App("factorial", [BinOp(...)])</code> → <code>func.call @factorial(%n_minus_1) : (i32) -&gt; i32</code></li>
</ul>
<p><strong>자기 참조가 자연스럽게 작동:</strong></p>
<ul>
<li><code>@factorial</code> 심볼이 모듈에 이미 존재 (본체 컴파일 중이지만 함수 자체는 이미 추가됨)</li>
<li><code>CreateFuncCall</code>이 심볼 참조 생성</li>
<li>Verifier가 나중에 확인</li>
</ul>
<h3 id="상호-재귀-처리"><a class="header" href="#상호-재귀-처리">상호 재귀 처리</a></h3>
<p><strong>상호 재귀도 특별한 처리 불필요:</strong></p>
<pre><code class="language-fsharp">let compileProgram (builder: OpBuilder) (moduleDef: ModuleOp) (Program(funcs, mainExpr)) =
    // 모든 함수 컴파일
    funcs |&gt; List.iter (compileFuncDef builder moduleDef)

    // Main 표현식 컴파일
    // ...
</code></pre>
<p><strong>순서:</strong></p>
<ol>
<li>
<p><code>is_even</code> 컴파일:</p>
<ul>
<li><code>func.func @is_even</code> 생성, 모듈에 추가</li>
<li>본체에서 <code>func.call @is_odd</code> 생성 (아직 <code>@is_odd</code> 없음 - OK!)</li>
</ul>
</li>
<li>
<p><code>is_odd</code> 컴파일:</p>
<ul>
<li><code>func.func @is_odd</code> 생성, 모듈에 추가</li>
<li>본체에서 <code>func.call @is_even</code> 생성 (<code>@is_even</code> 이미 존재)</li>
</ul>
</li>
<li>
<p>Verification:</p>
<ul>
<li><code>@is_even</code>의 <code>func.call @is_odd</code> → <code>@is_odd</code> 존재 확인 ✓</li>
<li><code>@is_odd</code>의 <code>func.call @is_even</code> → <code>@is_even</code> 존재 확인 ✓</li>
</ul>
</li>
</ol>
<p><strong>핵심:</strong> MLIR의 lazy verification 덕분에 순서 무관.</p>
<h3 id="compileprogram-전체-구조"><a class="header" href="#compileprogram-전체-구조">compileProgram 전체 구조</a></h3>
<p><strong>다중 함수 + Main 표현식:</strong></p>
<pre><code class="language-fsharp">let compileProgram (builder: OpBuilder) (moduleDef: ModuleOp) (Program(funcs, mainExpr)) =
    // 1. 모든 함수 정의 컴파일
    funcs |&gt; List.iter (fun funcDef -&gt;
        compileFuncDef builder moduleDef funcDef
    )

    // 2. Main 함수 생성
    let mainFuncType = builder.GetFunctionType([], builder.GetI32Type())
    let mainFunc = builder.CreateFuncOp("funlang_main", mainFuncType)

    let mainBlock = mainFunc.GetEntryBlock()
    builder.SetInsertionPointToEnd(mainBlock)

    // 3. Main 표현식 컴파일
    let mainValue = compileExpr builder Map.empty mainExpr

    // 4. Main 반환
    builder.CreateFuncReturn(mainValue)

    moduleDef.AddFunction(mainFunc)

    // 5. Verification
    if not (mlirOperationVerify(moduleDef.GetOperation())) then
        failwith "Module verification failed"

    moduleDef
</code></pre>
<p><strong>프로그램 구조:</strong></p>
<pre><code class="language-fsharp">Program([
    FunDef("factorial", ["n"], &lt;body&gt;),
    FunDef("fibonacci", ["n"], &lt;body&gt;),
    FunDef("is_even", ["n"], &lt;body&gt;),
    FunDef("is_odd", ["n"], &lt;body&gt;)
], App("factorial", [Num 5]))
</code></pre>
<p><strong>생성된 MLIR:</strong></p>
<pre><code class="language-mlir">module {
  func.func @factorial(%arg0: i32) -&gt; i32 { ... }
  func.func @fibonacci(%arg0: i32) -&gt; i32 { ... }
  func.func @is_even(%arg0: i32) -&gt; i1 { ... }
  func.func @is_odd(%arg0: i32) -&gt; i1 { ... }

  func.func @funlang_main() -&gt; i32 {
    %c5 = arith.constant 5 : i32
    %result = func.call @factorial(%c5) : (i32) -&gt; i32
    func.return %result : i32
  }
}
</code></pre>
<h2 id="완전한-예시-여러-재귀-함수"><a class="header" href="#완전한-예시-여러-재귀-함수">완전한 예시: 여러 재귀 함수</a></h2>
<h3 id="프로그램-소스"><a class="header" href="#프로그램-소스">프로그램 소스</a></h3>
<pre><code class="language-fsharp">// 함수 정의들
let rec factorial n =
    if n &lt;= 1 then 1
    else n * factorial (n - 1)

let rec fibonacci n =
    if n &lt;= 1 then n
    else fibonacci (n - 1) + fibonacci (n - 2)

let rec is_even n =
    if n = 0 then true
    else is_odd (n - 1)

let rec is_odd n =
    if n = 0 then false
    else is_even (n - 1)

// Main 표현식
let result_fact = factorial 5 in
let result_fib = fibonacci 6 in
let result_even = is_even 4 in
result_fact + result_fib + result_even
</code></pre>
<h3 id="ast-표현-간략"><a class="header" href="#ast-표현-간략">AST 표현 (간략)</a></h3>
<pre><code class="language-fsharp">Program([
    FunDef("factorial", ["n"], &lt;factorial_body&gt;),
    FunDef("fibonacci", ["n"], &lt;fibonacci_body&gt;),
    FunDef("is_even", ["n"], &lt;is_even_body&gt;),
    FunDef("is_odd", ["n"], &lt;is_odd_body&gt;)
],
Let("result_fact", App("factorial", [Num 5]),
Let("result_fib", App("fibonacci", [Num 6]),
Let("result_even", App("is_even", [Num 4]),
BinOp(
    BinOp(Var "result_fact", Add, Var "result_fib"),
    Add,
    Var "result_even"
)))))
</code></pre>
<h3 id="생성된-mlir-ir-전체"><a class="header" href="#생성된-mlir-ir-전체">생성된 MLIR IR (전체)</a></h3>
<pre><code class="language-mlir">module {
  // factorial 함수
  func.func @factorial(%arg0: i32) -&gt; i32 {
    %c1 = arith.constant 1 : i32
    %cmp = arith.cmpi sle, %arg0, %c1 : i32
    %result = scf.if %cmp -&gt; (i32) {
      scf.yield %c1 : i32
    } else {
      %n_minus_1 = arith.subi %arg0, %c1 : i32
      %rec = func.call @factorial(%n_minus_1) : (i32) -&gt; i32
      %product = arith.muli %arg0, %rec : i32
      scf.yield %product : i32
    }
    func.return %result : i32
  }

  // fibonacci 함수
  func.func @fibonacci(%arg0: i32) -&gt; i32 {
    %c1 = arith.constant 1 : i32
    %cmp = arith.cmpi sle, %arg0, %c1 : i32
    %result = scf.if %cmp -&gt; (i32) {
      scf.yield %arg0 : i32
    } else {
      %n_minus_1 = arith.subi %arg0, %c1 : i32
      %fib_n_1 = func.call @fibonacci(%n_minus_1) : (i32) -&gt; i32
      %c2 = arith.constant 2 : i32
      %n_minus_2 = arith.subi %arg0, %c2 : i32
      %fib_n_2 = func.call @fibonacci(%n_minus_2) : (i32) -&gt; i32
      %sum = arith.addi %fib_n_1, %fib_n_2 : i32
      scf.yield %sum : i32
    }
    func.return %result : i32
  }

  // is_even 함수
  func.func @is_even(%arg0: i32) -&gt; i1 {
    %c0 = arith.constant 0 : i32
    %is_zero = arith.cmpi eq, %arg0, %c0 : i32
    %result = scf.if %is_zero -&gt; (i1) {
      %true = arith.constant 1 : i1
      scf.yield %true : i1
    } else {
      %c1 = arith.constant 1 : i32
      %n_minus_1 = arith.subi %arg0, %c1 : i32
      %odd_result = func.call @is_odd(%n_minus_1) : (i32) -&gt; i1
      scf.yield %odd_result : i1
    }
    func.return %result : i1
  }

  // is_odd 함수
  func.func @is_odd(%arg0: i32) -&gt; i1 {
    %c0 = arith.constant 0 : i32
    %is_zero = arith.cmpi eq, %arg0, %c0 : i32
    %result = scf.if %is_zero -&gt; (i1) {
      %false = arith.constant 0 : i1
      scf.yield %false : i1
    } else {
      %c1 = arith.constant 1 : i32
      %n_minus_1 = arith.subi %arg0, %c1 : i32
      %even_result = func.call @is_even(%n_minus_1) : (i32) -&gt; i1
      scf.yield %even_result : i1
    }
    func.return %result : i1
  }

  // Main 함수
  func.func @funlang_main() -&gt; i32 {
    // result_fact = factorial(5)
    %c5 = arith.constant 5 : i32
    %result_fact = func.call @factorial(%c5) : (i32) -&gt; i32

    // result_fib = fibonacci(6)
    %c6 = arith.constant 6 : i32
    %result_fib = func.call @fibonacci(%c6) : (i32) -&gt; i32

    // result_even = is_even(4)
    %c4 = arith.constant 4 : i32
    %result_even_i1 = func.call @is_even(%c4) : (i32) -&gt; i1
    %result_even = arith.extui %result_even_i1 : i1 to i32

    // result_fact + result_fib + result_even
    %sum1 = arith.addi %result_fact, %result_fib : i32
    %sum2 = arith.addi %sum1, %result_even : i32

    func.return %sum2 : i32
  }
}
</code></pre>
<h3 id="컴파일-및-실행"><a class="header" href="#컴파일-및-실행">컴파일 및 실행</a></h3>
<pre><code class="language-bash"># 1. MLIR 파일 저장
echo "&lt;위 MLIR IR&gt;" &gt; recursion_example.mlir

# 2. Lowering passes 적용
mlir-opt \
  --convert-scf-to-cf \
  --convert-func-to-llvm \
  --convert-arith-to-llvm \
  recursion_example.mlir \
  -o lowered.mlir

# 3. LLVM IR로 변환
mlir-translate --mlir-to-llvmir lowered.mlir -o recursion.ll

# 4. Object file 생성
llc -filetype=obj recursion.ll -o recursion.o

# 5. Runtime과 링크
gcc -o recursion recursion.o runtime.o -lgc

# 6. 실행
./recursion
# 출력: 129
# (factorial(5)=120, fibonacci(6)=8, is_even(4)=1, 120+8+1=129)
</code></pre>
<h3 id="실행-결과-분석"><a class="header" href="#실행-결과-분석">실행 결과 분석</a></h3>
<p><strong>계산 과정:</strong></p>
<ol>
<li><code>factorial(5)</code> = 120</li>
<li><code>fibonacci(6)</code> = 8</li>
<li><code>is_even(4)</code> = true = 1 (i32로 확장)</li>
<li>120 + 8 + 1 = 129</li>
</ol>
<p><strong>스택 사용:</strong></p>
<ul>
<li><code>factorial(5)</code>: 최대 5개 스택 프레임</li>
<li><code>fibonacci(6)</code>: 최대 6개 스택 프레임 (하지만 호출 트리가 넓음)</li>
<li><code>is_even(4)</code>: 최대 5개 스택 프레임 (is_even/is_odd 번갈아가며)</li>
</ul>
<p><strong>총 호출 횟수:</strong></p>
<ul>
<li><code>factorial(5)</code>: 5번</li>
<li><code>fibonacci(6)</code>: 25번 (지수 복잡도!)</li>
<li><code>is_even(4)</code> + <code>is_odd</code>: 5번</li>
</ul>
<h2 id="성능-고려사항"><a class="header" href="#성능-고려사항">성능 고려사항</a></h2>
<h3 id="재귀-vs-반복-성능"><a class="header" href="#재귀-vs-반복-성능">재귀 vs 반복 성능</a></h3>
<p><strong>재귀의 오버헤드:</strong></p>
<ol>
<li>
<p><strong>함수 호출 비용:</strong></p>
<ul>
<li>스택 프레임 생성/소멸</li>
<li>레지스터 저장/복원</li>
<li>점프 instruction (call/ret)</li>
</ul>
</li>
<li>
<p><strong>스택 메모리 사용:</strong></p>
<ul>
<li>깊이 N → N개 스택 프레임</li>
<li>각 프레임 ~64-128 bytes</li>
<li>캐시 미스 가능성</li>
</ul>
</li>
<li>
<p><strong>분기 예측:</strong></p>
<ul>
<li>재귀 호출은 간접 분기</li>
<li>CPU 분기 예측기가 학습하기 어려움</li>
</ul>
</li>
</ol>
<p><strong>반복(Loop)의 이점:</strong></p>
<ol>
<li>
<p><strong>함수 호출 없음:</strong></p>
<ul>
<li>단일 스택 프레임</li>
<li>레지스터 할당 효율적</li>
</ul>
</li>
<li>
<p><strong>명령어 수 감소:</strong></p>
<ul>
<li>직접 점프 (conditional branch)</li>
<li>예측 가능한 패턴</li>
</ul>
</li>
<li>
<p><strong>메모리 효율:</strong></p>
<ul>
<li>스택 사용 최소</li>
</ul>
</li>
</ol>
<p><strong>언제 재귀가 괜찮은가?</strong></p>
<ol>
<li>
<p><strong>얕은 재귀 (shallow recursion):</strong></p>
<ul>
<li>깊이 &lt; 100: 성능 차이 미미</li>
<li>예: 균형 트리 탐색 (깊이 ~log N)</li>
</ul>
</li>
<li>
<p><strong>꼬리 재귀 + TCO:</strong></p>
<ul>
<li>컴파일러가 loop으로 변환</li>
<li>성능이 반복과 동일</li>
</ul>
</li>
<li>
<p><strong>알고리즘이 본질적으로 재귀적:</strong></p>
<ul>
<li>트리 순회, 퀵소트, 병합정렬</li>
<li>재귀로 작성하는 것이 자연스럽고 명확</li>
</ul>
</li>
</ol>
<p><strong>언제 재귀를 피해야 하는가?</strong></p>
<ol>
<li>
<p><strong>깊은 재귀 (deep recursion):</strong></p>
<ul>
<li>깊이 &gt; 10,000: 스택 오버플로우 위험</li>
<li>예: naive fibonacci</li>
</ul>
</li>
<li>
<p><strong>중복 계산:</strong></p>
<ul>
<li>Fibonacci 같은 지수 복잡도</li>
<li>Memoization 또는 DP로 해결</li>
</ul>
</li>
<li>
<p><strong>성능이 중요한 경우:</strong></p>
<ul>
<li>내부 루프 (hot path)</li>
<li>반복으로 작성 또는 TCO 보장</li>
</ul>
</li>
</ol>
<h3 id="스택-프레임-오버헤드"><a class="header" href="#스택-프레임-오버헤드">스택 프레임 오버헤드</a></h3>
<p><strong>스택 프레임 구조 (x86-64):</strong></p>
<pre><code>┌──────────────────────┐
│ Return address       │ 8 bytes
├──────────────────────┤
│ Saved rbp (frame ptr)│ 8 bytes
├──────────────────────┤
│ Local variables      │ Variable
├──────────────────────┤
│ Saved registers      │ Variable (callee-saved)
├──────────────────────┤
│ Padding (alignment)  │ 0-15 bytes (16-byte align)
└──────────────────────┘
</code></pre>
<p><strong>최소 크기:</strong> ~16 bytes (return address + rbp)
<strong>일반적 크기:</strong> 64-128 bytes (지역 변수, 레지스터 저장 포함)</p>
<p><strong>호출 비용:</strong></p>
<ul>
<li><code>call</code> instruction: ~1-2 CPU cycles (분기 예측 성공 시)</li>
<li>스택 프레임 setup: ~5-10 instructions (push rbp, mov, sub)</li>
<li>스택 프레임 teardown: ~5-10 instructions (mov, pop, ret)</li>
<li><strong>총:</strong> ~20-30 instructions per call</li>
</ul>
<p><strong>비교 (factorial 1000):</strong></p>
<ul>
<li><strong>재귀:</strong> 1,000 함수 호출 × 30 instructions = 30,000 instructions</li>
<li><strong>반복:</strong> ~5 instructions per iteration × 1,000 = 5,000 instructions</li>
</ul>
<p><strong>6배 차이!</strong> 하지만 절대 시간은 여전히 작음 (~수 마이크로초).</p>
<h3 id="llvm-최적화-기회"><a class="header" href="#llvm-최적화-기회">LLVM 최적화 기회</a></h3>
<p><strong>LLVM이 재귀에 적용하는 최적화:</strong></p>
<ol>
<li>
<p><strong>Tail Call Elimination (TCO):</strong></p>
<ul>
<li>꼬리 재귀 → loop 변환</li>
<li>스택 사용 O(1)</li>
</ul>
</li>
<li>
<p><strong>Inlining:</strong></p>
<ul>
<li>작은 재귀 함수를 호출 사이트에 인라인</li>
<li>함수 호출 오버헤드 제거</li>
</ul>
</li>
<li>
<p><strong>Constant Folding:</strong></p>
<ul>
<li>컴파일 타임에 계산 가능한 재귀 (예: <code>factorial(5)</code>) → 상수 120</li>
</ul>
</li>
<li>
<p><strong>Loop Optimization:</strong></p>
<ul>
<li>재귀를 loop으로 변환 후 loop unrolling, vectorization 적용</li>
</ul>
</li>
</ol>
<p><strong>예시 (LLVM -O3):</strong></p>
<pre><code class="language-fsharp">// 소스
let rec factorial n =
    if n &lt;= 1 then 1
    else n * factorial (n - 1)

let result = factorial 5
</code></pre>
<p><strong>LLVM -O3 최적화 후:</strong></p>
<pre><code class="language-llvm">define i32 @funlang_main() {
  ret i32 120  ; 컴파일 타임에 계산됨!
}
</code></pre>
<p><strong>변수 입력 (factorial n, n이 런타임 값):</strong></p>
<p>LLVM은 재귀를 그대로 유지하지만, 레지스터 할당과 분기 예측을 최적화.</p>
<h3 id="phase-7-최적화-preview"><a class="header" href="#phase-7-최적화-preview">Phase 7 최적화 Preview</a></h3>
<p><strong>Phase 7에서 다룰 내용:</strong></p>
<ol>
<li>
<p><strong>명시적 TCO 지원:</strong></p>
<ul>
<li><code>tailcc</code> calling convention</li>
<li>꼬리 재귀 자동 감지 및 변환</li>
</ul>
</li>
<li>
<p><strong>Inlining 제어:</strong></p>
<ul>
<li>작은 함수 자동 인라인</li>
<li><code>inline</code> 힌트</li>
</ul>
</li>
<li>
<p><strong>Memoization:</strong></p>
<ul>
<li>함수 결과 캐싱 (fibonacci 최적화)</li>
</ul>
</li>
<li>
<p><strong>Loop 변환:</strong></p>
<ul>
<li>재귀 → 반복 자동 변환 (특정 패턴)</li>
</ul>
</li>
</ol>
<p><strong>현재 (Phase 3):</strong></p>
<ul>
<li>재귀의 기본 개념과 제약 이해</li>
<li>성능 트레이드오프 인지</li>
<li>LLVM의 기본 최적화에 의존</li>
</ul>
<h2 id="일반적인-오류"><a class="header" href="#일반적인-오류">일반적인 오류</a></h2>
<h3 id="error-1-무한-재귀-기저-사례-누락"><a class="header" href="#error-1-무한-재귀-기저-사례-누락">Error 1: 무한 재귀 (기저 사례 누락)</a></h3>
<p><strong>문제:</strong></p>
<pre><code class="language-fsharp">let rec infinite_loop n =
    infinite_loop (n - 1)
    // 기저 사례가 없음!
</code></pre>
<p><strong>증상:</strong></p>
<pre><code class="language-bash">./program
Segmentation fault (core dumped)
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>재귀 종료 조건이 없음</li>
<li>스택이 무한히 성장</li>
<li>스택 오버플로우</li>
</ul>
<p><strong>해결:</strong></p>
<pre><code class="language-fsharp">let rec countdown n =
    if n &lt;= 0 then 0  // ← 기저 사례 추가
    else countdown (n - 1)
</code></pre>
<p><strong>디버깅 팁:</strong></p>
<ul>
<li>모든 재귀 함수에 기저 사례가 있는지 확인</li>
<li>“언제 재귀가 멈추는가?” 질문</li>
</ul>
<h3 id="error-2-스택-오버플로우-깊은-재귀"><a class="header" href="#error-2-스택-오버플로우-깊은-재귀">Error 2: 스택 오버플로우 (깊은 재귀)</a></h3>
<p><strong>문제:</strong></p>
<pre><code class="language-fsharp">let rec sum_to n =
    if n &lt;= 0 then 0
    else n + sum_to (n - 1)

let result = sum_to 100000  // 깊이 100,000!
</code></pre>
<p><strong>증상:</strong></p>
<pre><code class="language-bash">./program
Segmentation fault (core dumped)
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>재귀 깊이 &gt; 스택 크기</li>
<li>100,000 프레임 × 64 bytes = 6.4 MB &gt; 일부 플랫폼 한계</li>
</ul>
<p><strong>해결:</strong></p>
<ol>
<li><strong>꼬리 재귀로 변환:</strong></li>
</ol>
<pre><code class="language-fsharp">let rec sum_to_tail n acc =
    if n &lt;= 0 then acc
    else sum_to_tail (n - 1) (n + acc)

let sum_to n = sum_to_tail n 0
</code></pre>
<ol start="2">
<li><strong>입력 크기 제한:</strong></li>
</ol>
<pre><code class="language-fsharp">if n &gt; 10000 then
    failwith "Input too large"
else
    sum_to n
</code></pre>
<ol start="3">
<li><strong>반복으로 변환:</strong></li>
</ol>
<pre><code class="language-fsharp">// FunLang은 loop 없지만, LLVM이 TCO로 변환 가능
</code></pre>
<h3 id="error-3-심볼을-찾을-수-없음-타이포"><a class="header" href="#error-3-심볼을-찾을-수-없음-타이포">Error 3: 심볼을 찾을 수 없음 (타이포)</a></h3>
<p><strong>문제:</strong></p>
<pre><code class="language-fsharp">let rec factorial n =
    if n &lt;= 1 then 1
    else n * factorail (n - 1)  // typo: factorail
</code></pre>
<p><strong>증상 (MLIR verification):</strong></p>
<pre><code>error: 'func.call' op 'factorail' does not reference a valid function
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>함수 이름 오타</li>
<li>심볼 <code>@factorail</code>이 모듈에 없음</li>
</ul>
<p><strong>해결:</strong></p>
<ul>
<li>함수 이름 철자 확인</li>
<li>IDE의 자동완성 사용</li>
</ul>
<h3 id="error-4-인자-순서-오류-상호-재귀"><a class="header" href="#error-4-인자-순서-오류-상호-재귀">Error 4: 인자 순서 오류 (상호 재귀)</a></h3>
<p><strong>문제:</strong></p>
<pre><code class="language-fsharp">let rec is_even n =
    if n = 0 then true
    else is_odd n  // ← (n - 1) 빠뜨림!

let rec is_odd n =
    if n = 0 then false
    else is_even n  // ← 똑같은 오류
</code></pre>
<p><strong>증상:</strong></p>
<pre><code class="language-bash">./program
Segmentation fault (core dumped)
</code></pre>
<p><strong>원인:</strong></p>
<ul>
<li>무한 재귀: is_even(4) → is_odd(4) → is_even(4) → …</li>
<li>인자가 감소하지 않음</li>
</ul>
<p><strong>해결:</strong></p>
<pre><code class="language-fsharp">let rec is_even n =
    if n = 0 then true
    else is_odd (n - 1)  // ← (n - 1) 추가

let rec is_odd n =
    if n = 0 then false
    else is_even (n - 1)
</code></pre>
<h3 id="error-5-꼬리-위치가-아닌-곳에서-tco-기대"><a class="header" href="#error-5-꼬리-위치가-아닌-곳에서-tco-기대">Error 5: 꼬리 위치가 아닌 곳에서 TCO 기대</a></h3>
<p><strong>문제:</strong></p>
<pre><code class="language-fsharp">let rec factorial n =
    if n &lt;= 1 then 1
    else n * factorial (n - 1)
    //       ↑ 꼬리 위치 아님 (곱셈 후 실행)

// TCO가 적용될 것으로 기대하지만, 실제로는 안 됨
</code></pre>
<p><strong>증상:</strong></p>
<ul>
<li>깊은 재귀에서 스택 오버플로우</li>
<li>TCO가 적용되지 않음</li>
</ul>
<p><strong>원인:</strong></p>
<ul>
<li>재귀 호출 후 추가 작업 (<code>n *</code>)</li>
<li>꼬리 호출이 아님</li>
</ul>
<p><strong>해결:</strong></p>
<pre><code class="language-fsharp">// accumulator 패턴으로 변환
let rec factorial_tail n acc =
    if n &lt;= 1 then acc
    else factorial_tail (n - 1) (n * acc)
    //   ↑ 꼬리 위치! (호출이 마지막)
</code></pre>
<h3 id="디버깅-팁"><a class="header" href="#디버깅-팁">디버깅 팁</a></h3>
<ol>
<li><strong>Print 디버깅:</strong></li>
</ol>
<pre><code class="language-fsharp">let rec factorial n =
    // 디버깅: 함수 호출 출력
    print_int n;
    if n &lt;= 1 then 1
    else n * factorial (n - 1)
</code></pre>
<ol start="2">
<li><strong>기저 사례 먼저 확인:</strong></li>
</ol>
<p>재귀 함수를 작성할 때:</p>
<ul>
<li>먼저 기저 사례 작성</li>
<li>그 다음 재귀 사례 작성</li>
</ul>
<ol start="3">
<li><strong>작은 입력으로 테스트:</strong></li>
</ol>
<pre><code class="language-fsharp">// factorial 100000 전에 factorial 5 먼저 테스트
</code></pre>
<ol start="4">
<li><strong>스택 크기 늘리기 (임시 해결):</strong></li>
</ol>
<pre><code class="language-bash"># Linux에서 스택 크기 늘리기
ulimit -s 16384  # 16 MB
./program
</code></pre>
<ol start="5">
<li><strong>MLIR IR 검증:</strong></li>
</ol>
<pre><code class="language-bash">mlir-opt --verify-diagnostics program.mlir
</code></pre>
<h2 id="요약-및-phase-3-완료"><a class="header" href="#요약-및-phase-3-완료">요약 및 Phase 3 완료</a></h2>
<h3 id="chapter-11-요약"><a class="header" href="#chapter-11-요약">Chapter 11 요약</a></h3>
<p><strong>배운 내용:</strong></p>
<ol>
<li>
<p><strong>재귀의 기본:</strong></p>
<ul>
<li>자기 자신을 호출하는 함수</li>
<li>기저 사례 + 재귀 사례</li>
<li>예시: factorial, fibonacci</li>
</ul>
</li>
<li>
<p><strong>MLIR에서 재귀:</strong></p>
<ul>
<li>모듈 레벨 심볼 테이블</li>
<li>자기 참조 (<code>func.call @factorial</code> inside <code>@factorial</code>)</li>
<li>심볼 확인은 컴파일 타임, 호출은 런타임</li>
</ul>
</li>
<li>
<p><strong>상호 재귀:</strong></p>
<ul>
<li>두 함수가 서로 호출 (is_even, is_odd)</li>
<li>Forward declaration 불필요</li>
<li>Flat symbol namespace 덕분에 자연스럽게 작동</li>
</ul>
</li>
<li>
<p><strong>스택 프레임:</strong></p>
<ul>
<li>각 재귀 호출마다 스택 프레임 생성</li>
<li>깊이 N → N개 프레임</li>
<li>스택 크기 제한 (8 MB Linux, 1 MB Windows)</li>
</ul>
</li>
<li>
<p><strong>꼬리 호출 최적화:</strong></p>
<ul>
<li>꼬리 위치 = 함수의 마지막 표현식</li>
<li>꼬리 호출 = 꼬리 위치의 함수 호출</li>
<li>TCO = 꼬리 호출을 점프로 변환, 스택 재사용</li>
<li>Accumulator 패턴으로 꼬리 재귀 변환</li>
</ul>
</li>
<li>
<p><strong>성능:</strong></p>
<ul>
<li>재귀는 오버헤드 있음 (함수 호출, 스택)</li>
<li>얕은 재귀는 괜찮음</li>
<li>깊은 재귀는 TCO 필요</li>
<li>LLVM 최적화 활용</li>
</ul>
</li>
<li>
<p><strong>일반적인 오류:</strong></p>
<ul>
<li>무한 재귀 (기저 사례 누락)</li>
<li>스택 오버플로우 (깊은 재귀)</li>
<li>타이포 (심볼 참조 실패)</li>
<li>인자 오류 (상호 재귀)</li>
<li>꼬리 위치 오해</li>
</ul>
</li>
</ol>
<h3 id="phase-3-완료"><a class="header" href="#phase-3-완료">Phase 3 완료!</a></h3>
<p><strong>Phase 3 목표:</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""> 최상위 명명된 함수 (Chapter 10)</li>
<li><input disabled="" type="checkbox" checked=""> 함수 파라미터와 호출 (Chapter 10)</li>
<li><input disabled="" type="checkbox" checked=""> 재귀 함수 (Chapter 11)</li>
<li><input disabled="" type="checkbox" checked=""> 상호 재귀 (Chapter 11)</li>
<li><input disabled="" type="checkbox" checked=""> 스택 프레임 관리 (Chapter 11)</li>
<li><input disabled="" type="checkbox" checked=""> 꼬리 호출 최적화 개념 (Chapter 11)</li>
</ul>
<p><strong>Phase 3에서 구축한 것:</strong></p>
<ol>
<li>
<p><strong>func 다이얼렉트 통합:</strong></p>
<ul>
<li><code>func.func</code>, <code>func.call</code>, <code>func.return</code> 연산</li>
<li>P/Invoke 바인딩 및 OpBuilder 메서드</li>
</ul>
</li>
<li>
<p><strong>함수 컴파일 인프라:</strong></p>
<ul>
<li><code>compileFuncDef</code>: AST → func.func</li>
<li><code>compileProgram</code>: 다중 함수 + main</li>
<li>환경 관리 (파라미터를 block arguments로)</li>
</ul>
</li>
<li>
<p><strong>재귀 지원:</strong></p>
<ul>
<li>자기 참조 (심볼 테이블)</li>
<li>상호 재귀 (lazy verification)</li>
<li>스택 기반 실행 모델</li>
</ul>
</li>
<li>
<p><strong>Calling convention:</strong></p>
<ul>
<li>C calling convention (System V ABI)</li>
<li>LLVM의 자동 프롤로그/에필로그 생성</li>
</ul>
</li>
</ol>
<p><strong>Phase 3에서 제외된 것 (Phase 4로 연기):</strong></p>
<ul>
<li><strong>클로저:</strong> 환경을 캡처하는 함수</li>
<li><strong>고차 함수:</strong> 함수를 인자로 받거나 반환</li>
<li><strong>익명 함수:</strong> Lambda 표현식</li>
<li><strong>힙 할당:</strong> 클로저 환경 (GC_malloc 사용)</li>
</ul>
<h3 id="phase-4-preview"><a class="header" href="#phase-4-preview">Phase 4 Preview</a></h3>
<p><strong>Phase 4: 클로저와 고차 함수</strong></p>
<p><strong>목표:</strong></p>
<ol>
<li>
<p><strong>Lambda 표현식:</strong></p>
<pre><code class="language-fsharp">let add_n n = fun x -&gt; x + n
</code></pre>
</li>
<li>
<p><strong>환경 캡처:</strong></p>
<pre><code class="language-fsharp">let make_counter () =
    let count = ref 0 in
    fun () -&gt; (count := !count + 1; !count)
</code></pre>
</li>
<li>
<p><strong>고차 함수:</strong></p>
<pre><code class="language-fsharp">let map f list = ...
let result = map (fun x -&gt; x * 2) [1; 2; 3]
</code></pre>
</li>
<li>
<p><strong>클로저 변환:</strong></p>
<ul>
<li>자유 변수 분석</li>
<li>환경을 힙에 할당 (GC_malloc)</li>
<li>클로저 = (function pointer, environment pointer)</li>
</ul>
</li>
<li>
<p><strong>Heap 사용:</strong></p>
<ul>
<li>Chapter 9 (Boehm GC) 활성화</li>
<li>memref 다이얼렉트 (alloc, load, store)</li>
</ul>
</li>
</ol>
<p><strong>연결:</strong></p>
<ul>
<li>Phase 3: 스택 기반 함수 (파라미터만 사용)</li>
<li>Phase 4: 힙 기반 클로저 (파라미터 + 캡처된 환경)</li>
</ul>
<h3 id="다음-단계"><a class="header" href="#다음-단계">다음 단계</a></h3>
<p><strong>완성된 컴파일러 능력:</strong></p>
<p>Phase 3 완료 후 FunLang 컴파일러는 다음을 지원한다:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""> 산술 및 비교 연산 (Chapter 06)</li>
<li><input disabled="" type="checkbox" checked=""> Let 바인딩과 변수 (Chapter 07)</li>
<li><input disabled="" type="checkbox" checked=""> If/then/else 제어 흐름 (Chapter 08)</li>
<li><input disabled="" type="checkbox" checked=""> 메모리 관리 (Boehm GC 통합, Chapter 09)</li>
<li><input disabled="" type="checkbox" checked=""> 함수 정의 및 호출 (Chapter 10)</li>
<li><input disabled="" type="checkbox" checked=""> 재귀 및 상호 재귀 (Chapter 11)</li>
</ul>
<p><strong>아직 지원하지 않는 것:</strong></p>
<ul>
<li><input disabled="" type="checkbox"> 클로저 및 lambda</li>
<li><input disabled="" type="checkbox"> 고차 함수</li>
<li><input disabled="" type="checkbox"> 패턴 매칭</li>
<li><input disabled="" type="checkbox"> 대수적 데이터 타입 (ADT)</li>
<li><input disabled="" type="checkbox"> 리스트, 튜플 등 데이터 구조</li>
<li><input disabled="" type="checkbox"> 타입 시스템 (현재 모두 i32)</li>
</ul>
<p><strong>학습 경로:</strong></p>
<pre><code>Phase 1 (Foundation): MLIR 기초, P/Invoke
  ↓
Phase 2 (Core Language): 표현식, 제어 흐름, 메모리
  ↓
Phase 3 (Functions): 함수, 재귀, 스택 ← 현재 위치
  ↓
Phase 4 (Closures): 클로저, 고차 함수, 힙
  ↓
Phase 5 (Data Structures): 리스트, 튜플, ADT
  ↓
Phase 6 (Type System): 타입 추론, 다형성
  ↓
Phase 7 (Optimization): 인라인, TCO, 최적화 패스
</code></pre>
<p><strong>축하합니다!</strong> Phase 3를 완료했습니다. FunLang 컴파일러는 이제 재귀 함수를 포함한 완전한 프로그램을 네이티브 코드로 컴파일할 수 있습니다.</p>
<p><strong>다음 장 (Phase 4)에서:</strong> 클로저와 환경 캡처를 추가하여 진정한 함수형 프로그래밍 기능을 구현할 것입니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="10-functions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="appendix-custom-dialect.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="10-functions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="appendix-custom-dialect.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
