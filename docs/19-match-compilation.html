<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chapter 19: Match Compilation - LangBackend Tutorial</title>


        <!-- Custom HTML head -->

        <meta name="description" content="MLIR 기반 FunLang 컴파일러 백엔드 튜토리얼">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-2a27a2f4.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-d20149da.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">LangBackend Tutorial</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/ohama/LangBackend" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>
                        <a href="https://github.com/ohama/LangBackend/edit/master/tutorial/./19-match-compilation.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <span class=fa-svg id="git-edit-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M421.7 220.3l-11.3 11.3-22.6 22.6-205 205c-6.6 6.6-14.8 11.5-23.8 14.1L30.8 511c-8.4 2.5-17.5 .2-23.7-6.1S-1.5 489.7 1 481.2L38.7 353.1c2.6-9 7.5-17.2 14.1-23.8l205-205 22.6-22.6 11.3-11.3 33.9 33.9 62.1 62.1 33.9 33.9zM96 353.9l-9.3 9.3c-.9 .9-1.6 2.1-2 3.4l-25.3 86 86-25.3c1.3-.4 2.5-1.1 3.4-2l9.3-9.3H112c-8.8 0-16-7.2-16-16V353.9zM453.3 19.3l39.4 39.4c25 25 25 65.5 0 90.5l-14.5 14.5-22.6 22.6-11.3 11.3-33.9-33.9-62.1-62.1L314.3 67.7l11.3-11.3 22.6-22.6 14.5-14.5c25-25 65.5-25 90.5 0z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="chapter-19-match-compilation-match-compilation"><a class="header" href="#chapter-19-match-compilation-match-compilation">Chapter 19: Match Compilation (Match Compilation)</a></h1>
<h2 id="소개"><a class="header" href="#소개">소개</a></h2>
<p><strong>Chapter 17</strong>에서는 패턴 매칭의 <strong>이론적 기반</strong>을 다뤘다:</p>
<ul>
<li>Decision tree 알고리즘 (Maranget 2008)</li>
<li>Pattern matrix와 specialization/defaulting 연산</li>
<li>Exhaustiveness checking과 unreachable case detection</li>
</ul>
<p><strong>Chapter 18</strong>에서는 패턴 매칭이 작동할 <strong>데이터 구조</strong>를 구현했다:</p>
<ul>
<li><code>!funlang.list&lt;T&gt;</code> parameterized type</li>
<li><code>funlang.nil</code>과 <code>funlang.cons</code> operations</li>
<li>TypeConverter로 tagged union 변환</li>
<li>NilOpLowering과 ConsOpLowering patterns</li>
</ul>
<p><strong>Chapter 19</strong>에서는 모든 것을 종합하여 <strong>패턴 매칭 컴파일</strong>을 완성한다. <code>funlang.match</code> operation을 정의하고 SCF dialect로 lowering하여 실행 가능한 코드를 생성한다.</p>
<h3 id="두-장의-복습-왜-match-operation이-필요한가"><a class="header" href="#두-장의-복습-왜-match-operation이-필요한가">두 장의 복습: 왜 Match Operation이 필요한가?</a></h3>
<p>Chapter 17에서 우리는 decision tree 알고리즘을 배웠다:</p>
<pre><code class="language-fsharp">// F# 패턴 매칭 예제
let rec sum_list lst =
    match lst with
    | [] -&gt; 0
    | head :: tail -&gt; head + sum_list tail

sum_list [1; 2; 3]  // 6
</code></pre>
<p>Decision tree 컴파일 결과:</p>
<pre><code>Switch on lst:
  Case Nil -&gt; return 0
  Case Cons(head, tail) -&gt; return head + sum_list tail
</code></pre>
<p>Chapter 18에서 우리는 리스트 데이터 구조를 구현했다:</p>
<pre><code class="language-mlir">// Empty list
%empty = funlang.nil : !funlang.list&lt;i32&gt;

// List construction: [1, 2, 3]
%three = arith.constant 3 : i32
%t3 = funlang.nil : !funlang.list&lt;i32&gt;
%l3 = funlang.cons %three, %t3 : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;

%two = arith.constant 2 : i32
%l2 = funlang.cons %two, %l3 : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;

%one = arith.constant 1 : i32
%l1 = funlang.cons %one, %l2 : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;
</code></pre>
<p><strong>이제 이 두 가지를 연결할 방법이 필요하다:</strong></p>
<pre><code class="language-mlir">// 목표: sum_list를 MLIR로 표현
func.func @sum_list(%lst: !funlang.list&lt;i32&gt;) -&gt; i32 {
  %result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
    ^nil:
      %zero = arith.constant 0 : i32
      funlang.yield %zero : i32
    ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
      %tail_sum = func.call @sum_list(%tail) : (!funlang.list&lt;i32&gt;) -&gt; i32
      %sum = arith.addi %head, %tail_sum : i32
      funlang.yield %sum : i32
  }
  return %result : i32
}
</code></pre>
<h3 id="funlangmatch-the-most-complex-operation"><a class="header" href="#funlangmatch-the-most-complex-operation">funlang.match: The Most Complex Operation</a></h3>
<p><strong>왜 <code>funlang.match</code>가 가장 복잡한가?</strong></p>
<p>지금까지 우리가 구현한 FunLang operations:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Complexity</th><th>Why</th></tr>
</thead>
<tbody>
<tr><td><code>funlang.nil</code></td><td>Simple</td><td>Zero arguments, constant value</td></tr>
<tr><td><code>funlang.cons</code></td><td>Moderate</td><td>Two operands, GC allocation</td></tr>
<tr><td><code>funlang.closure</code></td><td>Moderate</td><td>Function ref + captures, GC allocation</td></tr>
<tr><td><code>funlang.apply</code></td><td>Moderate</td><td>Indirect call, block arguments</td></tr>
<tr><td><strong><code>funlang.match</code></strong></td><td><strong>Complex</strong></td><td><strong>Multiple regions, block arguments, type conversion</strong></td></tr>
</tbody>
</table>
</div>
<p><strong><code>funlang.match</code>의 복잡성:</strong></p>
<ol>
<li><strong>Region-based structure</strong>: 각 case가 별도의 region (not just basic block)</li>
<li><strong>Variable number of cases</strong>: Nil/Cons 2개부터 임의의 pattern 개수까지</li>
<li><strong>Block arguments per case</strong>: Cons case는 <code>(%head, %tail)</code> 같은 바인딩 필요</li>
<li><strong>Type conversion in regions</strong>: 각 region 내부의 operations도 lowering 필요</li>
<li><strong>Multi-stage lowering</strong>: FunLang → SCF → CF → LLVM</li>
</ol>
<p><strong>Chapter 15 Preview 복습:</strong></p>
<p>Chapter 15에서 우리는 <code>funlang.match</code>를 미리 살짝 봤다:</p>
<pre><code class="language-tablegen">// Chapter 15의 preview (간략 버전)
def FunLang_MatchOp : FunLang_Op&lt;"match"&gt; {
  let summary = "Pattern matching operation";
  let arguments = (ins AnyType:$input);
  let results = (outs AnyType:$result);
  let regions = (region VariadicRegion&lt;SizedRegion&lt;1&gt;&gt;:$cases);
}
</code></pre>
<p><strong>Chapter 19에서는 완전한 버전을 구현한다:</strong></p>
<ul>
<li>Full TableGen definition with verification</li>
<li>Custom assembly format (parser/printer)</li>
<li>C API shim for region-based operation</li>
<li>F# bindings with builder callback</li>
<li>Lowering pattern to SCF dialect</li>
</ul>
<h3 id="multi-stage-lowering-funlang--scf--llvm"><a class="header" href="#multi-stage-lowering-funlang--scf--llvm">Multi-Stage Lowering: FunLang → SCF → LLVM</a></h3>
<p><strong>왜 SCF dialect를 거치는가?</strong></p>
<p>Phase 5에서 우리는 FunLang operations를 직접 LLVM dialect로 lowering했다:</p>
<pre><code>funlang.closure → llvm.alloca + llvm.store  (direct lowering)
funlang.apply   → llvm.load + llvm.call     (direct lowering)
</code></pre>
<p><strong>하지만 <code>funlang.match</code>는 다르다:</strong></p>
<pre><code>funlang.match → scf.index_switch → cf.switch → llvm.switch
              (structured)        (CFG)       (machine)
</code></pre>
<p><strong>이유:</strong></p>
<ol>
<li><strong>Structured control flow preservation</strong>: SCF는 high-level structure 유지</li>
<li><strong>Optimization opportunities</strong>: SCF level에서 최적화 가능 (dead case elimination, etc.)</li>
<li><strong>Debugging</strong>: SCF IR이 source 구조를 반영하여 디버깅 쉬움</li>
<li><strong>Separation of concerns</strong>: Pattern matching logic과 low-level branching 분리</li>
</ol>
<p><strong>SCF Dialect란?</strong></p>
<p>SCF = <strong>Structured Control Flow</strong></p>
<p>MLIR의 standard dialect 중 하나로, high-level control flow operations 제공:</p>
<pre><code class="language-mlir">// scf.if: two-way branching (Chapter 8에서 사용)
%result = scf.if %cond : i1 -&gt; i32 {
  %x = arith.constant 42 : i32
  scf.yield %x : i32
} else {
  %y = arith.constant 0 : i32
  scf.yield %y : i32
}

// scf.index_switch: multi-way branching (Chapter 19에서 사용)
%result = scf.index_switch %tag : index -&gt; i32
case 0 {
  %zero = arith.constant 0 : i32
  scf.yield %zero : i32
}
case 1 {
  %one = arith.constant 1 : i32
  scf.yield %one : i32
}
default {
  %minus = arith.constant -1 : i32
  scf.yield %minus : i32
}
</code></pre>
<p><strong>SCF vs CF (Control Flow) dialect:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Dialect</th><th>Level</th><th>Structure</th><th>When</th></tr>
</thead>
<tbody>
<tr><td>SCF</td><td>High-level</td><td>Structured (nested regions)</td><td>Pattern matching, loops</td></tr>
<tr><td>CF</td><td>Low-level</td><td>Unstructured (goto-like)</td><td>After SCF lowering</td></tr>
</tbody>
</table>
</div>
<p><strong>Complete lowering pipeline:</strong></p>
<pre><code>FunLang Dialect
    ↓ (FunLangToSCFPass)
SCF + FunLang (partially lowered)
    ↓ (FunLangToLLVMPass - for nil/cons/closure/apply)
SCF + LLVM
    ↓ (SCFToControlFlowPass)
CF + LLVM
    ↓ (ControlFlowToLLVMPass)
LLVM Dialect only
    ↓ (LLVMToObjectPass)
Machine code
</code></pre>
<h3 id="chapter-19-goals"><a class="header" href="#chapter-19-goals">Chapter 19 Goals</a></h3>
<p><strong>이 장에서 배울 것:</strong></p>
<ol>
<li>
<p><strong>Match Operation Definition</strong> (Part 1)</p>
<ul>
<li>Region-based operation structure</li>
<li>TableGen definition with VariadicRegion</li>
<li>Custom verifier for region semantics</li>
<li>YieldOp terminator for match results</li>
<li>C API shim for region-based operations</li>
<li>F# bindings with builder callback pattern</li>
</ul>
</li>
<li>
<p><strong>SCF Lowering</strong> (Part 2)</p>
<ul>
<li>SCF dialect overview and <code>scf.index_switch</code></li>
<li>MatchOpLowering pattern implementation</li>
<li>Region cloning and type conversion</li>
<li>Block argument remapping</li>
<li>Common errors and debugging strategies</li>
</ul>
</li>
<li>
<p><strong>End-to-End Example</strong></p>
<ul>
<li>length function: complete compilation pipeline</li>
<li>Stage-by-stage IR transformation</li>
<li>Performance comparison vs naive approach</li>
</ul>
</li>
</ol>
<p><strong>Success criteria:</strong></p>
<ul>
<li>✅ <code>funlang.match</code> operation defined and verified</li>
<li>✅ Lowering to <code>scf.index_switch</code> working</li>
<li>✅ Pattern variables bound via block arguments</li>
<li>✅ End-to-end compilation of recursive list functions</li>
</ul>
<p>Let’s begin!</p>
<hr>
<h2 id="part-1-match-operation-definition"><a class="header" href="#part-1-match-operation-definition">Part 1: Match Operation Definition</a></h2>
<h3 id="region-based-operations-the-foundation"><a class="header" href="#region-based-operations-the-foundation">Region-Based Operations: The Foundation</a></h3>
<p><strong>Region이란 무엇인가?</strong></p>
<p>MLIR에서 <strong>region</strong>은 <strong>basic blocks의 container</strong>다.</p>
<pre><code>Region
  ├─ Block 1 (entry block)
  │   ├─ Operation 1
  │   ├─ Operation 2
  │   └─ Terminator
  ├─ Block 2
  │   └─ ...
  └─ Block N
</code></pre>
<p><strong>우리가 이미 본 region-based operations:</strong></p>
<p>Chapter 8에서 <code>scf.if</code>:</p>
<pre><code class="language-mlir">scf.if %cond : i1 -&gt; i32 {
  // "then" region (1 block)
  %x = arith.constant 42 : i32
  scf.yield %x : i32
} else {
  // "else" region (1 block)
  %y = arith.constant 0 : i32
  scf.yield %y : i32
}
</code></pre>
<ul>
<li><code>scf.if</code>는 2개의 regions (then, else)</li>
<li>각 region은 exactly 1 block</li>
<li>각 block은 <code>scf.yield</code> terminator로 끝남</li>
</ul>
<p>Chapter 10에서 <code>func.func</code>:</p>
<pre><code class="language-mlir">func.func @my_function(%arg: i32) -&gt; i32 {
  // function body region (1 or more blocks)
  %result = arith.addi %arg, %arg : i32
  return %result : i32
}
</code></pre>
<ul>
<li><code>func.func</code>는 1개의 region (body)</li>
<li>Region은 1개 이상의 blocks (control flow로 여러 block 가능)</li>
<li>Entry block은 function arguments as block arguments</li>
</ul>
<p><strong>왜 basic blocks이 아니라 regions인가?</strong></p>
<p><strong>Scenario: match expression with 3 cases</strong></p>
<pre><code class="language-fsharp">// F# code
match shape with
| Circle r -&gt; compute_circle_area r
| Rectangle (w, h) -&gt; compute_rectangle_area w h
| Triangle (a, b, c) -&gt; compute_triangle_area a b c
</code></pre>
<p><strong>Option 1: Basic blocks (NOT what we do)</strong></p>
<pre><code class="language-mlir">// 잘못된 접근: basic blocks only
func.func @match_shape(%shape: !funlang.shape) -&gt; f32 {
  // ... tag extraction ...
  cf.br ^dispatch

^dispatch:
  cf.switch %tag [
    ^circle,
    ^rectangle,
    ^triangle
  ]

^circle:
  // Circle case logic
  cf.br ^exit

^rectangle:
  // Rectangle case logic
  cf.br ^exit

^triangle:
  // Triangle case logic
  cf.br ^exit

^exit(%result: f32):
  return %result : f32
}
</code></pre>
<p><strong>문제점:</strong></p>
<ol>
<li><strong>All blocks in same scope</strong>: ^circle, ^rectangle, ^triangle은 모두 같은 function body region</li>
<li><strong>No encapsulation</strong>: Case logic이 function CFG에 섞임</li>
<li><strong>Hard to verify</strong>: “각 case가 정확히 1개의 yield를 가지는가?” 검증 어려움</li>
<li><strong>Type conversion complexity</strong>: Lowering pass가 case blocks을 구분하기 어려움</li>
</ol>
<p><strong>Option 2: Regions (What we do)</strong></p>
<pre><code class="language-mlir">// 올바른 접근: regions
func.func @match_shape(%shape: !funlang.shape) -&gt; f32 {
  %result = funlang.match %shape : !funlang.shape -&gt; f32 {
    ^circle(%r: f32):
      %area = call @compute_circle_area(%r) : (f32) -&gt; f32
      funlang.yield %area : f32
    ^rectangle(%w: f32, %h: f32):
      %area = call @compute_rectangle_area(%w, %h) : (f32, f32) -&gt; f32
      funlang.yield %area : f32
    ^triangle(%a: f32, %b: f32, %c: f32):
      %area = call @compute_triangle_area(%a, %b, %c) : (f32, f32, f32) -&gt; f32
      funlang.yield %area : f32
  }
  return %result : f32
}
</code></pre>
<p><strong>장점:</strong></p>
<ol>
<li><strong>Encapsulation</strong>: 각 case가 자신만의 region (isolated scope)</li>
<li><strong>Clear structure</strong>: match operation이 모든 cases를 소유</li>
<li><strong>Easy verification</strong>: 각 region은 정확히 1 block, 1 terminator</li>
<li><strong>Lowering-friendly</strong>: Region 단위로 type conversion 수행 가능</li>
</ol>
<p><strong>Region vs Block vs Operation:</strong></p>
<pre><code>Operation: funlang.match
  ↓ has
Regions: [case 1 region, case 2 region, ...]
  ↓ each contains
Blocks: [entry block]
  ↓ contains
Operations: [arith.constant, func.call, funlang.yield, ...]
</code></pre>
<h3 id="match-operation-semantics"><a class="header" href="#match-operation-semantics">Match Operation Semantics</a></h3>
<p><strong><code>funlang.match</code>의 의미론:</strong></p>
<pre><code class="language-mlir">%result = funlang.match %input : InputType -&gt; ResultType {
  ^case1(...pattern_vars1...):
    // case 1 logic
    funlang.yield %value1 : ResultType
  ^case2(...pattern_vars2...):
    // case 2 logic
    funlang.yield %value2 : ResultType
  ...
}
</code></pre>
<p><strong>Execution semantics:</strong></p>
<ol>
<li><strong>Input evaluation</strong>: <code>%input</code> 값을 runtime에 evaluate</li>
<li><strong>Tag extraction</strong>: Tagged union에서 tag value 추출</li>
<li><strong>Case selection</strong>: Tag에 따라 해당 region 선택</li>
<li><strong>Pattern variable binding</strong>: Region의 block arguments에 values 바인딩</li>
<li><strong>Case execution</strong>: 선택된 region 실행</li>
<li><strong>Result yielding</strong>: Region의 <code>funlang.yield</code>가 <code>%result</code>에 값 전달</li>
</ol>
<p><strong>Example: sum_list</strong></p>
<pre><code class="language-mlir">func.func @sum_list(%lst: !funlang.list&lt;i32&gt;) -&gt; i32 {
  %result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
    ^nil:
      %zero = arith.constant 0 : i32
      funlang.yield %zero : i32
    ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
      %tail_sum = func.call @sum_list(%tail) : (!funlang.list&lt;i32&gt;) -&gt; i32
      %sum = arith.addi %head, %tail_sum : i32
      funlang.yield %sum : i32
  }
  return %result : i32
}
</code></pre>
<p><strong>Runtime execution: sum_list([1, 2])</strong></p>
<ol>
<li><strong>Call</strong>: <code>@sum_list([1, 2])</code></li>
<li><strong>Tag extraction</strong>: Tag = 1 (Cons)</li>
<li><strong>Case selection</strong>: ^cons region</li>
<li><strong>Variable binding</strong>: <code>%head = 1</code>, <code>%tail = [2]</code></li>
<li><strong>Recursive call</strong>: <code>@sum_list([2])</code>
<ul>
<li>Tag = 1 (Cons)</li>
<li><code>%head = 2</code>, <code>%tail = []</code></li>
<li>Recursive call: <code>@sum_list([])</code>
<ul>
<li>Tag = 0 (Nil)</li>
<li>Return 0</li>
</ul>
</li>
<li><code>%sum = 2 + 0 = 2</code></li>
<li>Return 2</li>
</ul>
</li>
<li><strong>Final sum</strong>: <code>1 + 2 = 3</code></li>
<li><strong>Return</strong>: 3</li>
</ol>
<h3 id="block-arguments-for-pattern-variables"><a class="header" href="#block-arguments-for-pattern-variables">Block Arguments for Pattern Variables</a></h3>
<p><strong>패턴 변수는 어떻게 바인딩되는가?</strong></p>
<p>Chapter 2에서 우리는 <strong>block arguments</strong>를 배웠다:</p>
<pre><code class="language-mlir">^entry_block(%arg0: i32, %arg1: i32):
  %sum = arith.addi %arg0, %arg1 : i32
</code></pre>
<p>Block arguments는 PHI nodes의 structured 대안이다.</p>
<p><strong>Match operation에서 block arguments 활용:</strong></p>
<pre><code class="language-mlir">funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
  ^nil:
    // Nil case: 패턴 변수 없음 → block arguments 없음
    funlang.yield %zero : i32

  ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
    // Cons case: 2개 패턴 변수 → 2개 block arguments
    // %head: i32          → cons cell의 head field
    // %tail: !funlang.list&lt;i32&gt; → cons cell의 tail field
    funlang.yield %sum : i32
}
</code></pre>
<p><strong>Lowering이 block arguments를 채우는 방법:</strong></p>
<pre><code class="language-mlir">// funlang.match lowering 후 (pseudo-code)
%tag = // extract tag from %lst
scf.index_switch %tag {
  case 0 {  // Nil case
    // No data to extract, no arguments
    %zero = arith.constant 0 : i32
    scf.yield %zero : i32
  }
  case 1 {  // Cons case
    // Extract head and tail from cons cell
    %head = // extract field 0 from data pointer
    %tail = // extract field 1 from data pointer
    // Now pass to the ^cons block's body (with arguments bound)
    ^cons(%head, %tail):
      // User code here
  }
}
</code></pre>
<p><strong>실제로는 region을 clone하고 IRMapping으로 arguments를 remap한다</strong> (Part 2에서 자세히)</p>
<p><strong>Block arguments vs Let bindings:</strong></p>
<pre><code class="language-mlir">// Option 1: Block arguments (what we do)
^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
  %sum = arith.addi %head, ... : i32

// Option 2: Let-style extraction (what we DON'T do)
^cons:
  %head = funlang.extract_head %lst : !funlang.list&lt;i32&gt; -&gt; i32
  %tail = funlang.extract_tail %lst : !funlang.list&lt;i32&gt; -&gt; !funlang.list&lt;i32&gt;
  %sum = arith.addi %head, ... : i32
</code></pre>
<p><strong>Block arguments가 더 나은 이유:</strong></p>
<ol>
<li><strong>Declarative</strong>: Pattern structure가 arguments에 직접 반영</li>
<li><strong>SSA-friendly</strong>: Block entry에서 values가 이미 available</li>
<li><strong>No redundant ops</strong>: extract operations 불필요</li>
<li><strong>Verification</strong>: Argument types로 pattern structure 검증 가능</li>
</ol>
<h3 id="tablegen-definition-matchop"><a class="header" href="#tablegen-definition-matchop">TableGen Definition: MatchOp</a></h3>
<p>이제 <code>funlang.match</code> operation의 TableGen 정의를 작성한다.</p>
<p><strong>File: <code>FunLang/FunLangOps.td</code></strong> (conceptual, 실제로는 C++ codebase)</p>
<pre><code class="language-tablegen">def FunLang_MatchOp : FunLang_Op&lt;"match", [
    RecursiveSideEffect,
    SingleBlockImplicitTerminator&lt;"YieldOp"&gt;
  ]&gt; {
  let summary = "Pattern matching operation";
  let description = [{
    The `funlang.match` operation performs pattern matching on a value.
    Each case is represented as a separate region with exactly one block.

    The entry block of each region may have arguments corresponding to
    pattern variables. For example, a Cons case has two arguments:
    the head element and the tail list.

    Each region must terminate with a `funlang.yield` operation that
    returns a value of the result type.

    Example:
    ```mlir
    %result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
      ^nil:
        %zero = arith.constant 0 : i32
        funlang.yield %zero : i32
      ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
        %sum = func.call @sum_list(%tail) : (!funlang.list&lt;i32&gt;) -&gt; i32
        %result = arith.addi %head, %sum : i32
        funlang.yield %result : i32
    }
    ```
  }];

  let arguments = (ins AnyType:$input);
  let results = (outs AnyType:$result);
  let regions = (region VariadicRegion&lt;SizedRegion&lt;1&gt;&gt;:$cases);

  let hasCustomAssemblyFormat = 1;
  let hasVerifier = 1;
}
</code></pre>
<p><strong>핵심 요소 설명:</strong></p>
<p><strong>1. Traits: RecursiveSideEffect</strong></p>
<pre><code class="language-tablegen">RecursiveSideEffect
</code></pre>
<p><strong>의미:</strong> 이 operation의 side effects는 내부 regions의 operations에 의존한다.</p>
<p><strong>왜 필요한가?</strong></p>
<p>MLIR optimizer는 side effects를 분석하여 dead code elimination, common subexpression elimination 등을 수행한다.</p>
<ul>
<li><code>funlang.nil</code>은 <code>Pure</code> trait → no side effects</li>
<li><code>funlang.cons</code>는 side effects 있음 (GC allocation)</li>
</ul>
<p><strong>Match operation은?</strong></p>
<pre><code class="language-mlir">%result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
  ^nil:
    %x = funlang.nil : !funlang.list&lt;i32&gt;  // Pure
    funlang.yield %zero : i32
  ^cons(%h, %t):
    %y = funlang.cons %h, %t : ...  // Side effect!
    funlang.yield %sum : i32
}
</code></pre>
<ul>
<li>Nil case: no side effects</li>
<li>Cons case: side effect (funlang.cons)</li>
</ul>
<p><strong>RecursiveSideEffect trait는 MLIR에게 말한다:</strong></p>
<p>“이 operation의 side effects는 내부 regions을 재귀적으로 분석해서 결정해라”</p>
<p><strong>없으면 어떻게 되나?</strong></p>
<ul>
<li>Conservative assumption: match는 항상 side effects 있음</li>
<li>Optimizer가 legitimate optimizations를 못함</li>
<li>예: dead match elimination 불가</li>
</ul>
<p><strong>2. Traits: SingleBlockImplicitTerminator</strong></p>
<pre><code class="language-tablegen">SingleBlockImplicitTerminator&lt;"YieldOp"&gt;
</code></pre>
<p><strong>의미:</strong> 각 region은 정확히 1개의 block을 가지며, 그 block은 <code>YieldOp</code>로 끝나야 한다.</p>
<p><strong>검증 자동화:</strong></p>
<p>이 trait가 있으면 MLIR이 자동으로 검증:</p>
<ol>
<li>각 region이 정확히 1 block인가?</li>
<li>그 block이 <code>funlang.yield</code>로 끝나는가?</li>
</ol>
<p><strong>없으면 어떻게 되나?</strong></p>
<p>Custom verifier에서 수동 검증 필요:</p>
<pre><code class="language-cpp">// Without the trait (manual verification)
LogicalResult MatchOp::verify() {
  for (Region&amp; region : getCases()) {
    if (!region.hasOneBlock()) {
      return emitError("each case must have exactly one block");
    }
    Block&amp; block = region.front();
    if (!isa&lt;YieldOp&gt;(block.getTerminator())) {
      return emitError("each case must terminate with funlang.yield");
    }
  }
  return success();
}
</code></pre>
<p>Trait가 이 boilerplate를 제거한다!</p>
<p><strong>3. Regions: VariadicRegion&lt;SizedRegion&lt;1&gt;&gt;</strong></p>
<pre><code class="language-tablegen">let regions = (region VariadicRegion&lt;SizedRegion&lt;1&gt;&gt;:$cases);
</code></pre>
<p><strong>분해:</strong></p>
<ul>
<li><code>VariadicRegion</code>: 가변 개수의 regions (Nil/Cons = 2개, 더 많은 patterns = N개)</li>
<li><code>SizedRegion&lt;1&gt;</code>: 각 region은 정확히 1개의 block</li>
<li><code>:$cases</code>: C++ accessor name → <code>getCases()</code> method</li>
</ul>
<p><strong>대안들과 비교:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Declaration</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>region AnyRegion:$body</code></td><td>Exactly 1 region, any number of blocks</td></tr>
<tr><td><code>region SizedRegion&lt;1&gt;:$body</code></td><td>Exactly 1 region, exactly 1 block</td></tr>
<tr><td><code>region VariadicRegion&lt;AnyRegion&gt;:$cases</code></td><td>N regions, each with any blocks</td></tr>
<tr><td><code>region VariadicRegion&lt;SizedRegion&lt;1&gt;&gt;:$cases</code></td><td>N regions, each with 1 block ✅</td></tr>
</tbody>
</table>
</div>
<p><strong>scf.if와 비교:</strong></p>
<pre><code class="language-tablegen">// scf.if (exactly 2 regions)
def SCF_IfOp : ... {
  let regions = (region SizedRegion&lt;1&gt;:$thenRegion,
                        SizedRegion&lt;1&gt;:$elseRegion);
}

// funlang.match (variable number of regions)
def FunLang_MatchOp : ... {
  let regions = (region VariadicRegion&lt;SizedRegion&lt;1&gt;&gt;:$cases);
}
</code></pre>
<p><strong>4. Custom Assembly Format</strong></p>
<pre><code class="language-tablegen">let hasCustomAssemblyFormat = 1;
</code></pre>
<p><strong>이유:</strong> Generic format은 readable하지 않다.</p>
<p><strong>Generic format (자동 생성):</strong></p>
<pre><code class="language-mlir">%result = "funlang.match"(%lst) ({
  ^bb0:
    %zero = arith.constant 0 : i32
    "funlang.yield"(%zero) : (i32) -&gt; ()
}, {
  ^bb0(%head: i32, %tail: !funlang.list&lt;i32&gt;):
    %sum = arith.addi %head, %tail_sum : i32
    "funlang.yield"(%sum) : (i32) -&gt; ()
}) : (!funlang.list&lt;i32&gt;) -&gt; i32
</code></pre>
<p><strong>Custom format (우리가 작성):</strong></p>
<pre><code class="language-mlir">%result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
  ^nil:
    %zero = arith.constant 0 : i32
    funlang.yield %zero : i32
  ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
    %sum = arith.addi %head, %tail_sum : i32
    funlang.yield %sum : i32
}
</code></pre>
<p><strong>Custom parser/printer 구현 필요 (C++ code):</strong></p>
<pre><code class="language-cpp">// File: FunLangOps.cpp

void MatchOp::print(OpAsmPrinter&amp; p) {
  p &lt;&lt; " " &lt;&lt; getInput() &lt;&lt; " : " &lt;&lt; getInput().getType()
    &lt;&lt; " -&gt; " &lt;&lt; getResult().getType() &lt;&lt; " ";

  p.printRegion(getCases(), /*printEntryBlockArgs=*/true);
}

ParseResult MatchOp::parse(OpAsmParser&amp; parser, OperationState&amp; result) {
  OpAsmParser::UnresolvedOperand input;
  Type inputType, resultType;
  Region* casesRegion = result.addRegion();

  if (parser.parseOperand(input) ||
      parser.parseColon() ||
      parser.parseType(inputType) ||
      parser.parseArrow() ||
      parser.parseType(resultType) ||
      parser.parseRegion(*casesRegion, /*arguments=*/{}, /*argTypes=*/{}))
    return failure();

  result.addTypes(resultType);
  return success();
}
</code></pre>
<p><em>실제 구현은 더 복잡하지만, F# tutorial에서는 C API로 추상화됨</em></p>
<p><strong>5. Custom Verifier</strong></p>
<pre><code class="language-tablegen">let hasVerifier = 1;
</code></pre>
<p><strong>검증할 내용:</strong></p>
<ol>
<li>✅ Region count &gt; 0</li>
<li>✅ 각 region의 block arguments types 검증</li>
<li>✅ 각 region의 yield type이 result type과 일치</li>
<li>✅ Input type이 matchable type (현재는 !funlang.list<t>)</t></li>
</ol>
<p><strong>C++ verifier implementation:</strong></p>
<pre><code class="language-cpp">// File: FunLangOps.cpp

LogicalResult MatchOp::verify() {
  // Check: at least one case
  if (getCases().empty()) {
    return emitError("match must have at least one case");
  }

  Type resultType = getResult().getType();

  // Check each case region
  for (Region&amp; region : getCases()) {
    if (region.empty())
      return emitError("case region cannot be empty");

    Block&amp; block = region.front();

    // Verify terminator (already checked by SingleBlockImplicitTerminator)
    auto yieldOp = dyn_cast&lt;YieldOp&gt;(block.getTerminator());
    if (!yieldOp)
      return emitError("case must terminate with funlang.yield");

    // Verify yield type matches result type
    if (yieldOp.getValue().getType() != resultType) {
      return emitError("yield type ")
             &lt;&lt; yieldOp.getValue().getType()
             &lt;&lt; " does not match result type " &lt;&lt; resultType;
    }
  }

  return success();
}
</code></pre>
<p><strong>실전 예제:</strong></p>
<pre><code class="language-mlir">// ERROR: No cases
%result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
}
// Error: match must have at least one case

// ERROR: Type mismatch
%result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
  ^nil:
    %x = arith.constant 3.14 : f32  // Wrong type!
    funlang.yield %x : f32
}
// Error: yield type f32 does not match result type i32
</code></pre>
<h3 id="yieldop-match-result-terminator"><a class="header" href="#yieldop-match-result-terminator">YieldOp: Match Result Terminator</a></h3>
<p><strong>각 match case는 <code>funlang.yield</code>로 끝나야 한다.</strong></p>
<p><strong>TableGen definition:</strong></p>
<pre><code class="language-tablegen">def FunLang_YieldOp : FunLang_Op&lt;"yield", [
    Terminator,
    HasParent&lt;"MatchOp"&gt;
  ]&gt; {
  let summary = "Yield a value from a match case";
  let description = [{
    The `funlang.yield` operation terminates a match case region and
    returns a value to the parent `funlang.match` operation.

    Example:
    ```mlir
    funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
      ^nil:
        %zero = arith.constant 0 : i32
        funlang.yield %zero : i32  // Yield from nil case
      ^cons(%h, %t):
        %sum = arith.addi %h, ... : i32
        funlang.yield %sum : i32   // Yield from cons case
    }
    ```
  }];

  let arguments = (ins AnyType:$value);
  let results = (outs);

  let assemblyFormat = "$value attr-dict `:` type($value)";
}
</code></pre>
<p><strong>핵심 요소:</strong></p>
<p><strong>1. Trait: Terminator</strong></p>
<pre><code class="language-tablegen">Terminator
</code></pre>
<p><strong>의미:</strong> 이 operation은 basic block을 종료한다.</p>
<p><strong>Block의 terminator 규칙:</strong></p>
<ul>
<li>모든 block은 정확히 1개의 terminator로 끝나야 함</li>
<li>Terminator는 block의 마지막 operation이어야 함</li>
<li>Terminator 예: <code>func.return</code>, <code>cf.br</code>, <code>scf.yield</code>, <code>funlang.yield</code></li>
</ul>
<p><strong>2. Trait: HasParent&lt;“MatchOp”&gt;</strong></p>
<pre><code class="language-tablegen">HasParent&lt;"MatchOp"&gt;
</code></pre>
<p><strong>의미:</strong> 이 operation은 <code>MatchOp</code>의 region 내에서만 사용 가능.</p>
<p><strong>검증 자동화:</strong></p>
<pre><code class="language-mlir">// OK: inside funlang.match
funlang.match %lst {
  ^nil:
    funlang.yield %zero : i32  // ✅
}

// ERROR: outside match
func.func @wrong() -&gt; i32 {
  %x = arith.constant 42 : i32
  funlang.yield %x : i32  // ❌ Error: funlang.yield must be inside MatchOp
}
</code></pre>
<p><strong>3. Assembly Format</strong></p>
<pre><code class="language-tablegen">let assemblyFormat = "$value attr-dict `:` type($value)";
</code></pre>
<p><strong>생성되는 format:</strong></p>
<pre><code class="language-mlir">funlang.yield %sum : i32
</code></pre>
<p><strong>Generic format과 비교:</strong></p>
<pre><code class="language-mlir">// Generic (verbose)
"funlang.yield"(%sum) : (i32) -&gt; ()

// Custom (readable)
funlang.yield %sum : i32
</code></pre>
<h3 id="scfyield와-비교"><a class="header" href="#scfyield와-비교">scf.yield와 비교</a></h3>
<p><strong>MLIR에는 여러 yield operations이 있다:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Parent</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>scf.yield</code></td><td><code>scf.if</code>, <code>scf.for</code>, <code>scf.while</code></td><td>SCF control flow</td></tr>
<tr><td><code>funlang.yield</code></td><td><code>funlang.match</code></td><td>FunLang pattern matching</td></tr>
<tr><td><code>affine.yield</code></td><td><code>affine.for</code>, <code>affine.if</code></td><td>Affine loops</td></tr>
</tbody>
</table>
</div>
<p><strong>왜 <code>scf.yield</code>를 재사용하지 않는가?</strong></p>
<p><strong>Option 1: 재사용 (하지 않음)</strong></p>
<pre><code class="language-mlir">funlang.match %lst {
  ^nil:
    scf.yield %zero : i32  // Reuse scf.yield?
}
</code></pre>
<p><strong>문제:</strong></p>
<ol>
<li>
<p><strong>Trait conflict</strong>: <code>scf.yield</code>는 <code>HasParent&lt;"IfOp", "ForOp", ...&gt;</code></p>
<ul>
<li><code>MatchOp</code>이 parent list에 없으면 verifier 실패</li>
<li>SCF dialect 수정 필요 (bad coupling)</li>
</ul>
</li>
<li>
<p><strong>Semantic confusion</strong>: <code>scf.yield</code>는 SCF dialect semantics</p>
<ul>
<li>Lowering pass에서 <code>scf.yield</code> 처리 시 match context 고려해야 함</li>
<li>Separation of concerns 위반</li>
</ul>
</li>
</ol>
<p><strong>Option 2: 전용 operation (우리가 하는 것)</strong></p>
<pre><code class="language-mlir">funlang.match %lst {
  ^nil:
    funlang.yield %zero : i32  // FunLang-specific yield
}
</code></pre>
<p><strong>장점:</strong></p>
<ol>
<li><strong>Clear ownership</strong>: FunLang dialect이 자신의 terminators 소유</li>
<li><strong>Lowering flexibility</strong>: <code>funlang.yield</code> → <code>scf.yield</code> 변환을 명시적으로 제어</li>
<li><strong>Future extensions</strong>: 나중에 <code>funlang.yield</code>에 attributes 추가 가능</li>
</ol>
<h3 id="c-api-and-f-integration"><a class="header" href="#c-api-and-f-integration">C API and F# Integration</a></h3>
<p><strong>Region-based operations는 C API 설계가 복잡하다.</strong></p>
<p><strong>문제: Regions를 어떻게 F#에서 구축하는가?</strong></p>
<p><strong>Simple operations (Chapter 15):</strong></p>
<pre><code class="language-fsharp">// funlang.cons: no regions, straightforward
let cons =
    FunLangOps.CreateConsOp(builder, head, tail, listType)
</code></pre>
<p><strong>Region-based operations (Chapter 19):</strong></p>
<pre><code class="language-fsharp">// funlang.match: multiple regions, complex
let matchOp = FunLangOps.CreateMatchOp(builder, input, resultType, [
    // How to build regions here???
    nilRegion;
    consRegion
])
</code></pre>
<p><strong>Challenge:</strong></p>
<ul>
<li>Region 구축은 F# side에서 일어나야 함 (pattern cases logic)</li>
<li>하지만 MLIR C++ API를 직접 호출할 수 없음 (C API만 가능)</li>
<li>Builder callback pattern 필요!</li>
</ul>
<h3 id="c-api-shim-builder-callback-pattern"><a class="header" href="#c-api-shim-builder-callback-pattern">C API Shim: Builder Callback Pattern</a></h3>
<p><strong>Pattern: C API가 F# callback을 받아서 region을 채움</strong></p>
<p><strong>C API shim (C wrapper):</strong></p>
<pre><code class="language-c">// File: FunLang-C/FunLangOps.h

typedef void (*FunLangMatchCaseBuilder)(
    MlirOpBuilder builder,
    MlirBlock block,
    void* userData
);

typedef struct {
    FunLangMatchCaseBuilder builder;
    void* userData;
} FunLangMatchCase;

MLIR_CAPI_EXPORTED MlirOperation funlangMatchOpCreate(
    MlirOpBuilder builder,
    MlirLocation loc,
    MlirValue input,
    MlirType resultType,
    FunLangMatchCase* cases,
    intptr_t numCases
);
</code></pre>
<p><strong>Implementation (C++):</strong></p>
<pre><code class="language-cpp">// File: FunLang-C/FunLangOps.cpp

MlirOperation funlangMatchOpCreate(
    MlirOpBuilder builder,
    MlirLocation loc,
    MlirValue input,
    MlirType resultType,
    FunLangMatchCase* cases,
    intptr_t numCases
) {
  OpBuilder&amp; cppBuilder = unwrap(builder);
  Location cppLoc = unwrap(loc);
  Value cppInput = unwrap(input);
  Type cppResultType = unwrap(resultType);

  // Create match operation
  auto matchOp = cppBuilder.create&lt;MatchOp&gt;(
      cppLoc, cppResultType, cppInput, numCases);

  // Build each case region
  for (intptr_t i = 0; i &lt; numCases; ++i) {
    Region&amp; region = matchOp.getCases()[i];
    Block* block = cppBuilder.createBlock(&amp;region);

    // Invoke F# callback to populate the block
    MlirBlock wrappedBlock = wrap(block);
    cases[i].builder(builder, wrappedBlock, cases[i].userData);
  }

  return wrap(matchOp.getOperation());
}
</code></pre>
<p><strong>핵심 아이디어:</strong></p>
<ol>
<li>C API가 empty regions를 가진 <code>MatchOp</code> 생성</li>
<li>각 region에 대해 F# callback 호출</li>
<li>F# callback이 region의 block을 채움 (operations + yield)</li>
</ol>
<h3 id="f-bindings"><a class="header" href="#f-bindings">F# Bindings</a></h3>
<p><strong>Low-level binding:</strong></p>
<pre><code class="language-fsharp">// File: FunLang.Interop/FunLangOps.fs

type MatchCaseBuilder =
    MlirOpBuilder -&gt; MlirBlock -&gt; nativeint -&gt; unit

[&lt;Struct&gt;]
type MatchCase =
    val Builder: MatchCaseBuilder
    val UserData: nativeint

    new(builder, userData) =
        { Builder = builder; UserData = userData }

[&lt;DllImport("FunLang-C", CallingConvention = CallingConvention.Cdecl)&gt;]
extern MlirOperation funlangMatchOpCreate(
    MlirOpBuilder builder,
    MlirLocation loc,
    MlirValue input,
    MlirType resultType,
    MatchCase[] cases,
    nativeint numCases
)
</code></pre>
<p><strong>High-level wrapper:</strong></p>
<pre><code class="language-fsharp">// File: FunLang.Compiler/OpBuilder.fs

type OpBuilder with
    member this.CreateMatchOp(
        input: MlirValue,
        resultType: MlirType,
        buildCases: (OpBuilder -&gt; Block -&gt; unit) list
    ) : MlirOperation =

        // Convert F# functions to C callbacks
        let cases =
            buildCases
            |&gt; List.map (fun buildCase -&gt;
                let callback builder block userData =
                    let opBuilder = new OpBuilder(builder)
                    let mlirBlock = new Block(block)
                    buildCase opBuilder mlirBlock

                MatchCase(callback, 0n)
            )
            |&gt; List.toArray

        let numCases = nativeint cases.Length
        let loc = this.UnknownLoc()

        funlangMatchOpCreate(
            this.Handle,
            loc,
            input,
            resultType,
            cases,
            numCases
        )
</code></pre>
<p><strong>사용 예제 (F# compiler code):</strong></p>
<pre><code class="language-fsharp">// File: FunLang.Compiler/Codegen.fs

let compileMatch (builder: OpBuilder) (scrutinee: MlirValue) (cases: MatchCase list) =
    let resultType = // infer from cases

    let buildCases =
        cases |&gt; List.map (fun case -&gt;
            fun (builder: OpBuilder) (block: Block) -&gt;
                match case with
                | NilCase expr -&gt;
                    // Build nil case body
                    let value = compileExpr builder env expr
                    builder.CreateYieldOp(value) |&gt; ignore

                | ConsCase (headVar, tailVar, expr) -&gt;
                    // Add block arguments for head and tail
                    let headType = builder.GetIntegerType(32)
                    let tailType = builder.GetFunLangListType(headType)
                    block.AddArgument(headType) |&gt; ignore
                    block.AddArgument(tailType) |&gt; ignore

                    // Build cons case body with extended environment
                    let env' =
                        env
                        |&gt; Map.add headVar (block.GetArgument(0))
                        |&gt; Map.add tailVar (block.GetArgument(1))

                    let value = compileExpr builder env' expr
                    builder.CreateYieldOp(value) |&gt; ignore
        )

    builder.CreateMatchOp(scrutinee, resultType, buildCases)
</code></pre>
<p><strong>Generated MLIR:</strong></p>
<pre><code class="language-mlir">%result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
  ^nil:
    %zero = arith.constant 0 : i32
    funlang.yield %zero : i32
  ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
    %tail_sum = func.call @sum_list(%tail) : (!funlang.list&lt;i32&gt;) -&gt; i32
    %sum = arith.addi %head, %tail_sum : i32
    funlang.yield %sum : i32
}
</code></pre>
<p><strong>Builder callback pattern의 장점:</strong></p>
<ol>
<li><strong>Flexibility</strong>: F# code가 region 내용을 완전히 제어</li>
<li><strong>Type safety</strong>: F# compiler가 callback signature 검증</li>
<li><strong>Composability</strong>: Nested match expressions 지원 (callback 안에서 또 match 생성)</li>
</ol>
<h3 id="block-arguments-in-builder-callback"><a class="header" href="#block-arguments-in-builder-callback">Block Arguments in Builder Callback</a></h3>
<p><strong>위 코드에서 중요한 부분:</strong></p>
<pre><code class="language-fsharp">| ConsCase (headVar, tailVar, expr) -&gt;
    // Add block arguments for pattern variables
    block.AddArgument(headType) |&gt; ignore
    block.AddArgument(tailType) |&gt; ignore

    // Use block arguments in environment
    let env' =
        env
        |&gt; Map.add headVar (block.GetArgument(0))
        |&gt; Map.add tailVar (block.GetArgument(1))
</code></pre>
<p><strong>F# callback이 하는 일:</strong></p>
<ol>
<li><strong>Pattern structure 분석</strong>: ConsCase는 2개 변수 (head, tail)</li>
<li><strong>Block arguments 추가</strong>: Cons case block에 2개 arguments</li>
<li><strong>Environment extension</strong>: Pattern variables를 block arguments로 바인딩</li>
<li><strong>Body compilation</strong>: Extended environment로 case expression 컴파일</li>
</ol>
<p><strong>Lowering pass의 책임:</strong></p>
<p>Lowering pass는 이 block arguments를 실제 데이터로 채운다:</p>
<pre><code class="language-cpp">// MatchOpLowering (Part 2에서 자세히)
// 1. Extract head and tail from cons cell
Value head = extractHead(builder, consCellPtr);
Value tail = extractTail(builder, consCellPtr);

// 2. Clone cons region
IRMapping mapper;
mapper.map(consBlock-&gt;getArgument(0), head);  // Map %head
mapper.map(consBlock-&gt;getArgument(1), tail);  // Map %tail

// 3. Clone operations with mapped values
for (Operation&amp; op : consBlock-&gt;getOperations()) {
    builder.clone(op, mapper);
}
</code></pre>
<p><strong>결과: Block arguments가 실제 values로 대체됨</strong></p>
<hr>
<h2 id="중간-정리-part-1-완료"><a class="header" href="#중간-정리-part-1-완료">중간 정리: Part 1 완료</a></h2>
<p><strong>Part 1에서 다룬 내용:</strong></p>
<p>✅ <strong>Region-based operation structure</strong></p>
<ul>
<li>Regions vs basic blocks</li>
<li>Encapsulation과 verification 장점</li>
</ul>
<p>✅ <strong>Match operation semantics</strong></p>
<ul>
<li>Runtime execution model</li>
<li>Tag extraction → case selection → variable binding → yield</li>
</ul>
<p>✅ <strong>TableGen definition</strong></p>
<ul>
<li>Traits: RecursiveSideEffect, SingleBlockImplicitTerminator</li>
<li>VariadicRegion&lt;SizedRegion&lt;1&gt;&gt; for variable cases</li>
<li>Custom assembly format과 verifier</li>
</ul>
<p>✅ <strong>YieldOp terminator</strong></p>
<ul>
<li>Terminator trait</li>
<li>HasParent&lt;“MatchOp”&gt; constraint</li>
<li>Comparison with scf.yield</li>
</ul>
<p>✅ <strong>C API and F# integration</strong></p>
<ul>
<li>Builder callback pattern</li>
<li>High-level wrapper for match construction</li>
<li>Block arguments for pattern variables</li>
</ul>
<p><strong>다음 Part 2에서:</strong></p>
<ul>
<li>SCF dialect 상세 설명</li>
<li>MatchOpLowering pattern 완전 구현</li>
<li>Region cloning과 IRMapping</li>
<li>전체 pipeline 예제 (sum_list)</li>
<li>Common errors와 debugging</li>
</ul>
<hr>
<h2 id="part-2-scf-lowering-and-pipeline"><a class="header" href="#part-2-scf-lowering-and-pipeline">Part 2: SCF Lowering and Pipeline</a></h2>
<h3 id="scf-dialect-structured-control-flow"><a class="header" href="#scf-dialect-structured-control-flow">SCF Dialect: Structured Control Flow</a></h3>
<p><strong>SCF = Structured Control Flow</strong></p>
<p>Chapter 8에서 우리는 <code>scf.if</code>를 사용했다:</p>
<pre><code class="language-mlir">%result = scf.if %cond : i1 -&gt; i32 {
  %then_val = arith.constant 42 : i32
  scf.yield %then_val : i32
} else {
  %else_val = arith.constant 0 : i32
  scf.yield %else_val : i32
}
</code></pre>
<p><strong>SCF dialect의 핵심 operations:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Purpose</th><th>Regions</th></tr>
</thead>
<tbody>
<tr><td><code>scf.if</code></td><td>Two-way branch</td><td>2 (then, else)</td></tr>
<tr><td><code>scf.index_switch</code></td><td>Multi-way branch</td><td>N (cases) + default</td></tr>
<tr><td><code>scf.for</code></td><td>Counted loop</td><td>1 (body)</td></tr>
<tr><td><code>scf.while</code></td><td>Conditional loop</td><td>2 (before, after)</td></tr>
</tbody>
</table>
</div>
<p><strong>Chapter 19에서는 <code>scf.index_switch</code>를 사용한다.</strong></p>
<h3 id="scfindex_switch-multi-way-branching"><a class="header" href="#scfindex_switch-multi-way-branching">scf.index_switch: Multi-Way Branching</a></h3>
<p><strong>Syntax:</strong></p>
<pre><code class="language-mlir">%result = scf.index_switch %selector : index -&gt; ResultType
case 0 {
  // Case 0 operations
  scf.yield %value0 : ResultType
}
case 1 {
  // Case 1 operations
  scf.yield %value1 : ResultType
}
default {
  // Default case (optional)
  scf.yield %default_val : ResultType
}
</code></pre>
<p><strong>Semantics:</strong></p>
<ol>
<li><strong>Selector evaluation</strong>: <code>%selector</code> 값을 runtime에 evaluate (index type)</li>
<li><strong>Case selection</strong>: Selector 값에 해당하는 case region 선택</li>
<li><strong>Fallback</strong>: 해당하는 case가 없으면 default region (있다면)</li>
<li><strong>Result yielding</strong>: 선택된 region의 <code>scf.yield</code>가 결과 전달</li>
</ol>
<p><strong>Example: Tag dispatch for list</strong></p>
<pre><code class="language-mlir">// %lst: !funlang.list&lt;i32&gt;
// Tag extraction
%struct = // convert %lst to !llvm.struct&lt;(i32, ptr)&gt;
%tag = llvm.extractvalue %struct[0] : !llvm.struct&lt;(i32, ptr)&gt;
%tag_index = arith.index_cast %tag : i32 to index

// Dispatch on tag
%result = scf.index_switch %tag_index : index -&gt; i32
case 0 {  // Nil case (tag = 0)
  %zero = arith.constant 0 : i32
  scf.yield %zero : i32
}
case 1 {  // Cons case (tag = 1)
  %ptr = llvm.extractvalue %struct[1] : !llvm.struct&lt;(i32, ptr)&gt;
  %head = llvm.load %ptr : !llvm.ptr -&gt; i32
  // ... compute with head ...
  scf.yield %sum : i32
}
default {
  // Unreachable for {Nil, Cons} (complete constructor set)
  %minus = arith.constant -1 : i32
  scf.yield %minus : i32
}
</code></pre>
<h3 id="why-scf-before-llvm"><a class="header" href="#why-scf-before-llvm">Why SCF Before LLVM?</a></h3>
<p><strong>Option 1: Direct lowering funlang.match → LLVM (what we DON’T do)</strong></p>
<pre><code class="language-mlir">// Directly to LLVM dialect
%tag = llvm.extractvalue ...
llvm.switch %tag [
  0: ^nil_block,
  1: ^cons_block
]

^nil_block:
  // ... operations ...
  llvm.br ^merge_block(%zero)

^cons_block:
  // ... operations ...
  llvm.br ^merge_block(%sum)

^merge_block(%result: i32):
  llvm.return %result
</code></pre>
<p><strong>문제점:</strong></p>
<ol>
<li><strong>Lost structure</strong>: CFG는 원래 match의 case structure를 상실</li>
<li><strong>Harder optimization</strong>: Which blocks belong to which case? 불명확</li>
<li><strong>Debugging</strong>: LLVM IR에서 source pattern matching 추적 어려움</li>
<li><strong>Lowering complexity</strong>: funlang.match → LLVM을 한 번에 구현해야 함</li>
</ol>
<p><strong>Option 2: Progressive lowering funlang.match → SCF → CF → LLVM (what we do)</strong></p>
<pre><code class="language-mlir">// Stage 1: FunLang
%result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
  ^nil: funlang.yield %zero : i32
  ^cons(%h, %t): funlang.yield %sum : i32
}

// Stage 2: SCF (structured, high-level)
%tag_index = // extract tag and cast to index
%result = scf.index_switch %tag_index : index -&gt; i32
case 0 { scf.yield %zero : i32 }
case 1 { scf.yield %sum : i32 }

// Stage 3: CF (goto-style, low-level)
cf.switch %tag_index [
  0: ^block_0,
  1: ^block_1
]
^block_0: cf.br ^merge(%zero)
^block_1: cf.br ^merge(%sum)
^merge(%result: i32): ...

// Stage 4: LLVM (machine-level)
llvm.switch %tag_i8 [
  0: ^llvm_0,
  1: ^llvm_1
]
// ... LLVM blocks ...
</code></pre>
<p><strong>장점:</strong></p>
<ol>
<li><strong>Separation of concerns</strong>: 각 lowering pass는 하나의 변환만 책임</li>
<li><strong>Optimization hooks</strong>: SCF level에서 pattern-specific optimizations</li>
<li><strong>Incremental verification</strong>: 각 stage마다 IR 검증 가능</li>
<li><strong>Easier debugging</strong>: 문제 발생 시 어느 stage에서 일어났는지 명확</li>
</ol>
<p><strong>Comparison: SCF vs CF</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>SCF</th><th>CF</th></tr>
</thead>
<tbody>
<tr><td>Structure</td><td>Nested regions</td><td>Flat blocks</td></tr>
<tr><td>Control flow</td><td>Implicit (yield returns)</td><td>Explicit (br/switch)</td></tr>
<tr><td>Source mapping</td><td>Preserves match structure</td><td>Lost</td></tr>
<tr><td>Optimization</td><td>High-level (dead case elimination)</td><td>Low-level (block merging)</td></tr>
<tr><td>Readability</td><td>High (similar to source)</td><td>Low (machine-like)</td></tr>
</tbody>
</table>
</div>
<p><strong>Example: Dead case elimination at SCF level</strong></p>
<pre><code class="language-mlir">// Input: match on statically-known value
%nil = funlang.nil : !funlang.list&lt;i32&gt;
%result = funlang.match %nil : !funlang.list&lt;i32&gt; -&gt; i32 {
  ^nil: funlang.yield %zero : i32
  ^cons(%h, %t): funlang.yield %sum : i32  // Dead!
}

// After lowering to SCF
%tag_index = arith.constant 0 : index  // Statically known!
%result = scf.index_switch %tag_index : index -&gt; i32
case 0 { scf.yield %zero : i32 }
case 1 { scf.yield %sum : i32 }  // Dead case!

// SCF optimizer can eliminate case 1
%result = scf.index_switch %tag_index : index -&gt; i32
case 0 { scf.yield %zero : i32 }
// case 1 removed

// Further optimization: constant folding
%result = %zero  // Direct replacement!
</code></pre>
<p>이런 최적화는 CF level에서는 훨씬 어렵다.</p>
<h3 id="matchop-lowering-strategy"><a class="header" href="#matchop-lowering-strategy">MatchOp Lowering Strategy</a></h3>
<p><strong>Goal: <code>funlang.match</code> → <code>scf.index_switch</code> 변환</strong></p>
<p><strong>Input (FunLang):</strong></p>
<pre><code class="language-mlir">%result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
  ^nil:
    %zero = arith.constant 0 : i32
    funlang.yield %zero : i32
  ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
    %tail_sum = func.call @sum_list(%tail) : (!funlang.list&lt;i32&gt;) -&gt; i32
    %sum = arith.addi %head, %tail_sum : i32
    funlang.yield %sum : i32
}
</code></pre>
<p><strong>Output (SCF + LLVM):</strong></p>
<pre><code class="language-mlir">// 1. Convert list type to struct
%struct = builtin.unrealized_conversion_cast %lst
    : !funlang.list&lt;i32&gt; to !llvm.struct&lt;(i32, ptr)&gt;

// 2. Extract tag
%tag_i32 = llvm.extractvalue %struct[0] : !llvm.struct&lt;(i32, ptr)&gt;
%tag_index = arith.index_cast %tag_i32 : i32 to index

// 3. Extract data pointer (for cons case)
%data_ptr = llvm.extractvalue %struct[1] : !llvm.struct&lt;(i32, ptr)&gt;

// 4. Multi-way switch
%result = scf.index_switch %tag_index : index -&gt; i32
case 0 {
  // Nil case: no data to extract
  %zero = arith.constant 0 : i32
  scf.yield %zero : i32
}
case 1 {
  // Cons case: extract head and tail
  %head_ptr = %data_ptr  // Points to [head, tail] array
  %head = llvm.load %head_ptr : !llvm.ptr -&gt; i32

  %tail_ptr = llvm.getelementptr %data_ptr[1] : (!llvm.ptr) -&gt; !llvm.ptr
  %tail_struct_ptr = llvm.load %tail_ptr : !llvm.ptr -&gt; !llvm.ptr
  %tail_struct = llvm.load %tail_struct_ptr : !llvm.ptr -&gt; !llvm.struct&lt;(i32, ptr)&gt;
  %tail = builtin.unrealized_conversion_cast %tail_struct
      : !llvm.struct&lt;(i32, ptr)&gt; to !funlang.list&lt;i32&gt;

  // Cons case body (converted)
  %tail_sum = func.call @sum_list(%tail) : (!funlang.list&lt;i32&gt;) -&gt; i32
  %sum = arith.addi %head, %tail_sum : i32
  scf.yield %sum : i32
}
default {
  // Unreachable for {Nil, Cons}
  %minus = arith.constant -1 : i32
  scf.yield %minus : i32
}
</code></pre>
<p><strong>Lowering steps:</strong></p>
<ol>
<li><strong>Type conversion</strong>: <code>!funlang.list&lt;T&gt;</code> → <code>!llvm.struct&lt;(i32, ptr)&gt;</code></li>
<li><strong>Tag extraction</strong>: <code>llvm.extractvalue</code> to get tag field</li>
<li><strong>Index casting</strong>: <code>arith.index_cast</code> for <code>scf.index_switch</code> selector</li>
<li><strong>Case region cloning</strong>: 각 funlang.match case를 scf.index_switch case로 복사</li>
<li><strong>Block argument mapping</strong>: Pattern variables를 extracted values로 대체</li>
<li><strong>Terminator conversion</strong>: <code>funlang.yield</code> → <code>scf.yield</code></li>
</ol>
<h3 id="tag-value-mapping"><a class="header" href="#tag-value-mapping">Tag Value Mapping</a></h3>
<p><strong>Chapter 18 recap: List representation</strong></p>
<pre><code class="language-cpp">// NilOpLowering
Value tag = builder.create&lt;arith::ConstantIntOp&gt;(loc, 0, builder.getI32Type());

// ConsOpLowering
Value tag = builder.create&lt;arith::ConstantIntOp&gt;(loc, 1, builder.getI32Type());
</code></pre>
<p><strong>Tag mapping:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Constructor</th><th>Tag Value</th></tr>
</thead>
<tbody>
<tr><td>Nil</td><td>0</td></tr>
<tr><td>Cons</td><td>1</td></tr>
</tbody>
</table>
</div>
<p><strong>MatchOpLowering은 이 mapping을 알아야 한다:</strong></p>
<pre><code class="language-cpp">// In MatchOpLowering::matchAndRewrite
// Case 0 → Nil pattern
// Case 1 → Cons pattern
for (auto [index, region] : llvm::enumerate(matchOp.getCases())) {
  // index = 0 → Nil
  // index = 1 → Cons
  builder.create&lt;scf::IndexSwitchCaseOp&gt;(loc, index);
  // ... clone region ...
}
</code></pre>
<p><strong>Future extension: 임의의 ADT</strong></p>
<p>지금은 hardcoded mapping (Nil=0, Cons=1)이지만, 나중에는:</p>
<pre><code class="language-tablegen">// Extensible ADT definition
def Shape : FunLang_ADT&lt;"shape"&gt; {
  let constructors = [
    Constructor&lt;"circle", [F32]&gt;,           // tag = 0
    Constructor&lt;"rectangle", [F32, F32]&gt;,   // tag = 1
    Constructor&lt;"triangle", [F32, F32, F32]&gt;  // tag = 2
  ];
}
</code></pre>
<p>Compiler가 자동으로 tag 할당.</p>
<h3 id="pattern-variable-binding"><a class="header" href="#pattern-variable-binding">Pattern Variable Binding</a></h3>
<p><strong>Cons case의 challenge: block arguments를 어떻게 채우는가?</strong></p>
<p><strong>Source (FunLang):</strong></p>
<pre><code class="language-mlir">^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
  // %head와 %tail이 어디서 오는가?
  funlang.yield %sum : i32
</code></pre>
<p><strong>Lowering 후 (SCF):</strong></p>
<pre><code class="language-mlir">case 1 {
  // 여기서 %head와 %tail을 extract해야 함
  %head = llvm.load %data_ptr : !llvm.ptr -&gt; i32
  %tail = // ... complex extraction ...

  // 이제 body를 clone하면서 block arguments를 이 values로 map
  // (IRMapping 사용)
}
</code></pre>
<p><strong>IRMapping: SSA Value Remapping</strong></p>
<p>MLIR의 <code>IRMapping</code> class는 “old value → new value” mapping을 저장한다.</p>
<pre><code class="language-cpp">IRMapping mapper;
mapper.map(oldValue1, newValue1);
mapper.map(oldValue2, newValue2);

// Clone operation with mapped values
Operation* newOp = builder.clone(*oldOp, mapper);
// oldOp의 operands가 oldValue1, oldValue2였다면
// newOp의 operands는 newValue1, newValue2로 대체됨
</code></pre>
<p><strong>MatchOpLowering에서 IRMapping 사용:</strong></p>
<pre><code class="language-cpp">// Cons case region
Region&amp; consRegion = matchOp.getCases()[1];
Block* consBlock = &amp;consRegion.front();

// consBlock의 block arguments:
// consBlock-&gt;getArgument(0) = %head (i32)
// consBlock-&gt;getArgument(1) = %tail (!funlang.list&lt;i32&gt;)

// Extract actual values
Value actualHead = extractHead(builder, dataPtrConverted);
Value actualTail = extractTail(builder, dataPtrConverted, typeConverter);

// Map block arguments to extracted values
IRMapping mapper;
mapper.map(consBlock-&gt;getArgument(0), actualHead);
mapper.map(consBlock-&gt;getArgument(1), actualTail);

// Clone operations in consBlock with mapping
for (Operation&amp; op : consBlock-&gt;getOperations()) {
  if (isa&lt;YieldOp&gt;(op)) {
    // Convert funlang.yield → scf.yield
    builder.create&lt;scf::YieldOp&gt;(op.getLoc(),
                                  mapper.lookupOrDefault(op.getOperand(0)));
  } else {
    // Clone other operations with mapped operands
    builder.clone(op, mapper);
  }
}
</code></pre>
<p><strong>Result: Block arguments가 사라지고 extracted values로 대체됨</strong></p>
<pre><code class="language-mlir">// Before (funlang.match case)
^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
  %sum = arith.addi %head, %tail_sum : i32
  funlang.yield %sum : i32

// After (scf.index_switch case)
case 1 {
  %head = llvm.load ...  // Extracted value
  %tail = ...            // Extracted value
  %sum = arith.addi %head, %tail_sum : i32  // %head mapped
  scf.yield %sum : i32
}
</code></pre>
<h3 id="matchoplowering-pattern-complete-implementation"><a class="header" href="#matchoplowering-pattern-complete-implementation">MatchOpLowering Pattern: Complete Implementation</a></h3>
<p><strong>이제 전체 lowering pattern을 구현한다.</strong></p>
<p><strong>File: <code>FunLang/Transforms/FunLangToSCF.cpp</code></strong> (conceptual C++ code)</p>
<pre><code class="language-cpp">#include "mlir/Conversion/SCFToControlFlow/SCFToControlFlow.h"
#include "mlir/Dialect/Arith/IR/Arith.h"
#include "mlir/Dialect/Func/IR/FuncOps.h"
#include "mlir/Dialect/LLVM/LLVMDialect.h"
#include "mlir/Dialect/SCF/IR/SCF.h"
#include "mlir/IR/IRMapping.h"
#include "mlir/Transforms/DialectConversion.h"
#include "FunLang/IR/FunLangOps.h"
#include "FunLang/Transforms/TypeConverter.h"

using namespace mlir;
using namespace mlir::funlang;

namespace {

// Helper: Extract head from cons cell
// Input: %data_ptr points to [head, tail] array
// Output: %head value
Value extractHead(OpBuilder&amp; builder, Location loc,
                  Value dataPtrConverted, Type headType) {
  // %data_ptr already points to cons cell array
  // Load first element (head)
  Value head = builder.create&lt;LLVM::LoadOp&gt;(loc, headType, dataPtrConverted);
  return head;
}

// Helper: Extract tail from cons cell
// Input: %data_ptr points to [head, tail] array
// Output: %tail value (converted back to !funlang.list&lt;T&gt;)
Value extractTail(OpBuilder&amp; builder, Location loc,
                  Value dataPtrConverted,
                  FunLangTypeConverter* typeConverter,
                  Type tailFunLangType) {
  // GEP to second element (tail)
  Value one = builder.create&lt;arith::ConstantIntOp&gt;(loc, 1, builder.getI32Type());
  Value tailPtr = builder.create&lt;LLVM::GEPOp&gt;(
      loc, LLVM::LLVMPointerType::get(builder.getContext()),
      dataPtrConverted, ValueRange{one});

  // Load tail pointer
  Value tailStructPtr = builder.create&lt;LLVM::LoadOp&gt;(
      loc, LLVM::LLVMPointerType::get(builder.getContext()), tailPtr);

  // Load tail struct
  Type tailStructType = typeConverter-&gt;convertType(tailFunLangType);
  Value tailStruct = builder.create&lt;LLVM::LoadOp&gt;(
      loc, tailStructType, tailStructPtr);

  // Convert back to FunLang type (for remaining funlang operations in body)
  Value tail = builder.create&lt;UnrealizedConversionCastOp&gt;(
      loc, tailFunLangType, tailStruct).getResult(0);

  return tail;
}

// Helper: Convert funlang.yield to scf.yield in region
void convertYieldOps(Region&amp; region, OpBuilder&amp; builder, IRMapping&amp; mapper) {
  for (Block&amp; block : region) {
    for (Operation&amp; op : llvm::make_early_inc_range(block)) {
      if (auto yieldOp = dyn_cast&lt;YieldOp&gt;(&amp;op)) {
        builder.setInsertionPoint(yieldOp);
        Value yieldValue = mapper.lookupOrDefault(yieldOp.getValue());
        builder.create&lt;scf::YieldOp&gt;(yieldOp.getLoc(), yieldValue);
        yieldOp.erase();
      }
    }
  }
}

// Main lowering pattern
class MatchOpLowering : public OpConversionPattern&lt;MatchOp&gt; {
public:
  using OpConversionPattern&lt;MatchOp&gt;::OpConversionPattern;

  LogicalResult matchAndRewrite(
      MatchOp matchOp,
      OpAdaptor adaptor,
      ConversionPatternRewriter&amp; rewriter) const override {

    Location loc = matchOp.getLoc();
    Value input = adaptor.getInput();
    Type resultType = matchOp.getResult().getType();

    auto* typeConverter = getTypeConverter&lt;FunLangTypeConverter&gt;();

    // 1. Convert input to LLVM struct
    // input: !funlang.list&lt;T&gt; → !llvm.struct&lt;(i32, ptr)&gt;
    Type structType = typeConverter-&gt;convertType(input.getType());
    Value structVal = rewriter.create&lt;UnrealizedConversionCastOp&gt;(
        loc, structType, input).getResult(0);

    // 2. Extract tag field
    Value tag = rewriter.create&lt;LLVM::ExtractValueOp&gt;(loc, structVal, 0);

    // 3. Cast tag to index (for scf.index_switch)
    Value tagIndex = rewriter.create&lt;arith::IndexCastOp&gt;(
        loc, rewriter.getIndexType(), tag);

    // 4. Extract data pointer (needed for cons case)
    Value dataPtr = rewriter.create&lt;LLVM::ExtractValueOp&gt;(loc, structVal, 1);

    // 5. Create scf.index_switch
    auto indexSwitchOp = rewriter.create&lt;scf::IndexSwitchOp&gt;(
        loc, resultType, tagIndex, matchOp.getCases().size());

    // 6. Process each case region
    for (auto [caseIndex, caseRegion] :
         llvm::enumerate(matchOp.getCases())) {

      Block* originalBlock = &amp;caseRegion.front();
      Region&amp; switchCaseRegion = indexSwitchOp.getCaseRegions()[caseIndex];
      Block* caseBlock = rewriter.createBlock(&amp;switchCaseRegion);

      rewriter.setInsertionPointToStart(caseBlock);

      IRMapping mapper;

      // Handle block arguments (pattern variables)
      if (caseIndex == 1) {  // Cons case
        // originalBlock has 2 arguments: %head, %tail

        // Extract head
        Type headFunLangType = originalBlock-&gt;getArgument(0).getType();
        Type headLLVMType = typeConverter-&gt;convertType(headFunLangType);
        Value head = extractHead(rewriter, loc, dataPtr, headLLVMType);

        // Convert head to FunLang type if needed
        Value headFunLang = head;
        if (headFunLangType != headLLVMType) {
          headFunLang = rewriter.create&lt;UnrealizedConversionCastOp&gt;(
              loc, headFunLangType, head).getResult(0);
        }

        // Extract tail
        Type tailFunLangType = originalBlock-&gt;getArgument(1).getType();
        Value tail = extractTail(rewriter, loc, dataPtr,
                                  typeConverter, tailFunLangType);

        // Map block arguments to extracted values
        mapper.map(originalBlock-&gt;getArgument(0), headFunLang);
        mapper.map(originalBlock-&gt;getArgument(1), tail);
      }
      // Nil case (caseIndex == 0): no block arguments, no extraction

      // Clone operations from original region
      for (Operation&amp; op : originalBlock-&gt;getOperations()) {
        if (auto yieldOp = dyn_cast&lt;YieldOp&gt;(&amp;op)) {
          // Convert funlang.yield → scf.yield
          Value yieldValue = mapper.lookupOrDefault(yieldOp.getValue());
          rewriter.create&lt;scf::YieldOp&gt;(loc, yieldValue);
        } else {
          // Clone operation with mapped operands
          rewriter.clone(op, mapper);
        }
      }
    }

    // 7. Add default region (unreachable for complete constructor sets)
    {
      Region&amp; defaultRegion = indexSwitchOp.getDefaultRegion();
      Block* defaultBlock = rewriter.createBlock(&amp;defaultRegion);
      rewriter.setInsertionPointToStart(defaultBlock);

      // Emit error value (this should never execute)
      Value errorVal;
      if (resultType.isIntOrIndex()) {
        errorVal = rewriter.create&lt;arith::ConstantIntOp&gt;(loc, -1, resultType);
      } else {
        // For other types, emit unreachable or null
        errorVal = rewriter.create&lt;LLVM::ZeroOp&gt;(loc, resultType);
      }

      rewriter.create&lt;scf::YieldOp&gt;(loc, errorVal);
    }

    // 8. Replace match operation with index_switch result
    rewriter.replaceOp(matchOp, indexSwitchOp.getResult(0));

    return success();
  }
};

} // namespace

// Pass definition
struct FunLangToSCFPass
    : public PassWrapper&lt;FunLangToSCFPass, OperationPass&lt;ModuleOp&gt;&gt; {

  void getDependentDialects(DialectRegistry&amp; registry) const override {
    registry.insert&lt;arith::ArithDialect,
                    scf::SCFDialect,
                    LLVM::LLVMDialect&gt;();
  }

  void runOnOperation() override {
    auto module = getOperation();
    auto* context = &amp;getContext();

    FunLangTypeConverter typeConverter;
    ConversionTarget target(*context);

    // Mark funlang.match as illegal (must be lowered)
    target.addIllegalOp&lt;MatchOp&gt;();

    // Mark SCF operations as legal
    target.addLegalDialect&lt;scf::SCFDialect&gt;();
    target.addLegalDialect&lt;arith::ArithDialect&gt;();
    target.addLegalDialect&lt;LLVM::LLVMDialect&gt;();
    target.addLegalDialect&lt;func::FuncDialect&gt;();

    // Keep other FunLang ops legal (lowered in FunLangToLLVM pass)
    target.addLegalOp&lt;NilOp, ConsOp, ClosureOp, ApplyOp&gt;();

    RewritePatternSet patterns(context);
    patterns.add&lt;MatchOpLowering&gt;(typeConverter, context);

    if (failed(applyPartialConversion(module, target, std::move(patterns)))) {
      signalPassFailure();
    }
  }
};

std::unique_ptr&lt;Pass&gt; createFunLangToSCFPass() {
  return std::make_unique&lt;FunLangToSCFPass&gt;();
}
</code></pre>
<p><strong>핵심 로직 분석:</strong></p>
<p><strong>1. Type conversion (lines ~95-100)</strong></p>
<pre><code class="language-cpp">Type structType = typeConverter-&gt;convertType(input.getType());
Value structVal = rewriter.create&lt;UnrealizedConversionCastOp&gt;(
    loc, structType, input).getResult(0);
</code></pre>
<p><code>!funlang.list&lt;i32&gt;</code> → <code>!llvm.struct&lt;(i32, ptr)&gt;</code> 변환.</p>
<p><code>UnrealizedConversionCastOp</code>는 type conversion의 placeholder다. 나중에 다른 pass가 이를 실제 operations로 대체하거나 제거한다.</p>
<p><strong>2. Tag extraction (lines ~103-108)</strong></p>
<pre><code class="language-cpp">Value tag = rewriter.create&lt;LLVM::ExtractValueOp&gt;(loc, structVal, 0);
Value tagIndex = rewriter.create&lt;arith::IndexCastOp&gt;(
    loc, rewriter.getIndexType(), tag);
</code></pre>
<p>Struct의 첫 번째 field (tag)를 추출하고 index type으로 cast.</p>
<p><strong>3. scf.index_switch creation (lines ~113-115)</strong></p>
<pre><code class="language-cpp">auto indexSwitchOp = rewriter.create&lt;scf::IndexSwitchOp&gt;(
    loc, resultType, tagIndex, matchOp.getCases().size());
</code></pre>
<p>N개의 cases를 가진 index_switch 생성.</p>
<p><strong>4. Region cloning (lines ~118-160)</strong></p>
<p>각 case region을 iterate하며:</p>
<ul>
<li><strong>Nil case (caseIndex == 0)</strong>: Block arguments 없음, 그냥 clone</li>
<li><strong>Cons case (caseIndex == 1)</strong>: Block arguments 있음, extract + map</li>
</ul>
<p><strong>5. IRMapping for block arguments (lines ~130-148)</strong></p>
<pre><code class="language-cpp">mapper.map(originalBlock-&gt;getArgument(0), headFunLang);
mapper.map(originalBlock-&gt;getArgument(1), tail);
</code></pre>
<p>Original block의 arguments를 extracted values로 mapping.</p>
<p><strong>6. Operation cloning (lines ~152-159)</strong></p>
<pre><code class="language-cpp">for (Operation&amp; op : originalBlock-&gt;getOperations()) {
  if (auto yieldOp = dyn_cast&lt;YieldOp&gt;(&amp;op)) {
    Value yieldValue = mapper.lookupOrDefault(yieldOp.getValue());
    rewriter.create&lt;scf::YieldOp&gt;(loc, yieldValue);
  } else {
    rewriter.clone(op, mapper);
  }
}
</code></pre>
<ul>
<li><code>funlang.yield</code> → <code>scf.yield</code> 변환</li>
<li>다른 operations는 mapper와 함께 clone</li>
</ul>
<p><strong>7. Default region (lines ~163-176)</strong></p>
<p>Unreachable case를 위한 default region 생성.</p>
<h3 id="complete-pipeline-pass-registration"><a class="header" href="#complete-pipeline-pass-registration">Complete Pipeline: Pass Registration</a></h3>
<p><strong>전체 lowering pipeline:</strong></p>
<pre><code>FunLang Dialect (with match, nil, cons, closure, apply)
    ↓
[FunLangToSCFPass]
    ↓
FunLang (without match) + SCF
    ↓
[FunLangToLLVMPass] (lowers nil, cons, closure, apply)
    ↓
LLVM + SCF
    ↓
[SCFToControlFlowPass]
    ↓
LLVM + CF
    ↓
[ConvertControlFlowToLLVMPass]
    ↓
LLVM Dialect only
    ↓
[LLVMToObjectPass]
    ↓
Object file
</code></pre>
<p><strong>Pass manager setup (F# code):</strong></p>
<pre><code class="language-fsharp">// File: FunLang.Compiler/Pipeline.fs

let lowerToLLVM (module_: Module) =
    let pm = PassManager.Create(module_.Context)

    // 1. FunLang → SCF (lower match operation)
    pm.AddPass(FunLangPasses.CreateFunLangToSCFPass())

    // 2. FunLang → LLVM (lower nil, cons, closure, apply)
    pm.AddPass(FunLangPasses.CreateFunLangToLLVMPass())

    // 3. SCF → CF
    pm.AddPass(SCFPasses.CreateSCFToControlFlowPass())

    // 4. CF → LLVM
    pm.AddPass(ConversionPasses.CreateConvertControlFlowToLLVMPass())

    // 5. Func → LLVM
    pm.AddPass(ConversionPasses.CreateConvertFuncToLLVMPass())

    // 6. Arith → LLVM
    pm.AddPass(ConversionPasses.CreateConvertArithToLLVMPass())

    pm.Run(module_) |&gt; ignore
</code></pre>
<p><strong>Pass dependencies:</strong></p>
<ul>
<li>
<p><code>FunLangToSCFPass</code> must run <strong>before</strong> <code>FunLangToLLVMPass</code></p>
<ul>
<li>Reason: MatchOp의 regions에 다른 FunLang ops (nil, cons, etc.) 포함</li>
<li>SCF로 변환 후 남은 FunLang ops를 LLVM으로 변환</li>
</ul>
</li>
<li>
<p><code>SCFToControlFlowPass</code> must run <strong>after</strong> all FunLang lowering</p>
<ul>
<li>Reason: SCF ops는 다른 dialects가 모두 LLVM으로 변환된 후 lower</li>
</ul>
</li>
<li>
<p><code>ConvertFuncToLLVMPass</code> must run <strong>after</strong> SCF/CF conversion</p>
<ul>
<li>Reason: Function signatures에 FunLang types가 남아있으면 안 됨</li>
</ul>
</li>
</ul>
<h3 id="end-to-end-example-sum_list-function"><a class="header" href="#end-to-end-example-sum_list-function">End-to-End Example: sum_list Function</a></h3>
<p><strong>F# source code:</strong></p>
<pre><code class="language-fsharp">// FunLang source
let rec sum_list lst =
    match lst with
    | [] -&gt; 0
    | head :: tail -&gt; head + sum_list tail

let main () =
    let my_list = [1; 2; 3]
    sum_list my_list
</code></pre>
<p><strong>Stage 1: FunLang Dialect (after F# compiler)</strong></p>
<pre><code class="language-mlir">module {
  func.func @sum_list(%lst: !funlang.list&lt;i32&gt;) -&gt; i32 {
    %result = funlang.match %lst : !funlang.list&lt;i32&gt; -&gt; i32 {
      ^nil:
        %zero = arith.constant 0 : i32
        funlang.yield %zero : i32
      ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
        %tail_sum = func.call @sum_list(%tail) : (!funlang.list&lt;i32&gt;) -&gt; i32
        %sum = arith.addi %head, %tail_sum : i32
        funlang.yield %sum : i32
    }
    return %result : i32
  }

  func.func @main() -&gt; i32 {
    // Build list [1, 2, 3]
    %nil = funlang.nil : !funlang.list&lt;i32&gt;

    %c3 = arith.constant 3 : i32
    %l3 = funlang.cons %c3, %nil : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;

    %c2 = arith.constant 2 : i32
    %l2 = funlang.cons %c2, %l3 : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;

    %c1 = arith.constant 1 : i32
    %l1 = funlang.cons %c1, %l2 : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;

    // Call sum_list
    %sum = func.call @sum_list(%l1) : (!funlang.list&lt;i32&gt;) -&gt; i32
    return %sum : i32
  }
}
</code></pre>
<p><strong>Stage 2: After FunLangToSCFPass</strong></p>
<pre><code class="language-mlir">module {
  func.func @sum_list(%lst: !funlang.list&lt;i32&gt;) -&gt; i32 {
    // Type conversion
    %struct = builtin.unrealized_conversion_cast %lst
        : !funlang.list&lt;i32&gt; to !llvm.struct&lt;(i32, ptr)&gt;

    // Tag extraction
    %tag = llvm.extractvalue %struct[0] : !llvm.struct&lt;(i32, ptr)&gt;
    %tag_index = arith.index_cast %tag : i32 to index

    // Data pointer
    %data_ptr = llvm.extractvalue %struct[1] : !llvm.struct&lt;(i32, ptr)&gt;

    // Index switch
    %result = scf.index_switch %tag_index : index -&gt; i32
    case 0 {
      %zero = arith.constant 0 : i32
      scf.yield %zero : i32
    }
    case 1 {
      // Extract head
      %head = llvm.load %data_ptr : !llvm.ptr -&gt; i32

      // Extract tail
      %one = arith.constant 1 : i32
      %tail_ptr = llvm.getelementptr %data_ptr[%one] : (!llvm.ptr, i32) -&gt; !llvm.ptr
      %tail_struct_ptr = llvm.load %tail_ptr : !llvm.ptr -&gt; !llvm.ptr
      %tail_struct = llvm.load %tail_struct_ptr : !llvm.ptr -&gt; !llvm.struct&lt;(i32, ptr)&gt;
      %tail = builtin.unrealized_conversion_cast %tail_struct
          : !llvm.struct&lt;(i32, ptr)&gt; to !funlang.list&lt;i32&gt;

      // Recursive call
      %tail_sum = func.call @sum_list(%tail) : (!funlang.list&lt;i32&gt;) -&gt; i32

      // Sum
      %sum = arith.addi %head, %tail_sum : i32
      scf.yield %sum : i32
    }
    default {
      %error = arith.constant -1 : i32
      scf.yield %error : i32
    }

    return %result : i32
  }

  func.func @main() -&gt; i32 {
    // Still has funlang.nil and funlang.cons (not lowered yet)
    %nil = funlang.nil : !funlang.list&lt;i32&gt;
    %c3 = arith.constant 3 : i32
    %l3 = funlang.cons %c3, %nil : (i32, !funlang.list&lt;i32&gt;) -&gt; !funlang.list&lt;i32&gt;
    // ...
    %sum = func.call @sum_list(%l1) : (!funlang.list&lt;i32&gt;) -&gt; i32
    return %sum : i32
  }
}
</code></pre>
<p><strong>Stage 3: After FunLangToLLVMPass</strong></p>
<pre><code class="language-mlir">module {
  func.func @sum_list(%lst: !llvm.struct&lt;(i32, ptr)&gt;) -&gt; i32 {
    // ... same as Stage 2 but types converted ...
    %tag = llvm.extractvalue %lst[0] : !llvm.struct&lt;(i32, ptr)&gt;
    %tag_index = arith.index_cast %tag : i32 to index
    %data_ptr = llvm.extractvalue %lst[1] : !llvm.struct&lt;(i32, ptr)&gt;

    %result = scf.index_switch %tag_index : index -&gt; i32
    case 0 { /* ... */ }
    case 1 { /* ... */ }
    default { /* ... */ }

    return %result : i32
  }

  func.func @main() -&gt; i32 {
    // funlang.nil and funlang.cons lowered to LLVM
    %c0 = arith.constant 0 : i32
    %null = llvm.mlir.zero : !llvm.ptr
    %undef_nil = llvm.mlir.undef : !llvm.struct&lt;(i32, ptr)&gt;
    %s1_nil = llvm.insertvalue %c0, %undef_nil[0] : !llvm.struct&lt;(i32, ptr)&gt;
    %nil = llvm.insertvalue %null, %s1_nil[1] : !llvm.struct&lt;(i32, ptr)&gt;

    %c3 = arith.constant 3 : i32
    %c1_tag = arith.constant 1 : i32
    %size = arith.constant 16 : i64  // sizeof(cons cell)
    %ptr = llvm.call @GC_malloc(%size) : (i64) -&gt; !llvm.ptr
    llvm.store %c3, %ptr : i32, !llvm.ptr
    %tail_ptr = llvm.getelementptr %ptr[1] : (!llvm.ptr) -&gt; !llvm.ptr
    // ... store tail ...
    %undef_cons = llvm.mlir.undef : !llvm.struct&lt;(i32, ptr)&gt;
    %s1_cons = llvm.insertvalue %c1_tag, %undef_cons[0] : !llvm.struct&lt;(i32, ptr)&gt;
    %l3 = llvm.insertvalue %ptr, %s1_cons[1] : !llvm.struct&lt;(i32, ptr)&gt;

    // ...
    %sum = func.call @sum_list(%l1) : (!llvm.struct&lt;(i32, ptr)&gt;) -&gt; i32
    return %sum : i32
  }
}
</code></pre>
<p><strong>Stage 4: After SCFToControlFlowPass</strong></p>
<pre><code class="language-mlir">module {
  func.func @sum_list(%lst: !llvm.struct&lt;(i32, ptr)&gt;) -&gt; i32 {
    %tag = llvm.extractvalue %lst[0] : !llvm.struct&lt;(i32, ptr)&gt;
    %tag_index = arith.index_cast %tag : i32 to index
    %data_ptr = llvm.extractvalue %lst[1] : !llvm.struct&lt;(i32, ptr)&gt;

    // scf.index_switch → cf.switch
    cf.switch %tag_index : index, [
      default: ^default,
      0: ^case_0,
      1: ^case_1
    ]

  ^case_0:
    %zero = arith.constant 0 : i32
    cf.br ^merge(%zero : i32)

  ^case_1:
    %head = llvm.load %data_ptr : !llvm.ptr -&gt; i32
    // ... extract tail ...
    %tail_sum = func.call @sum_list(%tail) : (!llvm.struct&lt;(i32, ptr)&gt;) -&gt; i32
    %sum = arith.addi %head, %tail_sum : i32
    cf.br ^merge(%sum : i32)

  ^default:
    %error = arith.constant -1 : i32
    cf.br ^merge(%error : i32)

  ^merge(%result: i32):
    return %result : i32
  }

  func.func @main() -&gt; i32 {
    // ... LLVM code for list construction ...
    %sum = func.call @sum_list(%l1) : (!llvm.struct&lt;(i32, ptr)&gt;) -&gt; i32
    return %sum : i32
  }
}
</code></pre>
<p><strong>Stage 5: After ConvertControlFlowToLLVMPass + ConvertFuncToLLVMPass</strong></p>
<pre><code class="language-mlir">llvm.func @sum_list(%arg0: !llvm.struct&lt;(i32, ptr)&gt;) -&gt; i32 {
  %0 = llvm.extractvalue %arg0[0] : !llvm.struct&lt;(i32, ptr)&gt;
  %1 = llvm.sext %0 : i32 to i64  // index cast
  %2 = llvm.extractvalue %arg0[1] : !llvm.struct&lt;(i32, ptr)&gt;

  llvm.switch %1 : i64, ^default [
    0: ^case_0,
    1: ^case_1
  ]

^case_0:
  %c0 = llvm.mlir.constant(0 : i32) : i32
  llvm.br ^merge(%c0 : i32)

^case_1:
  %head = llvm.load %2 : !llvm.ptr -&gt; i32
  // ... tail extraction ...
  %tail_sum = llvm.call @sum_list(%tail) : (!llvm.struct&lt;(i32, ptr)&gt;) -&gt; i32
  %sum = llvm.add %head, %tail_sum : i32
  llvm.br ^merge(%sum : i32)

^default:
  %error = llvm.mlir.constant(-1 : i32) : i32
  llvm.br ^merge(%error : i32)

^merge(%result: i32):
  llvm.return %result : i32
}

llvm.func @main() -&gt; i32 {
  // ... LLVM code ...
  %sum = llvm.call @sum_list(%l1) : (!llvm.struct&lt;(i32, ptr)&gt;) -&gt; i32
  llvm.return %sum : i32
}
</code></pre>
<p><strong>Stage 6: Native code (after llc + linking)</strong></p>
<pre><code class="language-bash">$ ./funlang_program
6
</code></pre>
<p><strong>Pipeline verification at each stage:</strong></p>
<pre><code class="language-bash"># After each pass, verify IR
$ mlir-opt --funlang-to-scf --verify-diagnostics input.mlir
$ mlir-opt --funlang-to-llvm --verify-diagnostics input.mlir
$ mlir-opt --convert-scf-to-cf --verify-diagnostics input.mlir
</code></pre>
<h3 id="common-errors-and-debugging"><a class="header" href="#common-errors-and-debugging">Common Errors and Debugging</a></h3>
<p><strong>Error 1: Block argument count mismatch</strong></p>
<p><strong>Symptom:</strong></p>
<pre><code>error: 'scf.yield' op result type mismatch
</code></pre>
<p><strong>Cause:</strong></p>
<p>Cons case region의 block arguments 개수가 틀림.</p>
<pre><code class="language-cpp">// Wrong: forgot to map tail argument
mapper.map(originalBlock-&gt;getArgument(0), headFunLang);
// Missing: mapper.map(originalBlock-&gt;getArgument(1), tail);
</code></pre>
<p><strong>Fix:</strong></p>
<p>모든 block arguments를 map해야 함.</p>
<pre><code class="language-cpp">mapper.map(originalBlock-&gt;getArgument(0), headFunLang);
mapper.map(originalBlock-&gt;getArgument(1), tail);  // ✅
</code></pre>
<p><strong>Error 2: Type mismatch after region cloning</strong></p>
<p><strong>Symptom:</strong></p>
<pre><code>error: 'func.call' op operand type mismatch: expected '!llvm.struct&lt;...&gt;', got '!funlang.list&lt;...&gt;'
</code></pre>
<p><strong>Cause:</strong></p>
<p>Region 내부의 operations가 아직 type conversion 안 됨.</p>
<p><strong>Why:</strong></p>
<p><code>FunLangToSCFPass</code>는 partial conversion이다. Match operation만 lower하고 나머지 FunLang ops는 그대로 둔다.</p>
<p><strong>Fix:</strong></p>
<p>Region cloning 후 남은 FunLang operations는 다음 pass (<code>FunLangToLLVMPass</code>)에서 처리됨.</p>
<p>Temporary workaround: <code>UnrealizedConversionCastOp</code> 사용.</p>
<pre><code class="language-cpp">Value tail = extractTail(...);  // Returns LLVM struct
// Cast back to FunLang type for func.call
Value tailFunLang = rewriter.create&lt;UnrealizedConversionCastOp&gt;(
    loc, tailFunLangType, tail).getResult(0);
</code></pre>
<p><strong>Error 3: Missing scf.yield in converted regions</strong></p>
<p><strong>Symptom:</strong></p>
<pre><code>error: block must terminate with scf.yield
</code></pre>
<p><strong>Cause:</strong></p>
<p><code>funlang.yield</code>를 <code>scf.yield</code>로 변환하는 걸 까먹음.</p>
<pre><code class="language-cpp">// Wrong: just clone YieldOp as-is
for (Operation&amp; op : originalBlock-&gt;getOperations()) {
  rewriter.clone(op, mapper);  // funlang.yield gets cloned!
}
</code></pre>
<p><strong>Fix:</strong></p>
<p>YieldOp를 특별히 처리해서 변환.</p>
<pre><code class="language-cpp">for (Operation&amp; op : originalBlock-&gt;getOperations()) {
  if (auto yieldOp = dyn_cast&lt;YieldOp&gt;(&amp;op)) {
    Value yieldValue = mapper.lookupOrDefault(yieldOp.getValue());
    rewriter.create&lt;scf::YieldOp&gt;(loc, yieldValue);  // ✅ Convert
  } else {
    rewriter.clone(op, mapper);
  }
}
</code></pre>
<p><strong>Error 4: Wrong tag values (0 vs 1 confusion)</strong></p>
<p><strong>Symptom:</strong></p>
<p>런타임에 엉뚱한 case가 실행됨. 예: Nil list인데 Cons case 실행.</p>
<p><strong>Cause:</strong></p>
<p>Tag mapping이 틀림.</p>
<pre><code class="language-cpp">// Wrong: reversed mapping
// case 0 → Cons (wrong!)
// case 1 → Nil (wrong!)
</code></pre>
<p><strong>Fix:</strong></p>
<p>Chapter 18의 tag values와 일치시켜야 함:</p>
<pre><code class="language-cpp">// Correct mapping
// case 0 → Nil  (tag = 0)
// case 1 → Cons (tag = 1)
for (auto [caseIndex, caseRegion] : llvm::enumerate(matchOp.getCases())) {
  // caseIndex = 0 → Nil region (first in match)
  // caseIndex = 1 → Cons region (second in match)
}
</code></pre>
<p><strong>F# compiler는 pattern 순서를 보장해야 함:</strong></p>
<pre><code class="language-fsharp">// F# compiler must emit cases in this order:
// Case 0: Nil
// Case 1: Cons
match lst with
| [] -&gt; ...        // Must be first case
| head :: tail -&gt; ... // Must be second case
</code></pre>
<p><strong>Error 5: Incorrect data extraction from cons cell</strong></p>
<p><strong>Symptom:</strong></p>
<p>런타임 segfault or garbage values.</p>
<p><strong>Cause:</strong></p>
<p>GEP indices 틀림.</p>
<pre><code class="language-cpp">// Wrong: GEP from struct pointer
Value tailPtr = builder.create&lt;LLVM::GEPOp&gt;(
    loc, ptrType, structVal, ValueRange{one});  // ❌ structVal is value not pointer
</code></pre>
<p><strong>Fix:</strong></p>
<p>Data pointer는 이미 cons cell array를 가리킴.</p>
<pre><code class="language-cpp">// Correct: dataPtr already points to [head, tail] array
Value headPtr = dataPtr;  // Points to head
Value head = builder.create&lt;LLVM::LoadOp&gt;(loc, headType, headPtr);

Value one = builder.create&lt;arith::ConstantIntOp&gt;(loc, 1, i32Type);
Value tailPtr = builder.create&lt;LLVM::GEPOp&gt;(
    loc, ptrType, dataPtr, ValueRange{one});  // ✅ GEP from array pointer
</code></pre>
<p><strong>Debugging strategies:</strong></p>
<ol>
<li><strong>Print IR after each pass:</strong></li>
</ol>
<pre><code class="language-bash">$ mlir-opt --funlang-to-scf --print-ir-after-all input.mlir
</code></pre>
<ol start="2">
<li><strong>Use verifier:</strong></li>
</ol>
<pre><code class="language-bash">$ mlir-opt --funlang-to-scf --verify-diagnostics input.mlir
</code></pre>
<ol start="3">
<li><strong>Dump operations in lowering code:</strong></li>
</ol>
<pre><code class="language-cpp">matchOp.dump();  // Before lowering
indexSwitchOp.dump();  // After lowering
</code></pre>
<ol start="4">
<li><strong>Check IRMapping:</strong></li>
</ol>
<pre><code class="language-cpp">for (auto [caseIndex, region] : enumerate(matchOp.getCases())) {
  Block* block = &amp;region.front();
  llvm::errs() &lt;&lt; "Case " &lt;&lt; caseIndex &lt;&lt; ":\n";
  for (BlockArgument arg : block-&gt;getArguments()) {
    llvm::errs() &lt;&lt; "  Arg: " &lt;&lt; arg &lt;&lt; " → "
                 &lt;&lt; mapper.lookupOrDefault(arg) &lt;&lt; "\n";
  }
}
</code></pre>
<hr>
<h2 id="리터럴-패턴-로우어링"><a class="header" href="#리터럴-패턴-로우어링">리터럴 패턴 로우어링</a></h2>
<p>지금까지 constructor patterns (Nil, Cons)를 위한 lowering을 설명했다. 이제 <strong>리터럴 패턴</strong>을 위한 lowering 전략을 다룬다.</p>
<h3 id="constructor-vs-literal-dispatch"><a class="header" href="#constructor-vs-literal-dispatch">Constructor vs Literal Dispatch</a></h3>
<p><strong>Constructor 패턴과 리터럴 패턴의 핵심 차이:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>특성</th><th>Constructor</th><th>Literal</th></tr>
</thead>
<tbody>
<tr><td>값의 범위</td><td>유한 (finite)</td><td>무한 (infinite)</td></tr>
<tr><td>테스트</td><td>Tag extraction</td><td>Value comparison</td></tr>
<tr><td>MLIR dispatch</td><td><code>scf.index_switch</code></td><td><code>arith.cmpi</code> + <code>scf.if</code></td></tr>
<tr><td>Complexity</td><td>O(1)</td><td>O(n) sequential</td></tr>
</tbody>
</table>
</div>
<p><strong>Constructor patterns use <code>scf.index_switch</code>:</strong></p>
<p>Tag는 유한한 범위 (예: 0 = Nil, 1 = Cons)이므로 jump table이 가능하다.</p>
<pre><code class="language-mlir">// Constructor dispatch: O(1)
%tag = llvm.extractvalue %list[0] : !llvm.struct&lt;(i32, ptr)&gt;
%tag_index = arith.index_cast %tag : i32 to index

%result = scf.index_switch %tag_index : index -&gt; i32
case 0 { /* Nil case */ scf.yield ... }
case 1 { /* Cons case */ scf.yield ... }
default { scf.yield %unreachable : i32 }
</code></pre>
<p><strong>Literal patterns use <code>arith.cmpi</code> + <code>scf.if</code> chain:</strong></p>
<p>정수 리터럴은 무한하므로 순차적 비교가 필요하다.</p>
<pre><code class="language-mlir">// Literal dispatch: O(n)
%is_zero = arith.cmpi eq, %x, %c0 : i32
%result = scf.if %is_zero -&gt; i32 {
    scf.yield %zero_result : i32
} else {
    %is_one = arith.cmpi eq, %x, %c1 : i32
    %inner = scf.if %is_one -&gt; i32 {
        scf.yield %one_result : i32
    } else {
        scf.yield %default_result : i32
    }
    scf.yield %inner : i32
}
</code></pre>
<h3 id="리터럴-패턴-lowering-구현"><a class="header" href="#리터럴-패턴-lowering-구현">리터럴 패턴 Lowering 구현</a></h3>
<p><strong>리터럴 매칭을 위한 C++ lowering pattern:</strong></p>
<pre><code class="language-cpp">// LiteralMatchLowering.cpp

class LiteralMatchOpLowering : public OpConversionPattern&lt;LiteralMatchOp&gt; {
public:
  using OpConversionPattern&lt;LiteralMatchOp&gt;::OpConversionPattern;

  LogicalResult matchAndRewrite(
      LiteralMatchOp matchOp,
      OpAdaptor adaptor,
      ConversionPatternRewriter&amp; rewriter) const override {

    Location loc = matchOp.getLoc();
    Value scrutinee = adaptor.getScrutinee();
    Type resultType = matchOp.getResult().getType();

    // Collect all cases: (literal_value, region)
    auto cases = matchOp.getCases();
    Region* defaultRegion = matchOp.getDefaultRegion();

    // Build nested scf.if chain from bottom up
    Value result = buildIfChain(rewriter, loc, scrutinee,
                                 cases, defaultRegion, resultType);

    rewriter.replaceOp(matchOp, result);
    return success();
  }

private:
  Value buildIfChain(
      ConversionPatternRewriter&amp; rewriter,
      Location loc,
      Value scrutinee,
      ArrayRef&lt;std::pair&lt;int64_t, Region*&gt;&gt; cases,
      Region* defaultRegion,
      Type resultType) const {

    // Base case: no more cases, use default
    if (cases.empty()) {
      return cloneRegionAndGetResult(rewriter, loc, defaultRegion, resultType);
    }

    // Current case
    auto [literalValue, caseRegion] = cases.front();
    auto remainingCases = cases.drop_front();

    // Create comparison: scrutinee == literal
    Value literalConst = rewriter.create&lt;arith::ConstantIntOp&gt;(
        loc, literalValue, scrutinee.getType());
    Value isMatch = rewriter.create&lt;arith::CmpIOp&gt;(
        loc, arith::CmpIPredicate::eq, scrutinee, literalConst);

    // Create scf.if
    auto ifOp = rewriter.create&lt;scf::IfOp&gt;(
        loc, resultType, isMatch,
        /*thenBuilder=*/[&amp;](OpBuilder&amp; b, Location loc) {
          Value result = cloneRegionAndGetResult(b, loc, caseRegion, resultType);
          b.create&lt;scf::YieldOp&gt;(loc, result);
        },
        /*elseBuilder=*/[&amp;](OpBuilder&amp; b, Location loc) {
          Value result = buildIfChain(
              rewriter, loc, scrutinee, remainingCases, defaultRegion, resultType);
          b.create&lt;scf::YieldOp&gt;(loc, result);
        });

    return ifOp.getResult(0);
  }

  Value cloneRegionAndGetResult(
      OpBuilder&amp; builder,
      Location loc,
      Region* region,
      Type resultType) const {
    // Clone operations from region
    IRMapping mapper;
    for (Operation&amp; op : region-&gt;front()) {
      if (auto yieldOp = dyn_cast&lt;YieldOp&gt;(&amp;op)) {
        return mapper.lookupOrDefault(yieldOp.getValue());
      } else {
        builder.clone(op, mapper);
      }
    }
    llvm_unreachable("Region must end with yield");
  }
};
</code></pre>
<p><strong>생성된 IR 예제:</strong></p>
<pre><code class="language-fsharp">// FunLang source
match x with
| 0 -&gt; "zero"
| 1 -&gt; "one"
| _ -&gt; "other"
</code></pre>
<pre><code class="language-mlir">// After lowering: nested scf.if chain
%c0 = arith.constant 0 : i32
%c1 = arith.constant 1 : i32

%is_zero = arith.cmpi eq, %x, %c0 : i32
%result = scf.if %is_zero -&gt; !llvm.ptr&lt;i8&gt; {
    scf.yield %zero_str : !llvm.ptr&lt;i8&gt;
} else {
    %is_one = arith.cmpi eq, %x, %c1 : i32
    %inner = scf.if %is_one -&gt; !llvm.ptr&lt;i8&gt; {
        scf.yield %one_str : !llvm.ptr&lt;i8&gt;
    } else {
        // Default case: no comparison
        scf.yield %other_str : !llvm.ptr&lt;i8&gt;
    }
    scf.yield %inner : !llvm.ptr&lt;i8&gt;
}
</code></pre>
<h3 id="최적화-기회-optimization-opportunities"><a class="header" href="#최적화-기회-optimization-opportunities">최적화 기회 (Optimization Opportunities)</a></h3>
<p><strong>1. Dense Range Detection</strong></p>
<p>리터럴이 0, 1, 2, … 연속일 때 <code>scf.index_switch</code>로 변환 가능:</p>
<pre><code class="language-mlir">// Before: sequential comparisons
%is_0 = arith.cmpi eq, %x, %c0
scf.if %is_0 { ... } else {
    %is_1 = arith.cmpi eq, %x, %c1
    scf.if %is_1 { ... } else {
        %is_2 = arith.cmpi eq, %x, %c2
        // ...
    }
}

// After: range check + index_switch
%in_range = arith.cmpi ult, %x, %c3 : i32
scf.if %in_range {
    %idx = arith.index_cast %x : i32 to index
    scf.index_switch %idx : index -&gt; i32
    case 0 { /* case 0 */ }
    case 1 { /* case 1 */ }
    case 2 { /* case 2 */ }
} else {
    // default
}
</code></pre>
<p><strong>Dense range detection algorithm:</strong></p>
<pre><code class="language-cpp">bool isDenseRange(ArrayRef&lt;int64_t&gt; literals) {
  if (literals.empty()) return false;

  // Sort literals
  SmallVector&lt;int64_t&gt; sorted(literals.begin(), literals.end());
  llvm::sort(sorted);

  // Check if consecutive
  for (size_t i = 1; i &lt; sorted.size(); ++i) {
    if (sorted[i] != sorted[i-1] + 1)
      return false;
  }

  // Starts from 0 or 1 (common case)
  return sorted[0] == 0 || sorted[0] == 1;
}
</code></pre>
<p><strong>2. Sparse Set Optimization</strong></p>
<p>리터럴이 sparse할 때 (예: 0, 10, 100) binary search 가능:</p>
<pre><code class="language-mlir">// O(log n) with binary search
%mid = arith.constant 10 : i32
%less_than_mid = arith.cmpi slt, %x, %mid : i32
scf.if %less_than_mid {
    // Check 0
    %is_0 = arith.cmpi eq, %x, %c0
    scf.if %is_0 { ... } else { /* default */ }
} else {
    // Check 10, 100
    %is_10 = arith.cmpi eq, %x, %c10
    scf.if %is_10 { ... } else {
        %is_100 = arith.cmpi eq, %x, %c100
        scf.if %is_100 { ... } else { /* default */ }
    }
}
</code></pre>
<p>이 최적화는 MLIR transformation pass로 구현 가능 (Phase 7).</p>
<p><strong>3. LLVM Backend Optimization</strong></p>
<p>SCF → CF → LLVM pipeline 후 LLVM backend가 추가 최적화:</p>
<pre><code class="language-llvm">; LLVM will recognize this pattern
%cmp0 = icmp eq i32 %x, 0
br i1 %cmp0, label %case0, label %check1
check1:
%cmp1 = icmp eq i32 %x, 1
br i1 %cmp1, label %case1, label %default

; And optimize to switch:
switch i32 %x, label %default [
    i32 0, label %case0
    i32 1, label %case1
]
</code></pre>
<p><strong>LLVM switch lowering:</strong></p>
<ul>
<li>Dense: jump table (O(1))</li>
<li>Sparse: binary search tree (O(log n))</li>
<li>Very sparse: linear search (O(n))</li>
</ul>
<h3 id="mixed-patterns-constructor--literal"><a class="header" href="#mixed-patterns-constructor--literal">Mixed Patterns: Constructor + Literal</a></h3>
<p><strong>실제 코드는 constructor와 literal을 섞어 쓴다:</strong></p>
<pre><code class="language-fsharp">match (list, n) with
| (Nil, _) -&gt; 0
| (Cons(x, _), 0) -&gt; x
| (Cons(x, xs), n) -&gt; x + process xs (n - 1)
</code></pre>
<p><strong>Lowering 전략:</strong></p>
<ol>
<li><strong>First column (list)</strong>: Constructor pattern → <code>scf.index_switch</code></li>
<li><strong>Second column (n)</strong>: Literal pattern → <code>arith.cmpi</code> + <code>scf.if</code></li>
</ol>
<pre><code class="language-mlir">// Step 1: Constructor dispatch on list
%list_tag = llvm.extractvalue %list[0] : !llvm.struct&lt;(i32, ptr)&gt;
%tag_index = arith.index_cast %list_tag : i32 to index

%result = scf.index_switch %tag_index : index -&gt; i32
case 0 {
    // Nil case: wildcard on n (no test)
    %zero = arith.constant 0 : i32
    scf.yield %zero : i32
}
case 1 {
    // Cons case: extract data
    %data = llvm.extractvalue %list[1] : !llvm.struct&lt;(i32, ptr)&gt;
    %x = llvm.load %data : !llvm.ptr -&gt; i32

    // Step 2: Literal dispatch on n
    %is_zero = arith.cmpi eq, %n, %c0 : i32
    %inner = scf.if %is_zero -&gt; i32 {
        // Case: Cons(x, _), 0 → x
        scf.yield %x : i32
    } else {
        // Case: Cons(x, xs), n → x + process xs (n-1)
        %tail_ptr = llvm.getelementptr %data[1] : (!llvm.ptr) -&gt; !llvm.ptr
        %xs = llvm.load %tail_ptr : !llvm.ptr -&gt; !llvm.struct&lt;(i32, ptr)&gt;
        %n_minus_1 = arith.subi %n, %c1 : i32
        %rest = func.call @process(%xs, %n_minus_1) : (...) -&gt; i32
        %sum = arith.addi %x, %rest : i32
        scf.yield %sum : i32
    }
    scf.yield %inner : i32
}
</code></pre>
<p><strong>핵심 원칙:</strong></p>
<ul>
<li>Constructor column: <code>scf.index_switch</code>로 O(1) dispatch</li>
<li>Literal column: <code>scf.if</code> chain으로 O(n) dispatch</li>
<li>Wildcard: test 없음 (fallthrough 또는 skip)</li>
</ul>
<h3 id="와일드카드-default-case-처리"><a class="header" href="#와일드카드-default-case-처리">와일드카드 Default Case 처리</a></h3>
<p><strong>Wildcard (<code>_</code>) pattern의 lowering:</strong></p>
<p>Wildcard는 <strong>어떤 테스트도 생성하지 않는다.</strong></p>
<pre><code class="language-fsharp">match x with
| 0 -&gt; "zero"
| 1 -&gt; "one"
| _ -&gt; "other"  // Wildcard: no test
</code></pre>
<pre><code class="language-mlir">%is_zero = arith.cmpi eq, %x, %c0 : i32
scf.if %is_zero {
    scf.yield %zero_str : !llvm.ptr&lt;i8&gt;
} else {
    %is_one = arith.cmpi eq, %x, %c1 : i32
    scf.if %is_one {
        scf.yield %one_str : !llvm.ptr&lt;i8&gt;
    } else {
        // _ case: NO comparison, just yield
        scf.yield %other_str : !llvm.ptr&lt;i8&gt;
    }
}
</code></pre>
<p><strong>Wildcard optimization in subpatterns:</strong></p>
<pre><code class="language-fsharp">match list with
| Cons(_, tail) -&gt; length tail + 1  // Don't extract head
| Nil -&gt; 0
</code></pre>
<pre><code class="language-mlir">case 1 {  // Cons
    // Wildcard _: Skip head extraction
    // %head = llvm.load %data  -- NOT generated!

    %tail_ptr = llvm.getelementptr %data[1] : (!llvm.ptr) -&gt; !llvm.ptr
    %tail = llvm.load %tail_ptr : !llvm.ptr -&gt; !llvm.struct&lt;(i32, ptr)&gt;
    // ...
}
</code></pre>
<p><strong>Wildcard 최적화의 효과:</strong></p>
<ol>
<li><strong>메모리 접근 감소</strong>: 불필요한 load 제거</li>
<li><strong>레지스터 절약</strong>: unused 값을 저장 안 함</li>
<li><strong>DCE 촉진</strong>: Dead code elimination이 더 쉬워짐</li>
</ol>
<h3 id="type-dispatch-pattern"><a class="header" href="#type-dispatch-pattern">Type Dispatch Pattern</a></h3>
<p><strong>타입 기반 dispatch (future extension):</strong></p>
<p>일부 언어는 runtime type으로 dispatch한다:</p>
<pre><code class="language-fsharp">// Hypothetical type dispatch
match value with
| :? int as n -&gt; n + 1
| :? string as s -&gt; String.length s
| _ -&gt; 0
</code></pre>
<p>이는 다음으로 lowering 가능:</p>
<pre><code class="language-mlir">// Type tag dispatch (similar to ADT constructor)
%type_tag = llvm.extractvalue %boxed_value[0] : !llvm.struct&lt;(i32, ptr)&gt;
%tag_index = arith.index_cast %type_tag : i32 to index

scf.index_switch %tag_index : index -&gt; i32
case 0 { /* int case */ }
case 1 { /* string case */ }
default { scf.yield %zero : i32 }
</code></pre>
<p>현재 FunLang은 ADT constructor만 지원하지만, 동일한 패턴이 적용된다.</p>
<hr>
<h2 id="summary-and-chapter-20-preview"><a class="header" href="#summary-and-chapter-20-preview">Summary and Chapter 20 Preview</a></h2>
<h3 id="chapter-19-recap"><a class="header" href="#chapter-19-recap">Chapter 19 Recap</a></h3>
<p><strong>이 장에서 배운 것:</strong></p>
<p>✅ <strong>Part 1: Match Operation Definition</strong></p>
<ol>
<li>
<p><strong>Region-based operations</strong></p>
<ul>
<li>Regions vs basic blocks: encapsulation, verification 장점</li>
<li><code>funlang.match</code>는 multiple regions (variadic, each with 1 block)</li>
</ul>
</li>
<li>
<p><strong>Match operation semantics</strong></p>
<ul>
<li>Runtime execution: tag extraction → case selection → variable binding → yield</li>
<li>Block arguments for pattern variables</li>
</ul>
</li>
<li>
<p><strong>TableGen definition</strong></p>
<ul>
<li>Traits: <code>RecursiveSideEffect</code>, <code>SingleBlockImplicitTerminator&lt;"YieldOp"&gt;</code></li>
<li><code>VariadicRegion&lt;SizedRegion&lt;1&gt;&gt;</code> for flexible case count</li>
<li>Custom assembly format, verifier</li>
</ul>
</li>
<li>
<p><strong>YieldOp terminator</strong></p>
<ul>
<li>Terminator trait, HasParent&lt;“MatchOp”&gt; constraint</li>
<li>Dedicated operation (not reusing scf.yield)</li>
</ul>
</li>
<li>
<p><strong>C API and F# integration</strong></p>
<ul>
<li>Builder callback pattern for region construction</li>
<li>High-level wrapper: <code>CreateMatchOp(scrutinee, resultType, buildCases)</code></li>
<li>Block arguments added in F# callback, mapped in lowering pass</li>
</ul>
</li>
</ol>
<p>✅ <strong>Part 2: SCF Lowering and Pipeline</strong></p>
<ol>
<li>
<p><strong>SCF dialect overview</strong></p>
<ul>
<li>Structured control flow (regions, not goto)</li>
<li><code>scf.index_switch</code> for multi-way branching</li>
<li>Why SCF before LLVM: structure preservation, optimization, debugging</li>
</ul>
</li>
<li>
<p><strong>MatchOpLowering pattern</strong></p>
<ul>
<li>Tag extraction and index casting</li>
<li>Data extraction for pattern variables</li>
<li>IRMapping for block argument remapping</li>
<li>Region cloning with mapped values</li>
<li><code>funlang.yield</code> → <code>scf.yield</code> conversion</li>
</ul>
</li>
<li>
<p><strong>Complete pipeline</strong></p>
<ul>
<li>FunLangToSCFPass → FunLangToLLVMPass → SCFToControlFlowPass → …</li>
<li>Pass dependencies and ordering</li>
<li>End-to-end example: sum_list</li>
</ul>
</li>
<li>
<p><strong>Common errors</strong></p>
<ul>
<li>Block argument count mismatch</li>
<li>Type mismatch in regions</li>
<li>Missing scf.yield</li>
<li>Wrong tag values</li>
<li>Incorrect data extraction</li>
</ul>
</li>
</ol>
<h3 id="pattern-matching-pipeline-complete"><a class="header" href="#pattern-matching-pipeline-complete">Pattern Matching Pipeline: Complete</a></h3>
<p><strong>Phase 6 journey:</strong></p>
<pre><code>Chapter 17: Theory
  ↓
  Decision tree algorithm
  Pattern matrix, specialization/defaulting
  Exhaustiveness checking

Chapter 18: Data Structures
  ↓
  !funlang.list&lt;T&gt; type
  funlang.nil, funlang.cons operations
  TypeConverter, lowering patterns

Chapter 19: Match Compilation (현재)
  ↓
  funlang.match operation
  Region-based structure
  MatchOpLowering to scf.index_switch
  Complete pipeline

Chapter 20: Functional Programs (next)
  ↓
  Realistic examples: map, filter, fold
  Performance analysis
  Debugging functional code
</code></pre>
<p><strong>지금까지의 성과:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Chapters</th><th>Operations</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>Arithmetic</td><td>5-6</td><td>arith.*</td><td>✅ Phase 2</td></tr>
<tr><td>Let bindings</td><td>7</td><td>SSA values</td><td>✅ Phase 2</td></tr>
<tr><td>Control flow</td><td>8</td><td>scf.if</td><td>✅ Phase 2</td></tr>
<tr><td>Functions</td><td>10</td><td>func.func, func.call</td><td>✅ Phase 3</td></tr>
<tr><td>Recursion</td><td>11</td><td>func.call @self</td><td>✅ Phase 3</td></tr>
<tr><td>Closures</td><td>12</td><td>funlang.closure</td><td>✅ Phase 5</td></tr>
<tr><td>Higher-order</td><td>13</td><td>funlang.apply</td><td>✅ Phase 5</td></tr>
<tr><td>Custom dialect</td><td>14-16</td><td>Lowering passes</td><td>✅ Phase 5</td></tr>
<tr><td>Pattern matching</td><td>17-19</td><td>funlang.match</td><td>✅ Phase 6 (현재)</td></tr>
<tr><td>Data structures</td><td>17-19</td><td>funlang.nil, funlang.cons</td><td>✅ Phase 6 (현재)</td></tr>
</tbody>
</table>
</div>
<p><strong>다음: Realistic functional programs</strong></p>
<h3 id="chapter-20-preview-functional-programs"><a class="header" href="#chapter-20-preview-functional-programs">Chapter 20 Preview: Functional Programs</a></h3>
<p><strong>Chapter 20에서 할 것:</strong></p>
<ol>
<li>
<p><strong>Classic list functions</strong></p>
<ul>
<li><code>length</code>, <code>map</code>, <code>filter</code>, <code>fold_left</code>, <code>fold_right</code></li>
<li>Pattern matching + recursion 결합</li>
</ul>
</li>
<li>
<p><strong>Composed functions</strong></p>
<ul>
<li><code>sum = fold_left (+) 0</code></li>
<li><code>product = fold_left (*) 1</code></li>
<li>Higher-order functions로 추상화</li>
</ul>
</li>
<li>
<p><strong>Performance analysis</strong></p>
<ul>
<li>Tail recursion vs non-tail recursion</li>
<li>Closure allocation overhead</li>
<li>GC pressure measurement</li>
</ul>
</li>
<li>
<p><strong>Debugging techniques</strong></p>
<ul>
<li>IR dumping at each stage</li>
<li>printf debugging in functional code</li>
<li>Stack trace interpretation</li>
</ul>
</li>
<li>
<p><strong>Complete FunLang compiler</strong></p>
<ul>
<li>All features integrated</li>
<li>End-to-end compilation</li>
<li>Real-world program examples</li>
</ul>
</li>
</ol>
<p><strong>Chapter 20 목표:</strong></p>
<p>지금까지 배운 모든 기능을 종합하여 <strong>실용적인 함수형 프로그램</strong>을 작성하고 컴파일한다.</p>
<p><strong>Example program (Chapter 20):</strong></p>
<pre><code class="language-fsharp">// Functional list library
let rec map f lst =
    match lst with
    | [] -&gt; []
    | head :: tail -&gt; f head :: map f tail

let rec filter pred lst =
    match lst with
    | [] -&gt; []
    | head :: tail -&gt;
        if pred head then
            head :: filter pred tail
        else
            filter pred tail

let rec fold_left f acc lst =
    match lst with
    | [] -&gt; acc
    | head :: tail -&gt; fold_left f (f acc head) tail

// Usage
let double x = x * 2
let is_even x = x % 2 = 0

let main () =
    let numbers = [1; 2; 3; 4; 5; 6]
    let doubled = map double numbers         // [2; 4; 6; 8; 10; 12]
    let evens = filter is_even doubled       // [2; 4; 6; 8; 10; 12]
    let sum = fold_left (+) 0 evens          // 42
    sum
</code></pre>
<p><strong>Generated MLIR (high-level view):</strong></p>
<pre><code class="language-mlir">module {
  func.func @map(%f: !funlang.closure, %lst: !funlang.list&lt;i32&gt;)
      -&gt; !funlang.list&lt;i32&gt; {
    %result = funlang.match %lst {
      ^nil: ...
      ^cons(%h, %t): ...
    }
    return %result
  }

  func.func @filter(%pred: !funlang.closure, %lst: !funlang.list&lt;i32&gt;)
      -&gt; !funlang.list&lt;i32&gt; { ... }

  func.func @fold_left(%f: !funlang.closure, %acc: i32, %lst: !funlang.list&lt;i32&gt;)
      -&gt; i32 { ... }

  func.func @main() -&gt; i32 {
    // Build list [1; 2; 3; 4; 5; 6]
    %numbers = ...

    // map double numbers
    %double = funlang.closure @double, () : !funlang.closure
    %doubled = func.call @map(%double, %numbers) : ...

    // filter is_even doubled
    %is_even = funlang.closure @is_even, () : !funlang.closure
    %evens = func.call @filter(%is_even, %doubled) : ...

    // fold_left (+) 0 evens
    %plus = funlang.closure @plus, () : !funlang.closure
    %zero = arith.constant 0 : i32
    %sum = func.call @fold_left(%plus, %zero, %evens) : ...

    return %sum : i32
  }
}
</code></pre>
<p><strong>Chapter 20 will show:</strong></p>
<ul>
<li>Complete compilation to native code</li>
<li>Performance benchmarks</li>
<li>Comparison with imperative equivalents</li>
<li>Debugging workflow for functional programs</li>
</ul>
<hr>
<h2 id="튜플-패턴-매칭-tuple-pattern-matching"><a class="header" href="#튜플-패턴-매칭-tuple-pattern-matching">튜플 패턴 매칭 (Tuple Pattern Matching)</a></h2>
<p>Chapter 18에서 우리는 <code>!funlang.tuple&lt;T1, T2, ...&gt;</code> 타입과 <code>funlang.make_tuple</code> 연산을 구현했다. 이제 튜플에 대한 패턴 매칭을 구현하자.</p>
<h3 id="튜플-패턴의-특성-tuple-pattern-characteristics"><a class="header" href="#튜플-패턴의-특성-tuple-pattern-characteristics">튜플 패턴의 특성 (Tuple Pattern Characteristics)</a></h3>
<p><strong>튜플 패턴은 리스트 패턴과 근본적으로 다르다:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>특성</th><th>리스트 패턴</th><th>튜플 패턴</th></tr>
</thead>
<tbody>
<tr><td>태그 검사</td><td>필요 (Nil/Cons 구분)</td><td>불필요</td></tr>
<tr><td>패턴 case 수</td><td>최소 2개 (Nil, Cons)</td><td>항상 1개</td></tr>
<tr><td>매칭 실패 가능성</td><td>있음</td><td>없음 (항상 매칭)</td></tr>
<tr><td>Lowering 대상</td><td>scf.index_switch</td><td>직접 extractvalue</td></tr>
<tr><td>제어 흐름</td><td>조건부 분기</td><td>선형</td></tr>
</tbody>
</table>
</div>
<p><strong>핵심 통찰:</strong></p>
<p>튜플 패턴은 본질적으로 **구조 분해(destructuring)**다. 항상 매칭이 성공하므로 조건 분기가 필요 없다.</p>
<pre><code class="language-fsharp">// 리스트: 두 가지 가능성, 조건 분기 필요
match list with
| [] -&gt; expr1       // Nil case
| x :: xs -&gt; expr2  // Cons case

// 튜플: 한 가지 가능성, 조건 분기 불필요
match pair with
| (x, y) -&gt; x + y   // 항상 이 case로
</code></pre>
<h3 id="funlangmatch-튜플-지원-tuple-support-in-funlangmatch"><a class="header" href="#funlangmatch-튜플-지원-tuple-support-in-funlangmatch">funlang.match 튜플 지원 (Tuple Support in funlang.match)</a></h3>
<p><strong>튜플 패턴 매칭의 MLIR 표현:</strong></p>
<pre><code class="language-mlir">// 소스 코드: let (x, y) = pair in x + y
%pair = funlang.make_tuple(%a, %b) : !funlang.tuple&lt;i32, i32&gt;

%sum = funlang.match %pair : !funlang.tuple&lt;i32, i32&gt; -&gt; i32 {
  ^case(%x: i32, %y: i32):
    %result = arith.addi %x, %y : i32
    funlang.yield %result : i32
}
</code></pre>
<p><strong>리스트 패턴과 비교:</strong></p>
<pre><code class="language-mlir">// 리스트 패턴: 두 case
%result = funlang.match %list : !funlang.list&lt;i32&gt; -&gt; i32 {
  ^nil:
    %zero = arith.constant 0 : i32
    funlang.yield %zero : i32
  ^cons(%head: i32, %tail: !funlang.list&lt;i32&gt;):
    // ...
    funlang.yield %sum : i32
}

// 튜플 패턴: 한 case만
%result = funlang.match %tuple : !funlang.tuple&lt;i32, i32&gt; -&gt; i32 {
  ^case(%x: i32, %y: i32):
    // 항상 이 case 실행
    funlang.yield %result : i32
}
</code></pre>
<p><strong>튜플 패턴의 핵심:</strong></p>
<ol>
<li><strong>단일 case</strong>: 분기 불필요</li>
<li><strong>block arguments = 구조 분해된 원소</strong>: <code>(%x, %y)</code> → <code>^case(%x: i32, %y: i32)</code></li>
<li><strong>원소 개수 = block argument 개수</strong>: 타입의 arity와 일치</li>
</ol>
<h3 id="튜플-로우어링-구현-tuple-lowering-implementation"><a class="header" href="#튜플-로우어링-구현-tuple-lowering-implementation">튜플 로우어링 구현 (Tuple Lowering Implementation)</a></h3>
<p><strong>핵심 차이점:</strong></p>
<p>리스트 패턴 lowering:</p>
<ol>
<li>태그 추출 (extractvalue [0])</li>
<li>scf.index_switch로 분기</li>
<li>각 case에서 데이터 추출</li>
</ol>
<p>튜플 패턴 lowering:</p>
<ol>
<li>각 원소 추출 (extractvalue [i])</li>
<li>원래 block의 operation들을 inline</li>
<li>분기 없음!</li>
</ol>
<p><strong>TupleMatchLowering 패턴:</strong></p>
<pre><code class="language-cpp">// 튜플 패턴 매칭의 lowering은 특별 처리가 필요
// MatchOpLowering 내부에서 튜플 타입 감지 시

LogicalResult matchTuplePattern(MatchOp op, OpAdaptor adaptor,
                                 ConversionPatternRewriter &amp;rewriter) {
  Location loc = op.getLoc();
  Value input = adaptor.getInput();

  // 튜플은 단일 case만 가짐
  assert(op.getCases().size() == 1 &amp;&amp; "Tuple match must have exactly one case");

  Region&amp; caseRegion = op.getCases().front();
  Block&amp; caseBlock = caseRegion.front();

  // 구조체에서 각 원소 추출
  auto structType = input.getType().cast&lt;LLVM::LLVMStructType&gt;();
  IRMapping mapper;

  for (size_t i = 0; i &lt; caseBlock.getNumArguments(); ++i) {
    Value extracted = rewriter.create&lt;LLVM::ExtractValueOp&gt;(
        loc, structType.getBody()[i], input, i);
    mapper.map(caseBlock.getArgument(i), extracted);
  }

  // 원래 block의 operations를 현재 위치에 inline
  for (Operation&amp; op : caseBlock.getOperations()) {
    if (auto yieldOp = dyn_cast&lt;YieldOp&gt;(&amp;op)) {
      // yield의 값으로 match 결과를 대체
      Value yieldValue = mapper.lookupOrDefault(yieldOp.getValue());
      rewriter.replaceOp(op, yieldValue);
    } else {
      rewriter.clone(op, mapper);
    }
  }

  return success();
}
</code></pre>
<p><strong>Lowering 결과 비교:</strong></p>
<pre><code class="language-mlir">// Before lowering (FunLang)
%sum = funlang.match %pair : !funlang.tuple&lt;i32, i32&gt; -&gt; i32 {
  ^case(%x: i32, %y: i32):
    %result = arith.addi %x, %y : i32
    funlang.yield %result : i32
}

// After lowering (LLVM dialect) - 분기 없음!
%x = llvm.extractvalue %pair[0] : !llvm.struct&lt;(i32, i32)&gt;
%y = llvm.extractvalue %pair[1] : !llvm.struct&lt;(i32, i32)&gt;
%sum = arith.addi %x, %y : i32
</code></pre>
<p><strong>리스트 패턴 lowering과 비교:</strong></p>
<pre><code class="language-mlir">// 리스트: scf.index_switch 필요
%tag = llvm.extractvalue %list[0] : !llvm.struct&lt;(i32, ptr)&gt;
%tagIndex = arith.index_cast %tag : i32 to index
%result = scf.index_switch %tagIndex : index -&gt; i32
case 0 {  // Nil
  %zero = arith.constant 0 : i32
  scf.yield %zero : i32
}
case 1 {  // Cons
  %ptr = llvm.extractvalue %list[1] : !llvm.struct&lt;(i32, ptr)&gt;
  %head = llvm.load %ptr : !llvm.ptr -&gt; i32
  // ...
  scf.yield %sum : i32
}
default {
  llvm.unreachable
}

// 튜플: extractvalue만으로 충분
%x = llvm.extractvalue %pair[0] : !llvm.struct&lt;(i32, i32)&gt;
%y = llvm.extractvalue %pair[1] : !llvm.struct&lt;(i32, i32)&gt;
%result = arith.addi %x, %y : i32
</code></pre>
<h3 id="중첩-패턴-nested-patterns"><a class="header" href="#중첩-패턴-nested-patterns">중첩 패턴 (Nested Patterns)</a></h3>
<p><strong>튜플 안에 리스트가 있는 경우:</strong></p>
<pre><code class="language-fsharp">// 두 리스트를 튜플로 묶어서 동시에 패턴 매칭
let rec zip xs ys =
  match (xs, ys) with
  | ([], _) -&gt; []
  | (_, []) -&gt; []
  | (x :: xs', y :: ys') -&gt; (x, y) :: zip xs' ys'
</code></pre>
<p><strong>MLIR 표현:</strong></p>
<pre><code class="language-mlir">// 1단계: 튜플 구조 분해
%tuple = funlang.make_tuple(%xs, %ys) : !funlang.tuple&lt;!funlang.list&lt;i32&gt;, !funlang.list&lt;i32&gt;&gt;

// 2단계: 튜플에서 두 리스트 추출
%xs_extracted = ... extractvalue [0] ...
%ys_extracted = ... extractvalue [1] ...

// 3단계: 첫 번째 리스트에 대해 패턴 매칭
%result = funlang.match %xs_extracted : !funlang.list&lt;i32&gt; -&gt; ... {
  ^nil:
    // 빈 리스트 반환
  ^cons(%x: i32, %xs_tail: !funlang.list&lt;i32&gt;):
    // 4단계: 두 번째 리스트에 대해 중첩 패턴 매칭
    %inner = funlang.match %ys_extracted : !funlang.list&lt;i32&gt; -&gt; ... {
      ^nil:
        // 빈 리스트 반환
      ^cons(%y: i32, %ys_tail: !funlang.list&lt;i32&gt;):
        // (x, y) :: zip xs_tail ys_tail
        %pair = funlang.make_tuple(%x, %y) : !funlang.tuple&lt;i32, i32&gt;
        %rest = func.call @zip(%xs_tail, %ys_tail) : ...
        %result = funlang.cons %pair, %rest : ...
        funlang.yield %result
    }
    funlang.yield %inner
}
</code></pre>
<p><strong>중첩 패턴 lowering 전략:</strong></p>
<ol>
<li><strong>외부에서 내부로</strong>: 가장 바깥 패턴부터 lowering</li>
<li><strong>튜플 먼저</strong>: 튜플 분해는 조건 없이 extractvalue</li>
<li><strong>리스트는 분기</strong>: 각 리스트 패턴은 scf.index_switch 필요</li>
<li><strong>깊이 우선</strong>: 내부 패턴이 완전히 lowering된 후 외부로</li>
</ol>
<h3 id="matchoplowering-확장-튜플-지원"><a class="header" href="#matchoplowering-확장-튜플-지원">MatchOpLowering 확장: 튜플 지원</a></h3>
<p><strong>기존 MatchOpLowering에 튜플 분기 추가:</strong></p>
<pre><code class="language-cpp">class MatchOpLowering : public OpConversionPattern&lt;MatchOp&gt; {
public:
  LogicalResult matchAndRewrite(MatchOp op, OpAdaptor adaptor,
                                 ConversionPatternRewriter &amp;rewriter) const override {
    Location loc = op.getLoc();
    Value input = adaptor.getInput();
    Type inputType = op.getInput().getType();

    // 튜플인지 확인
    if (auto tupleType = inputType.dyn_cast&lt;funlang::TupleType&gt;()) {
      return matchTuplePattern(op, adaptor, rewriter, tupleType);
    }

    // 리스트인 경우 기존 로직 사용
    if (auto listType = inputType.dyn_cast&lt;funlang::ListType&gt;()) {
      return matchListPattern(op, adaptor, rewriter, listType);
    }

    return op.emitError("unsupported match input type");
  }

private:
  LogicalResult matchTuplePattern(MatchOp op, OpAdaptor adaptor,
                                   ConversionPatternRewriter &amp;rewriter,
                                   funlang::TupleType tupleType) const {
    Location loc = op.getLoc();
    Value input = adaptor.getInput();

    // 튜플은 단일 case만 허용
    if (op.getCases().size() != 1) {
      return op.emitError("tuple match must have exactly one case");
    }

    Region&amp; caseRegion = op.getCases().front();
    Block&amp; caseBlock = caseRegion.front();

    // block argument 개수 검증
    if (caseBlock.getNumArguments() != tupleType.getNumElements()) {
      return op.emitError() &lt;&lt; "tuple arity mismatch: type has "
                            &lt;&lt; tupleType.getNumElements() &lt;&lt; " elements but pattern has "
                            &lt;&lt; caseBlock.getNumArguments();
    }

    // 각 원소 추출 및 매핑
    auto structType = getTypeConverter()-&gt;convertType(tupleType);
    IRMapping mapper;

    for (size_t i = 0; i &lt; caseBlock.getNumArguments(); ++i) {
      auto elemType = structType.cast&lt;LLVM::LLVMStructType&gt;().getBody()[i];
      Value extracted = rewriter.create&lt;LLVM::ExtractValueOp&gt;(
          loc, elemType, input, i);
      mapper.map(caseBlock.getArgument(i), extracted);
    }

    // 현재 위치에 operations inline
    Value resultValue;
    for (Operation&amp; caseOp : caseBlock.getOperations()) {
      if (auto yieldOp = dyn_cast&lt;YieldOp&gt;(&amp;caseOp)) {
        resultValue = mapper.lookupOrDefault(yieldOp.getValue());
      } else {
        rewriter.clone(caseOp, mapper);
      }
    }

    rewriter.replaceOp(op, resultValue);
    return success();
  }

  LogicalResult matchListPattern(MatchOp op, OpAdaptor adaptor,
                                  ConversionPatternRewriter &amp;rewriter,
                                  funlang::ListType listType) const {
    // 기존 리스트 패턴 매칭 로직...
    // (scf.index_switch 사용)
  }
};
</code></pre>
<h3 id="리스트-vs-튜플-패턴-매칭-종합-비교"><a class="header" href="#리스트-vs-튜플-패턴-매칭-종합-비교">리스트 vs 튜플 패턴 매칭 종합 비교</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>구분</th><th>리스트 패턴</th><th>튜플 패턴</th></tr>
</thead>
<tbody>
<tr><td><strong>타입</strong></td><td><code>!funlang.list&lt;T&gt;</code></td><td><code>!funlang.tuple&lt;T1, T2, ...&gt;</code></td></tr>
<tr><td><strong>case 수</strong></td><td>2개 이상 (Nil, Cons, …)</td><td>정확히 1개</td></tr>
<tr><td><strong>태그 검사</strong></td><td>필요 (extractvalue [0])</td><td>불필요</td></tr>
<tr><td><strong>분기</strong></td><td>scf.index_switch</td><td>없음</td></tr>
<tr><td><strong>데이터 추출</strong></td><td>ptr load 필요</td><td>extractvalue만</td></tr>
<tr><td><strong>패턴 변수 바인딩</strong></td><td>조건부 (case 안에서)</td><td>무조건</td></tr>
<tr><td><strong>default case</strong></td><td>있음 (unreachable)</td><td>없음</td></tr>
<tr><td><strong>lowering 복잡도</strong></td><td>높음</td><td>낮음</td></tr>
<tr><td><strong>최종 코드 크기</strong></td><td>크다 (분기 포함)</td><td>작다 (선형)</td></tr>
</tbody>
</table>
</div>
<p><strong>생성되는 코드 비교:</strong></p>
<pre><code class="language-mlir">// 리스트 패턴 매칭 결과 (복잡)
%tag = llvm.extractvalue %list[0] : !llvm.struct&lt;(i32, ptr)&gt;
%idx = arith.index_cast %tag : i32 to index
%result = scf.index_switch %idx : index -&gt; i32
case 0 {  // ~10 lines
  ...
  scf.yield %val0 : i32
}
case 1 {  // ~15 lines
  ...
  scf.yield %val1 : i32
}
default {  // ~3 lines
  llvm.unreachable
}

// 튜플 패턴 매칭 결과 (단순)
%x = llvm.extractvalue %pair[0] : !llvm.struct&lt;(i32, i32)&gt;
%y = llvm.extractvalue %pair[1] : !llvm.struct&lt;(i32, i32)&gt;
// ... operations inline ...
</code></pre>
<h3 id="튜플-패턴의-최적화-기회"><a class="header" href="#튜플-패턴의-최적화-기회">튜플 패턴의 최적화 기회</a></h3>
<p><strong>튜플 패턴 매칭은 이미 최적화되어 있다:</strong></p>
<ol>
<li><strong>분기 제거</strong>: 조건문 없이 바로 연산</li>
<li><strong>Inlining 자동</strong>: 별도 함수 호출 없음</li>
<li><strong>레지스터 친화적</strong>: 작은 튜플은 레지스터에 유지</li>
</ol>
<p><strong>추가 최적화 가능:</strong></p>
<pre><code class="language-mlir">// Before: 사용하지 않는 원소도 추출
%pair = funlang.make_tuple(%a, %b) : !funlang.tuple&lt;i32, i32&gt;
%result = funlang.match %pair {
  ^case(%x: i32, %y: i32):  // %y 사용 안 함
    funlang.yield %x : i32
}

// After: Dead code elimination으로 %y 추출 제거
%x = llvm.extractvalue %pair[0] : !llvm.struct&lt;(i32, i32)&gt;
// %y 추출 생략됨
%result = %x
</code></pre>
<h3 id="와일드카드-패턴-wildcard-pattern"><a class="header" href="#와일드카드-패턴-wildcard-pattern">와일드카드 패턴 (Wildcard Pattern)</a></h3>
<p><strong>사용하지 않는 원소는 와일드카드로:</strong></p>
<pre><code class="language-fsharp">// 첫 번째 원소만 사용
let fst pair = match pair with (x, _) -&gt; x

// 두 번째 원소만 사용
let snd pair = match pair with (_, y) -&gt; y
</code></pre>
<p><strong>MLIR에서 와일드카드:</strong></p>
<pre><code class="language-mlir">// 와일드카드는 block argument가 없음
%fst = funlang.match %pair : !funlang.tuple&lt;i32, i32&gt; -&gt; i32 {
  ^case(%x: i32):  // %y 자리에 block argument 없음 (또는 unused)
    funlang.yield %x : i32
}
</code></pre>
<p><strong>Lowering 시 최적화:</strong></p>
<pre><code class="language-cpp">// 와일드카드 패턴 처리
for (size_t i = 0; i &lt; tupleType.getNumElements(); ++i) {
  BlockArgument arg = caseBlock.getArgument(i);
  if (!arg.use_empty()) {  // 사용되는 경우에만 추출
    Value extracted = rewriter.create&lt;LLVM::ExtractValueOp&gt;(...);
    mapper.map(arg, extracted);
  }
  // 와일드카드 (미사용)면 extractvalue 생략
}
</code></pre>
<h3 id="summary-튜플-패턴-매칭"><a class="header" href="#summary-튜플-패턴-매칭">Summary: 튜플 패턴 매칭</a></h3>
<p><strong>구현 완료:</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""> 튜플 패턴의 특성 이해 (단일 case, 분기 없음)</li>
<li><input disabled="" type="checkbox" checked=""> funlang.match에서 튜플 타입 지원</li>
<li><input disabled="" type="checkbox" checked=""> MatchOpLowering에서 튜플/리스트 분기 처리</li>
<li><input disabled="" type="checkbox" checked=""> extractvalue 체인으로 원소 추출</li>
<li><input disabled="" type="checkbox" checked=""> 분기 없이 inline lowering</li>
<li><input disabled="" type="checkbox" checked=""> 중첩 패턴 (튜플 + 리스트) 처리 전략</li>
<li><input disabled="" type="checkbox" checked=""> 와일드카드 패턴과 dead code elimination</li>
</ul>
<p><strong>튜플 패턴 vs 리스트 패턴:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>측면</th><th>리스트</th><th>튜플</th></tr>
</thead>
<tbody>
<tr><td>패턴 case</td><td>다중</td><td>단일</td></tr>
<tr><td>제어 흐름</td><td>scf.index_switch</td><td>선형</td></tr>
<tr><td>태그 검사</td><td>필요</td><td>불필요</td></tr>
<tr><td>Lowering</td><td>복잡</td><td>단순</td></tr>
<tr><td>생성 코드</td><td>분기 포함</td><td>extractvalue만</td></tr>
</tbody>
</table>
</div>
<p><strong>다음:</strong></p>
<ul>
<li>Chapter 20에서 튜플을 활용한 실제 프로그램 (zip, fst/snd)</li>
<li>중첩 튜플과 포인트 예제</li>
</ul>
<hr>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p><strong>Chapter 19 완료!</strong></p>
<p>우리는 <code>funlang.match</code> operation을 정의하고 SCF dialect로 lowering하여 <strong>패턴 매칭 컴파일 파이프라인</strong>을 완성했다.</p>
<p><strong>핵심 개념:</strong></p>
<ol>
<li><strong>Region-based operations</strong>: Encapsulation과 verification을 위한 구조</li>
<li><strong>Multi-stage lowering</strong>: FunLang → SCF → CF → LLVM (progressive refinement)</li>
<li><strong>IRMapping</strong>: Block arguments를 실제 values로 remapping</li>
<li><strong>Builder callback pattern</strong>: F#에서 regions를 구축하는 방법</li>
<li><strong>튜플 패턴 매칭</strong>: 분기 없는 extractvalue 기반 lowering</li>
</ol>
<p><strong>Phase 6 진행 상황:</strong></p>
<ul>
<li>✅ Chapter 17: Pattern matching theory (Decision tree algorithm)</li>
<li>✅ Chapter 18: List operations (funlang.nil, funlang.cons, funlang.tuple, funlang.make_tuple)</li>
<li>✅ Chapter 19: Match compilation (funlang.match, 리스트/튜플 패턴 lowering)</li>
<li>⏭️ Chapter 20: Functional programs (map, filter, fold, zip - realistic examples)</li>
</ul>
<p><strong>다음 장에서 만나요!</strong></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="18-list-operations.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="20-functional-programs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="18-list-operations.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="20-functional-programs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
