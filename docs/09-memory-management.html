<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chapter 09: 메모리 관리 - LangBackend Tutorial</title>


        <!-- Custom HTML head -->

        <meta name="description" content="MLIR 기반 FunLang 컴파일러 백엔드 튜토리얼">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-e7b79bcf.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-744e4df7.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">LangBackend Tutorial</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/ohama/LangBackend" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>
                        <a href="https://github.com/ohama/LangBackend/edit/master/tutorial/./09-memory-management.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <span class=fa-svg id="git-edit-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M421.7 220.3l-11.3 11.3-22.6 22.6-205 205c-6.6 6.6-14.8 11.5-23.8 14.1L30.8 511c-8.4 2.5-17.5 .2-23.7-6.1S-1.5 489.7 1 481.2L38.7 353.1c2.6-9 7.5-17.2 14.1-23.8l205-205 22.6-22.6 11.3-11.3 33.9 33.9 62.1 62.1 33.9 33.9zM96 353.9l-9.3 9.3c-.9 .9-1.6 2.1-2 3.4l-25.3 86 86-25.3c1.3-.4 2.5-1.1 3.4-2l9.3-9.3H112c-8.8 0-16-7.2-16-16V353.9zM453.3 19.3l39.4 39.4c25 25 25 65.5 0 90.5l-14.5 14.5-22.6 22.6-11.3 11.3-33.9-33.9-62.1-62.1L314.3 67.7l11.3-11.3 22.6-22.6 14.5-14.5c25-25 65.5-25 90.5 0z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="chapter-09-메모리-관리와-boehm-gc"><a class="header" href="#chapter-09-메모리-관리와-boehm-gc">Chapter 09: 메모리 관리와 Boehm GC</a></h1>
<h2 id="소개"><a class="header" href="#소개">소개</a></h2>
<p>지금까지 FunLang 컴파일러는 모든 값을 SSA 레지스터로 처리했다. 정수, boolean, 심지어 let 바인딩도 메모리 연산 없이 SSA value로만 표현했다.</p>
<pre><code class="language-mlir">func.func @main() -&gt; i32 {
  %c5 = arith.constant 5 : i32       // SSA value (레지스터)
  %c10 = arith.constant 10 : i32     // SSA value (레지스터)
  %sum = arith.addi %c5, %c10 : i32  // SSA value (레지스터)
  func.return %sum : i32
}
</code></pre>
<p>이 접근 방식은 단순한 표현식에서는 완벽하게 작동한다. 하지만 앞으로 구현할 기능은 <strong>메모리 할당</strong>이 필요하다:</p>
<ul>
<li><strong>클로저(Closures)</strong>: 외부 스코프의 변수를 캡처하는 함수</li>
<li><strong>데이터 구조</strong>: 리스트, 튜플, 문자열 등 동적 크기 데이터</li>
<li><strong>함수에서 반환되는 값</strong>: 함수 스코프를 벗어나 생존하는 값</li>
</ul>
<p>이 장에서는 메모리 관리 전략을 학습한다:</p>
<ul>
<li>Stack vs Heap 할당 전략</li>
<li>MLIR의 <code>memref</code> dialect</li>
<li><strong>Boehm GC</strong> 통합 (자동 메모리 회수)</li>
</ul>
<p><strong>중요한 관점:</strong> Phase 2 프로그램은 아직 메모리 할당이 필요하지 않다. 하지만 Phase 3 (함수와 클로저)에 들어가기 전에 GC 인프라를 미리 준비한다. “필요하기 전에 왜 GC가 필요한지“를 이해하는 것이 목표다.</p>
<p>이 장을 마치면:</p>
<ul>
<li>Stack과 heap의 차이를 이해한다</li>
<li>어떤 값이 stack에, 어떤 값이 heap에 가는지 안다</li>
<li>MLIR의 <code>memref</code> 연산을 사용할 수 있다</li>
<li>Boehm GC를 빌드하고 링킹할 수 있다</li>
<li>왜 클로저에 GC가 필요한지 이해한다</li>
</ul>
<blockquote>
<p><strong>Preview:</strong> Phase 3에서 클로저를 구현할 때, 이 장에서 준비한 GC가 바로 사용된다!</p>
</blockquote>
<h2 id="메모리-관리-전략"><a class="header" href="#메모리-관리-전략">메모리 관리 전략</a></h2>
<p>프로그램이 실행될 때 두 종류의 메모리 영역을 사용한다: <strong>Stack</strong>과 <strong>Heap</strong>.</p>
<h3 id="stack-할당"><a class="header" href="#stack-할당">Stack 할당</a></h3>
<p>**Stack (스택)**은 함수 호출 시 자동으로 관리되는 메모리 영역이다.</p>
<p><strong>Stack에 저장되는 것:</strong></p>
<ul>
<li>함수 파라미터</li>
<li>지역 변수</li>
<li>임시 계산 값</li>
<li>함수 반환 주소</li>
</ul>
<p><strong>Stack의 특징:</strong></p>
<ol>
<li>
<p><strong>자동 할당 및 해제</strong></p>
<pre><code class="language-c">int foo() {
    int x = 5;    // Stack에 할당
    int y = 10;   // Stack에 할당
    return x + y;
    // 함수 종료 시 x, y 자동 해제
}
</code></pre>
</li>
<li>
<p><strong>빠른 할당</strong></p>
<ul>
<li>Stack pointer만 이동 (포인터 연산 한 번)</li>
<li>별도의 할당자(allocator) 불필요</li>
</ul>
</li>
<li>
<p><strong>LIFO (Last-In-First-Out) 구조</strong></p>
<pre><code>foo() 호출:
┌──────────────┐
│ foo의 지역변수│ ← stack top
├──────────────┤
│ main의 지역변수│
├──────────────┤
│    ...       │
└──────────────┘

foo() 종료:
┌──────────────┐
│ main의 지역변수│ ← stack top (foo의 프레임 제거됨)
├──────────────┤
│    ...       │
└──────────────┘
</code></pre>
</li>
<li>
<p><strong>크기 제한</strong></p>
<ul>
<li>Stack 크기는 고정 (보통 1-8MB)</li>
<li>너무 많은 지역 변수나 깊은 재귀는 stack overflow 유발</li>
</ul>
</li>
</ol>
<p><strong>언제 stack을 사용하는가:</strong></p>
<ul>
<li>함수 내부에서만 사용되는 값</li>
<li>크기가 컴파일 타임에 결정되는 값</li>
<li>함수 종료 시 사라져도 되는 값</li>
</ul>
<h3 id="heap-할당"><a class="header" href="#heap-할당">Heap 할당</a></h3>
<p>**Heap (힙)**은 명시적으로 할당하고 해제하는 메모리 영역이다.</p>
<p><strong>Heap에 저장되는 것:</strong></p>
<ul>
<li>함수 스코프를 벗어나 생존하는 값</li>
<li>동적 크기 데이터 (런타임에 크기 결정)</li>
<li>여러 함수/클로저가 공유하는 값</li>
</ul>
<p><strong>Heap의 특징:</strong></p>
<ol>
<li>
<p><strong>명시적 할당</strong></p>
<pre><code class="language-c">void* ptr = malloc(100);  // Heap에 100바이트 할당
// ... ptr 사용 ...
free(ptr);                // 명시적 해제 필요
</code></pre>
</li>
<li>
<p><strong>느린 할당</strong></p>
<ul>
<li>할당자가 적절한 메모리 블록을 찾아야 함</li>
<li>Fragmentation (단편화) 관리 필요</li>
</ul>
</li>
<li>
<p><strong>유연한 생명주기</strong></p>
<pre><code class="language-c">int* create_value() {
    int* p = malloc(sizeof(int));
    *p = 42;
    return p;  // 함수 종료 후에도 값이 살아있다
}
</code></pre>
</li>
<li>
<p><strong>크기 제한이 크다</strong></p>
<ul>
<li>Heap은 시스템 전체 가용 메모리를 사용할 수 있다</li>
<li>Stack보다 훨씬 큰 데이터 구조 가능</li>
</ul>
</li>
</ol>
<p><strong>언제 heap을 사용하는가:</strong></p>
<ul>
<li>함수에서 반환되는 값</li>
<li>동적 크기 데이터 (리스트 길이를 런타임에 결정)</li>
<li>여러 클로저가 공유하는 환경</li>
</ul>
<h3 id="funlang의-메모리-전략"><a class="header" href="#funlang의-메모리-전략">FunLang의 메모리 전략</a></h3>
<p><strong>Phase 2 (현재):</strong></p>
<ul>
<li>모든 값이 SSA 레지스터</li>
<li>정수와 boolean만 존재</li>
<li>메모리 할당이 전혀 없다</li>
</ul>
<pre><code class="language-mlir">// Phase 2: 모든 것이 SSA value
func.func @main() -&gt; i32 {
  %c5 = arith.constant 5 : i32      // 레지스터
  %c10 = arith.constant 10 : i32    // 레지스터
  %sum = arith.addi %c5, %c10 : i32 // 레지스터
  func.return %sum : i32
}
</code></pre>
<p><strong>Phase 3 (클로저):</strong></p>
<ul>
<li>클로저가 환경을 캡처</li>
<li><strong>캡처된 환경은 heap에 할당</strong> (함수를 벗어나 생존)</li>
<li>GC가 자동으로 회수</li>
</ul>
<pre><code class="language-mlir">// Phase 3 예시 (preview):
// let x = 5 in (fun y -&gt; x + y)  // 클로저가 x를 캡처
func.func @main() -&gt; !closure {
  %c5 = arith.constant 5 : i32

  // 클로저 환경을 heap에 할당
  %env_size = arith.constant 8 : i64  // x를 저장할 공간
  %env = llvm.call @GC_malloc(%env_size) : (i64) -&gt; !llvm.ptr

  // x를 환경에 저장
  llvm.store %c5, %env : !llvm.ptr

  // 클로저 생성 (함수 포인터 + 환경 포인터)
  %closure = funlang.create_closure @lambda, %env
  func.return %closure : !closure
}
</code></pre>
<p><strong>Phase 6 (데이터 구조):</strong></p>
<ul>
<li>리스트, 튜플, 문자열</li>
<li>모두 heap에 할당</li>
<li>GC가 관리</li>
</ul>
<h3 id="stack-vs-heap-다이어그램"><a class="header" href="#stack-vs-heap-다이어그램">Stack vs Heap 다이어그램</a></h3>
<pre><code>함수 호출 스택                      Heap (GC 관리)
┌─────────────────────┐            ┌─────────────────────┐
│ main() 프레임       │            │ 클로저 환경 #1      │
│ - return addr       │     ┌─────&gt;│ - x = 5            │
│ - local: result     │─────┘      │ - y = 10           │
│ - temp: %c5, %c10   │            ├─────────────────────┤
├─────────────────────┤            │ 리스트 노드         │
│ foo() 프레임        │            │ - head = 1         │
│ - return addr       │            │ - tail = ...       │
│ - param: x          │            └─────────────────────┘
│ - local: y          │                     ↑
└─────────────────────┘                     │
   (함수 종료 시 자동 해제)           (GC가 회수)
</code></pre>
<p><strong>핵심 차이:</strong></p>
<ul>
<li><strong>Stack</strong>: 함수 스코프에 묶임, 자동 해제, 빠름</li>
<li><strong>Heap</strong>: 스코프 독립, 명시적 할당/해제, 유연함</li>
</ul>
<h3 id="왜-funlang은-heap이-필요한가"><a class="header" href="#왜-funlang은-heap이-필요한가">왜 FunLang은 Heap이 필요한가?</a></h3>
<p><strong>클로저가 핵심 이유다:</strong></p>
<pre><code class="language-fsharp">// FunLang 예시
let makeAdder = fun x -&gt;
    fun y -&gt; x + y

let add5 = makeAdder 5   // 클로저: x=5를 캡처
let add10 = makeAdder 10 // 클로저: x=10을 캡처

add5 3    // 결과: 8  (x=5 사용)
add10 3   // 결과: 13 (x=10 사용)
</code></pre>
<p><strong>문제:</strong></p>
<ul>
<li><code>makeAdder 5</code>가 반환될 때, <code>x=5</code>는 어디에 저장되는가?</li>
<li><code>makeAdder</code> 함수는 이미 종료되었다 (stack 프레임 해제됨)</li>
<li>하지만 <code>add5</code>를 호출할 때 <code>x=5</code>가 필요하다!</li>
</ul>
<p><strong>해답:</strong> <code>x=5</code>를 <strong>heap에 할당</strong>한다. 클로저는 heap 포인터를 가진다.</p>
<pre><code>makeAdder(5) 실행:
1. Heap에 환경 할당: { x: 5 }
2. 클로저 생성: (function_ptr, env_ptr)
3. makeAdder 종료 (stack 해제)
4. 클로저 반환 (env_ptr는 여전히 유효)

add5(3) 호출:
1. env_ptr에서 x 로드: x = 5
2. y = 3 (파라미터)
3. x + y = 8 반환
</code></pre>
<p><strong>GC 없이는?</strong></p>
<ul>
<li>수동으로 <code>free(env_ptr)</code> 호출 필요</li>
<li>언제 해제? <code>add5</code>가 더 이상 사용되지 않을 때</li>
<li>하지만 <code>add5</code>가 다른 변수에 할당되었다면?</li>
<li><strong>복잡성 폭발!</strong> → Garbage Collection 필요</li>
</ul>
<h2 id="mlir-memref-dialect-개요"><a class="header" href="#mlir-memref-dialect-개요">MLIR memref Dialect 개요</a></h2>
<p>MLIR은 메모리 연산을 위해 <strong>memref (memory reference)</strong> dialect를 제공한다.</p>
<h3 id="memref-타입"><a class="header" href="#memref-타입">memref 타입</a></h3>
<p><strong>memref</strong>는 “메모리 영역에 대한 참조“를 나타낸다:</p>
<pre><code class="language-mlir">memref&lt;10xi32&gt;           // 10개의 i32 배열
memref&lt;1xi32&gt;            // 단일 i32 (크기 1 배열)
memref&lt;5x5xf32&gt;          // 5×5 float 행렬
memref&lt;*xi32&gt;            // 동적 크기 i32 배열
</code></pre>
<p><strong>구성:</strong></p>
<ul>
<li><code>memref&lt;shape x type&gt;</code>: shape은 차원, type은 요소 타입</li>
<li><code>memref&lt;1xi32&gt;</code>: 하나의 i32를 저장하는 메모리 영역</li>
</ul>
<h3 id="stack-할당-memrefalloca"><a class="header" href="#stack-할당-memrefalloca">Stack 할당: memref.alloca</a></h3>
<p><strong>Stack에 메모리를 할당</strong>하는 연산:</p>
<pre><code class="language-mlir">func.func @stack_example() -&gt; i32 {
  // Stack에 i32 하나 할당
  %stack = memref.alloca() : memref&lt;1xi32&gt;

  %c0 = arith.constant 0 : index      // 인덱스 0
  %c42 = arith.constant 42 : i32      // 값 42

  // Stack에 값 저장
  memref.store %c42, %stack[%c0] : memref&lt;1xi32&gt;

  // Stack에서 값 로드
  %loaded = memref.load %stack[%c0] : memref&lt;1xi32&gt;

  func.return %loaded : i32
  // 함수 종료 시 stack 자동 해제
}
</code></pre>
<p><strong>동작:</strong></p>
<ol>
<li><code>memref.alloca</code>: Stack에 공간 할당</li>
<li><code>memref.store</code>: 메모리에 값 쓰기</li>
<li><code>memref.load</code>: 메모리에서 값 읽기</li>
<li>함수 종료: Stack 자동 해제</li>
</ol>
<p><strong>인덱스 타입:</strong></p>
<ul>
<li><code>index</code>: MLIR의 배열 인덱스 전용 타입</li>
<li>플랫폼에 따라 i32 또는 i64로 lowering됨</li>
</ul>
<p><strong>LLVM IR로 lowering:</strong></p>
<pre><code class="language-llvm">define i32 @stack_example() {
  %stack = alloca i32, i32 1         ; Stack 할당
  store i32 42, i32* %stack          ; 저장
  %loaded = load i32, i32* %stack    ; 로드
  ret i32 %loaded
}
</code></pre>
<h3 id="heap-할당-memrefalloc"><a class="header" href="#heap-할당-memrefalloc">Heap 할당: memref.alloc</a></h3>
<p><strong>Heap에 메모리를 할당</strong>하는 연산:</p>
<pre><code class="language-mlir">func.func @heap_example() -&gt; memref&lt;10xi32&gt; {
  // Heap에 i32 배열 10개 할당
  %heap = memref.alloc() : memref&lt;10xi32&gt;

  // ... heap 사용 ...

  // 명시적 해제 (수동 메모리 관리)
  // memref.dealloc %heap : memref&lt;10xi32&gt;

  func.return %heap : memref&lt;10xi32&gt;
  // heap은 함수 종료 후에도 유효
}
</code></pre>
<p><strong>동작:</strong></p>
<ol>
<li><code>memref.alloc</code>: Heap에 메모리 할당 (malloc과 유사)</li>
<li>메모리 사용</li>
<li><code>memref.dealloc</code>: 명시적 해제 (free와 유사)
<ul>
<li><strong>주의:</strong> 수동 해제는 에러 유발 (use-after-free, double-free)</li>
<li>FunLang은 GC를 사용하므로 dealloc을 호출하지 않는다!</li>
</ul>
</li>
</ol>
<p><strong>LLVM IR로 lowering:</strong></p>
<pre><code class="language-llvm">define ptr @heap_example() {
  ; malloc 호출
  %size = mul i64 10, 4                    ; 10 * sizeof(i32)
  %heap = call ptr @malloc(i64 %size)

  ; ... heap 사용 ...

  ret ptr %heap
}
</code></pre>
<h3 id="memrefload와-memrefstore"><a class="header" href="#memrefload와-memrefstore">memref.load와 memref.store</a></h3>
<p><strong>메모리 읽기/쓰기:</strong></p>
<pre><code class="language-mlir">// 쓰기
memref.store %value, %memref[%index] : memref&lt;10xi32&gt;

// 읽기
%loaded = memref.load %memref[%index] : memref&lt;10xi32&gt;
</code></pre>
<p><strong>다차원 배열:</strong></p>
<pre><code class="language-mlir">// 5×5 행렬
%matrix = memref.alloc() : memref&lt;5x5xi32&gt;
%c1 = arith.constant 1 : index
%c2 = arith.constant 2 : index
%c42 = arith.constant 42 : i32

// matrix[1][2] = 42
memref.store %c42, %matrix[%c1, %c2] : memref&lt;5x5xi32&gt;

// value = matrix[1][2]
%value = memref.load %matrix[%c1, %c2] : memref&lt;5x5xi32&gt;
</code></pre>
<h3 id="phase-2에서-memref를-사용하지-않는-이유"><a class="header" href="#phase-2에서-memref를-사용하지-않는-이유">Phase 2에서 memref를 사용하지 않는 이유</a></h3>
<p><strong>Phase 2 프로그램은 SSA 레지스터만으로 충분하다:</strong></p>
<pre><code class="language-mlir">// Phase 2 스타일 (SSA only)
func.func @main() -&gt; i32 {
  %x = arith.constant 5 : i32      // SSA value
  %y = arith.constant 10 : i32     // SSA value
  %sum = arith.addi %x, %y : i32   // SSA value
  func.return %sum : i32
}

// memref 스타일로 작성하면? (불필요하게 복잡)
func.func @main() -&gt; i32 {
  %x_mem = memref.alloca() : memref&lt;1xi32&gt;
  %c0 = arith.constant 0 : index
  %c5 = arith.constant 5 : i32
  memref.store %c5, %x_mem[%c0] : memref&lt;1xi32&gt;

  %y_mem = memref.alloca() : memref&lt;1xi32&gt;
  %c10 = arith.constant 10 : i32
  memref.store %c10, %y_mem[%c0] : memref&lt;1xi32&gt;

  %x = memref.load %x_mem[%c0] : memref&lt;1xi32&gt;
  %y = memref.load %y_mem[%c0] : memref&lt;1xi32&gt;
  %sum = arith.addi %x, %y : i32
  func.return %sum : i32
}
</code></pre>
<p>첫 번째 버전이 훨씬 간단하다! SSA 레지스터만으로 충분하면 memref를 사용할 필요가 없다.</p>
<p><strong>memref가 필요한 경우:</strong></p>
<ul>
<li>값이 함수 스코프를 벗어나야 할 때 (클로저 환경)</li>
<li>포인터가 필요할 때 (데이터 구조 간 참조)</li>
<li>Mutation이 필요할 때 (SSA는 immutable)</li>
</ul>
<h3 id="memref-요약"><a class="header" href="#memref-요약">memref 요약</a></h3>
<p><strong>memref dialect:</strong></p>
<ul>
<li>MLIR의 메모리 연산 추상화</li>
<li><code>memref.alloca</code>: Stack 할당 (자동 해제)</li>
<li><code>memref.alloc</code>: Heap 할당 (수동 해제 또는 GC)</li>
<li><code>memref.load/store</code>: 메모리 읽기/쓰기</li>
</ul>
<p><strong>Phase 2 vs Phase 3:</strong></p>
<ul>
<li>Phase 2: SSA 레지스터만 사용 (memref 불필요)</li>
<li>Phase 3: 클로저 환경 → heap 할당 → memref 필요</li>
</ul>
<p><strong>다음 섹션:</strong> 왜 Garbage Collection이 필요한가?</p>
<h2 id="왜-garbage-collection이-필요한가"><a class="header" href="#왜-garbage-collection이-필요한가">왜 Garbage Collection이 필요한가</a></h2>
<p>Heap 메모리는 명시적으로 할당하고 해제해야 한다. 하지만 수동 메모리 관리는 <strong>매우 어렵고 에러가 많다</strong>.</p>
<h3 id="수동-메모리-관리의-문제"><a class="header" href="#수동-메모리-관리의-문제">수동 메모리 관리의 문제</a></h3>
<h4 id="1-use-after-free"><a class="header" href="#1-use-after-free">1. Use-After-Free</a></h4>
<p><strong>freed 메모리에 접근:</strong></p>
<pre><code class="language-c">int* ptr = malloc(sizeof(int));
*ptr = 42;
free(ptr);        // 메모리 해제
printf("%d\n", *ptr);  // 에러! freed 메모리 접근
</code></pre>
<p><strong>결과:</strong></p>
<ul>
<li>Undefined behavior (프로그램 crash 또는 잘못된 값)</li>
<li>보안 취약점 (공격자가 freed 메모리를 재사용)</li>
</ul>
<h4 id="2-double-free"><a class="header" href="#2-double-free">2. Double-Free</a></h4>
<p><strong>같은 메모리를 두 번 해제:</strong></p>
<pre><code class="language-c">int* ptr = malloc(sizeof(int));
free(ptr);
free(ptr);  // 에러! 이미 freed된 메모리
</code></pre>
<p><strong>결과:</strong></p>
<ul>
<li>Heap 메타데이터 손상</li>
<li>프로그램 crash</li>
</ul>
<h4 id="3-memory-leak"><a class="header" href="#3-memory-leak">3. Memory Leak</a></h4>
<p><strong>메모리 해제를 잊음:</strong></p>
<pre><code class="language-c">void leak() {
    int* ptr = malloc(sizeof(int));
    *ptr = 42;
    return;  // ptr을 free하지 않음!
}

// leak()을 1000번 호출하면?
for (int i = 0; i &lt; 1000; i++) {
    leak();  // 메모리 누수: 1000 * sizeof(int) 바이트
}
</code></pre>
<p><strong>결과:</strong></p>
<ul>
<li>메모리 사용량 계속 증가</li>
<li>Out-of-memory 에러</li>
</ul>
<h3 id="클로저가-수동-메모리-관리를-어렵게-만드는-이유"><a class="header" href="#클로저가-수동-메모리-관리를-어렵게-만드는-이유">클로저가 수동 메모리 관리를 어렵게 만드는 이유</a></h3>
<p><strong>문제: 언제 클로저 환경을 해제하는가?</strong></p>
<pre><code class="language-fsharp">// FunLang 예시
let makeAdder x = fun y -&gt; x + y

let add5 = makeAdder 5   // 클로저 1: env = { x: 5 }
let add10 = makeAdder 10 // 클로저 2: env = { x: 10 }

// Q: env { x: 5 }를 언제 해제하는가?
// A: add5가 더 이상 사용되지 않을 때

// 하지만 이것이 언제인가?
let adders = [add5; add10]  // add5를 리스트에 저장
// 여기서 add5를 해제할 수 있는가? No! 리스트가 참조 중

let result = List.head adders 3  // add5 사용
// 이제 해제? 아직 adders가 add5를 가리킨다

// ... 프로그램 계속 실행 ...
</code></pre>
<p><strong>복잡성:</strong></p>
<ul>
<li><code>add5</code>가 언제 “더 이상 사용되지 않는가“를 결정하기 어렵다</li>
<li>여러 변수가 같은 클로저를 참조할 수 있다</li>
<li>클로저가 다른 클로저를 캡처할 수 있다 (환경이 중첩)</li>
</ul>
<p><strong>수동 관리 시도:</strong></p>
<pre><code class="language-fsharp">// 명시적 free 추가?
let add5 = makeAdder 5
// ... add5 사용 ...
free(add5)  // 하지만 다른 변수가 add5를 참조하면?

let alias = add5
free(add5)  // alias는 이제 invalid pointer!
</code></pre>
<p><strong>불가능한 이유:</strong></p>
<ul>
<li>참조 추적이 필요 (누가 클로저를 가리키는가?)</li>
<li>런타임 추적 메커니즘 필요</li>
<li><strong>이미 Garbage Collector를 구현하는 것과 같다!</strong></li>
</ul>
<h3 id="클로저-생명주기-예시"><a class="header" href="#클로저-생명주기-예시">클로저 생명주기 예시</a></h3>
<p><strong>복잡한 시나리오:</strong></p>
<pre><code class="language-fsharp">let outer x =
    let inner y =
        fun z -&gt; x + y + z  // x와 y를 모두 캡처
    inner

let f = outer 5 10   // f는 클로저, env = { x: 5, y: 10 }

// outer 함수는 종료됨 (stack 해제)
// 하지만 env { x: 5, y: 10 }은 heap에 살아있어야 함

let result = f 3     // x=5, y=10, z=3 → 18

// 언제 env를 해제?
// f가 더 이상 참조되지 않을 때
</code></pre>
<p><strong>Garbage Collector의 역할:</strong></p>
<ul>
<li>런타임에 객체 참조를 추적한다</li>
<li>더 이상 참조되지 않는 객체를 찾는다</li>
<li>자동으로 메모리를 회수한다</li>
</ul>
<h3 id="garbage-collection의-이점"><a class="header" href="#garbage-collection의-이점">Garbage Collection의 이점</a></h3>
<p><strong>1. 안전성</strong></p>
<ul>
<li>Use-after-free: 불가능 (GC가 사용 중인 객체를 해제하지 않음)</li>
<li>Double-free: 불가능 (GC가 한 번만 해제)</li>
<li>Memory leak: 최소화 (접근 불가능한 객체는 자동 회수)</li>
</ul>
<p><strong>2. 생산성</strong></p>
<ul>
<li>프로그래머가 메모리 관리를 신경 쓰지 않아도 됨</li>
<li>버그가 적다</li>
<li>코드가 간결해진다</li>
</ul>
<p><strong>3. 클로저 지원</strong></p>
<ul>
<li>클로저 환경의 생명주기를 자동 관리</li>
<li>복잡한 참조 그래프도 처리</li>
</ul>
<p><strong>트레이드오프:</strong></p>
<ul>
<li>성능: GC가 주기적으로 실행됨 (pause time)</li>
<li>메모리: GC는 약간의 메모리 오버헤드 존재</li>
<li><strong>FunLang의 선택:</strong> 클로저 지원을 위해 GC는 필수</li>
</ul>
<h3 id="gc-없이-클로저를-구현한다면"><a class="header" href="#gc-없이-클로저를-구현한다면">GC 없이 클로저를 구현한다면?</a></h3>
<p><strong>대안들:</strong></p>
<ol>
<li>
<p><strong>Reference Counting</strong></p>
<ul>
<li>각 객체의 참조 카운트 추적</li>
<li>카운트가 0이 되면 해제</li>
<li><strong>문제:</strong> 순환 참조 처리 불가
<pre><code class="language-fsharp">let rec loop x = fun y -&gt; loop y x  // 순환 참조!
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Arena Allocation</strong></p>
<ul>
<li>모든 객체를 arena에 할당</li>
<li>Arena 전체를 한 번에 해제</li>
<li><strong>문제:</strong> 클로저가 서로 다른 생명주기를 가질 때 비효율</li>
</ul>
</li>
<li>
<p><strong>Ownership System (Rust 스타일)</strong></p>
<ul>
<li>컴파일 타임에 생명주기 추적</li>
<li>런타임 오버헤드 없음</li>
<li><strong>문제:</strong> FunLang은 타입 추론 언어 (ownership 추가는 언어 복잡성 증가)</li>
</ul>
</li>
</ol>
<p><strong>결론:</strong> Garbage Collection이 가장 적합한 선택이다!</p>
<h3 id="왜-gc가-필요한가-요약"><a class="header" href="#왜-gc가-필요한가-요약">왜 GC가 필요한가 요약</a></h3>
<p><strong>문제:</strong></p>
<ul>
<li>클로저 환경은 heap에 할당해야 한다 (함수 스코프를 벗어남)</li>
<li>환경의 생명주기는 복잡하다 (여러 참조, 중첩, 순환)</li>
<li>수동 메모리 관리는 에러가 많다 (use-after-free, leak)</li>
</ul>
<p><strong>해답: Garbage Collection</strong></p>
<ul>
<li>런타임에 객체 참조를 추적한다</li>
<li>접근 불가능한 객체를 자동으로 회수한다</li>
<li>프로그래머가 메모리 관리를 신경 쓰지 않아도 된다</li>
</ul>
<p><strong>다음 섹션:</strong> Boehm GC 소개 - FunLang이 사용할 GC!</p>
<h2 id="boehm-gc-소개"><a class="header" href="#boehm-gc-소개">Boehm GC 소개</a></h2>
<p>FunLang은 <strong>Boehm-Demers-Weiser Garbage Collector</strong> (줄여서 Boehm GC 또는 bdwgc)를 사용한다.</p>
<h3 id="boehm-gc란"><a class="header" href="#boehm-gc란">Boehm GC란?</a></h3>
<p><strong>Boehm GC</strong>는 C와 C++을 위한 <strong>보수적(conservative) 가비지 컬렉터</strong>다.</p>
<p><strong>핵심 특징:</strong></p>
<ol>
<li>
<p><strong>Conservative Collection</strong></p>
<ul>
<li>“보수적“이란 정확한 타입 정보 없이 동작한다는 의미</li>
<li>Stack과 heap을 스캔하여 “포인터처럼 보이는 값“을 찾는다</li>
<li>값이 유효한 heap 주소 범위에 있으면 포인터로 간주한다</li>
</ul>
</li>
<li>
<p><strong>Drop-in Replacement for malloc/free</strong></p>
<pre><code class="language-c">// 기존 코드
int* ptr = malloc(sizeof(int) * 10);
// ... 사용 ...
free(ptr);

// Boehm GC 사용
int* ptr = GC_malloc(sizeof(int) * 10);
// ... 사용 ...
// free 불필요! GC가 자동으로 회수
</code></pre>
</li>
<li>
<p><strong>Battle-Tested</strong></p>
<ul>
<li>1988년부터 개발됨 (30년 이상 역사)</li>
<li>많은 프로그래밍 언어 구현에서 사용:
<ul>
<li>GNU Guile (Scheme)</li>
<li>Mono (.NET on Linux)</li>
<li>W3m (텍스트 브라우저)</li>
</ul>
</li>
<li>안정성이 검증됨</li>
</ul>
</li>
<li>
<p><strong>Thread-Safe</strong></p>
<ul>
<li>멀티스레드 환경에서 안전</li>
<li>적절한 초기화 필요 (<code>GC_INIT()</code>)</li>
</ul>
</li>
</ol>
<h3 id="왜-boehm-gc를-선택했는가"><a class="header" href="#왜-boehm-gc를-선택했는가">왜 Boehm GC를 선택했는가?</a></h3>
<p><strong>장점:</strong></p>
<ol>
<li>
<p><strong>컴파일러 변경 최소화</strong></p>
<ul>
<li>Stack map 불필요 (conservative 스캔)</li>
<li>Write barrier 불필요</li>
<li>GC를 위한 특별한 코드 생성 불필요</li>
</ul>
</li>
<li>
<p><strong>간단한 통합</strong></p>
<ul>
<li>C 라이브러리로 제공</li>
<li><code>GC_malloc</code> 호출만으로 사용 가능</li>
<li>기존 C runtime과 함께 링킹</li>
</ul>
</li>
<li>
<p><strong>안정성</strong></p>
<ul>
<li>오래 사용됨, 버그가 적다</li>
<li>다양한 플랫폼 지원 (Linux, macOS, Windows)</li>
</ul>
</li>
</ol>
<p><strong>단점:</strong></p>
<ol>
<li>
<p><strong>보수적 수집</strong></p>
<ul>
<li>False positive: 포인터가 아닌 값을 포인터로 오인</li>
<li>결과: 일부 객체가 회수되지 않을 수 있음 (메모리 누수)</li>
<li>실제로는 드물고, 대부분의 프로그램에서 문제없음</li>
</ul>
</li>
<li>
<p><strong>Stop-the-world GC</strong></p>
<ul>
<li>GC 실행 중 프로그램 전체가 일시 중지</li>
<li>Latency-critical 애플리케이션에는 부적합</li>
<li>FunLang은 교육용이므로 문제없음</li>
</ul>
</li>
</ol>
<h3 id="대안과-비교"><a class="header" href="#대안과-비교">대안과 비교</a></h3>
<p><strong>1. Reference Counting</strong></p>
<ul>
<li><strong>장점:</strong> 즉시 회수, 예측 가능</li>
<li><strong>단점:</strong> 순환 참조 처리 불가, 성능 오버헤드 (카운트 업데이트)</li>
<li><strong>FunLang:</strong> 클로저는 순환 참조 가능 → 부적합</li>
</ul>
<p><strong>2. LLVM Statepoints (Precise GC)</strong></p>
<ul>
<li><strong>장점:</strong> 정확한 수집 (false positive 없음)</li>
<li><strong>단점:</strong> 복잡한 컴파일러 지원 필요 (safepoint 삽입, stack map 생성)</li>
<li><strong>FunLang:</strong> 교육용으로는 너무 복잡 → 부적합</li>
</ul>
<p><strong>3. Custom Mark-Sweep GC</strong></p>
<ul>
<li><strong>장점:</strong> 완전한 제어</li>
<li><strong>단점:</strong> 구현이 어렵고 버그가 많음</li>
<li><strong>FunLang:</strong> Boehm GC가 이미 잘 동작 → 불필요</li>
</ul>
<p><strong>결론:</strong> Boehm GC가 FunLang에 가장 적합하다!</p>
<h3 id="boehm-gc-핵심-함수"><a class="header" href="#boehm-gc-핵심-함수">Boehm GC 핵심 함수</a></h3>
<p><strong>1. GC_INIT()</strong></p>
<pre><code class="language-c">GC_INIT();  // 프로그램 시작 시 한 번 호출
</code></pre>
<ul>
<li>GC를 초기화한다</li>
<li>반드시 <code>main()</code> 시작 부분이나 첫 <code>GC_malloc</code> 전에 호출</li>
<li>Thread-local storage 설정, heap 초기화</li>
</ul>
<p><strong>2. GC_malloc(size)</strong></p>
<pre><code class="language-c">void* ptr = GC_malloc(100);  // 100바이트 할당
</code></pre>
<ul>
<li>Heap에 메모리 할당</li>
<li><code>malloc</code>과 동일하게 사용</li>
<li>GC가 자동으로 회수 (free 불필요)</li>
</ul>
<p><strong>3. GC_malloc_atomic(size)</strong></p>
<pre><code class="language-c">void* ptr = GC_malloc_atomic(100);  // 포인터 없는 데이터
</code></pre>
<ul>
<li>포인터를 포함하지 않는 데이터용 할당</li>
<li>예: 문자열, 정수 배열</li>
<li>GC가 스캔하지 않음 (성능 향상)</li>
</ul>
<p><strong>4. GC_free(ptr)</strong> (선택 사항)</p>
<pre><code class="language-c">GC_free(ptr);  // 명시적 해제 (힌트)
</code></pre>
<ul>
<li>GC에게 “이 메모리를 즉시 회수해도 됨“을 알림</li>
<li>필수는 아님 (GC가 나중에 자동 회수)</li>
<li>성능 최적화용</li>
</ul>
<h3 id="conservative-gc-동작-원리"><a class="header" href="#conservative-gc-동작-원리">Conservative GC 동작 원리</a></h3>
<p><strong>1. Heap 스캔:</strong></p>
<pre><code>Heap:
┌────────────────┐ 0x1000
│ Object A       │
├────────────────┤ 0x1010
│ Object B       │
├────────────────┤ 0x1020
│ Free space     │
└────────────────┘
</code></pre>
<p><strong>2. Stack 스캔:</strong></p>
<pre><code>Stack:
┌────────────────┐
│ var1 = 0x1000  │ ← 포인터처럼 보임 (Object A 가리킴)
├────────────────┤
│ var2 = 42      │ ← 포인터 아님 (heap 범위 밖)
├────────────────┤
│ var3 = 0x1010  │ ← 포인터처럼 보임 (Object B 가리킴)
└────────────────┘
</code></pre>
<p><strong>3. Mark Phase:</strong></p>
<ul>
<li>Stack에서 <code>0x1000</code>, <code>0x1010</code> 발견</li>
<li>Object A와 Object B를 “live“로 표시</li>
</ul>
<p><strong>4. Sweep Phase:</strong></p>
<ul>
<li>Heap 전체를 스캔</li>
<li>“live” 표시 없는 객체 회수</li>
</ul>
<p><strong>False Positive 예시:</strong></p>
<pre><code class="language-c">int x = 0x1000;  // 우연히 heap 주소와 같은 정수
// GC는 x를 포인터로 오인할 수 있음
// 결과: 0x1000의 객체가 회수되지 않음 (누수)
</code></pre>
<p>실제로는 드물고, 대부분의 프로그램에서 문제없음.</p>
<h2 id="boehm-gc-빌드-및-설치"><a class="header" href="#boehm-gc-빌드-및-설치">Boehm GC 빌드 및 설치</a></h2>
<p>Boehm GC를 소스에서 빌드하거나 패키지 매니저로 설치할 수 있다.</p>
<h3 id="소스에서-빌드"><a class="header" href="#소스에서-빌드">소스에서 빌드</a></h3>
<p><strong>1. 저장소 클론:</strong></p>
<pre><code class="language-bash"># Boehm GC 저장소
git clone https://github.com/ivmai/bdwgc
cd bdwgc

# Atomic operations 라이브러리 (의존성)
git clone https://github.com/ivmai/libatomic_ops
</code></pre>
<p><strong>2. libatomic_ops 링크:</strong></p>
<pre><code class="language-bash"># bdwgc가 libatomic_ops를 찾을 수 있도록 심볼릭 링크 생성
ln -s $(pwd)/libatomic_ops $(pwd)/libatomic_ops
</code></pre>
<p>또는:</p>
<pre><code class="language-bash">cd bdwgc
ln -s ../libatomic_ops libatomic_ops
</code></pre>
<p><strong>3. Build 설정:</strong></p>
<pre><code class="language-bash">cd bdwgc
autoreconf -vif        # autoconf 파일 생성
automake --add-missing # 누락된 파일 추가
./configure --prefix=$HOME/boehm-gc --enable-threads=posix
</code></pre>
<p><strong>configure 옵션:</strong></p>
<ul>
<li><code>--prefix=$HOME/boehm-gc</code>: 설치 경로 (홈 디렉토리)</li>
<li><code>--enable-threads=posix</code>: 멀티스레드 지원 (POSIX threads)</li>
</ul>
<p><strong>4. 빌드 및 설치:</strong></p>
<pre><code class="language-bash">make -j$(nproc)        # 병렬 빌드 (CPU 코어 수만큼)
make check             # 테스트 실행 (선택 사항)
make install           # $HOME/boehm-gc에 설치
</code></pre>
<p><strong>5. 환경 변수 설정:</strong></p>
<pre><code class="language-bash"># 라이브러리 경로 추가
export LD_LIBRARY_PATH=$HOME/boehm-gc/lib:$LD_LIBRARY_PATH

# 헤더 경로 추가
export C_INCLUDE_PATH=$HOME/boehm-gc/include:$C_INCLUDE_PATH

# bashrc에 추가하여 영구 적용
echo 'export LD_LIBRARY_PATH=$HOME/boehm-gc/lib:$LD_LIBRARY_PATH' &gt;&gt; ~/.bashrc
echo 'export C_INCLUDE_PATH=$HOME/boehm-gc/include:$C_INCLUDE_PATH' &gt;&gt; ~/.bashrc
</code></pre>
<h3 id="패키지-매니저로-설치"><a class="header" href="#패키지-매니저로-설치">패키지 매니저로 설치</a></h3>
<p><strong>Ubuntu/Debian:</strong></p>
<pre><code class="language-bash">sudo apt update
sudo apt install libgc-dev
</code></pre>
<p><strong>macOS (Homebrew):</strong></p>
<pre><code class="language-bash">brew install bdw-gc
</code></pre>
<p><strong>Fedora/RHEL:</strong></p>
<pre><code class="language-bash">sudo dnf install gc-devel
</code></pre>
<p><strong>Arch Linux:</strong></p>
<pre><code class="language-bash">sudo pacman -S gc
</code></pre>
<p>패키지 매니저로 설치하면 환경 변수 설정이 자동으로 처리된다.</p>
<h3 id="설치-확인"><a class="header" href="#설치-확인">설치 확인</a></h3>
<p><strong>테스트 프로그램 작성:</strong></p>
<pre><code class="language-c">// test_gc.c
#include &lt;stdio.h&gt;
#include &lt;gc.h&gt;

int main() {
    GC_INIT();

    void* ptr = GC_malloc(100);
    if (ptr == NULL) {
        printf("GC_malloc failed\n");
        return 1;
    }

    printf("GC_malloc succeeded: %p\n", ptr);
    // GC_free 불필요 - GC가 자동 회수

    return 0;
}
</code></pre>
<p><strong>컴파일 및 실행:</strong></p>
<pre><code class="language-bash"># 소스 빌드한 경우
gcc test_gc.c -o test_gc -I$HOME/boehm-gc/include -L$HOME/boehm-gc/lib -lgc
./test_gc

# 패키지 매니저로 설치한 경우
gcc test_gc.c -o test_gc -lgc
./test_gc
</code></pre>
<p><strong>예상 출력:</strong></p>
<pre><code>GC_malloc succeeded: 0x7f1234567890
</code></pre>
<p>성공! Boehm GC가 올바르게 설치되었다.</p>
<h2 id="funlang-runtime-통합"><a class="header" href="#funlang-runtime-통합">FunLang Runtime 통합</a></h2>
<p>이제 FunLang 컴파일러가 생성하는 바이너리와 Boehm GC를 연결한다.</p>
<h3 id="c-runtime-작성"><a class="header" href="#c-runtime-작성">C Runtime 작성</a></h3>
<p><strong>runtime.c</strong> - FunLang 실행 환경:</p>
<pre><code class="language-c">// runtime.c - FunLang runtime with Boehm GC
#include &lt;stdio.h&gt;
#include &lt;gc.h&gt;

/**
 * GC 초기화
 * 프로그램 시작 시 한 번 호출
 */
void funlang_init() {
    GC_INIT();
}

/**
 * GC-managed 메모리 할당
 *
 * @param size 할당할 바이트 수
 * @return 할당된 메모리 포인터
 */
void* funlang_alloc(size_t size) {
    return GC_malloc(size);
}

/**
 * Atomic 메모리 할당 (포인터 없는 데이터용)
 *
 * @param size 할당할 바이트 수
 * @return 할당된 메모리 포인터
 */
void* funlang_alloc_atomic(size_t size) {
    return GC_malloc_atomic(size);
}

/**
 * 정수 출력 (Chapter 06에서 구현)
 *
 * @param value 출력할 정수 값
 */
void print_int(int value) {
    printf("%d\n", value);
}

/**
 * MLIR 컴파일된 main 함수
 * F# 컴파일러가 생성한 LLVM IR에서 정의됨
 */
extern int funlang_main();

/**
 * C 프로그램 진입점
 * GC 초기화 후 funlang_main 호출
 */
int main(int argc, char** argv) {
    funlang_init();
    int result = funlang_main();
    return result;
}
</code></pre>
<p><strong>Runtime 구조:</strong></p>
<ol>
<li><strong>funlang_init()</strong>: GC 초기화</li>
<li><strong>funlang_alloc()</strong>: Heap 할당 (Phase 3+에서 사용)</li>
<li><strong>print_int()</strong>: 정수 출력 (Phase 2에서 이미 사용 중)</li>
<li><strong>main()</strong>: GC 초기화 → funlang_main 호출</li>
</ol>
<h3 id="runtime-컴파일"><a class="header" href="#runtime-컴파일">Runtime 컴파일</a></h3>
<pre><code class="language-bash"># 소스 빌드한 경우
gcc -c runtime.c -o runtime.o -I$HOME/boehm-gc/include

# 패키지 매니저로 설치한 경우
gcc -c runtime.c -o runtime.o
</code></pre>
<p><strong>결과:</strong> <code>runtime.o</code> 오브젝트 파일 생성</p>
<h3 id="mlir에서-gc_malloc-호출"><a class="header" href="#mlir에서-gc_malloc-호출">MLIR에서 GC_malloc 호출</a></h3>
<p>Phase 3에서 클로저 환경을 heap에 할당할 때 사용할 패턴 (미리보기):</p>
<p><strong>1. GC_malloc 선언 (MLIR):</strong></p>
<pre><code class="language-mlir">// External function 선언
llvm.func @GC_malloc(i64) -&gt; !llvm.ptr attributes {
    sym_visibility = "private"
}
</code></pre>
<p><strong>2. Heap 할당 호출:</strong></p>
<pre><code class="language-mlir">func.func @allocate_closure_env() -&gt; !llvm.ptr {
    // 클로저 환경 크기 (예: 2개의 i64 값)
    %size = arith.constant 16 : i64  // 2 * 8 bytes

    // GC_malloc 호출
    %env = llvm.call @GC_malloc(%size) : (i64) -&gt; !llvm.ptr

    // env에 캡처된 값 저장
    // (Phase 3에서 구현)

    func.return %env : !llvm.ptr
}
</code></pre>
<p><strong>3. F# 코드 생성 패턴:</strong></p>
<pre><code class="language-fsharp">// MlirWrapper.fs에 추가할 헬퍼 메서드 (Phase 3)
type OpBuilder(context: Context) =
    // ... 기존 메서드 ...

    /// GC_malloc external function 선언
    member this.DeclareGCMalloc() : MlirOperation =
        let ptrType = this.LLVMPointerType()
        let i64Type = builder.Context.GetIntegerType(64)
        let funcType = MlirNative.mlirFunctionTypeGet(
            ctx.Handle,
            1n, [| i64Type |],
            1n, [| ptrType |]
        )

        let name = MlirHelpers.fromString("GC_malloc")
        let funcOp = MlirNative.mlirLLVMFuncCreate(location, name, funcType)

        // 가시성 속성 설정
        // ...

        funcOp

    /// GC_malloc 호출하여 메모리 할당
    member this.CallGCMalloc(size: MlirValue, location: MlirLocation) : MlirValue =
        let gcMalloc = // ... GC_malloc 함수 참조 ...
        let callOp = MlirNative.mlirLLVMCallCreate(
            location, gcMalloc, 1n, [| size |]
        )
        MlirNative.mlirOperationGetResult(callOp, 0)
</code></pre>
<p><strong>Phase 2에서는 사용하지 않지만</strong>, runtime.c에 <code>funlang_alloc</code>을 미리 정의하여 Phase 3에서 바로 사용할 수 있다.</p>
<h2 id="빌드-파이프라인-업데이트"><a class="header" href="#빌드-파이프라인-업데이트">빌드 파이프라인 업데이트</a></h2>
<p>Boehm GC를 포함한 완전한 빌드 파이프라인:</p>
<h3 id="단계별-빌드-과정"><a class="header" href="#단계별-빌드-과정">단계별 빌드 과정</a></h3>
<p><strong>1. FunLang 소스 → LLVM IR:</strong></p>
<pre><code class="language-bash"># F# 컴파일러 실행
dotnet run "let x = 5 in if x &gt; 0 then x * 2 else 0"

# 출력: output.ll (LLVM IR 파일)
</code></pre>
<p><strong>2. LLVM IR → Object 파일:</strong></p>
<pre><code class="language-bash">llc -filetype=obj output.ll -o output.o
</code></pre>
<p><strong>3. Runtime 컴파일:</strong></p>
<pre><code class="language-bash"># 소스 빌드한 경우
gcc -c runtime.c -o runtime.o -I$HOME/boehm-gc/include

# 패키지 매니저로 설치한 경우
gcc -c runtime.c -o runtime.o
</code></pre>
<p><strong>4. 링킹 (Boehm GC 포함):</strong></p>
<pre><code class="language-bash"># 소스 빌드한 경우
gcc output.o runtime.o -o program \
    -L$HOME/boehm-gc/lib -lgc \
    -Wl,-rpath,$HOME/boehm-gc/lib

# 패키지 매니저로 설치한 경우
gcc output.o runtime.o -o program -lgc
</code></pre>
<p><strong>링커 옵션 설명:</strong></p>
<ul>
<li><code>-L$HOME/boehm-gc/lib</code>: 라이브러리 검색 경로</li>
<li><code>-lgc</code>: Boehm GC 라이브러리 링크</li>
<li><code>-Wl,-rpath,$HOME/boehm-gc/lib</code>: 실행 시 라이브러리 경로 (RPATH)</li>
</ul>
<p><strong>5. 실행:</strong></p>
<pre><code class="language-bash">./program
echo $?   # Exit code 확인
</code></pre>
<h3 id="자동화된-빌드-스크립트"><a class="header" href="#자동화된-빌드-스크립트">자동화된 빌드 스크립트</a></h3>
<p><strong>build.sh:</strong></p>
<pre><code class="language-bash">#!/bin/bash
# FunLang 빌드 스크립트

set -e  # 에러 시 중단

FUNLANG_SRC="$1"
OUTPUT="program"

# 1. FunLang → LLVM IR
echo "Compiling FunLang to LLVM IR..."
dotnet run "$FUNLANG_SRC" &gt; output.ll

# 2. LLVM IR → Object
echo "Compiling LLVM IR to object file..."
llc -filetype=obj output.ll -o output.o

# 3. Runtime 컴파일 (필요 시)
if [ ! -f runtime.o ]; then
    echo "Compiling runtime..."
    gcc -c runtime.c -o runtime.o
fi

# 4. 링킹
echo "Linking with Boehm GC..."
if [ -d "$HOME/boehm-gc" ]; then
    # 소스 빌드
    gcc output.o runtime.o -o "$OUTPUT" \
        -L$HOME/boehm-gc/lib -lgc \
        -Wl,-rpath,$HOME/boehm-gc/lib
else
    # 패키지 매니저
    gcc output.o runtime.o -o "$OUTPUT" -lgc
fi

echo "Build complete: $OUTPUT"
</code></pre>
<p><strong>사용:</strong></p>
<pre><code class="language-bash">chmod +x build.sh
./build.sh "let x = 5 in x + x"
./program
</code></pre>
<h3 id="f-통합"><a class="header" href="#f-통합">F# 통합</a></h3>
<p><strong>Compiler.fs에 추가:</strong></p>
<pre><code class="language-fsharp">module Compiler =

    /// LLVM IR을 object 파일로 컴파일
    let compileToObject (llvmIR: string) (outputPath: string) =
        // LLVM IR을 파일에 쓰기
        let llPath = Path.ChangeExtension(outputPath, ".ll")
        File.WriteAllText(llPath, llvmIR)

        // llc 호출
        let llcArgs = sprintf "-filetype=obj %s -o %s" llPath outputPath
        let result = Process.Start("llc", llcArgs)
        result.WaitForExit()

        if result.ExitCode &lt;&gt; 0 then
            failwith "llc compilation failed"

    /// Object 파일과 runtime을 링킹
    let linkWithGC (objPath: string) (exePath: string) =
        let runtimePath = "runtime.o"

        // Boehm GC 경로 확인
        let gcPath = Environment.GetEnvironmentVariable("HOME") + "/boehm-gc"
        let hasSourceBuild = Directory.Exists(gcPath)

        let gccArgs =
            if hasSourceBuild then
                sprintf "%s %s -o %s -L%s/lib -lgc -Wl,-rpath,%s/lib"
                    objPath runtimePath exePath gcPath gcPath
            else
                sprintf "%s %s -o %s -lgc"
                    objPath runtimePath exePath

        let result = Process.Start("gcc", gccArgs)
        result.WaitForExit()

        if result.ExitCode &lt;&gt; 0 then
            failwith "gcc linking failed"

    /// 전체 컴파일 파이프라인
    let compileProgram (source: string) (outputExe: string) =
        // 1. Parse
        let ast = Parser.parse source

        // 2. MLIR IR 생성
        let mlirModule = CodeGen.compile ast

        // 3. Lowering
        Lowering.lowerToLLVMDialect mlirModule

        // 4. LLVM IR 변환
        let llvmIR = Lowering.translateToLLVMIR mlirModule

        // 5. Object 컴파일
        let objPath = Path.ChangeExtension(outputExe, ".o")
        compileToObject llvmIR objPath

        // 6. 링킹
        linkWithGC objPath outputExe

        printfn "Compilation successful: %s" outputExe
</code></pre>
<p><strong>사용:</strong></p>
<pre><code class="language-fsharp">// Program.fs
[&lt;EntryPoint&gt;]
let main argv =
    if argv.Length &lt; 1 then
        printfn "Usage: dotnet run &lt;source&gt; [output]"
        1
    else
        let source = argv.[0]
        let output = if argv.Length &gt; 1 then argv.[1] else "program"

        Compiler.compileProgram source output
        0
</code></pre>
<h2 id="phase-2-vs-phase-3-메모리-사용"><a class="header" href="#phase-2-vs-phase-3-메모리-사용">Phase 2 vs Phase 3+ 메모리 사용</a></h2>
<p>FunLang의 메모리 사용 패턴은 단계별로 진화한다.</p>
<h3 id="phase-2-현재"><a class="header" href="#phase-2-현재">Phase 2 (현재)</a></h3>
<p><strong>특징:</strong></p>
<ul>
<li>모든 값이 SSA 레지스터</li>
<li>메모리 할당 없음</li>
<li>GC 초기화되지만 사용되지 않음</li>
</ul>
<p><strong>생성되는 MLIR IR:</strong></p>
<pre><code class="language-mlir">module {
  func.func @funlang_main() -&gt; i32 {
    %c5 = arith.constant 5 : i32
    %c10 = arith.constant 10 : i32
    %sum = arith.addi %c5, %c10 : i32
    func.return %sum : i32
  }
}
</code></pre>
<p><strong>GC 호출:</strong> 없음 (<code>funlang_alloc</code> 호출 0회)</p>
<h3 id="phase-3-함수와-클로저"><a class="header" href="#phase-3-함수와-클로저">Phase 3 (함수와 클로저)</a></h3>
<p><strong>특징:</strong></p>
<ul>
<li>클로저가 환경을 캡처</li>
<li>환경은 heap에 할당 (<code>GC_malloc</code>)</li>
<li>GC가 죽은 클로저 회수</li>
</ul>
<p><strong>예시: 클로저 환경 할당</strong></p>
<pre><code class="language-mlir">// let makeAdder x = fun y -&gt; x + y
func.func @makeAdder(%x: i32) -&gt; !llvm.ptr {
    // 클로저 환경 할당 (x를 저장)
    %size = arith.constant 8 : i64
    %env = llvm.call @GC_malloc(%size) : (i64) -&gt; !llvm.ptr

    // x를 환경에 저장
    %x_i64 = arith.extsi %x : i32 to i64
    llvm.store %x_i64, %env : !llvm.ptr

    // 클로저 생성 (function pointer + env pointer)
    %closure = funlang.make_closure @lambda, %env

    func.return %closure : !llvm.ptr
}

// fun y -&gt; x + y
func.func private @lambda(%env: !llvm.ptr, %y: i32) -&gt; i32 {
    // 환경에서 x 로드
    %x_i64 = llvm.load %env : !llvm.ptr -&gt; i64
    %x = arith.trunci %x_i64 : i64 to i32

    // x + y
    %result = arith.addi %x, %y : i32
    func.return %result : i32
}
</code></pre>
<p><strong>GC 호출:</strong> <code>makeAdder</code> 호출마다 1회</p>
<h3 id="phase-6-데이터-구조"><a class="header" href="#phase-6-데이터-구조">Phase 6 (데이터 구조)</a></h3>
<p><strong>특징:</strong></p>
<ul>
<li>리스트, 튜플, 문자열 모두 heap 할당</li>
<li>재귀적 데이터 구조 (리스트의 tail)</li>
<li>GC가 복잡한 참조 그래프 처리</li>
</ul>
<p><strong>예시: 리스트 cons</strong></p>
<pre><code class="language-mlir">// cons(1, cons(2, nil))
func.func @build_list() -&gt; !llvm.ptr {
    // nil
    %nil = llvm.mlir.null : !llvm.ptr

    // cons(2, nil)
    %size = arith.constant 16 : i64  // head + tail
    %cons2 = llvm.call @GC_malloc(%size) : (i64) -&gt; !llvm.ptr
    %c2 = arith.constant 2 : i64
    llvm.store %c2, %cons2 : !llvm.ptr
    %tail_ptr = llvm.getelementptr %cons2[8] : !llvm.ptr
    llvm.store %nil, %tail_ptr : !llvm.ptr

    // cons(1, cons2)
    %cons1 = llvm.call @GC_malloc(%size) : (i64) -&gt; !llvm.ptr
    %c1 = arith.constant 1 : i64
    llvm.store %c1, %cons1 : !llvm.ptr
    %tail_ptr1 = llvm.getelementptr %cons1[8] : !llvm.ptr
    llvm.store %cons2, %tail_ptr1 : !llvm.ptr

    func.return %cons1 : !llvm.ptr
}
</code></pre>
<p><strong>GC 호출:</strong> cons 노드마다 1회</p>
<p><strong>메모리 그래프:</strong></p>
<pre><code>%cons1 ─→ [ head: 1 | tail: ─→ %cons2 ─→ [ head: 2 | tail: nil ] ]
</code></pre>
<p>GC는 <code>%cons1</code>이 접근 불가능해지면 전체 체인을 회수한다.</p>
<h3 id="메모리-사용-비교"><a class="header" href="#메모리-사용-비교">메모리 사용 비교</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Phase</th><th>할당 위치</th><th>GC 사용</th><th>복잡도</th></tr>
</thead>
<tbody>
<tr><td>Phase 2</td><td>SSA 레지스터만</td><td>초기화만 (호출 0회)</td><td>낮음</td></tr>
<tr><td>Phase 3</td><td>클로저 환경 → Heap</td><td>클로저 생성 시</td><td>중간</td></tr>
<tr><td>Phase 6</td><td>모든 데이터 구조 → Heap</td><td>거의 모든 연산</td><td>높음</td></tr>
</tbody>
</table>
</div>
<p><strong>핵심:</strong> Phase 2는 GC 인프라를 준비하지만, 실제 사용은 Phase 3부터다.</p>
<h2 id="공통-에러-및-해결"><a class="header" href="#공통-에러-및-해결">공통 에러 및 해결</a></h2>
<p>GC 통합 시 자주 발생하는 에러와 해결 방법:</p>
<h3 id="에러-1-gc_malloc-호출-시-segfault"><a class="header" href="#에러-1-gc_malloc-호출-시-segfault">에러 1: GC_malloc 호출 시 Segfault</a></h3>
<p><strong>증상:</strong></p>
<pre><code>Segmentation fault (core dumped)
</code></pre>
<p><strong>원인:</strong>
<code>GC_INIT()</code>을 호출하지 않고 <code>GC_malloc</code>을 사용했다.</p>
<p><strong>해결:</strong>
<code>main()</code> 시작 부분에서 <code>GC_INIT()</code> 호출:</p>
<pre><code class="language-c">int main() {
    GC_INIT();  // 필수!
    // ... 나머지 코드 ...
}
</code></pre>
<p><strong>FunLang runtime.c:</strong></p>
<pre><code class="language-c">void funlang_init() {
    GC_INIT();
}

int main(int argc, char** argv) {
    funlang_init();  // 첫 번째 호출
    // ...
}
</code></pre>
<h3 id="에러-2-linker-error---undefined-reference-to-gc_malloc"><a class="header" href="#에러-2-linker-error---undefined-reference-to-gc_malloc">에러 2: Linker Error - Undefined Reference to GC_malloc</a></h3>
<p><strong>증상:</strong></p>
<pre><code>undefined reference to `GC_malloc'
collect2: error: ld returned 1 exit status
</code></pre>
<p><strong>원인:</strong>
Boehm GC 라이브러리를 링킹하지 않았다.</p>
<p><strong>해결:</strong>
링킹 시 <code>-lgc</code> 옵션 추가:</p>
<pre><code class="language-bash">gcc output.o runtime.o -o program -lgc
</code></pre>
<p>또는 라이브러리 경로 지정:</p>
<pre><code class="language-bash">gcc output.o runtime.o -o program -L$HOME/boehm-gc/lib -lgc
</code></pre>
<h3 id="에러-3-실행-시-library-not-found"><a class="header" href="#에러-3-실행-시-library-not-found">에러 3: 실행 시 Library Not Found</a></h3>
<p><strong>증상:</strong></p>
<pre><code>error while loading shared libraries: libgc.so.1: cannot open shared object file
</code></pre>
<p><strong>원인:</strong>
실행 시 <code>libgc.so</code>를 찾을 수 없다.</p>
<p><strong>해결:</strong></p>
<p><strong>옵션 1: LD_LIBRARY_PATH 설정</strong></p>
<pre><code class="language-bash">export LD_LIBRARY_PATH=$HOME/boehm-gc/lib:$LD_LIBRARY_PATH
./program
</code></pre>
<p><strong>옵션 2: RPATH 사용 (권장)</strong></p>
<pre><code class="language-bash">gcc output.o runtime.o -o program \
    -L$HOME/boehm-gc/lib -lgc \
    -Wl,-rpath,$HOME/boehm-gc/lib
</code></pre>
<p>RPATH는 바이너리에 라이브러리 경로를 포함시킨다. <code>LD_LIBRARY_PATH</code> 설정 불필요.</p>
<h3 id="에러-4-gc가-메모리를-회수하지-않음"><a class="header" href="#에러-4-gc가-메모리를-회수하지-않음">에러 4: GC가 메모리를 회수하지 않음</a></h3>
<p><strong>증상:</strong>
프로그램 메모리 사용량이 계속 증가한다.</p>
<p><strong>원인:</strong>
Boehm GC는 보수적(conservative)이므로 일부 객체를 회수하지 못할 수 있다.</p>
<p><strong>확인 방법:</strong></p>
<pre><code class="language-c">#include &lt;gc.h&gt;

int main() {
    GC_INIT();

    for (int i = 0; i &lt; 1000000; i++) {
        void* ptr = GC_malloc(100);
        // ptr을 더 이상 사용하지 않음
    }

    // GC 통계 출력
    GC_gcollect();  // 강제 수집
    printf("Heap size: %zu\n", GC_get_heap_size());
    printf("Free bytes: %zu\n", GC_get_free_bytes());

    return 0;
}
</code></pre>
<p><strong>일반적인 경우:</strong></p>
<ul>
<li>Phase 2-3 프로그램에서는 문제없음</li>
<li>Conservative GC의 false positive는 드물다</li>
<li>메모리 누수가 심각하면 정확한(precise) GC 고려</li>
</ul>
<h3 id="에러-5-multi-threading-관련-crash"><a class="header" href="#에러-5-multi-threading-관련-crash">에러 5: Multi-threading 관련 Crash</a></h3>
<p><strong>증상:</strong>
멀티스레드 프로그램에서 random crash.</p>
<p><strong>원인:</strong>
GC를 멀티스레드 모드로 초기화하지 않았다.</p>
<p><strong>해결:</strong></p>
<p><strong>Phase 2-5:</strong> 싱글스레드만 사용하므로 문제없음.</p>
<p><strong>Phase 6+ (Future):</strong> 스레드 생성 시 GC-aware 함수 사용:</p>
<pre><code class="language-c">#include &lt;gc.h&gt;
#include &lt;pthread.h&gt;

void* thread_func(void* arg) {
    GC_pthread_create(...);  // GC-aware thread creation
    // ...
}
</code></pre>
<p>또는 빌드 시 thread-safe 옵션:</p>
<pre><code class="language-bash">./configure --enable-threads=posix
</code></pre>
<h2 id="장-요약"><a class="header" href="#장-요약">장 요약</a></h2>
<p>이 장에서 메모리 관리의 기초와 Boehm GC 통합을 완료했다.</p>
<h3 id="주요-성취"><a class="header" href="#주요-성취">주요 성취</a></h3>
<ol>
<li>
<p><strong>Stack vs Heap 이해</strong></p>
<ul>
<li>Stack: 함수 스코프, 자동 관리, LIFO</li>
<li>Heap: 유연한 생명주기, 명시적 할당/해제</li>
</ul>
</li>
<li>
<p><strong>FunLang 메모리 전략</strong></p>
<ul>
<li>Phase 2: SSA 레지스터만 사용</li>
<li>Phase 3+: 클로저 환경 → heap 할당</li>
</ul>
</li>
<li>
<p><strong>MLIR memref Dialect</strong></p>
<ul>
<li><code>memref.alloca</code>: Stack 할당</li>
<li><code>memref.alloc</code>: Heap 할당</li>
<li><code>memref.load/store</code>: 메모리 읽기/쓰기</li>
</ul>
</li>
<li>
<p><strong>GC 필요성 이해</strong></p>
<ul>
<li>수동 메모리 관리의 문제: use-after-free, leak, double-free</li>
<li>클로저가 복잡한 생명주기를 가진다</li>
<li>GC가 자동으로 회수한다</li>
</ul>
</li>
<li>
<p><strong>Boehm GC 통합</strong></p>
<ul>
<li>Conservative GC: 타입 정보 불필요</li>
<li><code>GC_INIT()</code>, <code>GC_malloc()</code> 사용</li>
<li>빌드 및 설치 완료</li>
</ul>
</li>
<li>
<p><strong>Runtime 작성</strong></p>
<ul>
<li><code>runtime.c</code>: GC 초기화, 메모리 할당 wrapper</li>
<li><code>funlang_main()</code> 호출 전에 <code>funlang_init()</code></li>
</ul>
</li>
<li>
<p><strong>빌드 파이프라인</strong></p>
<ul>
<li>FunLang → LLVM IR → Object → 링킹 (+ Boehm GC)</li>
<li>자동화 스크립트 및 F# 통합</li>
</ul>
</li>
<li>
<p><strong>에러 처리</strong></p>
<ul>
<li>GC_INIT 누락, 링킹 오류, 라이브러리 경로 문제 해결</li>
</ul>
</li>
</ol>
<h3 id="독자가-할-수-있는-것"><a class="header" href="#독자가-할-수-있는-것">독자가 할 수 있는 것</a></h3>
<ul>
<li>Stack과 heap의 차이를 설명할 수 있다 ✓</li>
<li>언제 heap 할당이 필요한지 안다 (클로저, 데이터 구조) ✓</li>
<li>Boehm GC를 빌드하고 설치할 수 있다 ✓</li>
<li><code>runtime.c</code>를 작성하여 GC를 초기화할 수 있다 ✓</li>
<li>FunLang 컴파일러 출력을 Boehm GC와 링킹할 수 있다 ✓</li>
<li>GC 관련 에러를 디버깅할 수 있다 ✓</li>
<li>왜 클로저가 GC를 필요로 하는지 이해한다 ✓</li>
</ul>
<h3 id="phase-2-완료"><a class="header" href="#phase-2-완료">Phase 2 완료!</a></h3>
<p><strong>Chapter 06:</strong> 산술 표현식 (+, -, *, /, 비교, 부정, print)
<strong>Chapter 07:</strong> Let 바인딩과 SSA 환경 전달
<strong>Chapter 08:</strong> 제어 흐름 (scf.if, block arguments, boolean)
<strong>Chapter 09:</strong> 메모리 관리 (stack/heap 전략, Boehm GC 통합)</p>
<p><strong>독자가 컴파일할 수 있는 프로그램:</strong></p>
<pre><code class="language-fsharp">// 복잡한 예시
let x = 5 in
let y = 10 in
if x &gt; 0 then
    if y &lt; 20 then
        x * y
    else
        x + y
else
    0
</code></pre>
<p><strong>생성되는 바이너리:</strong></p>
<ul>
<li>MLIR로 컴파일</li>
<li>LLVM IR로 lowering</li>
<li>Native object 생성</li>
<li>Boehm GC와 링킹</li>
<li>실행 가능한 바이너리!</li>
</ul>
<pre><code class="language-bash">$ ./program
$ echo $?
50
</code></pre>
<h3 id="phase-3-preview-함수와-클로저"><a class="header" href="#phase-3-preview-함수와-클로저">Phase 3 Preview: 함수와 클로저</a></h3>
<p>다음 Phase에서 다룰 내용:</p>
<p><strong>함수 정의:</strong></p>
<pre><code class="language-fsharp">let add = fun x -&gt; fun y -&gt; x + y
</code></pre>
<p><strong>클로저 캡처:</strong></p>
<pre><code class="language-fsharp">let makeAdder x = fun y -&gt; x + y
let add5 = makeAdder 5  // x=5를 캡처
</code></pre>
<p><strong>메모리 할당:</strong></p>
<ul>
<li>클로저 환경을 heap에 할당 (<code>GC_malloc</code>)</li>
<li>함수 포인터 + 환경 포인터 구조</li>
<li>GC가 죽은 클로저 회수</li>
</ul>
<p><strong>MLIR 연산:</strong></p>
<ul>
<li><code>llvm.call @GC_malloc</code>: Heap 할당</li>
<li><code>llvm.store</code>, <code>llvm.load</code>: 환경 읽기/쓰기</li>
<li>Function 타입과 호출 규약</li>
</ul>
<p><strong>이 장에서 준비한 GC 인프라가 바로 사용된다!</strong></p>
<hr>
<p><strong>독자는 이제 메모리 관리를 이해하고, Boehm GC를 통합했다. Phase 3로 가자!</strong></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="08-control-flow.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="10-functions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="08-control-flow.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="10-functions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
